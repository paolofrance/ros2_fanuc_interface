Idx = 1; markIdx <= 4; ++markIdx) {
      var tempName;
      /* SampleMarker# */
      eval("tempName = \"SampleMarker" + markIdx + "\"");
      if (dataName[0].toLowerCase() === tempName.toLowerCase()) {
        chart_CreateVertLineMarkers(markIdx, dataName[1])
        return;
      }
      for (var chNum = 1; chNum <= maxNumCh; ++chNum) {
        var tempName;
        /* ch#_DataMarker# */
        eval("tempName = \"ch" + chNum + "_DataMarker" + markIdx + "\"");
        if (dataName[0].toLowerCase() === tempName.toLowerCase()) {
          chart_CreateHorizLineMarkers(chNum, markIdx, dataName[1])
          return;
        }
      }
    }
  }
}

function chart_HandleKeyEvent(event, key) {
  // These keys came from the controller.
  /* Indicates the pipe transmission is complete */
  if (key == 4) {
    if (ChartConfig.combinedBuffer.length > 0) {
      /* Replace single quote with double quote */
      ChartConfig.combinedBuffer = ChartConfig.combinedBuffer.replace(/'/g, '"');
      /* remove whitespace before and after equal sign */
      ChartConfig.combinedBuffer = ChartConfig.combinedBuffer.replace(/\s*=\s*/g, '=');
      var lineData = ChartConfig.combinedBuffer.match(/(?:[^\s"]+|"[^"]*")+/g)
        for(var i = 0; i < lineData.length; i++) {
        if(lineData[i]) {
          var tempLineData = lineData[i].trim();
          if (tempLineData.indexOf('=') > 0) {
            var subData = tempLineData.split('=');
            chart_FormatDataStructure(subData);
          }
          else {
            chart_FormatDataStructure(lineData[i]);
          }
        }
      }
      ChartConfig.combinedBuffer = '';
      chart_CreateLabels();
      ChartConfig.thisChart.update();
    }
  }
}

function chart_HandlePipeEvent(event, file, buffer) {
  event.preventDefault();
  var data = event.data || event;
  
  if (file == data.Pipe) {
    if(data.Id) {
      current_canvas = data.Id;
      for (var idx = 0; idx < canvasIDs.length; idx++) {
        if(canvasIDs[idx] == data.Id) {
          ChartConfig = ChartConfig_array[idx];
          current_canvas = canvasIDs[idx];
        }
      }
    }
    if (buffer.length > 0) {
      ChartConfig.combinedBuffer = ChartConfig.combinedBuffer.concat(buffer);
    }
  }
  
  return true;
} // chart_HandlePipeEvent

/* This handles data that is coming through as a VAR */
/* Current assumption is only one value comes through at once */
function chart_HandleVarEvent(event, prog_name, var_name, type_code, val_str) {
  /* Remove Quotes */
  var_name = var_name.replace(/"/g, '');
  /* Loop over all ChartSource to find the right channel */
  for (var idx = 0; idx < ChartSource.chNum.length; ++idx) {
    if (prog_name.toUpperCase() == ChartSource.sourceType[idx] && var_name.toUpperCase() == ChartSource.sourceName[idx]) {
      chart_PopulateData(ChartSource.chNum[idx], false, null, parseFloat(val_str));
      /* TODO: What if the var in the same for two different channels? */
      /* break; */
    }
  }
  for (var idx = 0; idx < ChartName.chNum.length; ++idx) {
    if (prog_name.toUpperCase() == ChartName.sourceType[idx] && var_name.toUpperCase() == ChartName.sourceName[idx]) {
      ChartConfig.data.datasets[ChartSource.chNum[idx] - 1].label = val_str;
      /* TODO: What if the var in the same for two different channels? */
      /* break; */
    }
  }
  return true;
} // chart_HandleVarEvent

/* This handles data that is coming through as a IO */
function chart_HandleIOEvent(event, io_type, io_index, io_value) {
  /* Loop over all ChartSource to find the right channel */
  for (var idx = 0; idx < ChartSource.chNum.length; ++idx) {
    if (io_type.toUpperCase() == ChartSource.sourceType[idx] && io_index == ChartSource.sourceName[idx]) {
      chart_PopulateData(ChartSource.chNum[idx], false, null, parseFloat(io_value));
      /* TODO: What if the var in the same for two different channels? */
      /* break; */
    }
  }
  return true;
} // chart_HandleIOEvent

function chart_HandleClickEvent(event) {
  event.preventDefault();
  var data = event.data || event;
  chart_CtlEvent(data);
  return true;
} // chart_HandleClickEvent

function createChart() {
  var ctx = document.getElementById(current_canvas).getContext("2d");
  
  /* Need to remove the old chart if making a new one */
  if (ChartConfig.thisChart !== undefined)
    ChartConfig.thisChart.destroy();
  ChartConfig.thisChart = new Chart(ctx, ChartConfig);
  ChartConfig.thisChart.update();
}

function randomColor() {
  return ('#'+(Math.random()*0xFFFFFF<<0).toString(16));
}

function setupChartDefaults(data) {
  var chartGlobals = Chart.defaults.global;

  /* Line Defaults */
  /* Curvature of the line Typically: 0 - No Curve or .4 - Slight Cureve*/
  chartGlobals.elements.line.tension = 0;

  /* Animation time */
  chartGlobals.animation.duration = 0;
  
  /* Fonts */
  chartGlobals.defaultFontColor  = '#000000'
  chartGlobals.defaultFontFamily = data.FontName;
  chartGlobals.defaultFontSize   = parseInt(data.FontSize);
  chartGlobals.defaultFontStyle  = 'normal';
  if (parseInt(data.FontBold) > 0) {
    chartGlobals.defaultFontStyle  = 'bold';
  }
  else if (parseInt(data.FontItalic) > 0) {
    chartGlobals.defaultFontStyle  = 'italic';
  }
  else {
    chartGlobals.defaultFontStyle  = 'normal';
  }    

  /* Ledgend */
  chartGlobals.legend.position = 'left';
  chartGlobals.legend.labels.usePointStyle = true; /* Label style will match corresponding point style */
}

function chart_DefaultChannel(data, chNum) {
  /* NOTE: chNum starts at 1, not 0 */

  /* setup default dataset if active channel*/
  eval("tempName = data.ch" + chNum + "_Name");
  var rColor = randomColor();
  ChartConfig.data.datasets[chNum - 1] = {
    label: tempName,
    backgroundColor: rColor,
    borderColor: rColor,
    //borderWidth: 3,
    fillColor: rColor,
    data: [],
    hidden: false,
    legendHidden: false,
    fill: false,
    spanGaps: true,
    steppedLine: false,
    lineAtValue: [0, 0, 0, 0],
    lineAtValueC: [rColor, rColor, rColor, rColor],
    scaleY: "",
    autoScaleY: false,
  };

  /* Populate Color of Data */
  eval("tempVar = data.ch" + chNum + "_Color");
  /* Color of the Data */
  if (tempVar !== undefined) {
    /* Convert to hex and put in proper format */
    var curColor = translateColor(tempVar)
    ChartConfig.data.datasets[chNum - 1].backgroundColor = curColor;
    ChartConfig.data.datasets[chNum - 1].borderColor = curColor;
    ChartConfig.data.datasets[chNum - 1].lineAtValueC = [curColor, curColor, curColor, curColor];
  }
}

function chart_ActivateChannel(chNum) {
  ChartConfig.data.datasets[chNum - 1].hidden = false;
  ChartConfig.data.datasets[chNum - 1].legendHidden = false;
}

function chart_DeactivateChannel(chNum) {
  ChartConfig.data.datasets[chNum - 1].hidden = true;
  ChartConfig.data.datasets[chNum - 1].legendHidden = true;
}

function chart_ClearChannelData(chNum) {
  ChartConfig.data.datasets[chNum - 1].data = [];
}

function chart_PopulateData(chNum, interleaved, dataString, dataPoint) {
  /* NOTE: chNum starts at 1, not 0 */
  
  /* if data is paused, don't update dataset */
  if(paused) {
    return;
  }

  /* is data in string format */
  if (dataString) {
    /* replace double quote with single */
    dataString = dataString.replace(/['"]+/g, '');
    /* remove whitespace from beginning and end */
    dataString = dataString.trim();
    /* replace non-numbers with comma*/
    dataString = dataString.replace(/[^-0-9e+|.]+/g, ',');
    var array = dataString.split(",").map(Number);
    
    /* Not interleaved */
    if(!interleaved) {
      /* Erase current populated data */
      ChartConfig.data.datasets[chNum - 1].data = [];
      for (var i = 0; i < array.length; i++) {
        ChartConfig.data.datasets[chNum - 1].data.push(array[i]);
      }
    }
    /* Interleaved */
    else {
      for (var i = 0; i < array.length;) {
        for (var j = 0; j < chNum; j++) {
          if (ChartConfig.data.datasets[j]) {
            ChartConfig.data.datasets[j].data.push(array[i]);
          }
          i++;
        }
      }
    }
    
  }
  else if (dataPoint !== null) {
    ChartConfig.data.datasets[chNum - 1].data.push(dataPoint);
  }
  else {
    return
  }

}

function chart_CreateLabels() {

  var maxDataSet = 0; /* This is the length of the channel index with the more data points */

  for (var chIdx = 0; chIdx < maxNumCh; ++chIdx) {
    if (ChartConfig.data.datasets[chIdx]) {
      if (maxDataSet < ChartConfig.data.datasets[chIdx].data.length) {
        maxDataSet = ChartConfig.data.datasets[chIdx].data.length;
      }
    }
    /* Check if we need to auto scale */
    if(!ChartConfig.data.datasets[chIdx].hidden && ChartConfig.data.datasets[chIdx].autoScaleY) {
      var axis;
      if(barHorizontal) {
        axis = ChartConfig.options.scales.xAxes[0];
      }
      else {
        axis = ChartConfig.options.scales.yAxes[0];
      }
      if(axis.ticks.min !== undefined && axis.ticks.max !== undefined) {
        axis.ticks.suggestedMin = axis.ticks.min;
        axis.ticks.suggestedMax = axis.ticks.max;
        /* input zero is auto scale */
        chart_setYMaxMin(0);
      }
    }
  }

  /* Create Labels */
  /* CURRENTLY JUST DEFAULTING TO 1 INDEX STARTING AT 0*/
  if (maxDataSet && maxDataSet > ChartConfig.data.labels.length) {
    for (; maxDataSet > ChartConfig.data.labels.length || maxScaleX > ChartConfig.data.labels.length;) {
      ChartConfig.data.labels.push(parseFloat((ChartConfig.data.labels[ChartConfig.data.labels.length - 1] + ChartConfig.xStepSize).toPrecision(5)));
    }
  }

  /* Strip off data if larger that what user requested */
  if (maxDataSet >= 0 && maxDataSet > maxScaleX) {
    for (var chIdx = 0; chIdx < maxNumCh; ++chIdx) {
      if (ChartConfig.data.datasets[chIdx]) {
        for (; maxScaleX < ChartConfig.data.datasets[chIdx].data.length;) {
          ChartConfig.data.datasets[chIdx].data.shift();
        }
      }
    }
  }

  /* Strip off labels if larger that what user requested */
  for (; maxScaleX < ChartConfig.data.labels.length;) {
    ChartConfig.data.labels.shift();
  }
}

function chart_setYMaxMin(axisInput) {

  var axis;
  if(barHorizontal) {
    axis = ChartConfig.options.scales.xAxes[0];
  }
  else {
    axis = ChartConfig.options.scales.yAxes[0];
  }

  if (parseInt(axisInput) > 0) {
    var subData = ChartConfig.data.datasets[axisInput - 1].scaleY;
    subData = subData.trim();
    subData = subData.split(',');
    axis.ticks.min = parseInt(subData[0]);
    axis.ticks.max = parseInt(subData[1]);
    return
  }
  if (parseInt(axisInput) == 0) {
    axis.ticks.min = undefined;
    axis.ticks.max = undefined;
    return
  }
  
  axis.ticks.suggestedMax = 0;
  axis.ticks.suggestedMin = 0;

  /* Max Channels supported is 8 */
  for (var chIdx = 0; chIdx < maxNumCh; ++chIdx) {
    if(ChartConfig.data.datasets[chIdx]) {
      for (var markIdx = 0; markIdx < 4; ++markIdx) {
        if (axis.ticks.suggestedMax < ChartConfig.data.datasets[chIdx].lineAtValue[markIdx]) {
          axis.ticks.suggestedMax = ChartConfig.data.datasets[chIdx].lineAtValue[markIdx] + 1;
        }
        else if (axis.ticks.suggestedMin > ChartConfig.data.datasets[chIdx].lineAtValue[markIdx]) {
          axis.ticks.suggestedMin = ChartConfig.data.datasets[chIdx].lineAtValue[markIdx] - 1;
        }
      }
    }
  }

}

function chart_CreateHorizLineMarkers(chNum, markIdx, location) {
  /* NOTE: Marker Index starts at 1, not 0 */

  location = location.trim();
  var subData = location.split(',');
  /* Line is active */
  if (parseInt(subData[0]) === 1) {
    ChartConfig.data.datasets[chNum - 1].lineAtValue[markIdx - 1] = parseInt(subData[1]);
    /* Change color if it is sent */
    if (parseInt(subData[2])) {
      ChartConfig.data.datasets[chNum - 1].lineAtValueC[markIdx - 1] = translateColor(parseInt(subData[2]));
    }
  }
    /* Line is not active */
  else {
    ChartConfig.data.datasets[chNum - 1].lineAtValue[markIdx - 1] = 0;
  }

  chart_setYMaxMin();

}

function chart_CreateVertLineMarkers(markIdx, location) {
  /* NOTE: Marker Index starts at 1, not 0 */

  location = location.trim();
  var subData = location.split(',');
  /* Line is active */
  if (parseInt(subData[0]) === 1) {
    ChartConfig.data.lineAtIndex[markIdx - 1] = parseInt(subData[1]);
    /* Change color if it is sent */
    if (parseInt(subData[2])) {
      ChartConfig.data.lineAtIndexC[markIdx - 1] = translateColor(parseInt(subData[2]));
    }
  }
  /* Line is not active */ 
  else {
    ChartConfig.data.lineAtIndex[markIdx-1] = 0;
  }

}

function updateChart() {
  ChartConfig.data.labels.push(ChartConfig.data.labels[ChartConfig.data.labels.length - 1] + 1);

  for (var chIdx = 0; chIdx < maxNumCh; ++chIdx) {
    if (ChartConfig.data.datasets[chIdx]) {
      for (; ChartConfig.data.labels.length > ChartConfig.data.datasets[chIdx].data.length;) {
        ChartConfig.data.datasets[chIdx].data.push(ChartConfig.data.datasets[chIdx].data[ChartConfig.data.datasets[chIdx].data.length - 1]);
      }
    }
  }

  chart_CreateLabels();

  ChartConfig.thisChart.update();
  timeoutVar = setTimeout(function () { updateChart(); }, dataRate);
}

function chart_InitChart(data) {
  /* Create Canvas for the chart */
  if (data) {
    if(data.Id) {
      canvasIDs.push(data.Id);
      current_canvas = data.Id;
      ChartConfig = JSON.parse(JSON.stringify(ChartConfig_Default));
      ChartConfig.options.legend.labels.filter =
        function (legendItem, data) {
          var dataset = data.datasets[legendItem.datasetIndex];
          return !dataset.legendHidden;
        };
      ChartConfig_array.push(ChartConfig);
    }
    /* Create Canvas for the draw area */
    var out = '<canvas id="' + current_canvas + '"></canvas>';
    data.$this.html(out);
    var ctx = document.getElementById(current_canvas).getContext("2d");
    ctx.canvas.height = data.height;
    ctx.canvas.width = data.width;
  }
  else {
    var ctx = document.getElementById(current_canvas).getContext("2d");
    /* clear the canvas */
    ctx.fillStyle = backcolor;
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  }
  
  var numCh = 0; /* Num of Active Channels */
  var interleavedIdx = 0;
  
  /* These are used with the EVAL functions */
  var tempState;
  var tempName;
  var tempVar;
  var tempData;

  /* Set Chart Type */
  if (data.ChartType == 1) {
    ChartConfig.type = "bar";
    if(data.Orientation == 1) {
      ChartConfig.type = "horizontalBar";
      barHorizontal = true;
    }
  }
  else if (data.ChartType == 2) {
    ChartConfig.type = "line";
  }
  
  /* Show data values */
  if (data.DataShowValues == 1) {
    showValues = true;
  }

  /* Setup default label array */
  /* Get the Max amount of data to show on X axis */
  var scale = data.SampleScale;
  scale = scale.trim();
  scale = scale.split(',');
  ChartConfig.data.labels = [parseInt(scale[0])];
  maxScaleX = parseInt(scale[1]) - parseInt(scale[0]);
  
  ChartConfig.xStepSize = data.SampleScaleAspect;
  
  /* Max Channels supported is 8 */
  for (var chIdx = 0; chIdx < maxNumCh; ++chIdx) {
    var chNum = chIdx + 1;

    /* Check if channel is valid */
    eval("tempName = data.ch" + chNum + "_Name");
    if (undefined !== tempName) {  
      chart_DefaultChannel(data, chNum);

      /* Check if Channel is active */
      eval("tempState = data.ch" + chNum + "_State");
      if (tempState && parseInt(tempState)) {
        chart_ActivateChannel(chNum);
        numCh++;
      }
      else {
        chart_DeactivateChannel(chNum);
      }

      /* Check if Channel line is stepped (Digital) */
      eval("tempState = data.ch" + chNum + "_Digital");
      if (tempState) {
        ChartConfig.data.datasets[chIdx].steppedLine = Boolean(parseInt(tempState));
      }

      /* Check if there are horizontal Line markers */
      for (var markIdx = 1; markIdx <= 4; ++markIdx) {
        eval("tempData = data.ch" + chNum + "_DataMarker" + markIdx);
        if (tempData) {
          chart_CreateHorizLineMarkers(chNum, markIdx, tempData)
        }
      }

      /* Get Y Scale */
      eval("tempData = data.ch" + chNum + "_DataScale");
      ChartConfig.data.datasets[chIdx].scaleY = tempData;
      
      /* Get Auto Y Scale */
      eval("tempData = data.ch" + chNum + "_AutoRange");
      ChartConfig.data.datasets[chIdx].autoScaleY = Boolean(parseInt(tempData));
    }

    /* Populate Data */
    eval("tempData = data.ch" + chNum + "_Data");
    if(tempData) {
      chart_PopulateData(chNum, false, tempData, null)
    }
    
    /* Check if interleaved data exists - to be used later*/
    eval("tempData = data.ch_Data_" + chNum);
    if(tempData) {
      interleavedIdx = chNum;
    }
  }

  /* set Y axis */
  if (data.LineScaleActive) {
    chart_setYMaxMin(data.LineScaleActive);
  }
  
  /* Interleaved data overrides ch#_Data - Re-Populate Data */
  if (interleavedIdx) {
    eval("tempData = data.ch_Data_" + interleavedIdx);
    chart_PopulateData(interleavedIdx, true, tempData, null)
  }
    
  /* Set Chart Title */
  if(data.Caption) {
    ChartConfig.options.title.text = data.Caption;
    ChartConfig.options.title.display = true;
  }

  /* There are only 4 Sample Markers */
  for (var markIdx = 1; markIdx <= 4; ++markIdx) {
    eval("tempData = data.SampleMarker" + markIdx);
    if (tempData) {
      if (data.SampleMarkerColor > 0) {
        ChartConfig.data.lineAtIndexC[markIdx - 1] = translateColor(data.SampleMarkerColor);
      }
      chart_CreateVertLineMarkers(markIdx, tempData)
    }
  }

  chart_CreateLabels();
  
  createChart();
} // chart_InitchartFile


function chart_DrawLines(chart) {
  var ctx = chart.chart.ctx;
  var xaxis = chart.scales['x-axis-0'];
  var yaxis = chart.scales['y-axis-0'];

  /* Draw vertical Line - Uses lineAtIndex*/
  for (var markIdx = 0; markIdx < 4; ++markIdx) {
    var index = chart.config.data.lineAtIndex[markIdx];
    if (index) {
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(xaxis.getPixelForValue(undefined, index), yaxis.top);
      ctx.strokeStyle = chart.config.data.lineAtIndexC[markIdx];
      ctx.lineTo(xaxis.getPixelForValue(undefined, index), yaxis.bottom);
      ctx.stroke();
      ctx.restore();
    }
  }


  /* Draw horizontal Line - Uses lineAtValue*/
  /* Max Channels supported is 8 */
  for (var chIdx = 0; chIdx < maxNumCh; ++chIdx) {
    if (ChartConfig.data.datasets[chIdx]) {
      for (var markIdx = 0; markIdx < 4; ++markIdx) {
        var value = ChartConfig.data.datasets[chIdx].lineAtValue[markIdx];
        if (value) {
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(xaxis.left, yaxis.getPixelForValue(value));
          ctx.strokeStyle = ChartConfig.data.datasets[chIdx].lineAtValueC[markIdx];
          ctx.lineTo(xaxis.right, yaxis.getPixelForValue(value));
          ctx.stroke();
          ctx.restore();
        }
      }
    }
  }
  
  /* Show latest data value on chart */
  if(showValues && ChartConfig.thisChart !== undefined){
    for (var chIdx = 0; chIdx < maxNumCh; ++chIdx) {
      if (ChartConfig.data.datasets[chIdx] && ChartConfig.data.datasets[chIdx].data.length) {
        var meta = ChartConfig.thisChart.getDatasetMeta(chIdx);
        var dataIdx = ChartConfig.data.datasets[chIdx].data.length-1;
        var data = ChartConfig.data.datasets[chIdx].data[dataIdx];
        var x = meta.data[dataIdx]._model.x;
        var y = meta.data[dataIdx]._model.y;

        if(!isNaN(data) && meta.hidden != true && ChartConfig.data.datasets[chIdx].hidden != true) {
          ctx.save();
          ctx.textAlign = 'center';        
          if(ChartConfig.type == "line") {
            ctx.fillStyle = meta.data[dataIdx]._model.backgroundColor;
            ctx.translate(x - ((data.toString().length)*2), y-8);
          }
          else {
            var center = meta.data[dataIdx].getCenterPoint();
            /* Change text to white if black text on black background - default black for Bar*/
            ctx.fillStyle = "#000000";
            if(meta.data[dataIdx]._model.backgroundColor == "#000000") {
              ctx.fillStyle = "#FFFFFF";
            }
            ctx.translate(center.x, center.y);
            /* rotate text for vertical bar cahrts */
            if(!barHorizontal) {
              ctx.rotate(-0.5 * Math.PI);
            }
            /* Shift text over if too close to axis */
            else if (x - center.x < ((data.toString().length)*3)){
              ctx.translate(((data.toString().length)*3), 0);
            }
          }
          ctx.fillText(data, 0, 0);
          ctx.restore();
        }
      }
    }
  }

}

/* Draw Lines on Line chart */
var originalLineDraw = Chart.controllers.line.prototype.draw;
Chart.helpers.extend(Chart.controllers.line.prototype, {
  draw: function () {
    originalLineDraw.apply(this, arguments);
    var chart = this.chart;
    chart_DrawLines(chart);
  }
});

/* Draw Lines on Bar chart */
var originalBarDraw = Chart.controllers.bar.prototype.draw;
Chart.helpers.extend(Chart.controllers.bar.prototype, {
  draw: function () {
    originalBarDraw.apply(this, arguments);
    var chart = this.chart;
    chart_DrawLines(chart);
  }
});                                                                                                                                                    /*!
 * Chart.js v2.8.0
 * https://www.chartjs.org
 * (c) 2019 Chart.js Contributors
 * Released under the MIT License
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.Chart=e()}(this,function(){"use strict";var t={rgb2hsl:e,rgb2hsv:i,rgb2hwb:n,rgb2cmyk:a,rgb2keyword:o,rgb2xyz:s,rgb2lab:l,rgb2lch:function(t){return v(l(t))},hsl2rgb:u,hsl2hsv:function(t){var e=t[0],i=t[1]/100,n=t[2]/100;if(0===n)return[0,0,0];return[e,100*(2*(i*=(n*=2)<=1?n:2-n)/(n+i)),100*((n+i)/2)]},hsl2hwb:function(t){return n(u(t))},hsl2cmyk:function(t){return a(u(t))},hsl2keyword:function(t){return o(u(t))},hsv2rgb:d,hsv2hsl:function(t){var e,i,n=t[0],a=t[1]/100,r=t[2]/100;return e=a*r,[n,100*(e=(e/=(i=(2-a)*r)<=1?i:2-i)||0),100*(i/=2)]},hsv2hwb:function(t){return n(d(t))},hsv2cmyk:function(t){return a(d(t))},hsv2keyword:function(t){return o(d(t))},hwb2rgb:h,hwb2hsl:function(t){return e(h(t))},hwb2hsv:function(t){return i(h(t))},hwb2cmyk:function(t){return a(h(t))},hwb2keyword:function(t){return o(h(t))},cmyk2rgb:c,cmyk2hsl:function(t){return e(c(t))},cmyk2hsv:function(t){return i(c(t))},cmyk2hwb:function(t){return n(c(t))},cmyk2keyword:function(t){return o(c(t))},keyword2rgb:_,keyword2hsl:function(t){return e(_(t))},keyword2hsv:function(t){return i(_(t))},keyword2hwb:function(t){return n(_(t))},keyword2cmyk:function(t){return a(_(t))},keyword2lab:function(t){return l(_(t))},keyword2xyz:function(t){return s(_(t))},xyz2rgb:f,xyz2lab:m,xyz2lch:function(t){return v(m(t))},lab2xyz:p,lab2rgb:y,lab2lch:v,lch2lab:x,lch2xyz:function(t){return p(x(t))},lch2rgb:function(t){return y(x(t))}};function e(t){var e,i,n=t[0]/255,a=t[1]/255,r=t[2]/255,o=Math.min(n,a,r),s=Math.max(n,a,r),l=s-o;return s==o?e=0:n==s?e=(a-r)/l:a==s?e=2+(r-n)/l:r==s&&(e=4+(n-a)/l),(e=Math.min(60*e,360))<0&&(e+=360),i=(o+s)/2,[e,100*(s==o?0:i<=.5?l/(s+o):l/(2-s-o)),100*i]}function i(t){var e,i,n=t[0],a=t[1],r=t[2],o=Math.min(n,a,r),s=Math.max(n,a,r),l=s-o;return i=0==s?0:l/s*1e3/10,s==o?e=0:n==s?e=(a-r)/l:a==s?e=2+(r-n)/l:r==s&&(e=4+(n-a)/l),(e=Math.min(60*e,360))<0&&(e+=360),[e,i,s/255*1e3/10]}function n(t){var i=t[0],n=t[1],a=t[2];return[e(t)[0],100*(1/255*Math.min(i,Math.min(n,a))),100*(a=1-1/255*Math.max(i,Math.max(n,a)))]}function a(t){var e,i=t[0]/255,n=t[1]/255,a=t[2]/255;return[100*((1-i-(e=Math.min(1-i,1-n,1-a)))/(1-e)||0),100*((1-n-e)/(1-e)||0),100*((1-a-e)/(1-e)||0),100*e]}function o(t){return w[JSON.stringify(t)]}function s(t){var e=t[0]/255,i=t[1]/255,n=t[2]/255;return[100*(.4124*(e=e>.04045?Math.pow((e+.055)/1.055,2.4):e/12.92)+.3576*(i=i>.04045?Math.pow((i+.055)/1.055,2.4):i/12.92)+.1805*(n=n>.04045?Math.pow((n+.055)/1.055,2.4):n/12.92)),100*(.2126*e+.7152*i+.0722*n),100*(.0193*e+.1192*i+.9505*n)]}function l(t){var e=s(t),i=e[0],n=e[1],a=e[2];return n/=100,a/=108.883,i=(i/=95.047)>.008856?Math.pow(i,1/3):7.787*i+16/116,[116*(n=n>.008856?Math.pow(n,1/3):7.787*n+16/116)-16,500*(i-n),200*(n-(a=a>.008856?Math.pow(a,1/3):7.787*a+16/116))]}function u(t){var e,i,n,a,r,o=t[0]/360,s=t[1]/100,l=t[2]/100;if(0==s)return[r=255*l,r,r];e=2*l-(i=l<.5?l*(1+s):l+s-l*s),a=[0,0,0];for(var u=0;u<3;u++)(n=o+1/3*-(u-1))<0&&n++,n>1&&n--,r=6*n<1?e+6*(i-e)*n:2*n<1?i:3*n<2?e+(i-e)*(2/3-n)*6:e,a[u]=255*r;return a}function d(t){var e=t[0]/60,i=t[1]/100,n=t[2]/100,a=Math.floor(e)%6,r=e-Math.floor(e),o=255*n*(1-i),s=255*n*(1-i*r),l=255*n*(1-i*(1-r));n*=255;switch(a){case 0:return[n,l,o];case 1:return[s,n,o];case 2:return[o,n,l];case 3:return[o,s,n];case 4:return[l,o,n];case 5:return[n,o,s]}}function h(t){var e,i,n,a,o=t[0]/360,s=t[1]/100,l=t[2]/100,u=s+l;switch(u>1&&(s/=u,l/=u),n=6*o-(e=Math.floor(6*o)),0!=(1&e)&&(n=1-n),a=s+n*((i=1-l)-s),e){default:case 6:case 0:r=i,g=a,b=s;break;case 1:r=a,g=i,b=s;break;case 2:r=s,g=i,b=a;break;case 3:r=s,g=a,b=i;break;case 4:r=a,g=s,b=i;break;case 5:r=i,g=s,b=a}return[255*r,255*g,255*b]}function c(t){var e=t[0]/100,i=t[1]/100,n=t[2]/100,a=t[3]/100;return[255*(1-Math.min(1,e*(1-a)+a)),255*(1-Math.min(1,i*(1-a)+a)),255*(1-Math.min(1,n*(1-a)+a))]}function f(t){var e,i,n,a=t[0]/100,r=t[1]/100,o=t[2]/100;return i=-.9689*a+1.8758*r+.0415*o,n=.0557*a+-.204*r+1.057*o,e=(e=3.2406*a+-1.5372*r+-.4986*o)>.0031308?1.055*Math.pow(e,1/2.4)-.055:e*=12.92,i=i>.0031308?1.055*Math.pow(i,1/2.4)-.055:i*=12.92,n=n>.0031308?1.055*Math.pow(n,1/2.4)-.055:n*=12.92,[255*(e=Math.min(Math.max(0,e),1)),255*(i=Math.min(Math.max(0,i),1)),255*(n=Math.min(Math.max(0,n),1))]}function m(t){var e=t[0],i=t[1],n=t[2];return i/=100,n/=108.883,e=(e/=95.047)>.008856?Math.pow(e,1/3):7.787*e+16/116,[116*(i=i>.008856?Math.pow(i,1/3):7.787*i+16/116)-16,500*(e-i),200*(i-(n=n>.008856?Math.pow(n,1/3):7.787*n+16/116))]}function p(t){var e,i,n,a,r=t[0],o=t[1],s=t[2];return r<=8?a=(i=100*r/903.3)/100*7.787+16/116:(i=100*Math.pow((r+16)/116,3),a=Math.pow(i/100,1/3)),[e=e/95.047<=.008856?e=95.047*(o/500+a-16/116)/7.787:95.047*Math.pow(o/500+a,3),i,n=n/108.883<=.008859?n=108.883*(a-s/200-16/116)/7.787:108.883*Math.pow(a-s/200,3)]}function v(t){var e,i=t[0],n=t[1],a=t[2];return(e=360*Math.atan2(a,n)/2/Math.PI)<0&&(e+=360),[i,Math.sqrt(n*n+a*a),e]}function y(t){return f(p(t))}function x(t){var e,i=t[0],n=t[1];return e=t[2]/360*2*Math.PI,[i,n*Math.cos(e),n*Math.sin(e)]}function _(t){return k[t]}var k={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},w={};for(var M in k)w[JSON.stringify(k[M])]=M;var S=function(){return new O};for(var D in t){S[D+"Raw"]=function(e){return function(i){return"number"==typeof i&&(i=Array.prototype.slice.call(arguments)),t[e](i)}}(D);var C=/(\w+)2(\w+)/.exec(D),P=C[1],T=C[2];(S[P]=S[P]||{})[T]=S[D]=function(e){return function(i){"number"==typeof i&&(i=Array.prototype.slice.call(arguments));var n=t[e](i);if("string"==typeof n||void 0===n)return n;for(var a=0;a<n.length;a++)n[a]=Math.round(n[a]);return n}}(D)}var O=function(){this.convs={}};O.prototype.routeSpace=function(t,e){var i=e[0];return void 0===i?this.getValues(t):("number"==typeof i&&(i=Array.prototype.slice.call(e)),this.setValues(t,i))},O.prototype.setValues=function(t,e){return this.space=t,this.convs={},this.convs[t]=e,this},O.prototype.getValues=function(t){var e=this.convs[t];if(!e){var i=this.space,n=this.convs[i];e=S[i][t](n),this.convs[t]=e}return e},["rgb","hsl","hsv","cmyk","keyword"].forEach(function(t){O.prototype[t]=function(e){return this.routeSpace(t,arguments)}});var I=S,A={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},F={getRgba:R,getHsla:L,getRgb:function(t){var e=R(t);return e&&e.slice(0,3)},getHsl:function(t){var e=L(t);return e&&e.slice(0,3)},getHwb:W,getAlpha:function(t){var e=R(t);if(e)return e[3];if(e=L(t))return e[3];if(e=W(t))return e[3]},hexString:function(t,e){var e=void 0!==e&&3===t.length?e:t[3];return"#"+H(t[0])+H(t[1])+H(t[2])+(e>=0&&e<1?H(Math.round(255*e)):"")},rgbString:function(t,e){if(e<1||t[3]&&t[3]<1)return Y(t,e);return"rgb("+t[0]+", "+t[1]+", "+t[2]+")"},rgbaString:Y,percentString:function(t,e){if(e<1||t[3]&&t[3]<1)return N(t,e);var i=Math.round(t[0]/255*100),n=Math.round(t[1]/255*100),a=Math.round(t[2]/255*100);return"rgb("+i+"%, "+n+"%, "+a+"%)"},percentaString:N,hslString:function(t,e){if(e<1||t[3]&&t[3]<1)return z(t,e);return"hsl("+t[0]+", "+t[1]+"%, "+t[2]+"%)"},hslaString:z,hwbString:function(t,e){void 0===e&&(e=void 0!==t[3]?t[3]:1);return"hwb("+t[0]+", "+t[1]+"%, "+t[2]+"%"+(void 0!==e&&1!==e?", "+e:"")+")"},keyword:function(t){return E[t.slice(0,3)]}};function R(t){if(t){var e=[0,0,0],i=1,n=t.match(/^#([a-fA-F0-9]{3,4})$/i),a="";if(n){a=(n=n[1])[3];for(var r=0;r<e.length;r++)e[r]=parseInt(n[r]+n[r],16);a&&(i=Math.round(parseInt(a+a,16)/255*100)/100)}else if(n=t.match(/^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i)){a=n[2],n=n[1];for(r=0;r<e.length;r++)e[r]=parseInt(n.slice(2*r,2*r+2),16);a&&(i=Math.round(parseInt(a,16)/255*100)/100)}else if(n=t.match(/^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)){for(r=0;r<e.length;r++)e[r]=parseInt(n[r+1]);i=parseFloat(n[4])}else if(n=t.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)){for(r=0;r<e.length;r++)e[r]=Math.round(2.55*parseFloat(n[r+1]));i=parseFloat(n[4])}else if(n=t.match(/(\w+)/)){if("transparent"==n[1])return[0,0,0,0];if(!(e=A[n[1]]))return}for(r=0;r<e.length;r++)e[r]=V(e[r],0,255);return i=i||0==i?V(i,0,1):1,e[3]=i,e}}function L(t){if(t){var e=t.match(/^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/);if(e){var i=parseFloat(e[4]);return[V(parseInt(e[1]),0,360),V(parseFloat(e[2]),0,100),V(parseFloat(e[3]),0,100),V(isNaN(i)?1:i,0,1)]}}}function W(t){if(t){var e=t.match(/^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/);if(e){var i=parseFloat(e[4]);return[V(parseInt(e[1]),0,360),V(parseFloat(e[2]),0,100),V(parseFloat(e[3]),0,100),V(isNaN(i)?1:i,0,1)]}}}function Y(t,e){return void 0===e&&(e=void 0!==t[3]?t[3]:1),"rgba("+t[0]+", "+t[1]+", "+t[2]+", "+e+")"}function N(t,e){return"rgba("+Math.round(t[0]/255*100)+"%, "+Math.round(t[1]/255*100)+"%, "+Math.round(t[2]/255*100)+"%, "+(e||t[3]||1)+")"}function z(t,e){return void 0===e&&(e=void 0!==t[3]?t[3]:1),"hsla("+t[0]+", "+t[1]+"%, "+t[2]+"%, "+e+")"}function V(t,e,i){return Math.min(Math.max(e,t),i)}function H(t){var e=t.toString(16).toUpperCase();return e.length<2?"0"+e:e}var E={};for(var B in A)E[A[B]]=B;var j=function(t){return t instanceof j?t:this instanceof j?(this.valid=!1,this.values={rgb:[0,0,0],hsl:[0,0,0],hsv:[0,0,0],hwb:[0,0,0],cmyk:[0,0,0,0],alpha:1},void("string"==typeof t?(e=F.getRgba(t))?this.setValues("rgb",e):(e=F.getHsla(t))?this.setValues("hsl",e):(e=F.getHwb(t))&&this.setValues("hwb",e):"object"==typeof t&&(void 0!==(e=t).r||void 0!==e.red?this.setValues("rgb",e):void 0!==e.l||void 0!==e.lightness?this.setValues("hsl",e):void 0!==e.v||void 0!==e.value?this.setValues("hsv",e):void 0!==e.w||void 0!==e.whiteness?this.setValues("hwb",e):void 0===e.c&&void 0===e.cyan||this.setValues("cmyk",e)))):new j(t);var e};j.prototype={isValid:function(){return this.valid},rgb:function(){return this.setSpace("rgb",arguments)},hsl:function(){return this.setSpace("hsl",arguments)},hsv:function(){return this.setSpace("hsv",arguments)},hwb:function(){return this.setSpace("hwb",arguments)},cmyk:function(){return this.setSpace("cmyk",arguments)},rgbArray:function(){return this.values.rgb},hslArray:function(){return this.values.hsl},hsvArray:function(){return this.values.hsv},hwbArray:function(){var t=this.values;return 1!==t.alpha?t.hwb.concat([t.alpha]):t.hwb},cmykArray:function(){return this.values.cmyk},rgbaArray:function(){var t=this.values;return t.rgb.concat([t.alpha])},hslaArray:function(){var t=this.values;return t.hsl.concat([t.alpha])},alpha:function(t){return void 0===t?this.values.alpha:(this.setValues("alpha",t),this)},red:function(t){return this.setChannel("rgb",0,t)},green:function(t){return this.setChannel("rgb",1,t)},blue:function(t){return this.setChannel("rgb",2,t)},hue:function(t){return t&&(t=(t%=360)<0?360+t:t),this.setChannel("hsl",0,t)},saturation:function(t){return this.setChannel("hsl",1,t)},lightness:function(t){return this.setChannel("hsl",2,t)},saturationv:function(t){return this.setChannel("hsv",1,t)},whiteness:function(t){return this.setChannel("hwb",1,t)},blackness:function(t){return this.setChannel("hwb",2,t)},value:function(t){return this.setChannel("hsv",2,t)},cyan:function(t){return this.setChannel("cmyk",0,t)},magenta:function(t){return this.setChannel("cmyk",1,t)},yellow:function(t){return this.setChannel("cmyk",2,t)},black:function(t){return this.setChannel("cmyk",3,t)},hexString:function(){return F.hexString(this.values.rgb)},rgbString:function(){return F.rgbString(this.values.rgb,this.values.alpha)},rgbaString:function(){return F.rgbaString(this.values.rgb,this.values.alpha)},percentString:function(){return F.percentString(this.values.rgb,this.values.alpha)},hslString:function(){return F.hslString(this.values.hsl,this.values.alpha)},hslaString:function(){return F.hslaString(this.values.hsl,this.values.alpha)},hwbString:function(){return F.hwbString(this.values.hwb,this.values.alpha)},keyword:function(){return F.keyword(this.values.rgb,this.values.alpha)},rgbNumber:function(){var t=this.values.rgb;return t[0]<<16|t[1]<<8|t[2]},luminosity:function(){for(var t=this.values.rgb,e=[],i=0;i<t.length;i++){var n=t[i]/255;e[i]=n<=.03928?n/12.92:Math.pow((n+.055)/1.055,2.4)}return.2126*e[0]+.7152*e[1]+.0722*e[2]},contrast:function(t){var e=this.luminosity(),i=t.luminosity();return e>i?(e+.05)/(i+.05):(i+.05)/(e+.05)},level:function(t){var e=this.contrast(t);return e>=7.1?"AAA":e>=4.5?"AA":""},dark:function(){var t=this.values.rgb;return(299*t[0]+587*t[1]+114*t[2])/1e3<128},light:function(){return!this.dark()},negate:function(){for(var t=[],e=0;e<3;e++)t[e]=255-this.values.rgb[e];return this.setValues("rgb",t),this},lighten:function(t){var e=this.values.hsl;return e[2]+=e[2]*t,this.setValues("hsl",e),this},darken:function(t){var e=this.values.hsl;return e[2]-=e[2]*t,this.setValues("hsl",e),this},saturate:function(t){var e=this.values.hsl;return e[1]+=e[1]*t,this.setValues("hsl",e),this},desaturate:function(t){var e=this.values.hsl;return e[1]-=e[1]*t,this.setValues("hsl",e),this},whiten:function(t){var e=this.values.hwb;return e[1]+=e[1]*t,this.setValues("hwb",e),this},blacken:function(t){var e=this.values.hwb;return e[2]+=e[2]*t,this.setValues("hwb",e),this},greyscale:function(){var t=this.values.rgb,e=.3*t[0]+.59*t[1]+.11*t[2];return this.setValues("rgb",[e,e,e]),this},clearer:function(t){var e=this.values.alpha;return this.setValues("alpha",e-e*t),this},opaquer:function(t){var e=this.values.alpha;return this.setValues("alpha",e+e*t),this},rotate:function(t){var e=this.values.hsl,i=(e[0]+t)%360;return e[0]=i<0?360+i:i,this.setValues("hsl",e),this},mix:function(t,e){var i=t,n=void 0===e?.5:e,a=2*n-1,r=this.alpha()-i.alpha(),o=((a*r==-1?a:(a+r)/(1+a*r))+1)/2,s=1-o;return this.rgb(o*this.red()+s*i.red(),o*this.green()+s*i.green(),o*this.blue()+s*i.blue()).alpha(this.alpha()*n+i.alpha()*(1-n))},toJSON:function(){return this.rgb()},clone:function(){var t,e,i=new j,n=this.values,a=i.values;for(var r in n)n.hasOwnProperty(r)&&(t=n[r],"[object Array]"===(e={}.toString.call(t))?a[r]=t.slice(0):"[object Number]"===e?a[r]=t:console.error("unexpected color value:",t));return i}},j.prototype.spaces={rgb:["red","green","blue"],hsl:["hue","saturation","lightness"],hsv:["hue","saturation","value"],hwb:["hue","whiteness","blackness"],cmyk:["cyan","magenta","yellow","black"]},j.prototype.maxes={rgb:[255,255,255],hsl:[360,100,100],hsv:[360,100,100],hwb:[360,100,100],cmyk:[100,100,100,100]},j.prototype.getValues=function(t){for(var e=this.values,i={},n=0;n<t.length;n++)i[t.charAt(n)]=e[t][n];return 1!==e.alpha&&(i.a=e.alpha),i},j.prototype.setValues=function(t,e){var i,n,a=this.values,r=this.spaces,o=this.maxes,s=1;if(this.valid=!0,"alpha"===t)s=e;else if(e.length)a[t]=e.slice(0,t.length),s=e[t.length];else if(void 0!==e[t.charAt(0)]){for(i=0;i<t.length;i++)a[t][i]=e[t.charAt(i)];s=e.a}else if(void 0!==e[r[t][0]]){var l=r[t];for(i=0;i<t.length;i++)a[t][i]=e[l[i]];s=e.alpha}if(a.alpha=Math.max(0,Math.min(1,void 0===s?a.alpha:s)),"alpha"===t)return!1;for(i=0;i<t.length;i++)n=Math.max(0,Math.min(o[t][i],a[t][i])),a[t][i]=Math.round(n);for(var u in r)u!==t&&(a[u]=I[t][u](a[t]));return!0},j.prototype.setSpace=function(t,e){var i=e[0];return void 0===i?this.getValues(t):("number"==typeof i&&(i=Array.prototype.slice.call(e)),this.setValues(t,i),this)},j.prototype.setChannel=function(t,e,i){var n=this.values[t];return void 0===i?n[e]:i===n[e]?this:(n[e]=i,this.setValues(t,n),this)},"undefined"!=typeof window&&(window.Color=j);var U,G=j,q={noop:function(){},uid:(U=0,function(){return U++}),isNullOrUndef:function(t){return null==t},isArray:function(t){if(Array.isArray&&Array.isArray(t))return!0;var e=Object.prototype.toString.call(t);return"[object"===e.substr(0,7)&&"Array]"===e.substr(-6)},isObject:function(t){return null!==t&&"[object Object]"===Object.prototype.toString.call(t)},isFinite:function(t){return("number"==typeof t||t instanceof Number)&&isFinite(t)},valueOrDefault:function(t,e){return void 0===t?e:t},valueAtIndexOrDefault:function(t,e,i){return q.valueOrDefault(q.isArray(t)?t[e]:t,i)},callback:function(t,e,i){if(t&&"function"==typeof t.call)return t.apply(i,e)},each:function(t,e,i,n){var a,r,o;if(q.isArray(t))if(r=t.length,n)for(a=r-1;a>=0;a--)e.call(i,t[a],a);else for(a=0;a<r;a++)e.call(i,t[a],a);else if(q.isObject(t))for(r=(o=Object.keys(t)).length,a=0;a<r;a++)e.call(i,t[o[a]],o[a])},arrayEquals:function(t,e){var i,n,a,r;if(!t||!e||t.length!==e.length)return!1;for(i=0,n=t.length;i<n;++i)if(a=t[i],r=e[i],a instanceof Array&&r instanceof Array){if(!q.arrayEquals(a,r))return!1}else if(a!==r)return!1;return!0},clone:function(t){if(q.isArray(t))return t.map(q.clone);if(q.isObject(t)){for(var e={},i=Object.keys(t),n=i.length,a=0;a<n;++a)e[i[a]]=q.clone(t[i[a]]);return e}return t},_merger:function(t,e,i,n){var a=e[t],r=i[t];q.isObject(a)&&q.isObject(r)?q.merge(a,r,n):e[t]=q.clone(r)},_mergerIf:function(t,e,i){var n=e[t],a=i[t];q.isObject(n)&&q.isObject(a)?q.mergeIf(n,a):e.hasOwnProperty(t)||(e[t]=q.clone(a))},merge:function(t,e,i){var n,a,r,o,s,l=q.isArray(e)?e:[e],u=l.length;if(!q.isObject(t))return t;for(n=(i=i||{}).merger||q._merger,a=0;a<u;++a)if(e=l[a],q.isObject(e))for(s=0,o=(r=Object.keys(e)).length;s<o;++s)n(r[s],t,e,i);return t},mergeIf:function(t,e){return q.merge(t,e,{merger:q._mergerIf})},extend:function(t){for(var e=function(e,i){t[i]=e},i=1,n=arguments.length;i<n;++i)q.each(arguments[i],e);return t},inherits:function(t){var e=this,i=t&&t.hasOwnProperty("constructor")?t.constructor:function(){return e.apply(this,arguments)},n=function(){this.constructor=i};return n.prototype=e.prototype,i.prototype=new n,i.extend=q.inherits,t&&q.extend(i.prototype,t),i.__super__=e.prototype,i}},Z=q;q.callCallback=q.callback,q.indexOf=function(t,e,i){return Array.prototype.indexOf.call(t,e,i)},q.getValueOrDefault=q.valueOrDefault,q.getValueAtIndexOrDefault=q.valueAtIndexOrDefault;var $={linear:function(t){return t},easeInQuad:function(t){return t*t},easeOutQuad:function(t){return-t*(t-2)},easeInOutQuad:function(t){return(t/=.5)<1?.5*t*t:-.5*(--t*(t-2)-1)},easeInCubic:function(t){return t*t*t},easeOutCubic:function(t){return(t-=1)*t*t+1},easeInOutCubic:function(t){return(t/=.5)<1?.5*t*t*t:.5*((t-=2)*t*t+2)},easeInQuart:function(t){return t*t*t*t},easeOutQuart:function(t){return-((t-=1)*t*t*t-1)},easeInOutQuart:function(t){return(t/=.5)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2)},easeInQuint:function(t){return t*t*t*t*t},easeOutQuint:function(t){return(t-=1)*t*t*t*t+1},easeInOutQuint:function(t){return(t/=.5)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2)},easeInSine:function(t){return 1-Math.cos(t*(Math.PI/2))},easeOutSine:function(t){return Math.sin(t*(Math.PI/2))},easeInOutSine:function(t){return-.5*(Math.cos(Math.PI*t)-1)},easeInExpo:function(t){return 0===t?0:Math.pow(2,10*(t-1))},easeOutExpo:function(t){return 1===t?1:1-Math.pow(2,-10*t)},easeInOutExpo:function(t){return 0===t?0:1===t?1:(t/=.5)<1?.5*Math.pow(2,10*(t-1)):.5*(2-Math.pow(2,-10*--t))},easeInCirc:function(t){return t>=1?t:-(Math.sqrt(1-t*t)-1)},easeOutCirc:function(t){return Math.sqrt(1-(t-=1)*t)},easeInOutCirc:function(t){return(t/=.5)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)},easeInElastic:function(t){var e=1.70158,i=0,n=1;return 0===t?0:1===t?1:(i||(i=.3),n<1?(n=1,e=i/4):e=i/(2*Math.PI)*Math.asin(1/n),-n*Math.pow(2,10*(t-=1))*Math.sin((t-e)*(2*Math.PI)/i))},easeOutElastic:function(t){var e=1.70158,i=0,n=1;return 0===t?0:1===t?1:(i||(i=.3),n<1?(n=1,e=i/4):e=i/(2*Math.PI)*Math.asin(1/n),n*Math.pow(2,-10*t)*Math.sin((t-e)*(2*Math.PI)/i)+1)},easeInOutElastic:function(t){var e=1.70158,i=0,n=1;return 0===t?0:2==(t/=.5)?1:(i||(i=.45),n<1?(n=1,e=i/4):e=i/(2*Math.PI)*Math.asin(1/n),t<1?n*Math.pow(2,10*(t-=1))*Math.sin((t-e)*(2*Math.PI)/i)*-.5:n*Math.pow(2,-10*(t-=1))*Math.sin((t-e)*(2*Math.PI)/i)*.5+1)},easeInBack:function(t){var e=1.70158;return t*t*((e+1)*t-e)},easeOutBack:function(t){var e=1.70158;return(t-=1)*t*((e+1)*t+e)+1},easeInOutBack:function(t){var e=1.70158;return(t/=.5)<1?t*t*((1+(e*=1.525))*t-e)*.5:.5*((t-=2)*t*((1+(e*=1.525))*t+e)+2)},easeInBounce:function(t){return 1-$.easeOutBounce(1-t)},easeOutBounce:function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},easeInOutBounce:function(t){return t<.5?.5*$.easeInBounce(2*t):.5*$.easeOutBounce(2*t-1)+.5}},X={effects:$};Z.easingEffects=$;var K=Math.PI,J=K/180,Q=2*K,tt=K/2,et=K/4,it=2*K/3,nt={clear:function(t){t.ctx.clearRect(0,0,t.width,t.height)},roundedRect:function(t,e,i,n,a,r){if(r){var o=Math.min(r,a/2,n/2),s=e+o,l=i+o,u=e+n-o,d=i+a-o;t.moveTo(e,l),s<u&&l<d?(t.arc(s,l,o,-K,-tt),t.arc(u,l,o,-tt,0),t.arc(u,d,o,0,tt),t.arc(s,d,o,tt,K)):s<u?(t.moveTo(s,i),t.arc(u,l,o,-tt,tt),t.arc(s,l,o,tt,K+tt)):l<d?(t.arc(s,l,o,-K,0),t.arc(s,d,o,0,K)):t.arc(s,l,o,-K,K),t.closePath(),t.moveTo(e,i)}else t.rect(e,i,n,a)},drawPoint:function(t,e,i,n,a,r){var o,s,l,u,d,h=(r||0)*J;if(!e||"object"!=typeof e||"[object HTMLImageElement]"!==(o=e.toString())&&"[object HTMLCanvasElement]"!==o){if(!(isNaN(i)||i<=0)){switch(t.beginPath(),e){default:t.arc(n,a,i,0,Q),t.closePath();break;case"triangle":t.moveTo(n+Math.sin(h)*i,a-Math.cos(h)*i),h+=it,t.lineTo(n+Math.sin(h)*i,a-Math.cos(h)*i),h+=it,t.lineTo(n+Math.sin(h)*i,a-Math.cos(h)*i),t.closePath();break;case"rectRounded":u=i-(d=.516*i),s=Math.cos(h+et)*u,l=Math.sin(h+et)*u,t.arc(n-s,a-l,d,h-K,h-tt),t.arc(n+l,a-s,d,h-tt,h),t.arc(n+s,a+l,d,h,h+tt),t.arc(n-l,a+s,d,h+tt,h+K),t.closePath();break;case"rect":if(!r){u=Math.SQRT1_2*i,t.rect(n-u,a-u,2*u,2*u);break}h+=et;case"rectRot":s=Math.cos(h)*i,l=Math.sin(h)*i,t.moveTo(n-s,a-l),t.lineTo(n+l,a-s),t.lineTo(n+s,a+l),t.lineTo(n-l,a+s),t.closePath();break;case"crossRot":h+=et;case"cross":s=Math.cos(h)*i,l=Math.sin(h)*i,t.moveTo(n-s,a-l),t.lineTo(n+s,a+l),t.moveTo(n+l,a-s),t.lineTo(n-l,a+s);break;case"star":s=Math.cos(h)*i,l=Math.sin(h)*i,t.moveTo(n-s,a-l),t.lineTo(n+s,a+l),t.moveTo(n+l,a-s),t.lineTo(n-l,a+s),h+=et,s=Math.cos(h)*i,l=Math.sin(h)*i,t.moveTo(n-s,a-l),t.lineTo(n+s,a+l),t.moveTo(n+l,a-s),t.lineTo(n-l,a+s);break;case"line":s=Math.cos(h)*i,l=Math.sin(h)*i,t.moveTo(n-s,a-l),t.lineTo(n+s,a+l);break;case"dash":t.moveTo(n,a),t.lineTo(n+Math.cos(h)*i,a+Math.sin(h)*i)}t.fill(),t.stroke()}}else t.drawImage(e,n-e.width/2,a-e.height/2,e.width,e.height)},_isPointInArea:function(t,e){return t.x>e.left-1e-6&&t.x<e.right+1e-6&&t.y>e.top-1e-6&&t.y<e.bottom+1e-6},clipArea:function(t,e){t.save(),t.beginPath(),t.rect(e.left,e.top,e.right-e.left,e.bottom-e.top),t.clip()},unclipArea:function(t){t.restore()},lineTo:function(t,e,i,n){var a=i.steppedLine;if(a){if("middle"===a){var r=(e.x+i.x)/2;t.lineTo(r,n?i.y:e.y),t.lineTo(r,n?e.y:i.y)}else"after"===a&&!n||"after"!==a&&n?t.lineTo(e.x,i.y):t.lineTo(i.x,e.y);t.lineTo(i.x,i.y)}else i.tension?t.bezierCurveTo(n?e.controlPointPreviousX:e.controlPointNextX,n?e.controlPointPreviousY:e.controlPointNextY,n?i.controlPointNextX:i.controlPointPreviousX,n?i.controlPointNextY:i.controlPointPreviousY,i.x,i.y):t.lineTo(i.x,i.y)}},at=nt;Z.clear=nt.clear,Z.drawRoundedRectangle=function(t){t.beginPath(),nt.roundedRect.apply(nt,arguments)};var rt={_set:function(t,e){return Z.merge(this[t]||(this[t]={}),e)}};rt._set("global",{defaultColor:"rgba(0,0,0,0.1)",defaultFontColor:"#666",defaultFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",defaultFontSize:12,defaultFontStyle:"normal",defaultLineHeight:1.2,showLines:!0});var ot=rt,st=Z.valueOrDefault;var lt={toLineHeight:function(t,e){var i=(""+t).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);if(!i||"normal"===i[1])return 1.2*e;switch(t=+i[2],i[3]){case"px":return t;case"%":t/=100}return e*t},toPadding:function(t){var e,i,n,a;return Z.isObject(t)?(e=+t.top||0,i=+t.right||0,n=+t.bottom||0,a=+t.left||0):e=i=n=a=+t||0,{top:e,right:i,bottom:n,left:a,height:e+n,width:a+i}},_parseFont:function(t){var e=ot.global,i=st(t.fontSize,e.defaultFontSize),n={family:st(t.fontFamily,e.defaultFontFamily),lineHeight:Z.options.toLineHeight(st(t.lineHeight,e.defaultLineHeight),i),size:i,style:st(t.fontStyle,e.defaultFontStyle),weight:null,string:""};return n.string=function(t){return!t||Z.isNullOrUndef(t.size)||Z.isNullOrUndef(t.family)?null:(t.style?t.style+" ":"")+(t.weight?t.weight+" ":"")+t.size+"px "+t.family}(n),n},resolve:function(t,e,i){var n,a,r;for(n=0,a=t.length;n<a;++n)if(void 0!==(r=t[n])&&(void 0!==e&&"function"==typeof r&&(r=r(e)),void 0!==i&&Z.isArray(r)&&(r=r[i]),void 0!==r))return r}},ut=Z,dt=X,ht=at,ct=lt;ut.easing=dt,ut.canvas=ht,ut.options=ct;var ft=function(t){ut.extend(this,t),this.initialize.apply(this,arguments)};ut.extend(ft.prototype,{initialize:function(){this.hidden=!1},pivot:function(){var t=this;return t._view||(t._view=ut.clone(t._model)),t._start={},t},transition:function(t){var e=this,i=e._model,n=e._start,a=e._view;return i&&1!==t?(a||(a=e._view={}),n||(n=e._start={}),function(t,e,i,n){var a,r,o,s,l,u,d,h,c,f=Object.keys(i);for(a=0,r=f.length;a<r;++a)if(u=i[o=f[a]],e.hasOwnProperty(o)||(e[o]=u),(s=e[o])!==u&&"_"!==o[0]){if(t.hasOwnProperty(o)||(t[o]=s),(d=typeof u)==typeof(l=t[o]))if("string"===d){if((h=G(l)).valid&&(c=G(u)).valid){e[o]=c.mix(h,n).rgbString();continue}}else if(ut.isFinite(l)&&ut.isFinite(u)){e[o]=l+(u-l)*n;continue}e[o]=u}}(n,a,i,t),e):(e._view=i,e._start=null,e)},tooltipPosition:function(){return{x:this._model.x,y:this._model.y}},hasValue:function(){return ut.isNumber(this._model.x)&&ut.isNumber(this._model.y)}}),ft.extend=ut.inherits;var gt=ft,mt=gt.extend({chart:null,currentStep:0,numSteps:60,easing:"",render:null,onAnimationProgress:null,onAnimationComplete:null}),pt=mt;Object.defineProperty(mt.prototype,"animationObject",{get:function(){return this}}),Object.defineProperty(mt.prototype,"chartInstance",{get:function(){return this.chart},set:function(t){this.chart=t}}),ot._set("global",{animation:{duration:1e3,easing:"easeOutQuart",onProgress:ut.noop,onComplete:ut.noop}});var vt={animations:[],request:null,addAnimation:function(t,e,i,n){var a,r,o=this.animations;for(e.chart=t,e.startTime=Date.now(),e.duration=i,n||(t.animating=!0),a=0,r=o.length;a<r;++a)if(o[a].chart===t)return void(o[a]=e);o.push(e),1===o.length&&this.requestAnimationFrame()},cancelAnimation:function(t){var e=ut.findIndex(this.animations,function(e){return e.chart===t});-1!==e&&(this.animations.splice(e,1),t.animating=!1)},requestAnimationFrame:function(){var t=this;null===t.request&&(t.request=ut.requestAnimFrame.call(window,function(){t.request=null,t.startDigest()}))},startDigest:function(){this.advance(),this.animations.length>0&&this.requestAnimationFrame()},advance:function(){for(var t,e,i,n,a=this.animations,r=0;r<a.length;)e=(t=a[r]).chart,i=t.numSteps,n=Math.floor((Date.now()-t.startTime)/t.duration*i)+1,t.currentStep=Math.min(n,i),ut.callback(t.render,[e,t],e),ut.callback(t.onAnimationProgress,[t],e),t.currentStep>=i?(ut.callback(t.onAnimationComplete,[t],e),e.animating=!1,a.splice(r,1)):++r}},yt=ut.options.resolve,bt=["push","pop","shift","splice","unshift"];function xt(t,e){var i=t._chartjs;if(i){var n=i.listeners,a=n.indexOf(e);-1!==a&&n.splice(a,1),n.length>0||(bt.forEach(function(e){delete t[e]}),delete t._chartjs)}}var _t=function(t,e){this.initialize(t,e)};ut.extend(_t.prototype,{datasetElementType:null,dataElementType:null,initialize:function(t,e){this.chart=t,this.index=e,this.linkScales(),this.addElements()},updateIndex:function(t){this.index=t},linkScales:function(){var t=this,e=t.getMeta(),i=t.getDataset();null!==e.xAxisID&&e.xAxisID in t.chart.scales||(e.xAxisID=i.xAxisID||t.chart.options.scales.xAxes[0].id),null!==e.yAxisID&&e.yAxisID in t.chart.scales||(e.yAxisID=i.yAxisID||t.chart.options.scales.yAxes[0].id)},getDataset:function(){return this.chart.data.datasets[this.index]},getMeta:function(){return this.chart.getDatasetMeta(this.index)},getScaleForId:function(t){return this.chart.scales[t]},_getValueScaleId:function(){return this.getMeta().yAxisID},_getIndexScaleId:function(){return this.getMeta().xAxisID},_getValueScale:function(){return this.getScaleForId(this._getValueScaleId())},_getIndexScale:function(){return this.getScaleForId(this._getIndexScaleId())},reset:function(){this.update(!0)},destroy:function(){this._data&&xt(this._data,this)},createMetaDataset:function(){var t=this.datasetElementType;return t&&new t({_chart:this.chart,_datasetIndex:this.index})},createMetaData:function(t){var e=this.dataElementType;return e&&new e({_chart:this.chart,_datasetIndex:this.index,_index:t})},addElements:function(){var t,e,i=this.getMeta(),n=this.getDataset().data||[],a=i.data;for(t=0,e=n.length;t<e;++t)a[t]=a[t]||this.createMetaData(t);i.dataset=i.dataset||this.createMetaDataset()},addElementAndReset:function(t){var e=this.createMetaData(t);this.getMeta().data.splice(t,0,e),this.updateElement(e,t,!0)},buildOrUpdateElements:function(){var t,e,i=this,n=i.getDataset(),a=n.data||(n.data=[]);i._data!==a&&(i._data&&xt(i._data,i),a&&Object.isExtensible(a)&&(e=i,(t=a)._chartjs?t._chartjs.listeners.push(e):(Object.defineProperty(t,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[e]}}),bt.forEach(function(e){var i="onData"+e.charAt(0).toUpperCase()+e.slice(1),n=t[e];Object.defineProperty(t,e,{configurable:!0,enumerable:!1,value:function(){var e=Array.prototype.slice.call(arguments),a=n.apply(this,e);return ut.each(t._chartjs.listeners,function(t){"function"==typeof t[i]&&t[i].apply(t,e)}),a}})}))),i._data=a),i.resyncElements()},update:ut.noop,transition:function(t){for(var e=this.getMeta(),i=e.data||[],n=i.length,a=0;a<n;++a)i[a].transition(t);e.dataset&&e.dataset.transition(t)},draw:function(){var t=this.getMeta(),e=t.data||[],i=e.length,n=0;for(t.dataset&&t.dataset.draw();n<i;++n)e[n].draw()},removeHoverStyle:function(t){ut.merge(t._model,t.$previousStyle||{}),delete t.$previousStyle},setHoverStyle:function(t){var e=this.chart.data.datasets[t._datasetIndex],i=t._index,n=t.custom||{},a=t._model,r=ut.getHoverColor;t.$previousStyle={backgroundColor:a.backgroundColor,borderColor:a.borderColor,borderWidth:a.borderWidth},a.backgroundColor=yt([n.hoverBackgroundColor,e.hoverBackgroundColor,r(a.backgroundColor)],void 0,i),a.borderColor=yt([n.hoverBorderColor,e.hoverBorderColor,r(a.borderColor)],void 0,i),a.borderWidth=yt([n.hoverBorderWidth,e.hoverBorderWidth,a.borderWidth],void 0,i)},resyncElements:function(){var t=this.getMeta(),e=this.getDataset().data,i=t.data.length,n=e.length;n<i?t.data.splice(n,i-n):n>i&&this.insertElements(i,n-i)},insertElements:function(t,e){for(var i=0;i<e;++i)this.addElementAndReset(t+i)},onDataPush:function(){var t=arguments.length;this.insertElements(this.getDataset().data.length-t,t)},onDataPop:function(){this.getMeta().data.pop()},onDataShift:function(){this.getMeta().data.shift()},onDataSplice:function(t,e){this.getMeta().data.splice(t,e),this.insertElements(t,arguments.length-2)},onDataUnshift:function(){this.insertElements(0,arguments.length)}}),_t.extend=ut.inherits;var kt=_t;ot._set("global",{elements:{arc:{backgroundColor:ot.global.defaultColor,borderColor:"#fff",borderWidth:2,borderAlign:"center"}}});var wt=gt.extend({inLabelRange:function(t){var e=this._view;return!!e&&Math.pow(t-e.x,2)<Math.pow(e.radius+e.hoverRadius,2)},inRange:function(t,e){var i=this._view;if(i){for(var n=ut.getAngleFromPoint(i,{x:t,y:e}),a=n.angle,r=n.distance,o=i.startAngle,s=i.endAngle;s<o;)s+=2*Math.PI;for(;a>s;)a-=2*Math.PI;for(;a<o;)a+=2*Math.PI;var l=a>=o&&a<=s,u=r>=i.innerRadius&&r<=i.outerRadius;return l&&u}return!1},getCenterPoint:function(){var t=this._view,e=(t.startAngle+t.endAngle)/2,i=(t.innerRadius+t.outerRadius)/2;return{x:t.x+Math.cos(e)*i,y:t.y+Math.sin(e)*i}},getArea:function(){var t=this._view;return Math.PI*((t.endAngle-t.startAngle)/(2*Math.PI))*(Math.pow(t.outerRadius,2)-Math.pow(t.innerRadius,2))},tooltipPosition:function(){var t=this._view,e=t.startAngle+(t.endAngle-t.startAngle)/2,i=(t.outerRadius-t.innerRadius)/2+t.innerRadius;return{x:t.x+Math.cos(e)*i,y:t.y+Math.sin(e)*i}},draw:function(){var t,e=this._chart.ctx,i=this._view,n=i.startAngle,a=i.endAngle,r="inner"===i.borderAlign?.33:0;e.save(),e.beginPath(),e.arc(i.x,i.y,Math.max(i.outerRadius-r,0),n,a),e.arc(i.x,i.y,i.innerRadius,a,n,!0),e.closePath(),e.fillStyle=i.backgroundColor,e.fill(),i.borderWidth&&("inner"===i.borderAlign?(e.beginPath(),t=r/i.outerRadius,e.arc(i.x,i.y,i.outerRadius,n-t,a+t),i.innerRadius>r?(t=r/i.innerRadius,e.arc(i.x,i.y,i.innerRadius-r,a+t,n-t,!0)):e.arc(i.x,i.y,r,a+Math.PI/2,n-Math.PI/2),e.closePath(),e.clip(),e.beginPath(),e.arc(i.x,i.y,i.outerRadius,n,a),e.arc(i.x,i.y,i.innerRadius,a,n,!0),e.closePath(),e.lineWidth=2*i.borderWidth,e.lineJoin="round"):(e.lineWidth=i.borderWidth,e.lineJoin="bevel"),e.strokeStyle=i.borderColor,e.stroke()),e.restore()}}),Mt=ut.valueOrDefault,St=ot.global.defaultColor;ot._set("global",{elements:{line:{tension:.4,backgroundColor:St,borderWidth:3,borderColor:St,borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",capBezierPoints:!0,fill:!0}}});var Dt=gt.extend({draw:function(){var t,e,i,n,a=this._view,r=this._chart.ctx,o=a.spanGaps,s=this._children.slice(),l=ot.global,u=l.elements.line,d=-1;for(this._loop&&s.length&&s.push(s[0]),r.save(),r.lineCap=a.borderCapStyle||u.borderCapStyle,r.setLineDash&&r.setLineDash(a.borderDash||u.borderDash),r.lineDashOffset=Mt(a.borderDashOffset,u.borderDashOffset),r.lineJoin=a.borderJoinStyle||u.borderJoinStyle,r.lineWidth=Mt(a.borderWidth,u.borderWidth),r.strokeStyle=a.borderColor||l.defaultColor,r.beginPath(),d=-1,t=0;t<s.length;++t)e=s[t],i=ut.previousItem(s,t),n=e._view,0===t?n.skip||(r.moveTo(n.x,n.y),d=t):(i=-1===d?i:s[d],n.skip||(d!==t-1&&!o||-1===d?r.moveTo(n.x,n.y):ut.canvas.lineTo(r,i._view,e._view),d=t));r.stroke(),r.restore()}}),Ct=ut.valueOrDefault,Pt=ot.global.defaultColor;function Tt(t){var e=this._view;return!!e&&Math.abs(t-e.x)<e.radius+e.hitRadius}ot._set("global",{elements:{point:{radius:3,pointStyle:"circle",backgroundColor:Pt,borderColor:Pt,borderWidth:1,hitRadius:1,hoverRadius:4,hoverBorderWidth:1}}});var Ot=gt.extend({inRange:function(t,e){var i=this._view;return!!i&&Math.pow(t-i.x,2)+Math.pow(e-i.y,2)<Math.pow(i.hitRadius+i.radius,2)},inLabelRange:Tt,inXRange:Tt,inYRange:function(t){var e=this._view;return!!e&&Math.abs(t-e.y)<e.radius+e.hitRadius},getCenterPoint:function(){var t=this._view;return{x:t.x,y:t.y}},getArea:function(){return Math.PI*Math.pow(this._view.radius,2)},tooltipPosition:function(){var t=this._view;return{x:t.x,y:t.y,padding:t.radius+t.borderWidth}},draw:function(t){var e=this._view,i=this._chart.ctx,n=e.pointStyle,a=e.rotation,r=e.radius,o=e.x,s=e.y,l=ot.global,u=l.defaultColor;e.skip||(void 0===t||ut.canvas._isPointInArea(e,t))&&(i.strokeStyle=e.borderColor||u,i.lineWidth=Ct(e.borderWidth,l.elements.point.borderWidth),i.fillStyle=e.backgroundColor||u,ut.canvas.drawPoint(i,n,r,o,s,a))}}),It=ot.global.defaultColor;function At(t){return t&&void 0!==t.width}function Ft(t){var e,i,n,a,r;return At(t)?(r=t.width/2,e=t.x-r,i=t.x+r,n=Math.min(t.y,t.base),a=Math.max(t.y,t.base)):(r=t.height/2,e=Math.min(t.x,t.base),i=Math.max(t.x,t.base),n=t.y-r,a=t.y+r),{left:e,top:n,right:i,bottom:a}}function Rt(t,e,i){return t===e?i:t===i?e:t}function Lt(t,e,i){var n,a,r,o,s=t.borderWidth,l=function(t){var e=t.borderSkipped,i={};return e?(t.horizontal?t.base>t.x&&(e=Rt(e,"left","right")):t.base<t.y&&(e=Rt(e,"bottom","top")),i[e]=!0,i):i}(t);return ut.isObject(s)?(n=+s.top||0,a=+s.right||0,r=+s.bottom||0,o=+s.left||0):n=a=r=o=+s||0,{t:l.top||n<0?0:n>i?i:n,r:l.right||a<0?0:a>e?e:a,b:l.bottom||r<0?0:r>i?i:r,l:l.left||o<0?0:o>e?e:o}}function Wt(t,e,i){var n=null===e,a=null===i,r=!(!t||n&&a)&&Ft(t);return r&&(n||e>=r.left&&e<=r.right)&&(a||i>=r.top&&i<=r.bottom)}ot._set("global",{elements:{rectangle:{backgroundColor:It,borderColor:It,borderSkipped:"bottom",borderWidth:0}}});var Yt=gt.extend({draw:function(){var t=this._chart.ctx,e=this._view,i=function(t){var e=Ft(t),i=e.right-e.left,n=e.bottom-e.top,a=Lt(t,i/2,n/2);return{outer:{x:e.left,y:e.top,w:i,h:n},inner:{x:e.left+a.l,y:e.top+a.t,w:i-a.l-a.r,h:n-a.t-a.b}}}(e),n=i.outer,a=i.inner;t.fillStyle=e.backgroundColor,t.fillRect(n.x,n.y,n.w,n.h),n.w===a.w&&n.h===a.h||(t.save(),t.beginPath(),t.rect(n.x,n.y,n.w,n.h),t.clip(),t.fillStyle=e.borderColor,t.rect(a.x,a.y,a.w,a.h),t.fill("evenodd"),t.restore())},height:function(){var t=this._view;return t.base-t.y},inRange:function(t,e){return Wt(this._view,t,e)},inLabelRange:function(t,e){var i=this._view;return At(i)?Wt(i,t,null):Wt(i,null,e)},inXRange:function(t){return Wt(this._view,t,null)},inYRange:function(t){return Wt(this._view,null,t)},getCenterPoint:function(){var t,e,i=this._view;return At(i)?(t=i.x,e=(i.y+i.base)/2):(t=(i.x+i.base)/2,e=i.y),{x:t,y:e}},getArea:function(){var t=this._view;return At(t)?t.width*Math.abs(t.y-t.base):t.height*Math.abs(t.x-t.base)},tooltipPosition:function(){var t=this._view;return{x:t.x,y:t.y}}}),Nt={},zt=wt,Vt=Dt,Ht=Ot,Et=Yt;Nt.Arc=zt,Nt.Line=Vt,Nt.Point=Ht,Nt.Rectangle=Et;var Bt=ut.options.resolve;ot._set("bar",{hover:{mode:"label"},scales:{xAxes:[{type:"category",categoryPercentage:.8,barPercentage:.9,offset:!0,gridLines:{offsetGridLines:!0}}],yAxes:[{type:"linear"}]}});var jt=kt.extend({dataElementType:Nt.Rectangle,initialize:function(){var t;kt.prototype.initialize.apply(this,arguments),(t=this.getMeta()).stack=this.getDataset().stack,t.bar=!0},update:function(t){var e,i,n=this.getMeta().data;for(this._ruler=this.getRuler(),e=0,i=n.length;e<i;++e)this.updateElement(n[e],e,t)},updateElement:function(t,e,i){var n=this,a=n.getMeta(),r=n.getDataset(),o=n._resolveElementOptions(t,e);t._xScale=n.getScaleForId(a.xAxisID),t._yScale=n.getScaleForId(a.yAxisID),t._datasetIndex=n.index,t._index=e,t._model={backgroundColor:o.backgroundColor,borderColor:o.borderColor,borderSkipped:o.borderSkipped,borderWidth:o.borderWidth,datasetLabel:r.label,label:n.chart.data.labels[e]},n._updateElementGeometry(t,e,i),t.pivot()},_updateElementGeometry:function(t,e,i){var n=this,a=t._model,r=n._getValueScale(),o=r.getBasePixel(),s=r.isHorizontal(),l=n._ruler||n.getRuler(),u=n.calculateBarValuePixels(n.index,e),d=n.calculateBarIndexPixels(n.index,e,l);a.horizontal=s,a.base=i?o:u.base,a.x=s?i?o:u.head:d.center,a.y=s?d.center:i?o:u.head,a.height=s?d.size:void 0,a.width=s?void 0:d.size},_getStacks:function(t){var e,i,n=this.chart,a=this._getIndexScale().options.stacked,r=void 0===t?n.data.datasets.length:t+1,o=[];for(e=0;e<r;++e)(i=n.getDatasetMeta(e)).bar&&n.isDatasetVisible(e)&&(!1===a||!0===a&&-1===o.indexOf(i.stack)||void 0===a&&(void 0===i.stack||-1===o.indexOf(i.stack)))&&o.push(i.stack);return o},getStackCount:function(){return this._getStacks().length},getStackIndex:function(t,e){var i=this._getStacks(t),n=void 0!==e?i.indexOf(e):-1;return-1===n?i.length-1:n},getRuler:function(){var t,e,i=this._getIndexScale(),n=this.getStackCount(),a=this.index,r=i.isHorizontal(),o=r?i.left:i.top,s=o+(r?i.width:i.height),l=[];for(t=0,e=this.getMeta().data.length;t<e;++t)l.push(i.getPixelForValue(null,t,a));return{min:ut.isNullOrUndef(i.options.barThickness)?function(t,e){var i,n,a,r,o=t.isHorizontal()?t.width:t.height,s=t.getTicks();for(a=1,r=e.length;a<r;++a)o=Math.min(o,Math.abs(e[a]-e[a-1]));for(a=0,r=s.length;a<r;++a)n=t.getPixelForTick(a),o=a>0?Math.min(o,n-i):o,i=n;return o}(i,l):-1,pixels:l,start:o,end:s,stackCount:n,scale:i}},calculateBarValuePixels:function(t,e){var i,n,a,r,o,s,l=this.chart,u=this.getMeta(),d=this._getValueScale(),h=d.isHorizontal(),c=l.data.datasets,f=+d.getRightValue(c[t].data[e]),g=d.options.minBarLength,m=d.options.stacked,p=u.stack,v=0;if(m||void 0===m&&void 0!==p)for(i=0;i<t;++i)(n=l.getDatasetMeta(i)).bar&&n.stack===p&&n.controller._getValueScaleId()===d.id&&l.isDatasetVisible(i)&&(a=+d.getRightValue(c[i].data[e]),(f<0&&a<0||f>=0&&a>0)&&(v+=a));return r=d.getPixelForValue(v),s=(o=d.getPixelForValue(v+f))-r,void 0!==g&&Math.abs(s)<g&&(s=g,o=f>=0&&!h||f<0&&h?r-g:r+g),{size:s,base:r,head:o,center:o+s/2}},calculateBarIndexPixels:function(t,e,i){var n=i.scale.options,a="flex"===n.barThickness?function(t,e,i){var n,a=e.pixels,r=a[t],o=t>0?a[t-1]:null,s=t<a.length-1?a[t+1]:null,l=i.categoryPercentage;return null===o&&(o=r-(null===s?e.end-e.start:s-r)),null===s&&(s=r+r-o),n=r-(r-Math.min(o,s))/2*l,{chunk:Math.abs(s-o)/2*l/e.stackCount,ratio:i.barPercentage,start:n}}(e,i,n):function(t,e,i){var n,a,r=i.barThickness,o=e.stackCount,s=e.pixels[t];return ut.isNullOrUndef(r)?(n=e.min*i.categoryPercentage,a=i.barPercentage):(n=r*o,a=1),{chunk:n/o,ratio:a,start:s-n/2}}(e,i,n),r=this.getStackIndex(t,this.getMeta().stack),o=a.start+a.chunk*r+a.chunk/2,s=Math.min(ut.valueOrDefault(n.maxBarThickness,1/0),a.chunk*a.ratio);return{base:o-s/2,head:o+s/2,center:o,size:s}},draw:function(){var t=this.chart,e=this._getValueScale(),i=this.getMeta().data,n=this.getDataset(),a=i.length,r=0;for(ut.canvas.clipArea(t.ctx,t.chartArea);r<a;++r)isNaN(e.getRightValue(n.data[r]))||i[r].draw();ut.canvas.unclipArea(t.ctx)},_resolveElementOptions:function(t,e){var i,n,a,r=this.chart,o=r.data.datasets[this.index],s=t.custom||{},l=r.options.elements.rectangle,u={},d={chart:r,dataIndex:e,dataset:o,datasetIndex:this.index},h=["backgroundColor","borderColor","borderSkipped","borderWidth"];for(i=0,n=h.length;i<n;++i)u[a=h[i]]=Bt([s[a],o[a],l[a]],d,e);return u}}),Ut=ut.valueOrDefault,Gt=ut.options.resolve;ot._set("bubble",{hover:{mode:"single"},scales:{xAxes:[{type:"linear",position:"bottom",id:"x-axis-0"}],yAxes:[{type:"linear",position:"left",id:"y-axis-0"}]},tooltips:{callbacks:{title:function(){return""},label:function(t,e){var i=e.datasets[t.datasetIndex].label||"",n=e.datasets[t.datasetIndex].data[t.index];return i+": ("+t.xLabel+", "+t.yLabel+", "+n.r+")"}}}});var qt=kt.extend({dataElementType:Nt.Point,update:function(t){var e=this,i=e.getMeta().data;ut.each(i,function(i,n){e.updateElement(i,n,t)})},updateElement:function(t,e,i){var n=this,a=n.getMeta(),r=t.custom||{},o=n.getScaleForId(a.xAxisID),s=n.getScaleForId(a.yAxisID),l=n._resolveElementOptions(t,e),u=n.getDataset().data[e],d=n.index,h=i?o.getPixelForDecimal(.5):o.getPixelForValue("object"==typeof u?u:NaN,e,d),c=i?s.getBasePixel():s.getPixelForValue(u,e,d);t._xScale=o,t._yScale=s,t._options=l,t._datasetIndex=d,t._index=e,t._model={backgroundColor:l.backgroundColor,borderColor:l.borderColor,borderWidth:l.borderWidth,hitRadius:l.hitRadius,pointStyle:l.pointStyle,rotation:l.rotation,radius:i?0:l.radius,skip:r.skip||isNaN(h)||isNaN(c),x:h,y:c},t.pivot()},setHoverStyle:function(t){var e=t._model,i=t._options,n=ut.getHoverColor;t.$previousStyle={backgroundColor:e.backgroundColor,borderColor:e.borderColor,borderWidth:e.borderWidth,radius:e.radius},e.backgroundColor=Ut(i.hoverBackgroundColor,n(i.backgroundColor)),e.borderColor=Ut(i.hoverBorderColor,n(i.borderColor)),e.borderWidth=Ut(i.hoverBorderWidth,i.borderWidth),e.radius=i.radius+i.hoverRadius},_resolveElementOptions:function(t,e){var i,n,a,r=this.chart,o=r.data.datasets[this.index],s=t.custom||{},l=r.options.elements.point,u=o.data[e],d={},h={chart:r,dataIndex:e,dataset:o,datasetIndex:this.index},c=["backgroundColor","borderColor","borderWidth","hoverBackgroundColor","hoverBorderColor","hoverBorderWidth","hoverRadius","hitRadius","pointStyle","rotation"];for(i=0,n=c.length;i<n;++i)d[a=c[i]]=Gt([s[a],o[a],l[a]],h,e);return d.radius=Gt([s.radius,u?u.r:void 0,o.radius,l.radius],h,e),d}}),Zt=ut.options.resolve,$t=ut.valueOrDefault;ot._set("doughnut",{animation:{animateRotate:!0,animateScale:!1},hover:{mode:"single"},legendCallback:function(t){var e=[];e.push('<ul class="'+t.id+'-legend">');var i=t.data,n=i.datasets,a=i.labels;if(n.length)for(var r=0;r<n[0].data.length;++r)e.push('<li><span style="background-color:'+n[0].backgroundColor[r]+'"></span>'),a[r]&&e.push(a[r]),e.push("</li>");return e.push("</ul>"),e.join("")},legend:{labels:{generateLabels:function(t){var e=t.data;return e.labels.length&&e.datasets.length?e.labels.map(function(i,n){var a=t.getDatasetMeta(0),r=e.datasets[0],o=a.data[n],s=o&&o.custom||{},l=t.options.elements.arc;return{text:i,fillStyle:Zt([s.backgroundColor,r.backgroundColor,l.backgroundColor],void 0,n),strokeStyle:Zt([s.borderColor,r.borderColor,l.borderColor],void 0,n),lineWidth:Zt([s.borderWidth,r.borderWidth,l.borderWidth],void 0,n),hidden:isNaN(r.data[n])||a.data[n].hidden,index:n}}):[]}},onClick:function(t,e){var i,n,a,r=e.index,o=this.chart;for(i=0,n=(o.data.datasets||[]).length;i<n;++i)(a=o.getDatasetMeta(i)).data[r]&&(a.data[r].hidden=!a.data[r].hidden);o.update()}},cutoutPercentage:50,rotation:-.5*Math.PI,circumference:2*Math.PI,tooltips:{callbacks:{title:function(){return""},label:function(t,e){var i=e.labels[t.index],n=": "+e.datasets[t.datasetIndex].data[t.index];return ut.isArray(i)?(i=i.slice())[0]+=n:i+=n,i}}}});var Xt=kt.extend({dataElementType:Nt.Arc,linkScales:ut.noop,getRingIndex:function(t){for(var e=0,i=0;i<t;++i)this.chart.isDatasetVisible(i)&&++e;return e},update:function(t){var e,i,n=this,a=n.chart,r=a.chartArea,o=a.options,s=r.right-r.left,l=r.bottom-r.top,u=Math.min(s,l),d={x:0,y:0},h=n.getMeta(),c=h.data,f=o.cutoutPercentage,g=o.circumference,m=n._getRingWeight(n.index);if(g<2*Math.PI){var p=o.rotation%(2*Math.PI),v=(p+=2*Math.PI*(p>=Math.PI?-1:p<-Math.PI?1:0))+g,y={x:Math.cos(p),y:Math.sin(p)},b={x:Math.cos(v),y:Math.sin(v)},x=p<=0&&v>=0||p<=2*Math.PI&&2*Math.PI<=v,_=p<=.5*Math.PI&&.5*Math.PI<=v||p<=2.5*Math.PI&&2.5*Math.PI<=v,k=p<=-Math.PI&&-Math.PI<=v||p<=Math.PI&&Math.PI<=v,w=p<=.5*-Math.PI&&.5*-Math.PI<=v||p<=1.5*Math.PI&&1.5*Math.PI<=v,M=f/100,S={x:k?-1:Math.min(y.x*(y.x<0?1:M),b.x*(b.x<0?1:M)),y:w?-1:Math.min(y.y*(y.y<0?1:M),b.y*(b.y<0?1:M))},D={x:x?1:Math.max(y.x*(y.x>0?1:M),b.x*(b.x>0?1:M)),y:_?1:Math.max(y.y*(y.y>0?1:M),b.y*(b.y>0?1:M))},C={width:.5*(D.x-S.x),height:.5*(D.y-S.y)};u=Math.min(s/C.width,l/C.height),d={x:-.5*(D.x+S.x),y:-.5*(D.y+S.y)}}for(e=0,i=c.length;e<i;++e)c[e]._options=n._resolveElementOptions(c[e],e);for(a.borderWidth=n.getMaxBorderWidth(),a.outerRadius=Math.max((u-a.borderWidth)/2,0),a.innerRadius=Math.max(f?a.outerRadius/100*f:0,0),a.radiusLength=(a.outerRadius-a.innerRadius)/(n._getVisibleDatasetWeightTotal()||1),a.offsetX=d.x*a.outerRadius,a.offsetY=d.y*a.outerRadius,h.total=n.calculateTotal(),n.outerRadius=a.outerRadius-a.radiusLength*n._getRingWeightOffset(n.index),n.innerRadius=Math.max(n.outerRadius-a.radiusLength*m,0),e=0,i=c.length;e<i;++e)n.updateElement(c[e],e,t)},updateElement:function(t,e,i){var n=this,a=n.chart,r=a.chartArea,o=a.options,s=o.animation,l=(r.left+r.right)/2,u=(r.top+r.bottom)/2,d=o.rotation,h=o.rotation,c=n.getDataset(),f=i&&s.animateRotate?0:t.hidden?0:n.calculateCircumference(c.data[e])*(o.circumference/(2*Math.PI)),g=i&&s.animateScale?0:n.innerRadius,m=i&&s.animateScale?0:n.outerRadius,p=t._options||{};ut.extend(t,{_datasetIndex:n.index,_index:e,_model:{backgroundColor:p.backgroundColor,borderColor:p.borderColor,borderWidth:p.borderWidth,borderAlign:p.borderAlign,x:l+a.offsetX,y:u+a.offsetY,startAngle:d,endAngle:h,circumference:f,outerRadius:m,innerRadius:g,label:ut.valueAtIndexOrDefault(c.label,e,a.data.labels[e])}});var v=t._model;i&&s.animateRotate||(v.startAngle=0===e?o.rotation:n.getMeta().data[e-1]._model.endAngle,v.endAngle=v.startAngle+v.circumference),t.pivot()},calculateTotal:function(){var t,e=this.getDataset(),i=this.getMeta(),n=0;return ut.each(i.data,function(i,a){t=e.data[a],isNaN(t)||i.hidden||(n+=Math.abs(t))}),n},calculateCircumference:function(t){var e=this.getMeta().total;return e>0&&!isNaN(t)?2*Math.PI*(Math.abs(t)/e):0},getMaxBorderWidth:function(t){var e,i,n,a,r,o,s,l,u=0,d=this.chart;if(!t)for(e=0,i=d.data.datasets.length;e<i;++e)if(d.isDatasetVisible(e)){t=(n=d.getDatasetMeta(e)).data,e!==this.index&&(r=n.controller);break}if(!t)return 0;for(e=0,i=t.length;e<i;++e)a=t[e],"inner"!==(o=r?r._resolveElementOptions(a,e):a._options).borderAlign&&(s=o.borderWidth,u=(l=o.hoverBorderWidth)>(u=s>u?s:u)?l:u);return u},setHoverStyle:function(t){var e=t._model,i=t._options,n=ut.getHoverColor;t.$previousStyle={backgroundColor:e.backgroundColor,borderColor:e.borderColor,borderWidth:e.borderWidth},e.backgroundColor=$t(i.hoverBackgroundColor,n(i.backgroundColor)),e.borderColor=$t(i.hoverBorderColor,n(i.borderColor)),e.borderWidth=$t(i.hoverBorderWidth,i.borderWidth)},_resolveElementOptions:function(t,e){var i,n,a,r=this.chart,o=this.getDataset(),s=t.custom||{},l=r.options.elements.arc,u={},d={chart:r,dataIndex:e,dataset:o,datasetIndex:this.index},h=["backgroundColor","borderColor","borderWidth","borderAlign","hoverBackgroundColor","hoverBorderColor","hoverBorderWidth"];for(i=0,n=h.length;i<n;++i)u[a=h[i]]=Zt([s[a],o[a],l[a]],d,e);return u},_getRingWeightOffset:function(t){for(var e=0,i=0;i<t;++i)this.chart.isDatasetVisible(i)&&(e+=this._getRingWeight(i));return e},_getRingWeight:function(t){return Math.max($t(this.chart.data.datasets[t].weight,1),0)},_getVisibleDatasetWeightTotal:function(){return this._getRingWeightOffset(this.chart.data.datasets.length)}});ot._set("horizontalBar",{hover:{mode:"index",axis:"y"},scales:{xAxes:[{type:"linear",position:"bottom"}],yAxes:[{type:"category",position:"left",categoryPercentage:.8,barPercentage:.9,offset:!0,gridLines:{offsetGridLines:!0}}]},elements:{rectangle:{borderSkipped:"left"}},tooltips:{mode:"index",axis:"y"}});var Kt=jt.extend({_getValueScaleId:function(){return this.getMeta().xAxisID},_getIndexScaleId:function(){return this.getMeta().yAxisID}}),Jt=ut.valueOrDefault,Qt=ut.options.resolve,te=ut.canvas._isPointInArea;function ee(t,e){return Jt(t.showLine,e.showLines)}ot._set("line",{showLines:!0,spanGaps:!1,hover:{mode:"label"},scales:{xAxes:[{type:"category",id:"x-axis-0"}],yAxes:[{type:"linear",id:"y-axis-0"}]}});var ie=kt.extend({datasetElementType:Nt.Line,dataElementType:Nt.Point,update:function(t){var e,i,n=this,a=n.getMeta(),r=a.dataset,o=a.data||[],s=n.getScaleForId(a.yAxisID),l=n.getDataset(),u=ee(l,n.chart.options);for(u&&(void 0!==l.tension&&void 0===l.lineTension&&(l.lineTension=l.tension),r._scale=s,r._datasetIndex=n.index,r._children=o,r._model=n._resolveLineOptions(r),r.pivot()),e=0,i=o.length;e<i;++e)n.updateElement(o[e],e,t);for(u&&0!==r._model.tension&&n.updateBezierControlPoints(),e=0,i=o.length;e<i;++e)o[e].pivot()},updateElement:function(t,e,i){var n,a,r=this,o=r.getMeta(),s=t.custom||{},l=r.getDataset(),u=r.index,d=l.data[e],h=r.getScaleForId(o.yAxisID),c=r.getScaleForId(o.xAxisID),f=o.dataset._model,g=r._resolvePointOptions(t,e);n=c.getPixelForValue("object"==typeof d?d:NaN,e,u),a=i?h.getBasePixel():r.calculatePointY(d,e,u),t._xScale=c,t._yScale=h,t._options=g,t._datasetIndex=u,t._index=e,t._model={x:n,y:a,skip:s.skip||isNaN(n)||isNaN(a),radius:g.radius,pointStyle:g.pointStyle,rotation:g.rotation,backgroundColor:g.backgroundColor,borderColor:g.borderColor,borderWidth:g.borderWidth,tension:Jt(s.tension,f?f.tension:0),steppedLine:!!f&&f.steppedLine,hitRadius:g.hitRadius}},_resolvePointOptions:function(t,e){var i,n,a,r=this.chart,o=r.data.datasets[this.index],s=t.custom||{},l=r.options.elements.point,u={},d={chart:r,dataIndex:e,dataset:o,datasetIndex:this.index},h={backgroundColor:"pointBackgroundColor",borderColor:"pointBorderColor",borderWidth:"pointBorderWidth",hitRadius:"pointHitRadius",hoverBackgroundColor:"pointHoverBackgroundColor",hoverBorderColor:"pointHoverBorderColor",hoverBorderWidth:"pointHoverBorderWidth",hoverRadius:"pointHoverRadius",pointStyle:"pointStyle",radius:"pointRadius",rotation:"pointRotation"},c=Object.keys(h);for(i=0,n=c.length;i<n;++i)u[a=c[i]]=Qt([s[a],o[h[a]],o[a],l[a]],d,e);return u},_resolveLineOptions:function(t){var e,i,n,a=this.chart,r=a.data.datasets[this.index],o=t.custom||{},s=a.options,l=s.elements.line,u={},d=["backgroundColor","borderWidth","borderColor","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","fill","cubicInterpolationMode"];for(e=0,i=d.length;e<i;++e)u[n=d[e]]=Qt([o[n],r[n],l[n]]);return u.spanGaps=Jt(r.spanGaps,s.spanGaps),u.tension=Jt(r.lineTension,l.tension),u.steppedLine=Qt([o.steppedLine,r.steppedLine,l.stepped]),u},calculatePointY:function(t,e,i){var n,a,r,o=this.chart,s=this.getMeta(),l=this.getScaleForId(s.yAxisID),u=0,d=0;if(l.options.stacked){for(n=0;n<i;n++)if(a=o.data.datasets[n],"line"===(r=o.getDatasetMeta(n)).type&&r.yAxisID===l.id&&o.isDatasetVisible(n)){var h=Number(l.getRightValue(a.data[e]));h<0?d+=h||0:u+=h||0}var c=Number(l.getRightValue(t));return c<0?l.getPixelForValue(d+c):l.getPixelForValue(u+c)}return l.getPixelForValue(t)},updateBezierControlPoints:function(){var t,e,i,n,a=this.chart,r=this.getMeta(),o=r.dataset._model,s=a.chartArea,l=r.data||[];function u(t,e,i){return Math.max(Math.min(t,i),e)}if(o.spanGaps&&(l=l.filter(function(t){return!t._model.skip})),"monotone"===o.cubicInterpolationMode)ut.splineCurveMonotone(l);else for(t=0,e=l.length;t<e;++t)i=l[t]._model,n=ut.splineCurve(ut.previousItem(l,t)._model,i,ut.nextItem(l,t)._model,o.tension),i.controlPointPreviousX=n.previous.x,i.controlPointPreviousY=n.previous.y,i.controlPointNextX=n.next.x,i.controlPointNextY=n.next.y;if(a.options.elements.line.capBezierPoints)for(t=0,e=l.length;t<e;++t)i=l[t]._model,te(i,s)&&(t>0&&te(l[t-1]._model,s)&&(i.controlPointPreviousX=u(i.controlPointPreviousX,s.left,s.right),i.controlPointPreviousY=u(i.controlPointPreviousY,s.top,s.bottom)),t<l.length-1&&te(l[t+1]._model,s)&&(i.controlPointNextX=u(i.controlPointNextX,s.left,s.right),i.controlPointNextY=u(i.controlPointNextY,s.top,s.bottom)))},draw:function(){var t,e=this.chart,i=this.getMeta(),n=i.data||[],a=e.chartArea,r=n.length,o=0;for(ee(this.getDataset(),e.options)&&(t=(i.dataset._model.borderWidth||0)/2,ut.canvas.clipArea(e.ctx,{left:a.left,right:a.right,top:a.top-t,bottom:a.bottom+t}),i.dataset.draw(),ut.canvas.unclipArea(e.ctx));o<r;++o)n[o].draw(a)},setHoverStyle:function(t){var e=t._model,i=t._options,n=ut.getHoverColor;t.$previousStyle={backgroundColor:e.backgroundColor,borderColor:e.borderColor,borderWidth:e.borderWidth,radius:e.radius},e.backgroundColor=Jt(i.hoverBackgroundColor,n(i.backgroundColor)),e.borderColor=Jt(i.hoverBorderColor,n(i.borderColor)),e.borderWidth=Jt(i.hoverBorderWidth,i.borderWidth),e.radius=Jt(i.hoverRadius,i.radius)}}),ne=ut.options.resolve;ot._set("polarArea",{scale:{type:"radialLinear",angleLines:{display:!1},gridLines:{circular:!0},pointLabels:{display:!1},ticks:{beginAtZero:!0}},animation:{animateRotate:!0,animateScale:!0},startAngle:-.5*Math.PI,legendCallback:function(t){var e=[];e.push('<ul class="'+t.id+'-legend">');var i=t.data,n=i.datasets,a=i.labels;if(n.length)for(var r=0;r<n[0].data.length;++r)e.push('<li><span style="background-color:'+n[0].backgroundColor[r]+'"></span>'),a[r]&&e.push(a[r]),e.push("</li>");return e.push("</ul>"),e.join("")},legend:{labels:{generateLabels:function(t){var e=t.data;return e.labels.length&&e.datasets.length?e.labels.map(function(i,n){var a=t.getDatasetMeta(0),r=e.datasets[0],o=a.data[n].custom||{},s=t.options.elements.arc;return{text:i,fillStyle:ne([o.backgroundColor,r.backgroundColor,s.backgroundColor],void 0,n),strokeStyle:ne([o.borderColor,r.borderColor,s.borderColor],void 0,n),lineWidth:ne([o.borderWidth,r.borderWidth,s.borderWidth],void 0,n),hidden:isNaN(r.data[n])||a.data[n].hidden,index:n}}):[]}},onClick:function(t,e){var i,n,a,r=e.index,o=this.chart;for(i=0,n=(o.data.datasets||[]).length;i<n;++i)(a=o.getDatasetMeta(i)).data[r].hidden=!a.data[r].hidden;o.update()}},tooltips:{callbacks:{title:function(){return""},label:function(t,e){return e.labels[t.index]+": "+t.yLabel}}}});var ae=kt.extend({dataElementType:Nt.Arc,linkScales:ut.noop,update:function(t){var e,i,n,a=this,r=a.getDataset(),o=a.getMeta(),s=a.chart.options.startAngle||0,l=a._starts=[],u=a._angles=[],d=o.data;for(a._updateRadius(),o.count=a.countVisibleElements(),e=0,i=r.data.length;e<i;e++)l[e]=s,n=a._computeAngle(e),u[e]=n,s+=n;for(e=0,i=d.length;e<i;++e)d[e]._options=a._resolveElementOptions(d[e],e),a.updateElement(d[e],e,t)},_updateRadius:function(){var t=this,e=t.chart,i=e.chartArea,n=e.options,a=Math.min(i.right-i.left,i.bottom-i.top);e.outerRadius=Math.max(a/2,0),e.innerRadius=Math.max(n.cutoutPercentage?e.outerRadius/100*n.cutoutPercentage:1,0),e.radiusLength=(e.outerRadius-e.innerRadius)/e.getVisibleDatasetCount(),t.outerRadius=e.outerRadius-e.radiusLength*t.index,t.innerRadius=t.outerRadius-e.radiusLength},updateElement:function(t,e,i){var n=this,a=n.chart,r=n.getDataset(),o=a.options,s=o.animation,l=a.scale,u=a.data.labels,d=l.xCenter,h=l.yCenter,c=o.startAngle,f=t.hidden?0:l.getDistanceFromCenterForValue(r.data[e]),g=n._starts[e],m=g+(t.hidden?0:n._angles[e]),p=s.animateScale?0:l.getDistanceFromCenterForValue(r.data[e]),v=t._options||{};ut.extend(t,{_datasetIndex:n.index,_index:e,_scale:l,_model:{backgroundColor:v.backgroundColor,borderColor:v.borderColor,borderWidth:v.borderWidth,borderAlign:v.borderAlign,x:d,y:h,innerRadius:0,outerRadius:i?p:f,startAngle:i&&s.animateRotate?c:g,endAngle:i&&s.animateRotate?c:m,label:ut.valueAtIndexOrDefault(u,e,u[e])}}),t.pivot()},countVisibleElements:function(){var t=this.getDataset(),e=this.getMeta(),i=0;return ut.each(e.data,function(e,n){isNaN(t.data[n])||e.hidden||i++}),i},setHoverStyle:function(t){var e=t._model,i=t._options,n=ut.getHoverColor,a=ut.valueOrDefault;t.$previousStyle={backgroundColor:e.backgroundColor,borderColor:e.borderColor,borderWidth:e.borderWidth},e.backgroundColor=a(i.hoverBackgroundColor,n(i.backgroundColor)),e.borderColor=a(i.hoverBorderColor,n(i.borderColor)),e.borderWidth=a(i.hoverBorderWidth,i.borderWidth)},_resolveElementOptions:function(t,e){var i,n,a,r=this.chart,o=this.getDataset(),s=t.custom||{},l=r.options.elements.arc,u={},d={chart:r,dataIndex:e,dataset:o,datasetIndex:this.index},h=["backgroundColor","borderColor","borderWidth","borderAlign","hoverBackgroundColor","hoverBorderColor","hoverBorderWidth"];for(i=0,n=h.length;i<n;++i)u[a=h[i]]=ne([s[a],o[a],l[a]],d,e);return u},_computeAngle:function(t){var e=this,i=this.getMeta().count,n=e.getDataset(),a=e.getMeta();if(isNaN(n.data[t])||a.data[t].hidden)return 0;var r={chart:e.chart,dataIndex:t,dataset:n,datasetIndex:e.index};return ne([e.chart.options.elements.arc.angle,2*Math.PI/i],r,t)}});ot._set("pie",ut.clone(ot.doughnut)),ot._set("pie",{cutoutPercentage:0});var re=Xt,oe=ut.valueOrDefault,se=ut.options.resolve;ot._set("radar",{scale:{type:"radialLinear"},elements:{line:{tension:0}}});var le=kt.extend({datasetElementType:Nt.Line,dataElementType:Nt.Point,linkScales:ut.noop,update:function(t){var e,i,n=this,a=n.getMeta(),r=a.dataset,o=a.data||[],s=n.chart.scale,l=n.getDataset();for(void 0!==l.tension&&void 0===l.lineTension&&(l.lineTension=l.tension),r._scale=s,r._datasetIndex=n.index,r._children=o,r._loop=!0,r._model=n._resolveLineOptions(r),r.pivot(),e=0,i=o.length;e<i;++e)n.updateElement(o[e],e,t);for(n.updateBezierControlPoints(),e=0,i=o.length;e<i;++e)o[e].pivot()},updateElement:function(t,e,i){var n=this,a=t.custom||{},r=n.getDataset(),o=n.chart.scale,s=o.getPointPositionForValue(e,r.data[e]),l=n._resolvePointOptions(t,e),u=n.getMeta().dataset._model,d=i?o.xCenter:s.x,h=i?o.yCenter:s.y;t._scale=o,t._options=l,t._datasetIndex=n.index,t._index=e,t._model={x:d,y:h,skip:a.skip||isNaN(d)||isNaN(h),radius:l.radius,pointStyle:l.pointStyle,rotation:l.rotation,backgroundColor:l.backgroundColor,borderColor:l.borderColor,borderWidth:l.borderWidth,tension:oe(a.tension,u?u.tension:0),hitRadius:l.hitRadius}},_resolvePointOptions:function(t,e){var i,n,a,r=this.chart,o=r.data.datasets[this.index],s=t.custom||{},l=r.options.elements.point,u={},d={chart:r,dataIndex:e,dataset:o,datasetIndex:this.index},h={backgroundColor:"pointBackgroundColor",borderColor:"pointBorderColor",borderWidth:"pointBorderWidth",hitRadius:"pointHitRadius",hoverBackgroundColor:"pointHoverBackgroundColor",hoverBorderColor:"pointHoverBorderColor",hoverBorderWidth:"pointHoverBorderWidth",hoverRadius:"pointHoverRadius",pointStyle:"pointStyle",radius:"pointRadius",rotation:"pointRotation"},c=Object.keys(h);for(i=0,n=c.length;i<n;++i)u[a=c[i]]=se([s[a],o[h[a]],o[a],l[a]],d,e);return u},_resolveLineOptions:function(t){var e,i,n,a=this.chart,r=a.data.datasets[this.index],o=t.custom||{},s=a.options.elements.line,l={},u=["backgroundColor","borderWidth","borderColor","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","fill"];for(e=0,i=u.length;e<i;++e)l[n=u[e]]=se([o[n],r[n],s[n]]);return l.tension=oe(r.lineTension,s.tension),l},updateBezierControlPoints:function(){var t,e,i,n,a=this.getMeta(),r=this.chart.chartArea,o=a.data||[];function s(t,e,i){return Math.max(Math.min(t,i),e)}for(t=0,e=o.length;t<e;++t)i=o[t]._model,n=ut.splineCurve(ut.previousItem(o,t,!0)._model,i,ut.nextItem(o,t,!0)._model,i.tension),i.controlPointPreviousX=s(n.previous.x,r.left,r.right),i.controlPointPreviousY=s(n.previous.y,r.top,r.bottom),i.controlPointNextX=s(n.next.x,r.left,r.right),i.controlPointNextY=s(n.next.y,r.top,r.bottom)},setHoverStyle:function(t){var e=t._model,i=t._options,n=ut.getHoverColor;t.$previousStyle={backgroundColor:e.backgroundColor,borderColor:e.borderColor,borderWidth:e.borderWidth,radius:e.radius},e.backgroundColor=oe(i.hoverBackgroundColor,n(i.backgroundColor)),e.borderColor=oe(i.hoverBorderColor,n(i.borderColor)),e.borderWidth=oe(i.hoverBorderWidth,i.borderWidth),e.radius=oe(i.hoverRadius,i.radius)}});ot._set("scatter",{hover:{mode:"single"},scales:{xAxes:[{id:"x-axis-1",type:"linear",position:"bottom"}],yAxes:[{id:"y-axis-1",type:"linear",position:"left"}]},showLines:!1,tooltips:{callbacks:{title:function(){return""},label:function(t){return"("+t.xLabel+", "+t.yLabel+")"}}}});var ue={bar:jt,bubble:qt,doughnut:Xt,horizontalBar:Kt,line:ie,polarArea:ae,pie:re,radar:le,scatter:ie};function de(t,e){return t.native?{x:t.x,y:t.y}:ut.getRelativePosition(t,e)}function he(t,e){var i,n,a,r,o;for(n=0,r=t.data.datasets.length;n<r;++n)if(t.isDatasetVisible(n))for(a=0,o=(i=t.getDatasetMeta(n)).data.length;a<o;++a){var s=i.data[a];s&&s._view&&s._view.skip||e(s)}}function ce(t,e){var i=[];return he(t,function(t){t.inRange(e.x,e.y)&&i.push(t)}),i}function fe(t,e,i,n){var a=Number.POSITIVE_INFINITY,r=[];return he(t,function(t){if(!i||t.inRange(e.x,e.y)){var o=t.getCenterPoint(),s=n(e,o);s<a?(r=[t],a=s):s===a&&r.push(t)}}),r}function ge(t){var e=-1!==t.indexOf("x"),i=-1!==t.indexOf("y");return function(t,n){var a=e?Math.abs(t.x-n.x):0,r=i?Math.abs(t.y-n.y):0;return Math.sqrt(Math.pow(a,2)+Math.pow(r,2))}}function me(t,e,i){var n=de(e,t);i.axis=i.axis||"x";var a=ge(i.axis),r=i.intersect?ce(t,n):fe(t,n,!1,a),o=[];return r.length?(t.data.datasets.forEach(function(e,i){if(t.isDatasetVisible(i)){var n=t.getDatasetMeta(i).data[r[0]._index];n&&n._view&&!n._view.skip&&o.push(n)}}),o):[]}var pe={modes:{single:function(t,e){var i=de(e,t),n=[];return he(t,function(t){if(t.inRange(i.x,i.y))return n.push(t),n}),n.slice(0,1)},label:me,index:me,dataset:function(t,e,i){var n=de(e,t);i.axis=i.axis||"xy";var a=ge(i.axis),r=i.intersect?ce(t,n):fe(t,n,!1,a);return r.length>0&&(r=t.getDatasetMeta(r[0]._datasetIndex).data),r},"x-axis":function(t,e){return me(t,e,{intersect:!1})},point:function(t,e){return ce(t,de(e,t))},nearest:function(t,e,i){var n=de(e,t);i.axis=i.axis||"xy";var a=ge(i.axis);return fe(t,n,i.intersect,a)},x:function(t,e,i){var n=de(e,t),a=[],r=!1;return he(t,function(t){t.inXRange(n.x)&&a.push(t),t.inRange(n.x,n.y)&&(r=!0)}),i.intersect&&!r&&(a=[]),a},y:function(t,e,i){var n=de(e,t),a=[],r=!1;return he(t,function(t){t.inYRange(n.y)&&a.push(t),t.inRange(n.x,n.y)&&(r=!0)}),i.intersect&&!r&&(a=[]),a}}};function ve(t,e){return ut.where(t,function(t){return t.position===e})}function ye(t,e){t.forEach(function(t,e){return t._tmpIndex_=e,t}),t.sort(function(t,i){var n=e?i:t,a=e?t:i;return n.weight===a.weight?n._tmpIndex_-a._tmpIndex_:n.weight-a.weight}),t.forEach(function(t){delete t._tmpIndex_})}function be(t,e){ut.each(t,function(t){e[t.position]+=t.isHorizontal()?t.height:t.width})}ot._set("global",{layout:{padding:{top:0,right:0,bottom:0,left:0}}});var xe={defaults:{},addBox:function(t,e){t.boxes||(t.boxes=[]),e.fullWidth=e.fullWidth||!1,e.position=e.position||"top",e.weight=e.weight||0,t.boxes.push(e)},removeBox:function(t,e){var i=t.boxes?t.boxes.indexOf(e):-1;-1!==i&&t.boxes.splice(i,1)},configure:function(t,e,i){for(var n,a=["fullWidth","position","weight"],r=a.length,o=0;o<r;++o)n=a[o],i.hasOwnProperty(n)&&(e[n]=i[n])},update:function(t,e,i){if(t){var n=t.options.layout||{},a=ut.options.toPadding(n.padding),r=a.left,o=a.right,s=a.top,l=a.bottom,u=ve(t.boxes,"left"),d=ve(t.boxes,"right"),h=ve(t.boxes,"top"),c=ve(t.boxes,"bottom"),f=ve(t.boxes,"chartArea");ye(u,!0),ye(d,!1),ye(h,!0),ye(c,!1);var g,m=u.concat(d),p=h.concat(c),v=m.concat(p),y=e-r-o,b=i-s-l,x=(e-y/2)/m.length,_=y,k=b,w={top:s,left:r,bottom:l,right:o},M=[];ut.each(v,function(t){var e,i=t.isHorizontal();i?(e=t.update(t.fullWidth?y:_,b/2),k-=e.height):(e=t.update(x,k),_-=e.width),M.push({horizontal:i,width:e.width,box:t})}),g=function(t){var e=0,i=0,n=0,a=0;return ut.each(t,function(t){if(t.getPadding){var r=t.getPadding();e=Math.max(e,r.top),i=Math.max(i,r.left),n=Math.max(n,r.bottom),a=Math.max(a,r.right)}}),{top:e,left:i,bottom:n,right:a}}(v),ut.each(m,I),be(m,w),ut.each(p,I),be(p,w),ut.each(m,function(t){var e=ut.findNextWhere(M,function(e){return e.box===t}),i={left:0,right:0,top:w.top,bottom:w.bottom};e&&t.update(e.width,k,i)}),be(v,w={top:s,left:r,bottom:l,right:o});var S=Math.max(g.left-w.left,0);w.left+=S,w.right+=Math.max(g.right-w.right,0);var D=Math.max(g.top-w.top,0);w.top+=D,w.bottom+=Math.max(g.bottom-w.bottom,0);var C=i-w.top-w.bottom,P=e-w.left-w.right;P===_&&C===k||(ut.each(m,function(t){t.height=C}),ut.each(p,function(t){t.fullWidth||(t.width=P)}),k=C,_=P);var T=r+S,O=s+D;ut.each(u.concat(h),A),T+=_,O+=k,ut.each(d,A),ut.each(c,A),t.chartArea={left:w.left,top:w.top,right:w.left+_,bottom:w.top+k},ut.each(f,function(e){e.left=t.chartArea.left,e.top=t.chartArea.top,e.right=t.chartArea.right,e.bottom=t.chartArea.bottom,e.update(_,k)})}function I(t){var e=ut.findNextWhere(M,function(e){return e.box===t});if(e)if(e.horizontal){var i={left:Math.max(w.left,g.left),right:Math.max(w.right,g.right),top:0,bottom:0};t.update(t.fullWidth?y:_,b/2,i)}else t.update(e.width,k)}function A(t){t.isHorizontal()?(t.left=t.fullWidth?r:w.left,t.right=t.fullWidth?e-o:w.left+_,t.top=O,t.bottom=O+t.height,O=t.bottom):(t.left=T,t.right=T+t.width,t.top=w.top,t.bottom=w.top+k,T=t.right)}}};"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;function _e(){throw new Error("Dynamic requires are not currently supported by rollup-plugin-commonjs")}var ke,we=(ke=Object.freeze({default:"@keyframes chartjs-render-animation{from{opacity:.99}to{opacity:1}}.chartjs-render-monitor{animation:chartjs-render-animation 1ms}.chartjs-size-monitor,.chartjs-size-monitor-expand,.chartjs-size-monitor-shrink{position:absolute;direction:ltr;left:0;top:0;right:0;bottom:0;overflow:hidden;pointer-events:none;visibility:hidden;z-index:-1}.chartjs-size-monitor-expand>div{position:absolute;width:1000000px;height:1000000px;left:0;top:0}.chartjs-size-monitor-shrink>div{position:absolute;width:200%;height:200%;left:0;top:0}"}))&&ke.default||ke,Me="$chartjs",Se="chartjs-size-monitor",De="chartjs-render-monitor",Ce="chartjs-render-animation",Pe=["animationstart","webkitAnimationStart"],Te={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"};function Oe(t,e){var i=ut.getStyle(t,e),n=i&&i.match(/^(\d+)(\.\d+)?px$/);return n?Number(n[1]):void 0}var Ie=!!function(){var t=!1;try{var e=Object.defineProperty({},"passive",{get:function(){t=!0}});window.addEventListener("e",null,e)}catch(t){}return t}()&&{passive:!0};function Ae(t,e,i){t.addEventListener(e,i,Ie)}function Fe(t,e,i){t.removeEventListener(e,i,Ie)}function Re(t,e,i,n,a){return{type:t,chart:e,native:a||null,x:void 0!==i?i:null,y:void 0!==n?n:null}}function Le(t){var e=document.createElement("div");return e.className=t||"",e}function We(t,e,i){var n,a,r,o,s=t[Me]||(t[Me]={}),l=s.resizer=function(t){var e=Le(Se),i=Le(Se+"-expand"),n=Le(Se+"-shrink");i.appendChild(Le()),n.appendChild(Le()),e.appendChild(i),e.appendChild(n),e._reset=function(){i.scrollLeft=1e6,i.scrollTop=1e6,n.scrollLeft=1e6,n.scrollTop=1e6};var a=function(){e._reset(),t()};return Ae(i,"scroll",a.bind(i,"expand")),Ae(n,"scroll",a.bind(n,"shrink")),e}((n=function(){if(s.resizer){var n=i.options.maintainAspectRatio&&t.parentNode,a=n?n.clientWidth:0;e(Re("resize",i)),n&&n.clientWidth<a&&i.canvas&&e(Re("resize",i))}},r=!1,o=[],function(){o=Array.prototype.slice.call(arguments),a=a||this,r||(r=!0,ut.requestAnimFrame.call(window,function(){r=!1,n.apply(a,o)}))}));!function(t,e){var i=t[Me]||(t[Me]={}),n=i.renderProxy=function(t){t.animationName===Ce&&e()};ut.each(Pe,function(e){Ae(t,e,n)}),i.reflow=!!t.offsetParent,t.classList.add(De)}(t,function(){if(s.resizer){var e=t.parentNode;e&&e!==l.parentNode&&e.insertBefore(l,e.firstChild),l._reset()}})}function Ye(t){var e=t[Me]||{},i=e.resizer;delete e.resizer,function(t){var e=t[Me]||{},i=e.renderProxy;i&&(ut.each(Pe,function(e){Fe(t,e,i)}),delete e.renderProxy),t.classList.remove(De)}(t),i&&i.parentNode&&i.parentNode.removeChild(i)}var Ne={disableCSSInjection:!1,_enabled:"undefined"!=typeof window&&"undefined"!=typeof document,_ensureLoaded:function(){var t,e,i;this._loaded||(this._loaded=!0,this.disableCSSInjection||(e=we,i=(t=this)._style||document.createElement("style"),t._style||(t._style=i,e="/* Chart.js */\n"+e,i.setAttribute("type","text/css"),document.getElementsByTagName("head")[0].appendChild(i)),i.appendChild(document.createTextNode(e))))},acquireContext:function(t,e){"string"==typeof t?t=document.getElementById(t):t.length&&(t=t[0]),t&&t.canvas&&(t=t.canvas);var i=t&&t.getContext&&t.getContext("2d");return this._ensureLoaded(),i&&i.canvas===t?(function(t,e){var i=t.style,n=t.getAttribute("height"),a=t.getAttribute("width");if(t[Me]={initial:{height:n,width:a,style:{display:i.display,height:i.height,width:i.width}}},i.display=i.display||"block",null===a||""===a){var r=Oe(t,"width");void 0!==r&&(t.width=r)}if(null===n||""===n)if(""===t.style.height)t.height=t.width/(e.options.aspectRatio||2);else{var o=Oe(t,"height");void 0!==r&&(t.height=o)}}(t,e),i):null},releaseContext:function(t){var e=t.canvas;if(e[Me]){var i=e[Me].initial;["height","width"].forEach(function(t){var n=i[t];ut.isNullOrUndef(n)?e.removeAttribute(t):e.setAttribute(t,n)}),ut.each(i.style||{},function(t,i){e.style[i]=t}),e.width=e.width,delete e[Me]}},addEventListener:function(t,e,i){var n=t.canvas;if("resize"!==e){var a=i[Me]||(i[Me]={});Ae(n,e,(a.proxies||(a.proxies={}))[t.id+"_"+e]=function(e){i(function(t,e){var i=Te[t.type]||t.type,n=ut.getRelativePosition(t,e);return Re(i,e,n.x,n.y,t)}(e,t))})}else We(n,i,t)},removeEventListener:function(t,e,i){var n=t.canvas;if("resize"!==e){var a=((i[Me]||{}).proxies||{})[t.id+"_"+e];a&&Fe(n,e,a)}else Ye(n)}};ut.addEvent=Ae,ut.removeEvent=Fe;var ze=Ne._enabled?Ne:{acquireContext:function(t){return t&&t.canvas&&(t=t.canvas),t&&t.getContext("2d")||null}},Ve=ut.extend({initialize:function(){},acquireContext:function(){},releaseContext:function(){},addEventListener:function(){},removeEventListener:function(){}},ze);ot._set("global",{plugins:{}});var He={_plugins:[],_cacheId:0,register:function(t){var e=this._plugins;[].concat(t).forEach(function(t){-1===e.indexOf(t)&&e.push(t)}),this._cacheId++},unregister:function(t){var e=this._plugins;[].concat(t).forEach(function(t){var i=e.indexOf(t);-1!==i&&e.splice(i,1)}),this._cacheId++},clear:function(){this._plugins=[],this._cacheId++},count:function(){return this._plugins.length},getAll:function(){return this._plugins},notify:function(t,e,i){var n,a,r,o,s,l=this.descriptors(t),u=l.length;for(n=0;n<u;++n)if("function"==typeof(s=(r=(a=l[n]).plugin)[e])&&((o=[t].concat(i||[])).push(a.options),!1===s.apply(r,o)))return!1;return!0},descriptors:function(t){var e=t.$plugins||(t.$plugins={});if(e.id===this._cacheId)return e.descriptors;var i=[],n=[],a=t&&t.config||{},r=a.options&&a.options.plugins||{};return this._plugins.concat(a.plugins||[]).forEach(function(t){if(-1===i.indexOf(t)){var e=t.id,a=r[e];!1!==a&&(!0===a&&(a=ut.clone(ot.global.plugins[e])),i.push(t),n.push({plugin:t,options:a||{}}))}}),e.descriptors=n,e.id=this._cacheId,n},_invalidate:function(t){delete t.$plugins}},Ee={constructors:{},defaults:{},registerScaleType:function(t,e,i){this.constructors[t]=e,this.defaults[t]=ut.clone(i)},getScaleConstructor:function(t){return this.constructors.hasOwnProperty(t)?this.constructors[t]:void 0},getScaleDefaults:function(t){return this.defaults.hasOwnProperty(t)?ut.merge({},[ot.scale,this.defaults[t]]):{}},updateScaleDefaults:function(t,e){this.defaults.hasOwnProperty(t)&&(this.defaults[t]=ut.extend(this.defaults[t],e))},addScalesToLayout:function(t){ut.each(t.scales,function(e){e.fullWidth=e.options.fullWidth,e.position=e.options.position,e.weight=e.options.weight,xe.addBox(t,e)})}},Be=ut.valueOrDefault;ot._set("global",{tooltips:{enabled:!0,custom:null,mode:"nearest",position:"average",intersect:!0,backgroundColor:"rgba(0,0,0,0.8)",titleFontStyle:"bold",titleSpacing:2,titleMarginBottom:6,titleFontColor:"#fff",titleAlign:"left",bodySpacing:2,bodyFontColor:"#fff",bodyAlign:"left",footerFontStyle:"bold",footerSpacing:2,footerMarginTop:6,footerFontColor:"#fff",footerAlign:"left",yPadding:6,xPadding:6,caretPadding:2,caretSize:5,cornerRadius:6,multiKeyBackground:"#fff",displayColors:!0,borderColor:"rgba(0,0,0,0)",borderWidth:0,callbacks:{beforeTitle:ut.noop,title:function(t,e){var i="",n=e.labels,a=n?n.length:0;if(t.length>0){var r=t[0];r.label?i=r.label:r.xLabel?i=r.xLabel:a>0&&r.index<a&&(i=n[r.index])}return i},afterTitle:ut.noop,beforeBody:ut.noop,beforeLabel:ut.noop,label:function(t,e){var i=e.datasets[t.datasetIndex].label||"";return i&&(i+=": "),ut.isNullOrUndef(t.value)?i+=t.yLabel:i+=t.value,i},labelColor:function(t,e){var i=e.getDatasetMeta(t.datasetIndex).data[t.index]._view;return{borderColor:i.borderColor,backgroundColor:i.backgroundColor}},labelTextColor:function(){return this._options.bodyFontColor},afterLabel:ut.noop,afterBody:ut.noop,beforeFooter:ut.noop,footer:ut.noop,afterFooter:ut.noop}}});var je={average:function(t){if(!t.length)return!1;var e,i,n=0,a=0,r=0;for(e=0,i=t.length;e<i;++e){var o=t[e];if(o&&o.hasValue()){var s=o.tooltipPosition();n+=s.x,a+=s.y,++r}}return{x:n/r,y:a/r}},nearest:function(t,e){var i,n,a,r=e.x,o=e.y,s=Number.POSITIVE_INFINITY;for(i=0,n=t.length;i<n;++i){var l=t[i];if(l&&l.hasValue()){var u=l.getCenterPoint(),d=ut.distanceBetweenPoints(e,u);d<s&&(s=d,a=l)}}if(a){var h=a.tooltipPosition();r=h.x,o=h.y}return{x:r,y:o}}};function Ue(t,e){return e&&(ut.isArray(e)?Array.prototype.push.apply(t,e):t.push(e)),t}function Ge(t){return("string"==typeof t||t instanceof String)&&t.indexOf("\n")>-1?t.split("\n"):t}function qe(t){var e=ot.global;return{xPadding:t.xPadding,yPadding:t.yPadding,xAlign:t.xAlign,yAlign:t.yAlign,bodyFontColor:t.bodyFontColor,_bodyFontFamily:Be(t.bodyFontFamily,e.defaultFontFamily),_bodyFontStyle:Be(t.bodyFontStyle,e.defaultFontStyle),_bodyAlign:t.bodyAlign,bodyFontSize:Be(t.bodyFontSize,e.defaultFontSize),bodySpacing:t.bodySpacing,titleFontColor:t.titleFontColor,_titleFontFamily:Be(t.titleFontFamily,e.defaultFontFamily),_titleFontStyle:Be(t.titleFontStyle,e.defaultFontStyle),titleFontSize:Be(t.titleFontSize,e.defaultFontSize),_titleAlign:t.titleAlign,titleSpacing:t.titleSpacing,titleMarginBottom:t.titleMarginBottom,footerFontColor:t.footerFontColor,_footerFontFamily:Be(t.footerFontFamily,e.defaultFontFamily),_footerFontStyle:Be(t.footerFontStyle,e.defaultFontStyle),footerFontSize:Be(t.footerFontSize,e.defaultFontSize),_footerAlign:t.footerAlign,footerSpacing:t.footerSpacing,footerMarginTop:t.footerMarginTop,caretSize:t.caretSize,cornerRadius:t.cornerRadius,backgroundColor:t.backgroundColor,opacity:0,legendColorBackground:t.multiKeyBackground,displayColors:t.displayColors,borderColor:t.borderColor,borderWidth:t.borderWidth}}function Ze(t,e){return"center"===e?t.x+t.width/2:"right"===e?t.x+t.width-t.xPadding:t.x+t.xPadding}function $e(t){return Ue([],Ge(t))}var Xe=gt.extend({initialize:function(){this._model=qe(this._options),this._lastActive=[]},getTitle:function(){var t=this._options.callbacks,e=t.beforeTitle.apply(this,arguments),i=t.title.apply(this,arguments),n=t.afterTitle.apply(this,arguments),a=[];return a=Ue(a,Ge(e)),a=Ue(a,Ge(i)),a=Ue(a,Ge(n))},getBeforeBody:function(){return $e(this._options.callbacks.beforeBody.apply(this,arguments))},getBody:function(t,e){var i=this,n=i._options.callbacks,a=[];return ut.each(t,function(t){var r={before:[],lines:[],after:[]};Ue(r.before,Ge(n.beforeLabel.call(i,t,e))),Ue(r.lines,n.label.call(i,t,e)),Ue(r.after,Ge(n.afterLabel.call(i,t,e))),a.push(r)}),a},getAfterBody:function(){return $e(this._options.callbacks.afterBody.apply(this,arguments))},getFooter:function(){var t=this._options.callbacks,e=t.beforeFooter.apply(this,arguments),i=t.footer.apply(this,arguments),n=t.afterFooter.apply(this,arguments),a=[];return a=Ue(a,Ge(e)),a=Ue(a,Ge(i)),a=Ue(a,Ge(n))},update:function(t){var e,i,n,a,r,o,s,l,u,d,h=this,c=h._options,f=h._model,g=h._model=qe(c),m=h._active,p=h._data,v={xAlign:f.xAlign,yAlign:f.yAlign},y={x:f.x,y:f.y},b={width:f.width,height:f.height},x={x:f.caretX,y:f.caretY};if(m.length){g.opacity=1;var _=[],k=[];x=je[c.position].call(h,m,h._eventPosition);var w=[];for(e=0,i=m.length;e<i;++e)w.push((n=m[e],a=void 0,r=void 0,o=void 0,s=void 0,l=void 0,u=void 0,d=void 0,a=n._xScale,r=n._yScale||n._scale,o=n._index,s=n._datasetIndex,l=n._chart.getDatasetMeta(s).controller,u=l._getIndexScale(),d=l._getValueScale(),{xLabel:a?a.getLabelForIndex(o,s):"",yLabel:r?r.getLabelForIndex(o,s):"",label:u?""+u.getLabelForIndex(o,s):"",value:d?""+d.getLabelForIndex(o,s):"",index:o,datasetIndex:s,x:n._model.x,y:n._model.y}));c.filter&&(w=w.filter(function(t){return c.filter(t,p)})),c.itemSort&&(w=w.sort(function(t,e){return c.itemSort(t,e,p)})),ut.each(w,function(t){_.push(c.callbacks.labelColor.call(h,t,h._chart)),k.push(c.callbacks.labelTextColor.call(h,t,h._chart))}),g.title=h.getTitle(w,p),g.beforeBody=h.getBeforeBody(w,p),g.body=h.getBody(w,p),g.afterBody=h.getAfterBody(w,p),g.footer=h.getFooter(w,p),g.x=x.x,g.y=x.y,g.caretPadding=c.caretPadding,g.labelColors=_,g.labelTextColors=k,g.dataPoints=w,b=function(t,e){var i=t._chart.ctx,n=2*e.yPadding,a=0,r=e.body,o=r.reduce(function(t,e){return t+e.before.length+e.lines.length+e.after.length},0);o+=e.beforeBody.length+e.afterBody.length;var s=e.title.length,l=e.footer.length,u=e.titleFontSize,d=e.bodyFontSize,h=e.footerFontSize;n+=s*u,n+=s?(s-1)*e.titleSpacing:0,n+=s?e.titleMarginBottom:0,n+=o*d,n+=o?(o-1)*e.bodySpacing:0,n+=l?e.footerMarginTop:0,n+=l*h,n+=l?(l-1)*e.footerSpacing:0;var c=0,f=function(t){a=Math.max(a,i.measureText(t).width+c)};return i.font=ut.fontString(u,e._titleFontStyle,e._titleFontFamily),ut.each(e.title,f),i.font=ut.fontString(d,e._bodyFontStyle,e._bodyFontFamily),ut.each(e.beforeBody.concat(e.afterBody),f),c=e.displayColors?d+2:0,ut.each(r,function(t){ut.each(t.before,f),ut.each(t.lines,f),ut.each(t.after,f)}),c=0,i.font=ut.fontString(h,e._footerFontStyle,e._footerFontFamily),ut.each(e.footer,f),{width:a+=2*e.xPadding,height:n}}(this,g),y=function(t,e,i,n){var a=t.x,r=t.y,o=t.caretSize,s=t.caretPadding,l=t.cornerRadius,u=i.xAlign,d=i.yAlign,h=o+s,c=l+s;return"right"===u?a-=e.width:"center"===u&&((a-=e.width/2)+e.width>n.width&&(a=n.width-e.width),a<0&&(a=0)),"top"===d?r+=h:r-="bottom"===d?e.height+h:e.height/2,"center"===d?"left"===u?a+=h:"right"===u&&(a-=h):"left"===u?a-=c:"right"===u&&(a+=c),{x:a,y:r}}(g,b,v=function(t,e){var i,n,a,r,o,s=t._model,l=t._chart,u=t._chart.chartArea,d="center",h="center";s.y<e.height?h="top":s.y>l.height-e.height&&(h="bottom");var c=(u.left+u.right)/2,f=(u.top+u.bottom)/2;"center"===h?(i=function(t){return t<=c},n=function(t){return t>c}):(i=function(t){return t<=e.width/2},n=function(t){return t>=l.width-e.width/2}),a=function(t){return t+e.width+s.caretSize+s.caretPadding>l.width},r=function(t){return t-e.width-s.caretSize-s.caretPadding<0},o=function(t){return t<=f?"top":"bottom"},i(s.x)?(d="left",a(s.x)&&(d="center",h=o(s.y))):n(s.x)&&(d="right",r(s.x)&&(d="center",h=o(s.y)));var g=t._options;return{xAlign:g.xAlign?g.xAlign:d,yAlign:g.yAlign?g.yAlign:h}}(this,b),h._chart)}else g.opacity=0;return g.xAlign=v.xAlign,g.yAlign=v.yAlign,g.x=y.x,g.y=y.y,g.width=b.width,g.height=b.height,g.caretX=x.x,g.caretY=x.y,h._model=g,t&&c.custom&&c.custom.call(h,g),h},drawCaret:function(t,e){var i=this._chart.ctx,n=this._view,a=this.getCaretPosition(t,e,n);i.lineTo(a.x1,a.y1),i.lineTo(a.x2,a.y2),i.lineTo(a.x3,a.y3)},getCaretPosition:function(t,e,i){var n,a,r,o,s,l,u=i.caretSize,d=i.cornerRadius,h=i.xAlign,c=i.yAlign,f=t.x,g=t.y,m=e.width,p=e.height;if("center"===c)s=g+p/2,"left"===h?(a=(n=f)-u,r=n,o=s+u,l=s-u):(a=(n=f+m)+u,r=n,o=s-u,l=s+u);else if("left"===h?(n=(a=f+d+u)-u,r=a+u):"right"===h?(n=(a=f+m-d-u)-u,r=a+u):(n=(a=i.caretX)-u,r=a+u),"top"===c)s=(o=g)-u,l=o;else{s=(o=g+p)+u,l=o;var v=r;r=n,n=v}return{x1:n,x2:a,x3:r,y1:o,y2:s,y3:l}},drawTitle:function(t,e,i){var n=e.title;if(n.length){t.x=Ze(e,e._titleAlign),i.textAlign=e._titleAlign,i.textBaseline="top";var a,r,o=e.titleFontSize,s=e.titleSpacing;for(i.fillStyle=e.titleFontColor,i.font=ut.fontString(o,e._titleFontStyle,e._titleFontFamily),a=0,r=n.length;a<r;++a)i.fillText(n[a],t.x,t.y),t.y+=o+s,a+1===n.length&&(t.y+=e.titleMarginBottom-s)}},drawBody:function(t,e,i){var n,a=e.bodyFontSize,r=e.bodySpacing,o=e._bodyAlign,s=e.body,l=e.displayColors,u=e.labelColors,d=0,h=l?Ze(e,"left"):0;i.textAlign=o,i.textBaseline="top",i.font=ut.fontString(a,e._bodyFontStyle,e._bodyFontFamily),t.x=Ze(e,o);var c=function(e){i.fillText(e,t.x+d,t.y),t.y+=a+r};i.fillStyle=e.bodyFontColor,ut.each(e.beforeBody,c),d=l&&"right"!==o?"center"===o?a/2+1:a+2:0,ut.each(s,function(r,o){n=e.labelTextColors[o],i.fillStyle=n,ut.each(r.before,c),ut.each(r.lines,function(r){l&&(i.fillStyle=e.legendColorBackground,i.fillRect(h,t.y,a,a),i.lineWidth=1,i.strokeStyle=u[o].borderColor,i.strokeRect(h,t.y,a,a),i.fillStyle=u[o].backgroundColor,i.fillRect(h+1,t.y+1,a-2,a-2),i.fillStyle=n),c(r)}),ut.each(r.after,c)}),d=0,ut.each(e.afterBody,c),t.y-=r},drawFooter:function(t,e,i){var n=e.footer;n.length&&(t.x=Ze(e,e._footerAlign),t.y+=e.footerMarginTop,i.textAlign=e._footerAlign,i.textBaseline="top",i.fillStyle=e.footerFontColor,i.font=ut.fontString(e.footerFontSize,e._footerFontStyle,e._footerFontFamily),ut.each(n,function(n){i.fillText(n,t.x,t.y),t.y+=e.footerFontSize+e.footerSpacing}))},drawBackground:function(t,e,i,n){i.fillStyle=e.backgroundColor,i.strokeStyle=e.borderColor,i.lineWidth=e.borderWidth;var a=e.xAlign,r=e.yAlign,o=t.x,s=t.y,l=n.width,u=n.height,d=e.cornerRadius;i.beginPath(),i.moveTo(o+d,s),"top"===r&&this.drawCaret(t,n),i.lineTo(o+l-d,s),i.quadraticCurveTo(o+l,s,o+l,s+d),"center"===r&&"right"===a&&this.drawCaret(t,n),i.lineTo(o+l,s+u-d),i.quadraticCurveTo(o+l,s+u,o+l-d,s+u),"bottom"===r&&this.drawCaret(t,n),i.lineTo(o+d,s+u),i.quadraticCurveTo(o,s+u,o,s+u-d),"center"===r&&"left"===a&&this.drawCaret(t,n),i.lineTo(o,s+d),i.quadraticCurveTo(o,s,o+d,s),i.closePath(),i.fill(),e.borderWidth>0&&i.stroke()},draw:function(){var t=this._chart.ctx,e=this._view;if(0!==e.opacity){var i={width:e.width,height:e.height},n={x:e.x,y:e.y},a=Math.abs(e.opacity<.001)?0:e.opacity,r=e.title.length||e.beforeBody.length||e.body.length||e.afterBody.length||e.footer.length;this._options.enabled&&r&&(t.save(),t.globalAlpha=a,this.drawBackground(n,e,t,i),n.y+=e.yPadding,this.drawTitle(n,e,t),this.drawBody(n,e,t),this.drawFooter(n,e,t),t.restore())}},handleEvent:function(t){var e,i=this,n=i._options;return i._lastActive=i._lastActive||[],"mouseout"===t.type?i._active=[]:i._active=i._chart.getElementsAtEventForMode(t,n.mode,n),(e=!ut.arrayEquals(i._active,i._lastActive))&&(i._lastActive=i._active,(n.enabled||n.custom)&&(i._eventPosition={x:t.x,y:t.y},i.update(!0),i.pivot())),e}}),Ke=je,Je=Xe;Je.positioners=Ke;var Qe=ut.valueOrDefault;function ti(){return ut.merge({},[].slice.call(arguments),{merger:function(t,e,i,n){if("xAxes"===t||"yAxes"===t){var a,r,o,s=i[t].length;for(e[t]||(e[t]=[]),a=0;a<s;++a)o=i[t][a],r=Qe(o.type,"xAxes"===t?"category":"linear"),a>=e[t].length&&e[t].push({}),!e[t][a].type||o.type&&o.type!==e[t][a].type?ut.merge(e[t][a],[Ee.getScaleDefaults(r),o]):ut.merge(e[t][a],o)}else ut._merger(t,e,i,n)}})}function ei(){return ut.merge({},[].slice.call(arguments),{merger:function(t,e,i,n){var a=e[t]||{},r=i[t];"scales"===t?e[t]=ti(a,r):"scale"===t?e[t]=ut.merge(a,[Ee.getScaleDefaults(r.type),r]):ut._merger(t,e,i,n)}})}function ii(t){return"top"===t||"bottom"===t}ot._set("global",{elements:{},events:["mousemove","mouseout","click","touchstart","touchmove"],hover:{onHover:null,mode:"nearest",intersect:!0,animationDuration:400},onClick:null,maintainAspectRatio:!0,responsive:!0,responsiveAnimationDuration:0});var ni=function(t,e){return this.construct(t,e),this};ut.extend(ni.prototype,{construct:function(t,e){var i=this;e=function(t){var e=(t=t||{}).data=t.data||{};return e.datasets=e.datasets||[],e.labels=e.labels||[],t.options=ei(ot.global,ot[t.type],t.options||{}),t}(e);var n=Ve.acquireContext(t,e),a=n&&n.canvas,r=a&&a.height,o=a&&a.width;i.id=ut.uid(),i.ctx=n,i.canvas=a,i.config=e,i.width=o,i.height=r,i.aspectRatio=r?o/r:null,i.options=e.options,i._bufferedRender=!1,i.chart=i,i.controller=i,ni.instances[i.id]=i,Object.defineProperty(i,"data",{get:function(){return i.config.data},set:function(t){i.config.data=t}}),n&&a?(i.initialize(),i.update()):console.error("Failed to create chart: can't acquire context from the given item")},initialize:function(){var t=this;return He.notify(t,"beforeInit"),ut.retinaScale(t,t.options.devicePixelRatio),t.bindEvents(),t.options.responsive&&t.resize(!0),t.ensureScalesHaveIDs(),t.buildOrUpdateScales(),t.initToolTip(),He.notify(t,"afterInit"),t},clear:function(){return ut.canvas.clear(this),this},stop:function(){return vt.cancelAnimation(this),this},resize:function(t){var e=this,i=e.options,n=e.canvas,a=i.maintainAspectRatio&&e.aspectRatio||null,r=Math.max(0,Math.floor(ut.getMaximumWidth(n))),o=Math.max(0,Math.floor(a?r/a:ut.getMaximumHeight(n)));if((e.width!==r||e.height!==o)&&(n.width=e.width=r,n.height=e.height=o,n.style.width=r+"px",n.style.height=o+"px",ut.retinaScale(e,i.devicePixelRatio),!t)){var s={width:r,height:o};He.notify(e,"resize",[s]),i.onResize&&i.onResize(e,s),e.stop(),e.update({duration:i.responsiveAnimationDuration})}},ensureScalesHaveIDs:function(){var t=this.options,e=t.scales||{},i=t.scale;ut.each(e.xAxes,function(t,e){t.id=t.id||"x-axis-"+e}),ut.each(e.yAxes,function(t,e){t.id=t.id||"y-axis-"+e}),i&&(i.id=i.id||"scale")},buildOrUpdateScales:function(){var t=this,e=t.options,i=t.scales||{},n=[],a=Object.keys(i).reduce(function(t,e){return t[e]=!1,t},{});e.scales&&(n=n.concat((e.scales.xAxes||[]).map(function(t){return{options:t,dtype:"category",dposition:"bottom"}}),(e.scales.yAxes||[]).map(function(t){return{options:t,dtype:"linear",dposition:"left"}}))),e.scale&&n.push({options:e.scale,dtype:"radialLinear",isDefault:!0,dposition:"chartArea"}),ut.each(n,function(e){var n=e.options,r=n.id,o=Qe(n.type,e.dtype);ii(n.position)!==ii(e.dposition)&&(n.position=e.dposition),a[r]=!0;var s=null;if(r in i&&i[r].type===o)(s=i[r]).options=n,s.ctx=t.ctx,s.chart=t;else{var l=Ee.getScaleConstructor(o);if(!l)return;s=new l({id:r,type:o,options:n,ctx:t.ctx,chart:t}),i[s.id]=s}s.mergeTicksOptions(),e.isDefault&&(t.scale=s)}),ut.each(a,function(t,e){t||delete i[e]}),t.scales=i,Ee.addScalesToLayout(this)},buildOrUpdateControllers:function(){var t=this,e=[];return ut.each(t.data.datasets,function(i,n){var a=t.getDatasetMeta(n),r=i.type||t.config.type;if(a.type&&a.type!==r&&(t.destroyDatasetMeta(n),a=t.getDatasetMeta(n)),a.type=r,a.controller)a.controller.updateIndex(n),a.controller.linkScales();else{var o=ue[a.type];if(void 0===o)throw new Error('"'+a.type+'" is not a chart type.');a.controller=new o(t,n),e.push(a.controller)}},t),e},resetElements:function(){var t=this;ut.each(t.data.datasets,function(e,i){t.getDatasetMeta(i).controller.reset()},t)},reset:function(){this.resetElements(),this.tooltip.initialize()},update:function(t){var e,i,n=this;if(t&&"object"==typeof t||(t={duration:t,lazy:arguments[1]}),i=(e=n).options,ut.each(e.scales,function(t){xe.removeBox(e,t)}),i=ei(ot.global,ot[e.config.type],i),e.options=e.config.options=i,e.ensureScalesHaveIDs(),e.buildOrUpdateScales(),e.tooltip._options=i.tooltips,e.tooltip.initialize(),He._invalidate(n),!1!==He.notify(n,"beforeUpdate")){n.tooltip._data=n.data;var a=n.buildOrUpdateControllers();ut.each(n.data.datasets,function(t,e){n.getDatasetMeta(e).controller.buildOrUpdateElements()},n),n.updateLayout(),n.options.animation&&n.options.animation.duration&&ut.each(a,function(t){t.reset()}),n.updateDatasets(),n.tooltip.initialize(),n.lastActive=[],He.notify(n,"afterUpdate"),n._bufferedRender?n._bufferedRequest={duration:t.duration,easing:t.easing,lazy:t.lazy}:n.render(t)}},updateLayout:function(){!1!==He.notify(this,"beforeLayout")&&(xe.update(this,this.width,this.height),He.notify(this,"afterScaleUpdate"),He.notify(this,"afterLayout"))},updateDatasets:function(){if(!1!==He.notify(this,"beforeDatasetsUpdate")){for(var t=0,e=this.data.datasets.length;t<e;++t)this.updateDataset(t);He.notify(this,"afterDatasetsUpdate")}},updateDataset:function(t){var e=this.getDatasetMeta(t),i={meta:e,index:t};!1!==He.notify(this,"beforeDatasetUpdate",[i])&&(e.controller.update(),He.notify(this,"afterDatasetUpdate",[i]))},render:function(t){var e=this;t&&"object"==typeof t||(t={duration:t,lazy:arguments[1]});var i=e.options.animation,n=Qe(t.duration,i&&i.duration),a=t.lazy;if(!1!==He.notify(e,"beforeRender")){var r=function(t){He.notify(e,"afterRender"),ut.callback(i&&i.onComplete,[t],e)};if(i&&n){var o=new pt({numSteps:n/16.66,easing:t.easing||i.easing,render:function(t,e){var i=ut.easing.effects[e.easing],n=e.currentStep,a=n/e.numSteps;t.draw(i(a),a,n)},onAnimationProgress:i.onProgress,onAnimationComplete:r});vt.addAnimation(e,o,n,a)}else e.draw(),r(new pt({numSteps:0,chart:e}));return e}},draw:function(t){var e=this;e.clear(),ut.isNullOrUndef(t)&&(t=1),e.transition(t),e.width<=0||e.height<=0||!1!==He.notify(e,"beforeDraw",[t])&&(ut.each(e.boxes,function(t){t.draw(e.chartArea)},e),e.drawDatasets(t),e._drawTooltip(t),He.notify(e,"afterDraw",[t]))},transition:function(t){for(var e=0,i=(this.data.datasets||[]).length;e<i;++e)this.isDatasetVisible(e)&&this.getDatasetMeta(e).controller.transition(t);this.tooltip.transition(t)},drawDatasets:function(t){var e=this;if(!1!==He.notify(e,"beforeDatasetsDraw",[t])){for(var i=(e.data.datasets||[]).length-1;i>=0;--i)e.isDatasetVisible(i)&&e.drawDataset(i,t);He.notify(e,"afterDatasetsDraw",[t])}},drawDataset:function(t,e){var i=this.getDatasetMeta(t),n={meta:i,index:t,easingValue:e};!1!==He.notify(this,"beforeDatasetDraw",[n])&&(i.controller.draw(e),He.notify(this,"afterDatasetDraw",[n]))},_drawTooltip:function(t){var e=this.tooltip,i={tooltip:e,easingValue:t};!1!==He.notify(this,"beforeTooltipDraw",[i])&&(e.draw(),He.notify(this,"afterTooltipDraw",[i]))},getElementAtEvent:function(t){return pe.modes.single(this,t)},getElementsAtEvent:function(t){return pe.modes.label(this,t,{intersect:!0})},getElementsAtXAxis:function(t){return pe.modes["x-axis"](this,t,{intersect:!0})},getElementsAtEventForMode:function(t,e,i){var n=pe.modes[e];return"function"==typeof n?n(this,t,i):[]},getDatasetAtEvent:function(t){return pe.modes.dataset(this,t,{intersect:!0})},getDatasetMeta:function(t){var e=this.data.datasets[t];e._meta||(e._meta={});var i=e._meta[this.id];return i||(i=e._meta[this.id]={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null}),i},getVisibleDatasetCount:function(){for(var t=0,e=0,i=this.data.datasets.length;e<i;++e)this.isDatasetVisible(e)&&t++;return t},isDatasetVisible:function(t){var e=this.getDatasetMeta(t);return"boolean"==typeof e.hidden?!e.hidden:!this.data.datasets[t].hidden},generateLegend:function(){return this.options.legendCallback(this)},destroyDatasetMeta:function(t){var e=this.id,i=this.data.datasets[t],n=i._meta&&i._meta[e];n&&(n.controller.destroy(),delete i._meta[e])},destroy:function(){var t,e,i=this,n=i.canvas;for(i.stop(),t=0,e=i.data.datasets.length;t<e;++t)i.destroyDatasetMeta(t);n&&(i.unbindEvents(),ut.canvas.clear(i),Ve.releaseContext(i.ctx),i.canvas=null,i.ctx=null),He.notify(i,"destroy"),delete ni.instances[i.id]},toBase64Image:function(){return this.canvas.toDataURL.apply(this.canvas,arguments)},initToolTip:function(){var t=this;t.tooltip=new Je({_chart:t,_chartInstance:t,_data:t.data,_options:t.options.tooltips},t)},bindEvents:function(){var t=this,e=t._listeners={},i=function(){t.eventHandler.apply(t,arguments)};ut.each(t.options.events,function(n){Ve.addEventListener(t,n,i),e[n]=i}),t.options.responsive&&(i=function(){t.resize()},Ve.addEventListener(t,"resize",i),e.resize=i)},unbindEvents:function(){var t=this,e=t._listeners;e&&(delete t._listeners,ut.each(e,function(e,i){Ve.removeEventListener(t,i,e)}))},updateHoverStyle:function(t,e,i){var n,a,r,o=i?"setHoverStyle":"removeHoverStyle";for(a=0,r=t.length;a<r;++a)(n=t[a])&&this.getDatasetMeta(n._datasetIndex).controller[o](n)},eventHandler:function(t){var e=this,i=e.tooltip;if(!1!==He.notify(e,"beforeEvent",[t])){e._bufferedRender=!0,e._bufferedRequest=null;var n=e.handleEvent(t);i&&(n=i._start?i.handleEvent(t):n|i.handleEvent(t)),He.notify(e,"afterEvent",[t]);var a=e._bufferedRequest;return a?e.render(a):n&&!e.animating&&(e.stop(),e.render({duration:e.options.hover.animationDuration,lazy:!0})),e._bufferedRender=!1,e._bufferedRequest=null,e}},handleEvent:function(t){var e,i=this,n=i.options||{},a=n.hover;return i.lastActive=i.lastActive||[],"mouseout"===t.type?i.active=[]:i.active=i.getElementsAtEventForMode(t,a.mode,a),ut.callback(n.onHover||n.hover.onHover,[t.native,i.active],i),"mouseup"!==t.type&&"click"!==t.type||n.onClick&&n.onClick.call(i,t.native,i.active),i.lastActive.length&&i.updateHoverStyle(i.lastActive,a.mode,!1),i.active.length&&a.mode&&i.updateHoverStyle(i.active,a.mode,!0),e=!ut.arrayEquals(i.active,i.lastActive),i.lastActive=i.active,e}}),ni.instances={};var ai=ni;ni.Controller=ni,ni.types={},ut.configMerge=ei,ut.scaleMerge=ti;function ri(){throw new Error("This method is not implemented: either no adapter can be found or an incomplete integration was provided.")}function oi(t){this.options=t||{}}ut.extend(oi.prototype,{formats:ri,parse:ri,format:ri,add:ri,diff:ri,startOf:ri,endOf:ri,_create:function(t){return t}}),oi.override=function(t){ut.extend(oi.prototype,t)};var si={_date:oi},li={formatters:{values:function(t){return ut.isArray(t)?t:""+t},linear:function(t,e,i){var n=i.length>3?i[2]-i[1]:i[1]-i[0];Math.abs(n)>1&&t!==Math.floor(t)&&(n=t-Math.floor(t));var a=ut.log10(Math.abs(n)),r="";if(0!==t)if(Math.max(Math.abs(i[0]),Math.abs(i[i.length-1]))<1e-4){var o=ut.log10(Math.abs(t));r=t.toExponential(Math.floor(o)-Math.floor(a))}else{var s=-1*Math.floor(a);s=Math.max(Math.min(s,20),0),r=t.toFixed(s)}else r="0";return r},logarithmic:function(t,e,i){var n=t/Math.pow(10,Math.floor(ut.log10(t)));return 0===t?"0":1===n||2===n||5===n||0===e||e===i.length-1?t.toExponential():""}}},ui=ut.valueOrDefault,di=ut.valueAtIndexOrDefault;function hi(t){var e,i,n=[];for(e=0,i=t.length;e<i;++e)n.push(t[e].label);return n}function ci(t,e,i){return ut.isArray(e)?ut.longestText(t,i,e):t.measureText(e).width}ot._set("scale",{display:!0,position:"left",offset:!1,gridLines:{display:!0,color:"rgba(0, 0, 0, 0.1)",lineWidth:1,drawBorder:!0,drawOnChartArea:!0,drawTicks:!0,tickMarkLength:10,zeroLineWidth:1,zeroLineColor:"rgba(0,0,0,0.25)",zeroLineBorderDash:[],zeroLineBorderDashOffset:0,offsetGridLines:!1,borderDash:[],borderDashOffset:0},scaleLabel:{display:!1,labelString:"",padding:{top:4,bottom:4}},ticks:{beginAtZero:!1,minRotation:0,maxRotation:50,mirror:!1,padding:0,reverse:!1,display:!0,autoSkip:!0,autoSkipPadding:0,labelOffset:0,callback:li.formatters.values,minor:{},major:{}}});var fi=gt.extend({getPadding:function(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}},getTicks:function(){return this._ticks},mergeTicksOptions:function(){var t=this.options.ticks;for(var e in!1===t.minor&&(t.minor={display:!1}),!1===t.major&&(t.major={display:!1}),t)"major"!==e&&"minor"!==e&&(void 0===t.minor[e]&&(t.minor[e]=t[e]),void 0===t.major[e]&&(t.major[e]=t[e]))},beforeUpdate:function(){ut.callback(this.options.beforeUpdate,[this])},update:function(t,e,i){var n,a,r,o,s,l,u=this;for(u.beforeUpdate(),u.maxWidth=t,u.maxHeight=e,u.margins=ut.extend({left:0,right:0,top:0,bottom:0},i),u._maxLabelLines=0,u.longestLabelWidth=0,u.longestTextCache=u.longestTextCache||{},u.beforeSetDimensions(),u.setDimensions(),u.afterSetDimensions(),u.beforeDataLimits(),u.determineDataLimits(),u.afterDataLimits(),u.beforeBuildTicks(),s=u.buildTicks()||[],s=u.afterBuildTicks(s)||s,u.beforeTickToLabelConversion(),r=u.convertTicksToLabels(s)||u.ticks,u.afterTickToLabelConversion(),u.ticks=r,n=0,a=r.length;n<a;++n)o=r[n],(l=s[n])?l.label=o:s.push(l={label:o,major:!1});return u._ticks=s,u.beforeCalculateTickRotation(),u.calculateTickRotation(),u.afterCalculateTickRotation(),u.beforeFit(),u.fit(),u.afterFit(),u.afterUpdate(),u.minSize},afterUpdate:function(){ut.callback(this.options.afterUpdate,[this])},beforeSetDimensions:function(){ut.callback(this.options.beforeSetDimensions,[this])},setDimensions:function(){var t=this;t.isHorizontal()?(t.width=t.maxWidth,t.left=0,t.right=t.width):(t.height=t.maxHeight,t.top=0,t.bottom=t.height),t.paddingLeft=0,t.paddingTop=0,t.paddingRight=0,t.paddingBottom=0},afterSetDimensions:function(){ut.callback(this.options.afterSetDimensions,[this])},beforeDataLimits:function(){ut.callback(this.options.beforeDataLimits,[this])},determineDataLimits:ut.noop,afterDataLimits:function(){ut.callback(this.options.afterDataLimits,[this])},beforeBuildTicks:function(){ut.callback(this.options.beforeBuildTicks,[this])},buildTicks:ut.noop,afterBuildTicks:function(t){var e=this;return ut.isArray(t)&&t.length?ut.callback(e.options.afterBuildTicks,[e,t]):(e.ticks=ut.callback(e.options.afterBuildTicks,[e,e.ticks])||e.ticks,t)},beforeTickToLabelConversion:function(){ut.callback(this.options.beforeTickToLabelConversion,[this])},convertTicksToLabels:function(){var t=this.options.ticks;this.ticks=this.ticks.map(t.userCallback||t.callback,this)},afterTickToLabelConversion:function(){ut.callback(this.options.afterTickToLabelConversion,[this])},beforeCalculateTickRotation:function(){ut.callback(this.options.beforeCalculateTickRotation,[this])},calculateTickRotation:function(){var t=this,e=t.ctx,i=t.options.ticks,n=hi(t._ticks),a=ut.options._parseFont(i);e.font=a.string;var r=i.minRotation||0;if(n.length&&t.options.display&&t.isHorizontal())for(var o,s=ut.longestText(e,a.string,n,t.longestTextCache),l=s,u=t.getPixelForTick(1)-t.getPixelForTick(0)-6;l>u&&r<i.maxRotation;){var d=ut.toRadians(r);if(o=Math.cos(d),Math.sin(d)*s>t.maxHeight){r--;break}r++,l=o*s}t.labelRotation=r},afterCalculateTickRotation:function(){ut.callback(this.options.afterCalculateTickRotation,[this])},beforeFit:function(){ut.callback(this.options.beforeFit,[this])},fit:function(){var t=this,e=t.minSize={width:0,height:0},i=hi(t._ticks),n=t.options,a=n.ticks,r=n.scaleLabel,o=n.gridLines,s=t._isVisible(),l=n.position,u=t.isHorizontal(),d=ut.options._parseFont,h=d(a),c=n.gridLines.tickMarkLength;if(e.width=u?t.isFullWidth()?t.maxWidth-t.margins.left-t.margins.right:t.maxWidth:s&&o.drawTicks?c:0,e.height=u?s&&o.drawTicks?c:0:t.maxHeight,r.display&&s){var f=d(r),g=ut.options.toPadding(r.padding),m=f.lineHeight+g.height;u?e.height+=m:e.width+=m}if(a.display&&s){var p=ut.longestText(t.ctx,h.string,i,t.longestTextCache),v=ut.numberOfLabelLines(i),y=.5*h.size,b=t.options.ticks.padding;if(t._maxLabelLines=v,t.longestLabelWidth=p,u){var x=ut.toRadians(t.labelRotation),_=Math.cos(x),k=Math.sin(x)*p+h.lineHeight*v+y;e.height=Math.min(t.maxHeight,e.height+k+b),t.ctx.font=h.string;var w,M,S=ci(t.ctx,i[0],h.string),D=ci(t.ctx,i[i.length-1],h.string),C=t.getPixelForTick(0)-t.left,P=t.right-t.getPixelForTick(i.length-1);0!==t.labelRotation?(w="bottom"===l?_*S:_*y,M="bottom"===l?_*y:_*D):(w=S/2,M=D/2),t.paddingLeft=Math.max(w-C,0)+3,t.paddingRight=Math.max(M-P,0)+3}else a.mirror?p=0:p+=b+y,e.width=Math.min(t.maxWidth,e.width+p),t.paddingTop=h.size/2,t.paddingBottom=h.size/2}t.handleMargins(),t.width=e.width,t.height=e.height},handleMargins:function(){var t=this;t.margins&&(t.paddingLeft=Math.max(t.paddingLeft-t.margins.left,0),t.paddingTop=Math.max(t.paddingTop-t.margins.top,0),t.paddingRight=Math.max(t.paddingRight-t.margins.right,0),t.paddingBottom=Math.max(t.paddingBottom-t.margins.bottom,0))},afterFit:function(){ut.callback(this.options.afterFit,[this])},isHorizontal:function(){return"top"===this.options.position||"bottom"===this.options.position},isFullWidth:function(){return this.options.fullWidth},getRightValue:function(t){if(ut.isNullOrUndef(t))return NaN;if(("number"==typeof t||t instanceof Number)&&!isFinite(t))return NaN;if(t)if(this.isHorizontal()){if(void 0!==t.x)return this.getRightValue(t.x)}else if(void 0!==t.y)return this.getRightValue(t.y);return t},getLabelForIndex:ut.noop,getPixelForValue:ut.noop,getValueForPixel:ut.noop,getPixelForTick:function(t){var e=this,i=e.options.offset;if(e.isHorizontal()){var n=(e.width-(e.paddingLeft+e.paddingRight))/Math.max(e._ticks.length-(i?0:1),1),a=n*t+e.paddingLeft;i&&(a+=n/2);var r=e.left+a;return r+=e.isFullWidth()?e.margins.left:0}var o=e.height-(e.paddingTop+e.paddingBottom);return e.top+t*(o/(e._ticks.length-1))},getPixelForDecimal:function(t){var e=this;if(e.isHorizontal()){var i=(e.width-(e.paddingLeft+e.paddingRight))*t+e.paddingLeft,n=e.left+i;return n+=e.isFullWidth()?e.margins.left:0}return e.top+t*e.height},getBasePixel:function(){return this.getPixelForValue(this.getBaseValue())},getBaseValue:function(){var t=this.min,e=this.max;return this.beginAtZero?0:t<0&&e<0?e:t>0&&e>0?t:0},_autoSkip:function(t){var e,i,n=this,a=n.isHorizontal(),r=n.options.ticks.minor,o=t.length,s=!1,l=r.maxTicksLimit,u=n._tickSize()*(o-1),d=a?n.width-(n.paddingLeft+n.paddingRight):n.height-(n.paddingTop+n.PaddingBottom),h=[];for(u>d&&(s=1+Math.floor(u/d)),o>l&&(s=Math.max(s,1+Math.floor(o/l))),e=0;e<o;e++)i=t[e],s>1&&e%s>0&&delete i.label,h.push(i);return h},_tickSize:function(){var t=this,e=t.isHorizontal(),i=t.options.ticks.minor,n=ut.toRadians(t.labelRotation),a=Math.abs(Math.cos(n)),r=Math.abs(Math.sin(n)),o=i.autoSkipPadding||0,s=t.longestLabelWidth+o||0,l=ut.options._parseFont(i),u=t._maxLabelLines*l.lineHeight+o||0;return e?u*a>s*r?s/a:u/r:u*r<s*a?u/a:s/r},_isVisible:function(){var t,e,i,n=this.chart,a=this.options.display;if("auto"!==a)return!!a;for(t=0,e=n.data.datasets.length;t<e;++t)if(n.isDatasetVisible(t)&&((i=n.getDatasetMeta(t)).xAxisID===this.id||i.yAxisID===this.id))return!0;return!1},draw:function(t){var e=this,i=e.options;if(e._isVisible()){var n,a,r,o=e.chart,s=e.ctx,l=ot.global.defaultFontColor,u=i.ticks.minor,d=i.ticks.major||u,h=i.gridLines,c=i.scaleLabel,f=i.position,g=0!==e.labelRotation,m=u.mirror,p=e.isHorizontal(),v=ut.options._parseFont,y=u.display&&u.autoSkip?e._autoSkip(e.getTicks()):e.getTicks(),b=ui(u.fontColor,l),x=v(u),_=x.lineHeight,k=ui(d.fontColor,l),w=v(d),M=u.padding,S=u.labelOffset,D=h.drawTicks?h.tickMarkLength:0,C=ui(c.fontColor,l),P=v(c),T=ut.options.toPadding(c.padding),O=ut.toRadians(e.labelRotation),I=[],A=h.drawBorder?di(h.lineWidth,0,0):0,F=ut._alignPixel;"top"===f?(n=F(o,e.bottom,A),a=e.bottom-D,r=n-A/2):"bottom"===f?(n=F(o,e.top,A),a=n+A/2,r=e.top+D):"left"===f?(n=F(o,e.right,A),a=e.right-D,r=n-A/2):(n=F(o,e.left,A),a=n+A/2,r=e.left+D);if(ut.each(y,function(n,s){if(!ut.isNullOrUndef(n.label)){var l,u,d,c,v,y,b,x,k,w,C,P,T,R,L,W,Y=n.label;s===e.zeroLineIndex&&i.offset===h.offsetGridLines?(l=h.zeroLineWidth,u=h.zeroLineColor,d=h.zeroLineBorderDash||[],c=h.zeroLineBorderDashOffset||0):(l=di(h.lineWidth,s),u=di(h.color,s),d=h.borderDash||[],c=h.borderDashOffset||0);var N=ut.isArray(Y)?Y.length:1,z=function(t,e,i){var n=t.getPixelForTick(e);return i&&(1===t.getTicks().length?n-=t.isHorizontal()?Math.max(n-t.left,t.right-n):Math.max(n-t.top,t.bottom-n):n-=0===e?(t.getPixelForTick(1)-n)/2:(n-t.getPixelForTick(e-1))/2),n}(e,s,h.offsetGridLines);if(p){var V=D+M;z<e.left-1e-7&&(u="rgba(0,0,0,0)"),v=b=k=C=F(o,z,l),y=a,x=r,T=e.getPixelForTick(s)+S,"top"===f?(w=F(o,t.top,A)+A/2,P=t.bottom,L=((g?1:.5)-N)*_,W=g?"left":"center",R=e.bottom-V):(w=t.top,P=F(o,t.bottom,A)-A/2,L=(g?0:.5)*_,W=g?"right":"center",R=e.top+V)}else{var H=(m?0:D)+M;z<e.top-1e-7&&(u="rgba(0,0,0,0)"),v=a,b=r,y=x=w=P=F(o,z,l),R=e.getPixelForTick(s)+S,L=(1-N)*_/2,"left"===f?(k=F(o,t.left,A)+A/2,C=t.right,W=m?"left":"right",T=e.right-H):(k=t.left,C=F(o,t.right,A)-A/2,W=m?"right":"left",T=e.left+H)}I.push({tx1:v,ty1:y,tx2:b,ty2:x,x1:k,y1:w,x2:C,y2:P,labelX:T,labelY:R,glWidth:l,glColor:u,glBorderDash:d,glBorderDashOffset:c,rotation:-1*O,label:Y,major:n.major,textOffset:L,textAlign:W})}}),ut.each(I,function(t){var e=t.glWidth,i=t.glColor;if(h.display&&e&&i&&(s.save(),s.lineWidth=e,s.strokeStyle=i,s.setLineDash&&(s.setLineDash(t.glBorderDash),s.lineDashOffset=t.glBorderDashOffset),s.beginPath(),h.drawTicks&&(s.moveTo(t.tx1,t.ty1),s.lineTo(t.tx2,t.ty2)),h.drawOnChartArea&&(s.moveTo(t.x1,t.y1),s.lineTo(t.x2,t.y2)),s.stroke(),s.restore()),u.display){s.save(),s.translate(t.labelX,t.labelY),s.rotate(t.rotation),s.font=t.major?w.string:x.string,s.fillStyle=t.major?k:b,s.textBaseline="middle",s.textAlign=t.textAlign;var n=t.label,a=t.textOffset;if(ut.isArray(n))for(var r=0;r<n.length;++r)s.fillText(""+n[r],0,a),a+=_;else s.fillText(n,0,a);s.restore()}}),c.display){var R,L,W=0,Y=P.lineHeight/2;if(p)R=e.left+(e.right-e.left)/2,L="bottom"===f?e.bottom-Y-T.bottom:e.top+Y+T.top;else{var N="left"===f;R=N?e.left+Y+T.top:e.right-Y-T.top,L=e.top+(e.bottom-e.top)/2,W=N?-.5*Math.PI:.5*Math.PI}s.save(),s.translate(R,L),s.rotate(W),s.textAlign="center",s.textBaseline="middle",s.fillStyle=C,s.font=P.string,s.fillText(c.labelString,0,0),s.restore()}if(A){var z,V,H,E,B=A,j=di(h.lineWidth,y.length-1,0);p?(z=F(o,e.left,B)-B/2,V=F(o,e.right,j)+j/2,H=E=n):(H=F(o,e.top,B)-B/2,E=F(o,e.bottom,j)+j/2,z=V=n),s.lineWidth=A,s.strokeStyle=di(h.color,0),s.beginPath(),s.moveTo(z,H),s.lineTo(V,E),s.stroke()}}}}),gi=fi.extend({getLabels:function(){var t=this.chart.data;return this.options.labels||(this.isHorizontal()?t.xLabels:t.yLabels)||t.labels},determineDataLimits:function(){var t,e=this,i=e.getLabels();e.minIndex=0,e.maxIndex=i.length-1,void 0!==e.options.ticks.min&&(t=i.indexOf(e.options.ticks.min),e.minIndex=-1!==t?t:e.minIndex),void 0!==e.options.ticks.max&&(t=i.indexOf(e.options.ticks.max),e.maxIndex=-1!==t?t:e.maxIndex),e.min=i[e.minIndex],e.max=i[e.maxIndex]},buildTicks:function(){var t=this,e=t.getLabels();t.ticks=0===t.minIndex&&t.maxIndex===e.length-1?e:e.slice(t.minIndex,t.maxIndex+1)},getLabelForIndex:function(t,e){var i=this,n=i.chart;return n.getDatasetMeta(e).controller._getValueScaleId()===i.id?i.getRightValue(n.data.datasets[e].data[t]):i.ticks[t-i.minIndex]},getPixelForValue:function(t,e){var i,n=this,a=n.options.offset,r=Math.max(n.maxIndex+1-n.minIndex-(a?0:1),1);if(null!=t&&(i=n.isHorizontal()?t.x:t.y),void 0!==i||void 0!==t&&isNaN(e)){t=i||t;var o=n.getLabels().indexOf(t);e=-1!==o?o:e}if(n.isHorizontal()){var s=n.width/r,l=s*(e-n.minIndex);return a&&(l+=s/2),n.left+l}var u=n.height/r,d=u*(e-n.minIndex);return a&&(d+=u/2),n.top+d},getPixelForTick:function(t){return this.getPixelForValue(this.ticks[t],t+this.minIndex,null)},getValueForPixel:function(t){var e=this,i=e.options.offset,n=Math.max(e._ticks.length-(i?0:1),1),a=e.isHorizontal(),r=(a?e.width:e.height)/n;return t-=a?e.left:e.top,i&&(t-=r/2),(t<=0?0:Math.round(t/r))+e.minIndex},getBasePixel:function(){return this.bottom}}),mi={position:"bottom"};gi._defaults=mi;var pi=ut.noop,vi=ut.isNullOrUndef;var yi=fi.extend({getRightValue:function(t){return"string"==typeof t?+t:fi.prototype.getRightValue.call(this,t)},handleTickRangeOptions:function(){var t=this,e=t.options.ticks;if(e.beginAtZero){var i=ut.sign(t.min),n=ut.sign(t.max);i<0&&n<0?t.max=0:i>0&&n>0&&(t.min=0)}var a=void 0!==e.min||void 0!==e.suggestedMin,r=void 0!==e.max||void 0!==e.suggestedMax;void 0!==e.min?t.min=e.min:void 0!==e.suggestedMin&&(null===t.min?t.min=e.suggestedMin:t.min=Math.min(t.min,e.suggestedMin)),void 0!==e.max?t.max=e.max:void 0!==e.suggestedMax&&(null===t.max?t.max=e.suggestedMax:t.max=Math.max(t.max,e.suggestedMax)),a!==r&&t.min>=t.max&&(a?t.max=t.min+1:t.min=t.max-1),t.min===t.max&&(t.max++,e.beginAtZero||t.min--)},getTickLimit:function(){var t,e=this.options.ticks,i=e.stepSize,n=e.maxTicksLimit;return i?t=Math.ceil(this.max/i)-Math.floor(this.min/i)+1:(t=this._computeTickLimit(),n=n||11),n&&(t=Math.min(n,t)),t},_computeTickLimit:function(){return Number.POSITIVE_INFINITY},handleDirectionalChanges:pi,buildTicks:function(){var t=this,e=t.options.ticks,i=t.getTickLimit(),n={maxTicks:i=Math.max(2,i),min:e.min,max:e.max,precision:e.precision,stepSize:ut.valueOrDefault(e.fixedStepSize,e.stepSize)},a=t.ticks=function(t,e){var i,n,a,r,o=[],s=t.stepSize,l=s||1,u=t.maxTicks-1,d=t.min,h=t.max,c=t.precision,f=e.min,g=e.max,m=ut.niceNum((g-f)/u/l)*l;if(m<1e-14&&vi(d)&&vi(h))return[f,g];(r=Math.ceil(g/m)-Math.floor(f/m))>u&&(m=ut.niceNum(r*m/u/l)*l),s||vi(c)?i=Math.pow(10,ut._decimalPlaces(m)):(i=Math.pow(10,c),m=Math.ceil(m*i)/i),n=Math.floor(f/m)*m,a=Math.ceil(g/m)*m,s&&(!vi(d)&&ut.almostWhole(d/m,m/1e3)&&(n=d),!vi(h)&&ut.almostWhole(h/m,m/1e3)&&(a=h)),r=(a-n)/m,r=ut.almostEquals(r,Math.round(r),m/1e3)?Math.round(r):Math.ceil(r),n=Math.round(n*i)/i,a=Math.round(a*i)/i,o.push(vi(d)?n:d);for(var p=1;p<r;++p)o.push(Math.round((n+p*m)*i)/i);return o.push(vi(h)?a:h),o}(n,t);t.handleDirectionalChanges(),t.max=ut.max(a),t.min=ut.min(a),e.reverse?(a.reverse(),t.start=t.max,t.end=t.min):(t.start=t.min,t.end=t.max)},convertTicksToLabels:function(){var t=this;t.ticksAsNumbers=t.ticks.slice(),t.zeroLineIndex=t.ticks.indexOf(0),fi.prototype.convertTicksToLabels.call(t)}}),bi={position:"left",ticks:{callback:li.formatters.linear}},xi=yi.extend({determineDataLimits:function(){var t=this,e=t.options,i=t.chart,n=i.data.datasets,a=t.isHorizontal();function r(e){return a?e.xAxisID===t.id:e.yAxisID===t.id}t.min=null,t.max=null;var o=e.stacked;if(void 0===o&&ut.each(n,function(t,e){if(!o){var n=i.getDatasetMeta(e);i.isDatasetVisible(e)&&r(n)&&void 0!==n.stack&&(o=!0)}}),e.stacked||o){var s={};ut.each(n,function(n,a){var o=i.getDatasetMeta(a),l=[o.type,void 0===e.stacked&&void 0===o.stack?a:"",o.stack].join(".");void 0===s[l]&&(s[l]={positiveValues:[],negativeValues:[]});var u=s[l].positiveValues,d=s[l].negativeValues;i.isDatasetVisible(a)&&r(o)&&ut.each(n.data,function(i,n){var a=+t.getRightValue(i);isNaN(a)||o.data[n].hidden||(u[n]=u[n]||0,d[n]=d[n]||0,e.relativePoints?u[n]=100:a<0?d[n]+=a:u[n]+=a)})}),ut.each(s,function(e){var i=e.positiveValues.concat(e.negativeValues),n=ut.min(i),a=ut.max(i);t.min=null===t.min?n:Math.min(t.min,n),t.max=null===t.max?a:Math.max(t.max,a)})}else ut.each(n,function(e,n){var a=i.getDatasetMeta(n);i.isDatasetVisible(n)&&r(a)&&ut.each(e.data,function(e,i){var n=+t.getRightValue(e);isNaN(n)||a.data[i].hidden||(null===t.min?t.min=n:n<t.min&&(t.min=n),null===t.max?t.max=n:n>t.max&&(t.max=n))})});t.min=isFinite(t.min)&&!isNaN(t.min)?t.min:0,t.max=isFinite(t.max)&&!isNaN(t.max)?t.max:1,this.handleTickRangeOptions()},_computeTickLimit:function(){var t;return this.isHorizontal()?Math.ceil(this.width/40):(t=ut.options._parseFont(this.options.ticks),Math.ceil(this.height/t.lineHeight))},handleDirectionalChanges:function(){this.isHorizontal()||this.ticks.reverse()},getLabelForIndex:function(t,e){return+this.getRightValue(this.chart.data.datasets[e].data[t])},getPixelForValue:function(t){var e=this,i=e.start,n=+e.getRightValue(t),a=e.end-i;return e.isHorizontal()?e.left+e.width/a*(n-i):e.bottom-e.height/a*(n-i)},getValueForPixel:function(t){var e=this,i=e.isHorizontal(),n=i?e.width:e.height,a=(i?t-e.left:e.bottom-t)/n;return e.start+(e.end-e.start)*a},getPixelForTick:function(t){return this.getPixelForValue(this.ticksAsNumbers[t])}}),_i=bi;xi._defaults=_i;var ki=ut.valueOrDefault;var wi={position:"left",ticks:{callback:li.formatters.logarithmic}};function Mi(t,e){return ut.isFinite(t)&&t>=0?t:e}var Si=fi.extend({determineDataLimits:function(){var t=this,e=t.options,i=t.chart,n=i.data.datasets,a=t.isHorizontal();function r(e){return a?e.xAxisID===t.id:e.yAxisID===t.id}t.min=null,t.max=null,t.minNotZero=null;var o=e.stacked;if(void 0===o&&ut.each(n,function(t,e){if(!o){var n=i.getDatasetMeta(e);i.isDatasetVisible(e)&&r(n)&&void 0!==n.stack&&(o=!0)}}),e.stacked||o){var s={};ut.each(n,function(n,a){var o=i.getDatasetMeta(a),l=[o.type,void 0===e.stacked&&void 0===o.stack?a:"",o.stack].join(".");i.isDatasetVisible(a)&&r(o)&&(void 0===s[l]&&(s[l]=[]),ut.each(n.data,function(e,i){var n=s[l],a=+t.getRightValue(e);isNaN(a)||o.data[i].hidden||a<0||(n[i]=n[i]||0,n[i]+=a)}))}),ut.each(s,function(e){if(e.length>0){var i=ut.min(e),n=ut.max(e);t.min=null===t.min?i:Math.min(t.min,i),t.max=null===t.max?n:Math.max(t.max,n)}})}else ut.each(n,function(e,n){var a=i.getDatasetMeta(n);i.isDatasetVisible(n)&&r(a)&&ut.each(e.data,function(e,i){var n=+t.getRightValue(e);isNaN(n)||a.data[i].hidden||n<0||(null===t.min?t.min=n:n<t.min&&(t.min=n),null===t.max?t.max=n:n>t.max&&(t.max=n),0!==n&&(null===t.minNotZero||n<t.minNotZero)&&(t.minNotZero=n))})});this.handleTickRangeOptions()},handleTickRangeOptions:function(){var t=this,e=t.options.ticks;t.min=Mi(e.min,t.min),t.max=Mi(e.max,t.max),t.min===t.max&&(0!==t.min&&null!==t.min?(t.min=Math.pow(10,Math.floor(ut.log10(t.min))-1),t.max=Math.pow(10,Math.floor(ut.log10(t.max))+1)):(t.min=1,t.max=10)),null===t.min&&(t.min=Math.pow(10,Math.floor(ut.log10(t.max))-1)),null===t.max&&(t.max=0!==t.min?Math.pow(10,Math.floor(ut.log10(t.min))+1):10),null===t.minNotZero&&(t.min>0?t.minNotZero=t.min:t.max<1?t.minNotZero=Math.pow(10,Math.floor(ut.log10(t.max))):t.minNotZero=1)},buildTicks:function(){var t=this,e=t.options.ticks,i=!t.isHorizontal(),n={min:Mi(e.min),max:Mi(e.max)},a=t.ticks=function(t,e){var i,n,a=[],r=ki(t.min,Math.pow(10,Math.floor(ut.log10(e.min)))),o=Math.floor(ut.log10(e.max)),s=Math.ceil(e.max/Math.pow(10,o));0===r?(i=Math.floor(ut.log10(e.minNotZero)),n=Math.floor(e.minNotZero/Math.pow(10,i)),a.push(r),r=n*Math.pow(10,i)):(i=Math.floor(ut.log10(r)),n=Math.floor(r/Math.pow(10,i)));var l=i<0?Math.pow(10,Math.abs(i)):1;do{a.push(r),10==++n&&(n=1,l=++i>=0?1:l),r=Math.round(n*Math.pow(10,i)*l)/l}while(i<o||i===o&&n<s);var u=ki(t.max,r);return a.push(u),a}(n,t);t.max=ut.max(a),t.min=ut.min(a),e.reverse?(i=!i,t.start=t.max,t.end=t.min):(t.start=t.min,t.end=t.max),i&&a.reverse()},convertTicksToLabels:function(){this.tickValues=this.ticks.slice(),fi.prototype.convertTicksToLabels.call(this)},getLabelForIndex:function(t,e){return+this.getRightValue(this.chart.data.datasets[e].data[t])},getPixelForTick:function(t){return this.getPixelForValue(this.tickValues[t])},_getFirstTickValue:function(t){var e=Math.floor(ut.log10(t));return Math.floor(t/Math.pow(10,e))*Math.pow(10,e)},getPixelForValue:function(t){var e,i,n,a,r,o=this,s=o.options.ticks,l=s.reverse,u=ut.log10,d=o._getFirstTickValue(o.minNotZero),h=0;return t=+o.getRightValue(t),l?(n=o.end,a=o.start,r=-1):(n=o.start,a=o.end,r=1),o.isHorizontal()?(e=o.width,i=l?o.right:o.left):(e=o.height,r*=-1,i=l?o.top:o.bottom),t!==n&&(0===n&&(e-=h=ki(s.fontSize,ot.global.defaultFontSize),n=d),0!==t&&(h+=e/(u(a)-u(n))*(u(t)-u(n))),i+=r*h),i},getValueForPixel:function(t){var e,i,n,a,r=this,o=r.options.ticks,s=o.reverse,l=ut.log10,u=r._getFirstTickValue(r.minNotZero);if(s?(i=r.end,n=r.start):(i=r.start,n=r.end),r.isHorizontal()?(e=r.width,a=s?r.right-t:t-r.left):(e=r.height,a=s?t-r.top:r.bottom-t),a!==i){if(0===i){var d=ki(o.fontSize,ot.global.defaultFontSize);a-=d,e-=d,i=u}a*=l(n)-l(i),a/=e,a=Math.pow(10,l(i)+a)}return a}}),Di=wi;Si._defaults=Di;var Ci=ut.valueOrDefault,Pi=ut.valueAtIndexOrDefault,Ti=ut.options.resolve,Oi={display:!0,animate:!0,position:"chartArea",angleLines:{display:!0,color:"rgba(0, 0, 0, 0.1)",lineWidth:1,borderDash:[],borderDashOffset:0},gridLines:{circular:!1},ticks:{showLabelBackdrop:!0,backdropColor:"rgba(255,255,255,0.75)",backdropPaddingY:2,backdropPaddingX:2,callback:li.formatters.linear},pointLabels:{display:!0,fontSize:10,callback:function(t){return t}}};function Ii(t){var e=t.options;return e.angleLines.display||e.pointLabels.display?t.chart.data.labels.length:0}function Ai(t){var e=t.ticks;return e.display&&t.display?Ci(e.fontSize,ot.global.defaultFontSize)+2*e.backdropPaddingY:0}function Fi(t,e,i,n,a){return t===n||t===a?{start:e-i/2,end:e+i/2}:t<n||t>a?{start:e-i,end:e}:{start:e,end:e+i}}function Ri(t){return 0===t||180===t?"center":t<180?"left":"right"}function Li(t,e,i,n){var a,r,o=i.y+n/2;if(ut.isArray(e))for(a=0,r=e.length;a<r;++a)t.fillText(e[a],i.x,o),o+=n;else t.fillText(e,i.x,o)}function Wi(t,e,i){90===t||270===t?i.y-=e.h/2:(t>270||t<90)&&(i.y-=e.h)}function Yi(t){return ut.isNumber(t)?t:0}var Ni=yi.extend({setDimensions:function(){var t=this;t.width=t.maxWidth,t.height=t.maxHeight,t.paddingTop=Ai(t.options)/2,t.xCenter=Math.floor(t.width/2),t.yCenter=Math.floor((t.height-t.paddingTop)/2),t.drawingArea=Math.min(t.height-t.paddingTop,t.width)/2},determineDataLimits:function(){var t=this,e=t.chart,i=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY;ut.each(e.data.datasets,function(a,r){if(e.isDatasetVisible(r)){var o=e.getDatasetMeta(r);ut.each(a.data,function(e,a){var r=+t.getRightValue(e);isNaN(r)||o.data[a].hidden||(i=Math.min(r,i),n=Math.max(r,n))})}}),t.min=i===Number.POSITIVE_INFINITY?0:i,t.max=n===Number.NEGATIVE_INFINITY?0:n,t.handleTickRangeOptions()},_computeTickLimit:function(){return Math.ceil(this.drawingArea/Ai(this.options))},convertTicksToLabels:function(){var t=this;yi.prototype.convertTicksToLabels.call(t),t.pointLabels=t.chart.data.labels.map(t.options.pointLabels.callback,t)},getLabelForIndex:function(t,e){return+this.getRightValue(this.chart.data.datasets[e].data[t])},fit:function(){var t=this.options;t.display&&t.pointLabels.display?function(t){var e,i,n,a=ut.options._parseFont(t.options.pointLabels),r={l:0,r:t.width,t:0,b:t.height-t.paddingTop},o={};t.ctx.font=a.string,t._pointLabelSizes=[];var s,l,u,d=Ii(t);for(e=0;e<d;e++){n=t.getPointPosition(e,t.drawingArea+5),s=t.ctx,l=a.lineHeight,u=t.pointLabels[e]||"",i=ut.isArray(u)?{w:ut.longestText(s,s.font,u),h:u.length*l}:{w:s.measureText(u).width,h:l},t._pointLabelSizes[e]=i;var h=t.getIndexAngle(e),c=ut.toDegrees(h)%360,f=Fi(c,n.x,i.w,0,180),g=Fi(c,n.y,i.h,90,270);f.start<r.l&&(r.l=f.start,o.l=h),f.end>r.r&&(r.r=f.end,o.r=h),g.start<r.t&&(r.t=g.start,o.t=h),g.end>r.b&&(r.b=g.end,o.b=h)}t.setReductions(t.drawingArea,r,o)}(this):this.setCenterPoint(0,0,0,0)},setReductions:function(t,e,i){var n=this,a=e.l/Math.sin(i.l),r=Math.max(e.r-n.width,0)/Math.sin(i.r),o=-e.t/Math.cos(i.t),s=-Math.max(e.b-(n.height-n.paddingTop),0)/Math.cos(i.b);a=Yi(a),r=Yi(r),o=Yi(o),s=Yi(s),n.drawingArea=Math.min(Math.floor(t-(a+r)/2),Math.floor(t-(o+s)/2)),n.setCenterPoint(a,r,o,s)},setCenterPoint:function(t,e,i,n){var a=this,r=a.width-e-a.drawingArea,o=t+a.drawingArea,s=i+a.drawingArea,l=a.height-a.paddingTop-n-a.drawingArea;a.xCenter=Math.floor((o+r)/2+a.left),a.yCenter=Math.floor((s+l)/2+a.top+a.paddingTop)},getIndexAngle:function(t){return t*(2*Math.PI/Ii(this))+(this.chart.options&&this.chart.options.startAngle?this.chart.options.startAngle:0)*Math.PI*2/360},getDistanceFromCenterForValue:function(t){var e=this;if(null===t)return 0;var i=e.drawingArea/(e.max-e.min);return e.options.ticks.reverse?(e.max-t)*i:(t-e.min)*i},getPointPosition:function(t,e){var i=this.getIndexAngle(t)-Math.PI/2;return{x:Math.cos(i)*e+this.xCenter,y:Math.sin(i)*e+this.yCenter}},getPointPositionForValue:function(t,e){return this.getPointPosition(t,this.getDistanceFromCenterForValue(e))},getBasePosition:function(){var t=this.min,e=this.max;return this.getPointPositionForValue(0,this.beginAtZero?0:t<0&&e<0?e:t>0&&e>0?t:0)},draw:function(){var t=this,e=t.options,i=e.gridLines,n=e.ticks;if(e.display){var a=t.ctx,r=this.getIndexAngle(0),o=ut.options._parseFont(n);(e.angleLines.display||e.pointLabels.display)&&function(t){var e=t.ctx,i=t.options,n=i.angleLines,a=i.gridLines,r=i.pointLabels,o=Ci(n.lineWidth,a.lineWidth),s=Ci(n.color,a.color),l=Ai(i);e.save(),e.lineWidth=o,e.strokeStyle=s,e.setLineDash&&(e.setLineDash(Ti([n.borderDash,a.borderDash,[]])),e.lineDashOffset=Ti([n.borderDashOffset,a.borderDashOffset,0]));var u=t.getDistanceFromCenterForValue(i.ticks.reverse?t.min:t.max),d=ut.options._parseFont(r);e.font=d.string,e.textBaseline="middle";for(var h=Ii(t)-1;h>=0;h--){if(n.display&&o&&s){var c=t.getPointPosition(h,u);e.beginPath(),e.moveTo(t.xCenter,t.yCenter),e.lineTo(c.x,c.y),e.stroke()}if(r.display){var f=0===h?l/2:0,g=t.getPointPosition(h,u+f+5),m=Pi(r.fontColor,h,ot.global.defaultFontColor);e.fillStyle=m;var p=t.getIndexAngle(h),v=ut.toDegrees(p);e.textAlign=Ri(v),Wi(v,t._pointLabelSizes[h],g),Li(e,t.pointLabels[h]||"",g,d.lineHeight)}}e.restore()}(t),ut.each(t.ticks,function(e,s){if(s>0||n.reverse){var l=t.getDistanceFromCenterForValue(t.ticksAsNumbers[s]);if(i.display&&0!==s&&function(t,e,i,n){var a,r=t.ctx,o=e.circular,s=Ii(t),l=Pi(e.color,n-1),u=Pi(e.lineWidth,n-1);if((o||s)&&l&&u){if(r.save(),r.strokeStyle=l,r.lineWidth=u,r.setLineDash&&(r.setLineDash(e.borderDash||[]),r.lineDashOffset=e.borderDashOffset||0),r.beginPath(),o)r.arc(t.xCenter,t.yCenter,i,0,2*Math.PI);else{a=t.getPointPosition(0,i),r.moveTo(a.x,a.y);for(var d=1;d<s;d++)a=t.getPointPosition(d,i),r.lineTo(a.x,a.y)}r.closePath(),r.stroke(),r.restore()}}(t,i,l,s),n.display){var u=Ci(n.fontColor,ot.global.defaultFontColor);if(a.font=o.string,a.save(),a.translate(t.xCenter,t.yCenter),a.rotate(r),n.showLabelBackdrop){var d=a.measureText(e).width;a.fillStyle=n.backdropColor,a.fillRect(-d/2-n.backdropPaddingX,-l-o.size/2-n.backdropPaddingY,d+2*n.backdropPaddingX,o.size+2*n.backdropPaddingY)}a.textAlign="center",a.textBaseline="middle",a.fillStyle=u,a.fillText(e,0,-l),a.restore()}}})}}}),zi=Oi;Ni._defaults=zi;var Vi=ut.valueOrDefault,Hi=Number.MIN_SAFE_INTEGER||-9007199254740991,Ei=Number.MAX_SAFE_INTEGER||9007199254740991,Bi={millisecond:{common:!0,size:1,steps:[1,2,5,10,20,50,100,250,500]},second:{common:!0,size:1e3,steps:[1,2,5,10,15,30]},minute:{common:!0,size:6e4,steps:[1,2,5,10,15,30]},hour:{common:!0,size:36e5,steps:[1,2,3,6,12]},day:{common:!0,size:864e5,steps:[1,2,5]},week:{common:!1,size:6048e5,steps:[1,2,3,4]},month:{common:!0,size:2628e6,steps:[1,2,3]},quarter:{common:!1,size:7884e6,steps:[1,2,3,4]},year:{common:!0,size:3154e7}},ji=Object.keys(Bi);function Ui(t,e){return t-e}function Gi(t){var e,i,n,a={},r=[];for(e=0,i=t.length;e<i;++e)a[n=t[e]]||(a[n]=!0,r.push(n));return r}function qi(t,e,i,n){var a=function(t,e,i){for(var n,a,r,o=0,s=t.length-1;o>=0&&o<=s;){if(a=t[(n=o+s>>1)-1]||null,r=t[n],!a)return{lo:null,hi:r};if(r[e]<i)o=n+1;else{if(!(a[e]>i))return{lo:a,hi:r};s=n-1}}return{lo:r,hi:null}}(t,e,i),r=a.lo?a.hi?a.lo:t[t.length-2]:t[0],o=a.lo?a.hi?a.hi:t[t.length-1]:t[1],s=o[e]-r[e],l=s?(i-r[e])/s:0,u=(o[n]-r[n])*l;return r[n]+u}function Zi(t,e){var i=t._adapter,n=t.options.time,a=n.parser,r=a||n.format,o=e;return"function"==typeof a&&(o=a(o)),ut.isFinite(o)||(o="string"==typeof r?i.parse(o,r):i.parse(o)),null!==o?+o:(a||"function"!=typeof r||(o=r(e),ut.isFinite(o)||(o=i.parse(o))),o)}function $i(t,e){if(ut.isNullOrUndef(e))return null;var i=t.options.time,n=Zi(t,t.getRightValue(e));return null===n?n:(i.round&&(n=+t._adapter.startOf(n,i.round)),n)}function Xi(t){for(var e=ji.indexOf(t)+1,i=ji.length;e<i;++e)if(Bi[ji[e]].common)return ji[e]}function Ki(t,e,i,n){var a,r=t._adapter,o=t.options,s=o.time,l=s.unit||function(t,e,i,n){var a,r,o,s=ji.length;for(a=ji.indexOf(t);a<s-1;++a)if(o=(r=Bi[ji[a]]).steps?r.steps[r.steps.length-1]:Ei,r.common&&Math.ceil((i-e)/(o*r.size))<=n)return ji[a];return ji[s-1]}(s.minUnit,e,i,n),u=Xi(l),d=Vi(s.stepSize,s.unitStepSize),h="week"===l&&s.isoWeekday,c=o.ticks.major.enabled,f=Bi[l],g=e,m=i,p=[];for(d||(d=function(t,e,i,n){var a,r,o,s=e-t,l=Bi[i],u=l.size,d=l.steps;if(!d)return Math.ceil(s/(n*u));for(a=0,r=d.length;a<r&&(o=d[a],!(Math.ceil(s/(u*o))<=n));++a);return o}(e,i,l,n)),h&&(g=+r.startOf(g,"isoWeek",h),m=+r.startOf(m,"isoWeek",h)),g=+r.startOf(g,h?"day":l),(m=+r.startOf(m,h?"day":l))<i&&(m=+r.add(m,1,l)),a=g,c&&u&&!h&&!s.round&&(a=+r.startOf(a,u),a=+r.add(a,~~((g-a)/(f.size*d))*d,l));a<m;a=+r.add(a,d,l))p.push(+a);return p.push(+a),p}var Ji=fi.extend({initialize:function(){this.mergeTicksOptions(),fi.prototype.initialize.call(this)},update:function(){var t=this.options,e=t.time||(t.time={}),i=this._adapter=new si._date(t.adapters.date);return e.format&&console.warn("options.time.format is deprecated and replaced by options.time.parser."),ut.mergeIf(e.displayFormats,i.formats()),fi.prototype.update.apply(this,arguments)},getRightValue:function(t){return t&&void 0!==t.t&&(t=t.t),fi.prototype.getRightValue.call(this,t)},determineDataLimits:function(){var t,e,i,n,a,r,o=this,s=o.chart,l=o._adapter,u=o.options.time,d=u.unit||"day",h=Ei,c=Hi,f=[],g=[],m=[],p=s.data.labels||[];for(t=0,i=p.length;t<i;++t)m.push($i(o,p[t]));for(t=0,i=(s.data.datasets||[]).length;t<i;++t)if(s.isDatasetVisible(t))if(a=s.data.datasets[t].data,ut.isObject(a[0]))for(g[t]=[],e=0,n=a.length;e<n;++e)r=$i(o,a[e]),f.push(r),g[t][e]=r;else{for(e=0,n=m.length;e<n;++e)f.push(m[e]);g[t]=m.slice(0)}else g[t]=[];m.length&&(m=Gi(m).sort(Ui),h=Math.min(h,m[0]),c=Math.max(c,m[m.length-1])),f.length&&(f=Gi(f).sort(Ui),h=Math.min(h,f[0]),c=Math.max(c,f[f.length-1])),h=$i(o,u.min)||h,c=$i(o,u.max)||c,h=h===Ei?+l.startOf(Date.now(),d):h,c=c===Hi?+l.endOf(Date.now(),d)+1:c,o.min=Math.min(h,c),o.max=Math.max(h+1,c),o._horizontal=o.isHorizontal(),o._table=[],o._timestamps={data:f,datasets:g,labels:m}},buildTicks:function(){var t,e,i,n=this,a=n.min,r=n.max,o=n.options,s=o.time,l=[],u=[];switch(o.ticks.source){case"data":l=n._timestamps.data;break;case"labels":l=n._timestamps.labels;break;case"auto":default:l=Ki(n,a,r,n.getLabelCapacity(a))}for("ticks"===o.bounds&&l.length&&(a=l[0],r=l[l.length-1]),a=$i(n,s.min)||a,r=$i(n,s.max)||r,t=0,e=l.length;t<e;++t)(i=l[t])>=a&&i<=r&&u.push(i);return n.min=a,n.max=r,n._unit=s.unit||function(t,e,i,n,a){var r,o;for(r=ji.length-1;r>=ji.indexOf(i);r--)if(o=ji[r],Bi[o].common&&t._adapter.diff(a,n,o)>=e.length)return o;return ji[i?ji.indexOf(i):0]}(n,u,s.minUnit,n.min,n.max),n._majorUnit=Xi(n._unit),n._table=function(t,e,i,n){if("linear"===n||!t.length)return[{time:e,pos:0},{time:i,pos:1}];var a,r,o,s,l,u=[],d=[e];for(a=0,r=t.length;a<r;++a)(s=t[a])>e&&s<i&&d.push(s);for(d.push(i),a=0,r=d.length;a<r;++a)l=d[a+1],o=d[a-1],s=d[a],void 0!==o&&void 0!==l&&Math.round((l+o)/2)===s||u.push({time:s,pos:a/(r-1)});return u}(n._timestamps.data,a,r,o.distribution),n._offsets=function(t,e,i,n,a){var r,o,s=0,l=0;return a.offset&&e.length&&(a.time.min||(r=qi(t,"time",e[0],"pos"),s=1===e.length?1-r:(qi(t,"time",e[1],"pos")-r)/2),a.time.max||(o=qi(t,"time",e[e.length-1],"pos"),l=1===e.length?o:(o-qi(t,"time",e[e.length-2],"pos"))/2)),{start:s,end:l}}(n._table,u,0,0,o),o.ticks.reverse&&u.reverse(),function(t,e,i){var n,a,r,o,s=[];for(n=0,a=e.length;n<a;++n)r=e[n],o=!!i&&r===+t._adapter.startOf(r,i),s.push({value:r,major:o});return s}(n,u,n._majorUnit)},getLabelForIndex:function(t,e){var i=this,n=i._adapter,a=i.chart.data,r=i.options.time,o=a.labels&&t<a.labels.length?a.labels[t]:"",s=a.datasets[e].data[t];return ut.isObject(s)&&(o=i.getRightValue(s)),r.tooltipFormat?n.format(Zi(i,o),r.tooltipFormat):"string"==typeof o?o:n.format(Zi(i,o),r.displayFormats.datetime)},tickFormatFunction:function(t,e,i,n){var a=this._adapter,r=this.options,o=r.time.displayFormats,s=o[this._unit],l=this._majorUnit,u=o[l],d=+a.startOf(t,l),h=r.ticks.major,c=h.enabled&&l&&u&&t===d,f=a.format(t,n||(c?u:s)),g=c?h:r.ticks.minor,m=Vi(g.callback,g.userCallback);return m?m(f,e,i):f},convertTicksToLabels:function(t){var e,i,n=[];for(e=0,i=t.length;e<i;++e)n.push(this.tickFormatFunction(t[e].value,e,t));return n},getPixelForOffset:function(t){var e=this,i=e.options.ticks.reverse,n=e._horizontal?e.width:e.height,a=e._horizontal?i?e.right:e.left:i?e.bottom:e.top,r=qi(e._table,"time",t,"pos"),o=n*(e._offsets.start+r)/(e._offsets.start+1+e._offsets.end);return i?a-o:a+o},getPixelForValue:function(t,e,i){var n=null;if(void 0!==e&&void 0!==i&&(n=this._timestamps.datasets[i][e]),null===n&&(n=$i(this,t)),null!==n)return this.getPixelForOffset(n)},getPixelForTick:function(t){var e=this.getTicks();return t>=0&&t<e.length?this.getPixelForOffset(e[t].value):null},getValueForPixel:function(t){var e=this,i=e._horizontal?e.width:e.height,n=e._horizontal?e.left:e.top,a=(i?(t-n)/i:0)*(e._offsets.start+1+e._offsets.start)-e._offsets.end,r=qi(e._table,"pos",a,"time");return e._adapter._create(r)},getLabelWidth:function(t){var e=this.options.ticks,i=this.ctx.measureText(t).width,n=ut.toRadians(e.maxRotation),a=Math.cos(n),r=Math.sin(n);return i*a+Vi(e.fontSize,ot.global.defaultFontSize)*r},getLabelCapacity:function(t){var e=this,i=e.options.time.displayFormats.millisecond,n=e.tickFormatFunction(t,0,[],i),a=e.getLabelWidth(n),r=e.isHorizontal()?e.width:e.height,o=Math.floor(r/a);return o>0?o:1}}),Qi={position:"bottom",distribution:"linear",bounds:"data",adapters:{},time:{parser:!1,format:!1,unit:!1,round:!1,displayFormat:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{}},ticks:{autoSkip:!1,source:"auto",major:{enabled:!1}}};Ji._defaults=Qi;var tn,en={category:gi,linear:xi,logarithmic:Si,radialLinear:Ni,time:Ji},nn=(function(t,e){t.exports=function(){var e,i;function n(){return e.apply(null,arguments)}function a(t){return t instanceof Array||"[object Array]"===Object.prototype.toString.call(t)}function r(t){return null!=t&&"[object Object]"===Object.prototype.toString.call(t)}function o(t){return void 0===t}function s(t){return"number"==typeof t||"[object Number]"===Object.prototype.toString.call(t)}function l(t){return t instanceof Date||"[object Date]"===Object.prototype.toString.call(t)}function u(t,e){var i,n=[];for(i=0;i<t.length;++i)n.push(e(t[i],i));return n}function d(t,e){return Object.prototype.hasOwnProperty.call(t,e)}function h(t,e){for(var i in e)d(e,i)&&(t[i]=e[i]);return d(e,"toString")&&(t.toString=e.toString),d(e,"valueOf")&&(t.valueOf=e.valueOf),t}function c(t,e,i,n){return Oe(t,e,i,n,!0).utc()}function f(t){return null==t._pf&&(t._pf={empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1,parsedDateParts:[],meridiem:null,rfc2822:!1,weekdayMismatch:!1}),t._pf}function g(t){if(null==t._isValid){var e=f(t),n=i.call(e.parsedDateParts,function(t){return null!=t}),a=!isNaN(t._d.getTime())&&e.overflow<0&&!e.empty&&!e.invalidMonth&&!e.invalidWeekday&&!e.weekdayMismatch&&!e.nullInput&&!e.invalidFormat&&!e.userInvalidated&&(!e.meridiem||e.meridiem&&n);if(t._strict&&(a=a&&0===e.charsLeftOver&&0===e.unusedTokens.length&&void 0===e.bigHour),null!=Object.isFrozen&&Object.isFrozen(t))return a;t._isValid=a}return t._isValid}function m(t){var e=c(NaN);return null!=t?h(f(e),t):f(e).userInvalidated=!0,e}i=Array.prototype.some?Array.prototype.some:function(t){for(var e=Object(this),i=e.length>>>0,n=0;n<i;n++)if(n in e&&t.call(this,e[n],n,e))return!0;return!1};var p=n.momentProperties=[];function v(t,e){var i,n,a;if(o(e._isAMomentObject)||(t._isAMomentObject=e._isAMomentObject),o(e._i)||(t._i=e._i),o(e._f)||(t._f=e._f),o(e._l)||(t._l=e._l),o(e._strict)||(t._strict=e._strict),o(e._tzm)||(t._tzm=e._tzm),o(e._isUTC)||(t._isUTC=e._isUTC),o(e._offset)||(t._offset=e._offset),o(e._pf)||(t._pf=f(e)),o(e._locale)||(t._locale=e._locale),p.length>0)for(i=0;i<p.length;i++)n=p[i],o(a=e[n])||(t[n]=a);return t}var y=!1;function b(t){v(this,t),this._d=new Date(null!=t._d?t._d.getTime():NaN),this.isValid()||(this._d=new Date(NaN)),!1===y&&(y=!0,n.updateOffset(this),y=!1)}function x(t){return t instanceof b||null!=t&&null!=t._isAMomentObject}function _(t){return t<0?Math.ceil(t)||0:Math.floor(t)}function k(t){var e=+t,i=0;return 0!==e&&isFinite(e)&&(i=_(e)),i}function w(t,e,i){var n,a=Math.min(t.length,e.length),r=Math.abs(t.length-e.length),o=0;for(n=0;n<a;n++)(i&&t[n]!==e[n]||!i&&k(t[n])!==k(e[n]))&&o++;return o+r}function M(t){!1===n.suppressDeprecationWarnings&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+t)}function S(t,e){var i=!0;return h(function(){if(null!=n.deprecationHandler&&n.deprecationHandler(null,t),i){for(var a,r=[],o=0;o<arguments.length;o++){if(a="","object"==typeof arguments[o]){for(var s in a+="\n["+o+"] ",arguments[0])a+=s+": "+arguments[0][s]+", ";a=a.slice(0,-2)}else a=arguments[o];r.push(a)}M(t+"\nArguments: "+Array.prototype.slice.call(r).join("")+"\n"+(new Error).stack),i=!1}return e.apply(this,arguments)},e)}var D,C={};function P(t,e){null!=n.deprecationHandler&&n.deprecationHandler(t,e),C[t]||(M(e),C[t]=!0)}function T(t){return t instanceof Function||"[object Function]"===Object.prototype.toString.call(t)}function O(t,e){var i,n=h({},t);for(i in e)d(e,i)&&(r(t[i])&&r(e[i])?(n[i]={},h(n[i],t[i]),h(n[i],e[i])):null!=e[i]?n[i]=e[i]:delete n[i]);for(i in t)d(t,i)&&!d(e,i)&&r(t[i])&&(n[i]=h({},n[i]));return n}function I(t){null!=t&&this.set(t)}n.suppressDeprecationWarnings=!1,n.deprecationHandler=null,D=Object.keys?Object.keys:function(t){var e,i=[];for(e in t)d(t,e)&&i.push(e);return i};var A={};function F(t,e){var i=t.toLowerCase();A[i]=A[i+"s"]=A[e]=t}function R(t){return"string"==typeof t?A[t]||A[t.toLowerCase()]:void 0}function L(t){var e,i,n={};for(i in t)d(t,i)&&(e=R(i))&&(n[e]=t[i]);return n}var W={};function Y(t,e){W[t]=e}function N(t,e,i){var n=""+Math.abs(t),a=e-n.length,r=t>=0;return(r?i?"+":"":"-")+Math.pow(10,Math.max(0,a)).toString().substr(1)+n}var z=/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,V=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,H={},E={};function B(t,e,i,n){var a=n;"string"==typeof n&&(a=function(){return this[n]()}),t&&(E[t]=a),e&&(E[e[0]]=function(){return N(a.apply(this,arguments),e[1],e[2])}),i&&(E[i]=function(){return this.localeData().ordinal(a.apply(this,arguments),t)})}function j(t,e){return t.isValid()?(e=U(e,t.localeData()),H[e]=H[e]||function(t){var e,i,n,a=t.match(z);for(e=0,i=a.length;e<i;e++)E[a[e]]?a[e]=E[a[e]]:a[e]=(n=a[e]).match(/\[[\s\S]/)?n.replace(/^\[|\]$/g,""):n.replace(/\\/g,"");return function(e){var n,r="";for(n=0;n<i;n++)r+=T(a[n])?a[n].call(e,t):a[n];return r}}(e),H[e](t)):t.localeData().invalidDate()}function U(t,e){var i=5;function n(t){return e.longDateFormat(t)||t}for(V.lastIndex=0;i>=0&&V.test(t);)t=t.replace(V,n),V.lastIndex=0,i-=1;return t}var G=/\d/,q=/\d\d/,Z=/\d{3}/,$=/\d{4}/,X=/[+-]?\d{6}/,K=/\d\d?/,J=/\d\d\d\d?/,Q=/\d\d\d\d\d\d?/,tt=/\d{1,3}/,et=/\d{1,4}/,it=/[+-]?\d{1,6}/,nt=/\d+/,at=/[+-]?\d+/,rt=/Z|[+-]\d\d:?\d\d/gi,ot=/Z|[+-]\d\d(?::?\d\d)?/gi,st=/[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,lt={};function ut(t,e,i){lt[t]=T(e)?e:function(t,n){return t&&i?i:e}}function dt(t,e){return d(lt,t)?lt[t](e._strict,e._locale):new RegExp(ht(t.replace("\\","").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(t,e,i,n,a){return e||i||n||a})))}function ht(t){return t.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}var ct={};function ft(t,e){var i,n=e;for("string"==typeof t&&(t=[t]),s(e)&&(n=function(t,i){i[e]=k(t)}),i=0;i<t.length;i++)ct[t[i]]=n}function gt(t,e){ft(t,function(t,i,n,a){n._w=n._w||{},e(t,n._w,n,a)})}function mt(t,e,i){null!=e&&d(ct,t)&&ct[t](e,i._a,i,t)}var pt=0,vt=1,yt=2,bt=3,xt=4,_t=5,kt=6,wt=7,Mt=8;function St(t){return Dt(t)?366:365}function Dt(t){return t%4==0&&t%100!=0||t%400==0}B("Y",0,0,function(){var t=this.year();return t<=9999?""+t:"+"+t}),B(0,["YY",2],0,function(){return this.year()%100}),B(0,["YYYY",4],0,"year"),B(0,["YYYYY",5],0,"year"),B(0,["YYYYYY",6,!0],0,"year"),F("year","y"),Y("year",1),ut("Y",at),ut("YY",K,q),ut("YYYY",et,$),ut("YYYYY",it,X),ut("YYYYYY",it,X),ft(["YYYYY","YYYYYY"],pt),ft("YYYY",function(t,e){e[pt]=2===t.length?n.parseTwoDigitYear(t):k(t)}),ft("YY",function(t,e){e[pt]=n.parseTwoDigitYear(t)}),ft("Y",function(t,e){e[pt]=parseInt(t,10)}),n.parseTwoDigitYear=function(t){return k(t)+(k(t)>68?1900:2e3)};var Ct,Pt=Tt("FullYear",!0);function Tt(t,e){return function(i){return null!=i?(It(this,t,i),n.updateOffset(this,e),this):Ot(this,t)}}function Ot(t,e){return t.isValid()?t._d["get"+(t._isUTC?"UTC":"")+e]():NaN}function It(t,e,i){t.isValid()&&!isNaN(i)&&("FullYear"===e&&Dt(t.year())&&1===t.month()&&29===t.date()?t._d["set"+(t._isUTC?"UTC":"")+e](i,t.month(),At(i,t.month())):t._d["set"+(t._isUTC?"UTC":"")+e](i))}function At(t,e){if(isNaN(t)||isNaN(e))return NaN;var i,n=(e%(i=12)+i)%i;return t+=(e-n)/12,1===n?Dt(t)?29:28:31-n%7%2}Ct=Array.prototype.indexOf?Array.prototype.indexOf:function(t){var e;for(e=0;e<this.length;++e)if(this[e]===t)return e;return-1},B("M",["MM",2],"Mo",function(){return this.month()+1}),B("MMM",0,0,function(t){return this.localeData().monthsShort(this,t)}),B("MMMM",0,0,function(t){return this.localeData().months(this,t)}),F("month","M"),Y("month",8),ut("M",K),ut("MM",K,q),ut("MMM",function(t,e){return e.monthsShortRegex(t)}),ut("MMMM",function(t,e){return e.monthsRegex(t)}),ft(["M","MM"],function(t,e){e[vt]=k(t)-1}),ft(["MMM","MMMM"],function(t,e,i,n){var a=i._locale.monthsParse(t,n,i._strict);null!=a?e[vt]=a:f(i).invalidMonth=t});var Ft=/D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,Rt="January_February_March_April_May_June_July_August_September_October_November_December".split("_"),Lt="Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");function Wt(t,e){var i;if(!t.isValid())return t;if("string"==typeof e)if(/^\d+$/.test(e))e=k(e);else if(!s(e=t.localeData().monthsParse(e)))return t;return i=Math.min(t.date(),At(t.year(),e)),t._d["set"+(t._isUTC?"UTC":"")+"Month"](e,i),t}function Yt(t){return null!=t?(Wt(this,t),n.updateOffset(this,!0),this):Ot(this,"Month")}var Nt=st,zt=st;function Vt(){function t(t,e){return e.length-t.length}var e,i,n=[],a=[],r=[];for(e=0;e<12;e++)i=c([2e3,e]),n.push(this.monthsShort(i,"")),a.push(this.months(i,"")),r.push(this.months(i,"")),r.push(this.monthsShort(i,""));for(n.sort(t),a.sort(t),r.sort(t),e=0;e<12;e++)n[e]=ht(n[e]),a[e]=ht(a[e]);for(e=0;e<24;e++)r[e]=ht(r[e]);this._monthsRegex=new RegExp("^("+r.join("|")+")","i"),this._monthsShortRegex=this._monthsRegex,this._monthsStrictRegex=new RegExp("^("+a.join("|")+")","i"),this._monthsShortStrictRegex=new RegExp("^("+n.join("|")+")","i")}function Ht(t){var e;if(t<100&&t>=0){var i=Array.prototype.slice.call(arguments);i[0]=t+400,e=new Date(Date.UTC.apply(null,i)),isFinite(e.getUTCFullYear())&&e.setUTCFullYear(t)}else e=new Date(Date.UTC.apply(null,arguments));return e}function Et(t,e,i){var n=7+e-i,a=(7+Ht(t,0,n).getUTCDay()-e)%7;return-a+n-1}function Bt(t,e,i,n,a){var r,o,s=(7+i-n)%7,l=Et(t,n,a),u=1+7*(e-1)+s+l;return u<=0?o=St(r=t-1)+u:u>St(t)?(r=t+1,o=u-St(t)):(r=t,o=u),{year:r,dayOfYear:o}}function jt(t,e,i){var n,a,r=Et(t.year(),e,i),o=Math.floor((t.dayOfYear()-r-1)/7)+1;return o<1?(a=t.year()-1,n=o+Ut(a,e,i)):o>Ut(t.year(),e,i)?(n=o-Ut(t.year(),e,i),a=t.year()+1):(a=t.year(),n=o),{week:n,year:a}}function Ut(t,e,i){var n=Et(t,e,i),a=Et(t+1,e,i);return(St(t)-n+a)/7}function Gt(t,e){return t.slice(e,7).concat(t.slice(0,e))}B("w",["ww",2],"wo","week"),B("W",["WW",2],"Wo","isoWeek"),F("week","w"),F("isoWeek","W"),Y("week",5),Y("isoWeek",5),ut("w",K),ut("ww",K,q),ut("W",K),ut("WW",K,q),gt(["w","ww","W","WW"],function(t,e,i,n){e[n.substr(0,1)]=k(t)}),B("d",0,"do","day"),B("dd",0,0,function(t){return this.localeData().weekdaysMin(this,t)}),B("ddd",0,0,function(t){return this.localeData().weekdaysShort(this,t)}),B("dddd",0,0,function(t){return this.localeData().weekdays(this,t)}),B("e",0,0,"weekday"),B("E",0,0,"isoWeekday"),F("day","d"),F("weekday","e"),F("isoWeekday","E"),Y("day",11),Y("weekday",11),Y("isoWeekday",11),ut("d",K),ut("e",K),ut("E",K),ut("dd",function(t,e){return e.weekdaysMinRegex(t)}),ut("ddd",function(t,e){return e.weekdaysShortRegex(t)}),ut("dddd",function(t,e){return e.weekdaysRegex(t)}),gt(["dd","ddd","dddd"],function(t,e,i,n){var a=i._locale.weekdaysParse(t,n,i._strict);null!=a?e.d=a:f(i).invalidWeekday=t}),gt(["d","e","E"],function(t,e,i,n){e[n]=k(t)});var qt="Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),Zt="Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),$t="Su_Mo_Tu_We_Th_Fr_Sa".split("_"),Xt=st,Kt=st,Jt=st;function Qt(){function t(t,e){return e.length-t.length}var e,i,n,a,r,o=[],s=[],l=[],u=[];for(e=0;e<7;e++)i=c([2e3,1]).day(e),n=this.weekdaysMin(i,""),a=this.weekdaysShort(i,""),r=this.weekdays(i,""),o.push(n),s.push(a),l.push(r),u.push(n),u.push(a),u.push(r);for(o.sort(t),s.sort(t),l.sort(t),u.sort(t),e=0;e<7;e++)s[e]=ht(s[e]),l[e]=ht(l[e]),u[e]=ht(u[e]);this._weekdaysRegex=new RegExp("^("+u.join("|")+")","i"),this._weekdaysShortRegex=this._weekdaysRegex,this._weekdaysMinRegex=this._weekdaysRegex,this._weekdaysStrictRegex=new RegExp("^("+l.join("|")+")","i"),this._weekdaysShortStrictRegex=new RegExp("^("+s.join("|")+")","i"),this._weekdaysMinStrictRegex=new RegExp("^("+o.join("|")+")","i")}function te(){return this.hours()%12||12}function ee(t,e){B(t,0,0,function(){return this.localeData().meridiem(this.hours(),this.minutes(),e)})}function ie(t,e){return e._meridiemParse}B("H",["HH",2],0,"hour"),B("h",["hh",2],0,te),B("k",["kk",2],0,function(){return this.hours()||24}),B("hmm",0,0,function(){return""+te.apply(this)+N(this.minutes(),2)}),B("hmmss",0,0,function(){return""+te.apply(this)+N(this.minutes(),2)+N(this.seconds(),2)}),B("Hmm",0,0,function(){return""+this.hours()+N(this.minutes(),2)}),B("Hmmss",0,0,function(){return""+this.hours()+N(this.minutes(),2)+N(this.seconds(),2)}),ee("a",!0),ee("A",!1),F("hour","h"),Y("hour",13),ut("a",ie),ut("A",ie),ut("H",K),ut("h",K),ut("k",K),ut("HH",K,q),ut("hh",K,q),ut("kk",K,q),ut("hmm",J),ut("hmmss",Q),ut("Hmm",J),ut("Hmmss",Q),ft(["H","HH"],bt),ft(["k","kk"],function(t,e,i){var n=k(t);e[bt]=24===n?0:n}),ft(["a","A"],function(t,e,i){i._isPm=i._locale.isPM(t),i._meridiem=t}),ft(["h","hh"],function(t,e,i){e[bt]=k(t),f(i).bigHour=!0}),ft("hmm",function(t,e,i){var n=t.length-2;e[bt]=k(t.substr(0,n)),e[xt]=k(t.substr(n)),f(i).bigHour=!0}),ft("hmmss",function(t,e,i){var n=t.length-4,a=t.length-2;e[bt]=k(t.substr(0,n)),e[xt]=k(t.substr(n,2)),e[_t]=k(t.substr(a)),f(i).bigHour=!0}),ft("Hmm",function(t,e,i){var n=t.length-2;e[bt]=k(t.substr(0,n)),e[xt]=k(t.substr(n))}),ft("Hmmss",function(t,e,i){var n=t.length-4,a=t.length-2;e[bt]=k(t.substr(0,n)),e[xt]=k(t.substr(n,2)),e[_t]=k(t.substr(a))});var ne,ae=Tt("Hours",!0),re={calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},longDateFormat:{LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},invalidDate:"Invalid date",ordinal:"%d",dayOfMonthOrdinalParse:/\d{1,2}/,relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},months:Rt,monthsShort:Lt,week:{dow:0,doy:6},weekdays:qt,weekdaysMin:$t,weekdaysShort:Zt,meridiemParse:/[ap]\.?m?\.?/i},oe={},se={};function le(t){return t?t.toLowerCase().replace("_","-"):t}function ue(e){var i=null;if(!oe[e]&&t&&t.exports)try{i=ne._abbr;var n=_e;n("./locale/"+e),de(i)}catch(t){}return oe[e]}function de(t,e){var i;return t&&((i=o(e)?ce(t):he(t,e))?ne=i:"undefined"!=typeof console&&console.warn&&console.warn("Locale "+t+" not found. Did you forget to load it?")),ne._abbr}function he(t,e){if(null!==e){var i,n=re;if(e.abbr=t,null!=oe[t])P("defineLocaleOverride","use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."),n=oe[t]._config;else if(null!=e.parentLocale)if(null!=oe[e.parentLocale])n=oe[e.parentLocale]._config;else{if(null==(i=ue(e.parentLocale)))return se[e.parentLocale]||(se[e.parentLocale]=[]),se[e.parentLocale].push({name:t,config:e}),null;n=i._config}return oe[t]=new I(O(n,e)),se[t]&&se[t].forEach(function(t){he(t.name,t.config)}),de(t),oe[t]}return delete oe[t],null}function ce(t){var e;if(t&&t._locale&&t._locale._abbr&&(t=t._locale._abbr),!t)return ne;if(!a(t)){if(e=ue(t))return e;t=[t]}return function(t){for(var e,i,n,a,r=0;r<t.length;){for(a=le(t[r]).split("-"),e=a.length,i=(i=le(t[r+1]))?i.split("-"):null;e>0;){if(n=ue(a.slice(0,e).join("-")))return n;if(i&&i.length>=e&&w(a,i,!0)>=e-1)break;e--}r++}return ne}(t)}function fe(t){var e,i=t._a;return i&&-2===f(t).overflow&&(e=i[vt]<0||i[vt]>11?vt:i[yt]<1||i[yt]>At(i[pt],i[vt])?yt:i[bt]<0||i[bt]>24||24===i[bt]&&(0!==i[xt]||0!==i[_t]||0!==i[kt])?bt:i[xt]<0||i[xt]>59?xt:i[_t]<0||i[_t]>59?_t:i[kt]<0||i[kt]>999?kt:-1,f(t)._overflowDayOfYear&&(e<pt||e>yt)&&(e=yt),f(t)._overflowWeeks&&-1===e&&(e=wt),f(t)._overflowWeekday&&-1===e&&(e=Mt),f(t).overflow=e),t}function ge(t,e,i){return null!=t?t:null!=e?e:i}function me(t){var e,i,a,r,o,s=[];if(!t._d){for(a=function(t){var e=new Date(n.now());return t._useUTC?[e.getUTCFullYear(),e.getUTCMonth(),e.getUTCDate()]:[e.getFullYear(),e.getMonth(),e.getDate()]}(t),t._w&&null==t._a[yt]&&null==t._a[vt]&&function(t){var e,i,n,a,r,o,s,l;if(null!=(e=t._w).GG||null!=e.W||null!=e.E)r=1,o=4,i=ge(e.GG,t._a[pt],jt(Ie(),1,4).year),n=ge(e.W,1),((a=ge(e.E,1))<1||a>7)&&(l=!0);else{r=t._locale._week.dow,o=t._locale._week.doy;var u=jt(Ie(),r,o);i=ge(e.gg,t._a[pt],u.year),n=ge(e.w,u.week),null!=e.d?((a=e.d)<0||a>6)&&(l=!0):null!=e.e?(a=e.e+r,(e.e<0||e.e>6)&&(l=!0)):a=r}n<1||n>Ut(i,r,o)?f(t)._overflowWeeks=!0:null!=l?f(t)._overflowWeekday=!0:(s=Bt(i,n,a,r,o),t._a[pt]=s.year,t._dayOfYear=s.dayOfYear)}(t),null!=t._dayOfYear&&(o=ge(t._a[pt],a[pt]),(t._dayOfYear>St(o)||0===t._dayOfYear)&&(f(t)._overflowDayOfYear=!0),i=Ht(o,0,t._dayOfYear),t._a[vt]=i.getUTCMonth(),t._a[yt]=i.getUTCDate()),e=0;e<3&&null==t._a[e];++e)t._a[e]=s[e]=a[e];for(;e<7;e++)t._a[e]=s[e]=null==t._a[e]?2===e?1:0:t._a[e];24===t._a[bt]&&0===t._a[xt]&&0===t._a[_t]&&0===t._a[kt]&&(t._nextDay=!0,t._a[bt]=0),t._d=(t._useUTC?Ht:function(t,e,i,n,a,r,o){var s;return t<100&&t>=0?(s=new Date(t+400,e,i,n,a,r,o),isFinite(s.getFullYear())&&s.setFullYear(t)):s=new Date(t,e,i,n,a,r,o),s}).apply(null,s),r=t._useUTC?t._d.getUTCDay():t._d.getDay(),null!=t._tzm&&t._d.setUTCMinutes(t._d.getUTCMinutes()-t._tzm),t._nextDay&&(t._a[bt]=24),t._w&&void 0!==t._w.d&&t._w.d!==r&&(f(t).weekdayMismatch=!0)}}var pe=/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,ve=/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,ye=/Z|[+-]\d\d(?::?\d\d)?/,be=[["YYYYYY-MM-DD",/[+-]\d{6}-\d\d-\d\d/],["YYYY-MM-DD",/\d{4}-\d\d-\d\d/],["GGGG-[W]WW-E",/\d{4}-W\d\d-\d/],["GGGG-[W]WW",/\d{4}-W\d\d/,!1],["YYYY-DDD",/\d{4}-\d{3}/],["YYYY-MM",/\d{4}-\d\d/,!1],["YYYYYYMMDD",/[+-]\d{10}/],["YYYYMMDD",/\d{8}/],["GGGG[W]WWE",/\d{4}W\d{3}/],["GGGG[W]WW",/\d{4}W\d{2}/,!1],["YYYYDDD",/\d{7}/]],xe=[["HH:mm:ss.SSSS",/\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss,SSSS",/\d\d:\d\d:\d\d,\d+/],["HH:mm:ss",/\d\d:\d\d:\d\d/],["HH:mm",/\d\d:\d\d/],["HHmmss.SSSS",/\d\d\d\d\d\d\.\d+/],["HHmmss,SSSS",/\d\d\d\d\d\d,\d+/],["HHmmss",/\d\d\d\d\d\d/],["HHmm",/\d\d\d\d/],["HH",/\d\d/]],ke=/^\/?Date\((\-?\d+)/i;function we(t){var e,i,n,a,r,o,s=t._i,l=pe.exec(s)||ve.exec(s);if(l){for(f(t).iso=!0,e=0,i=be.length;e<i;e++)if(be[e][1].exec(l[1])){a=be[e][0],n=!1!==be[e][2];break}if(null==a)return void(t._isValid=!1);if(l[3]){for(e=0,i=xe.length;e<i;e++)if(xe[e][1].exec(l[3])){r=(l[2]||" ")+xe[e][0];break}if(null==r)return void(t._isValid=!1)}if(!n&&null!=r)return void(t._isValid=!1);if(l[4]){if(!ye.exec(l[4]))return void(t._isValid=!1);o="Z"}t._f=a+(r||"")+(o||""),Pe(t)}else t._isValid=!1}var Me=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;function Se(t){var e=parseInt(t,10);return e<=49?2e3+e:e<=999?1900+e:e}var De={UT:0,GMT:0,EDT:-240,EST:-300,CDT:-300,CST:-360,MDT:-360,MST:-420,PDT:-420,PST:-480};function Ce(t){var e,i,n,a,r,o,s,l=Me.exec(t._i.replace(/\([^)]*\)|[\n\t]/g," ").replace(/(\s\s+)/g," ").replace(/^\s\s*/,"").replace(/\s\s*$/,""));if(l){var u=(e=l[4],i=l[3],n=l[2],a=l[5],r=l[6],o=l[7],s=[Se(e),Lt.indexOf(i),parseInt(n,10),parseInt(a,10),parseInt(r,10)],o&&s.push(parseInt(o,10)),s);if(!function(t,e,i){if(t){var n=Zt.indexOf(t),a=new Date(e[0],e[1],e[2]).getDay();if(n!==a)return f(i).weekdayMismatch=!0,i._isValid=!1,!1}return!0}(l[1],u,t))return;t._a=u,t._tzm=function(t,e,i){if(t)return De[t];if(e)return 0;var n=parseInt(i,10),a=n%100,r=(n-a)/100;return 60*r+a}(l[8],l[9],l[10]),t._d=Ht.apply(null,t._a),t._d.setUTCMinutes(t._d.getUTCMinutes()-t._tzm),f(t).rfc2822=!0}else t._isValid=!1}function Pe(t){if(t._f!==n.ISO_8601)if(t._f!==n.RFC_2822){t._a=[],f(t).empty=!0;var e,i,a,r,o,s=""+t._i,l=s.length,u=0;for(a=U(t._f,t._locale).match(z)||[],e=0;e<a.length;e++)r=a[e],(i=(s.match(dt(r,t))||[])[0])&&((o=s.substr(0,s.indexOf(i))).length>0&&f(t).unusedInput.push(o),s=s.slice(s.indexOf(i)+i.length),u+=i.length),E[r]?(i?f(t).empty=!1:f(t).unusedTokens.push(r),mt(r,i,t)):t._strict&&!i&&f(t).unusedTokens.push(r);f(t).charsLeftOver=l-u,s.length>0&&f(t).unusedInput.push(s),t._a[bt]<=12&&!0===f(t).bigHour&&t._a[bt]>0&&(f(t).bigHour=void 0),f(t).parsedDateParts=t._a.slice(0),f(t).meridiem=t._meridiem,t._a[bt]=(d=t._locale,h=t._a[bt],null==(c=t._meridiem)?h:null!=d.meridiemHour?d.meridiemHour(h,c):null!=d.isPM?((g=d.isPM(c))&&h<12&&(h+=12),g||12!==h||(h=0),h):h),me(t),fe(t)}else Ce(t);else we(t);var d,h,c,g}function Te(t){var e=t._i,i=t._f;return t._locale=t._locale||ce(t._l),null===e||void 0===i&&""===e?m({nullInput:!0}):("string"==typeof e&&(t._i=e=t._locale.preparse(e)),x(e)?new b(fe(e)):(l(e)?t._d=e:a(i)?function(t){var e,i,n,a,r;if(0===t._f.length)return f(t).invalidFormat=!0,void(t._d=new Date(NaN));for(a=0;a<t._f.length;a++)r=0,e=v({},t),null!=t._useUTC&&(e._useUTC=t._useUTC),e._f=t._f[a],Pe(e),g(e)&&(r+=f(e).charsLeftOver,r+=10*f(e).unusedTokens.length,f(e).score=r,(null==n||r<n)&&(n=r,i=e));h(t,i||e)}(t):i?Pe(t):function(t){var e=t._i;o(e)?t._d=new Date(n.now()):l(e)?t._d=new Date(e.valueOf()):"string"==typeof e?function(t){var e=ke.exec(t._i);null===e?(we(t),!1===t._isValid&&(delete t._isValid,Ce(t),!1===t._isValid&&(delete t._isValid,n.createFromInputFallback(t)))):t._d=new Date(+e[1])}(t):a(e)?(t._a=u(e.slice(0),function(t){return parseInt(t,10)}),me(t)):r(e)?function(t){if(!t._d){var e=L(t._i);t._a=u([e.year,e.month,e.day||e.date,e.hour,e.minute,e.second,e.millisecond],function(t){return t&&parseInt(t,10)}),me(t)}}(t):s(e)?t._d=new Date(e):n.createFromInputFallback(t)}(t),g(t)||(t._d=null),t))}function Oe(t,e,i,n,o){var s,l={};return!0!==i&&!1!==i||(n=i,i=void 0),(r(t)&&function(t){if(Object.getOwnPropertyNames)return 0===Object.getOwnPropertyNames(t).length;var e;for(e in t)if(t.hasOwnProperty(e))return!1;return!0}(t)||a(t)&&0===t.length)&&(t=void 0),l._isAMomentObject=!0,l._useUTC=l._isUTC=o,l._l=i,l._i=t,l._f=e,l._strict=n,(s=new b(fe(Te(l))))._nextDay&&(s.add(1,"d"),s._nextDay=void 0),s}function Ie(t,e,i,n){return Oe(t,e,i,n,!1)}n.createFromInputFallback=S("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",function(t){t._d=new Date(t._i+(t._useUTC?" UTC":""))}),n.ISO_8601=function(){},n.RFC_2822=function(){};var Ae=S("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var t=Ie.apply(null,arguments);return this.isValid()&&t.isValid()?t<this?this:t:m()}),Fe=S("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var t=Ie.apply(null,arguments);return this.isValid()&&t.isValid()?t>this?this:t:m()});function Re(t,e){var i,n;if(1===e.length&&a(e[0])&&(e=e[0]),!e.length)return Ie();for(i=e[0],n=1;n<e.length;++n)e[n].isValid()&&!e[n][t](i)||(i=e[n]);return i}var Le=["year","quarter","month","week","day","hour","minute","second","millisecond"];function We(t){var e=L(t),i=e.year||0,n=e.quarter||0,a=e.month||0,r=e.week||e.isoWeek||0,o=e.day||0,s=e.hour||0,l=e.minute||0,u=e.second||0,d=e.millisecond||0;this._isValid=function(t){for(var e in t)if(-1===Ct.call(Le,e)||null!=t[e]&&isNaN(t[e]))return!1;for(var i=!1,n=0;n<Le.length;++n)if(t[Le[n]]){if(i)return!1;parseFloat(t[Le[n]])!==k(t[Le[n]])&&(i=!0)}return!0}(e),this._milliseconds=+d+1e3*u+6e4*l+1e3*s*60*60,this._days=+o+7*r,this._months=+a+3*n+12*i,this._data={},this._locale=ce(),this._bubble()}function Ye(t){return t instanceof We}function Ne(t){return t<0?-1*Math.round(-1*t):Math.round(t)}function ze(t,e){B(t,0,0,function(){var t=this.utcOffset(),i="+";return t<0&&(t=-t,i="-"),i+N(~~(t/60),2)+e+N(~~t%60,2)})}ze("Z",":"),ze("ZZ",""),ut("Z",ot),ut("ZZ",ot),ft(["Z","ZZ"],function(t,e,i){i._useUTC=!0,i._tzm=He(ot,t)});var Ve=/([\+\-]|\d\d)/gi;function He(t,e){var i=(e||"").match(t);if(null===i)return null;var n=i[i.length-1]||[],a=(n+"").match(Ve)||["-",0,0],r=60*a[1]+k(a[2]);return 0===r?0:"+"===a[0]?r:-r}function Ee(t,e){var i,a;return e._isUTC?(i=e.clone(),a=(x(t)||l(t)?t.valueOf():Ie(t).valueOf())-i.valueOf(),i._d.setTime(i._d.valueOf()+a),n.updateOffset(i,!1),i):Ie(t).local()}function Be(t){return 15*-Math.round(t._d.getTimezoneOffset()/15)}function je(){return!!this.isValid()&&this._isUTC&&0===this._offset}n.updateOffset=function(){};var Ue=/^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,Ge=/^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;function qe(t,e){var i,n,a,r,o,l,u=t,h=null;return Ye(t)?u={ms:t._milliseconds,d:t._days,M:t._months}:s(t)?(u={},e?u[e]=t:u.milliseconds=t):(h=Ue.exec(t))?(i="-"===h[1]?-1:1,u={y:0,d:k(h[yt])*i,h:k(h[bt])*i,m:k(h[xt])*i,s:k(h[_t])*i,ms:k(Ne(1e3*h[kt]))*i}):(h=Ge.exec(t))?(i="-"===h[1]?-1:1,u={y:Ze(h[2],i),M:Ze(h[3],i),w:Ze(h[4],i),d:Ze(h[5],i),h:Ze(h[6],i),m:Ze(h[7],i),s:Ze(h[8],i)}):null==u?u={}:"object"==typeof u&&("from"in u||"to"in u)&&(r=Ie(u.from),o=Ie(u.to),a=r.isValid()&&o.isValid()?(o=Ee(o,r),r.isBefore(o)?l=$e(r,o):((l=$e(o,r)).milliseconds=-l.milliseconds,l.months=-l.months),l):{milliseconds:0,months:0},(u={}).ms=a.milliseconds,u.M=a.months),n=new We(u),Ye(t)&&d(t,"_locale")&&(n._locale=t._locale),n}function Ze(t,e){var i=t&&parseFloat(t.replace(",","."));return(isNaN(i)?0:i)*e}function $e(t,e){var i={};return i.months=e.month()-t.month()+12*(e.year()-t.year()),t.clone().add(i.months,"M").isAfter(e)&&--i.months,i.milliseconds=+e-+t.clone().add(i.months,"M"),i}function Xe(t,e){return function(i,n){var a;return null===n||isNaN(+n)||(P(e,"moment()."+e+"(period, number) is deprecated. Please use moment()."+e+"(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."),a=i,i=n,n=a),Ke(this,qe(i="string"==typeof i?+i:i,n),t),this}}function Ke(t,e,i,a){var r=e._milliseconds,o=Ne(e._days),s=Ne(e._months);t.isValid()&&(a=null==a||a,s&&Wt(t,Ot(t,"Month")+s*i),o&&It(t,"Date",Ot(t,"Date")+o*i),r&&t._d.setTime(t._d.valueOf()+r*i),a&&n.updateOffset(t,o||s))}qe.fn=We.prototype,qe.invalid=function(){return qe(NaN)};var Je=Xe(1,"add"),Qe=Xe(-1,"subtract");function ti(t,e){var i,n,a=12*(e.year()-t.year())+(e.month()-t.month()),r=t.clone().add(a,"months");return e-r<0?(i=t.clone().add(a-1,"months"),n=(e-r)/(r-i)):(i=t.clone().add(a+1,"months"),n=(e-r)/(i-r)),-(a+n)||0}function ei(t){var e;return void 0===t?this._locale._abbr:(null!=(e=ce(t))&&(this._locale=e),this)}n.defaultFormat="YYYY-MM-DDTHH:mm:ssZ",n.defaultFormatUtc="YYYY-MM-DDTHH:mm:ss[Z]";var ii=S("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",function(t){return void 0===t?this.localeData():this.locale(t)});function ni(){return this._locale}var ai=1e3,ri=60*ai,oi=60*ri,si=3506328*oi;function li(t,e){return(t%e+e)%e}function ui(t,e,i){return t<100&&t>=0?new Date(t+400,e,i)-si:new Date(t,e,i).valueOf()}function di(t,e,i){return t<100&&t>=0?Date.UTC(t+400,e,i)-si:Date.UTC(t,e,i)}function hi(t,e){B(0,[t,t.length],0,e)}function ci(t,e,i,n,a){var r;return null==t?jt(this,n,a).year:(r=Ut(t,n,a),e>r&&(e=r),function(t,e,i,n,a){var r=Bt(t,e,i,n,a),o=Ht(r.year,0,r.dayOfYear);return this.year(o.getUTCFullYear()),this.month(o.getUTCMonth()),this.date(o.getUTCDate()),this}.call(this,t,e,i,n,a))}B(0,["gg",2],0,function(){return this.weekYear()%100}),B(0,["GG",2],0,function(){return this.isoWeekYear()%100}),hi("gggg","weekYear"),hi("ggggg","weekYear"),hi("GGGG","isoWeekYear"),hi("GGGGG","isoWeekYear"),F("weekYear","gg"),F("isoWeekYear","GG"),Y("weekYear",1),Y("isoWeekYear",1),ut("G",at),ut("g",at),ut("GG",K,q),ut("gg",K,q),ut("GGGG",et,$),ut("gggg",et,$),ut("GGGGG",it,X),ut("ggggg",it,X),gt(["gggg","ggggg","GGGG","GGGGG"],function(t,e,i,n){e[n.substr(0,2)]=k(t)}),gt(["gg","GG"],function(t,e,i,a){e[a]=n.parseTwoDigitYear(t)}),B("Q",0,"Qo","quarter"),F("quarter","Q"),Y("quarter",7),ut("Q",G),ft("Q",function(t,e){e[vt]=3*(k(t)-1)}),B("D",["DD",2],"Do","date"),F("date","D"),Y("date",9),ut("D",K),ut("DD",K,q),ut("Do",function(t,e){return t?e._dayOfMonthOrdinalParse||e._ordinalParse:e._dayOfMonthOrdinalParseLenient}),ft(["D","DD"],yt),ft("Do",function(t,e){e[yt]=k(t.match(K)[0])});var fi=Tt("Date",!0);B("DDD",["DDDD",3],"DDDo","dayOfYear"),F("dayOfYear","DDD"),Y("dayOfYear",4),ut("DDD",tt),ut("DDDD",Z),ft(["DDD","DDDD"],function(t,e,i){i._dayOfYear=k(t)}),B("m",["mm",2],0,"minute"),F("minute","m"),Y("minute",14),ut("m",K),ut("mm",K,q),ft(["m","mm"],xt);var gi=Tt("Minutes",!1);B("s",["ss",2],0,"second"),F("second","s"),Y("second",15),ut("s",K),ut("ss",K,q),ft(["s","ss"],_t);var mi,pi=Tt("Seconds",!1);for(B("S",0,0,function(){return~~(this.millisecond()/100)}),B(0,["SS",2],0,function(){return~~(this.millisecond()/10)}),B(0,["SSS",3],0,"millisecond"),B(0,["SSSS",4],0,function(){return 10*this.millisecond()}),B(0,["SSSSS",5],0,function(){return 100*this.millisecond()}),B(0,["SSSSSS",6],0,function(){return 1e3*this.millisecond()}),B(0,["SSSSSSS",7],0,function(){return 1e4*this.millisecond()}),B(0,["SSSSSSSS",8],0,function(){return 1e5*this.millisecond()}),B(0,["SSSSSSSSS",9],0,function(){return 1e6*this.millisecond()}),F("millisecond","ms"),Y("millisecond",16),ut("S",tt,G),ut("SS",tt,q),ut("SSS",tt,Z),mi="SSSS";mi.length<=9;mi+="S")ut(mi,nt);function vi(t,e){e[kt]=k(1e3*("0."+t))}for(mi="S";mi.length<=9;mi+="S")ft(mi,vi);var yi=Tt("Milliseconds",!1);B("z",0,0,"zoneAbbr"),B("zz",0,0,"zoneName");var bi=b.prototype;function xi(t){return t}bi.add=Je,bi.calendar=function(t,e){var i=t||Ie(),a=Ee(i,this).startOf("day"),r=n.calendarFormat(this,a)||"sameElse",o=e&&(T(e[r])?e[r].call(this,i):e[r]);return this.format(o||this.localeData().calendar(r,this,Ie(i)))},bi.clone=function(){return new b(this)},bi.diff=function(t,e,i){var n,a,r;if(!this.isValid())return NaN;if(!(n=Ee(t,this)).isValid())return NaN;switch(a=6e4*(n.utcOffset()-this.utcOffset()),e=R(e)){case"year":r=ti(this,n)/12;break;case"month":r=ti(this,n);break;case"quarter":r=ti(this,n)/3;break;case"second":r=(this-n)/1e3;break;case"minute":r=(this-n)/6e4;break;case"hour":r=(this-n)/36e5;break;case"day":r=(this-n-a)/864e5;break;case"week":r=(this-n-a)/6048e5;break;default:r=this-n}return i?r:_(r)},bi.endOf=function(t){var e;if(void 0===(t=R(t))||"millisecond"===t||!this.isValid())return this;var i=this._isUTC?di:ui;switch(t){case"year":e=i(this.year()+1,0,1)-1;break;case"quarter":e=i(this.year(),this.month()-this.month()%3+3,1)-1;break;case"month":e=i(this.year(),this.month()+1,1)-1;break;case"week":e=i(this.year(),this.month(),this.date()-this.weekday()+7)-1;break;case"isoWeek":e=i(this.year(),this.month(),this.date()-(this.isoWeekday()-1)+7)-1;break;case"day":case"date":e=i(this.year(),this.month(),this.date()+1)-1;break;case"hour":e=this._d.valueOf(),e+=oi-li(e+(this._isUTC?0:this.utcOffset()*ri),oi)-1;break;case"minute":e=this._d.valueOf(),e+=ri-li(e,ri)-1;break;case"second":e=this._d.valueOf(),e+=ai-li(e,ai)-1}return this._d.setTime(e),n.updateOffset(this,!0),this},bi.format=function(t){t||(t=this.isUtc()?n.defaultFormatUtc:n.defaultFormat);var e=j(this,t);return this.localeData().postformat(e)},bi.from=function(t,e){return this.isValid()&&(x(t)&&t.isValid()||Ie(t).isValid())?qe({to:this,from:t}).locale(this.locale()).humanize(!e):this.localeData().invalidDate()},bi.fromNow=function(t){return this.from(Ie(),t)},bi.to=function(t,e){return this.isValid()&&(x(t)&&t.isValid()||Ie(t).isValid())?qe({from:this,to:t}).locale(this.locale()).humanize(!e):this.localeData().invalidDate()},bi.toNow=function(t){return this.to(Ie(),t)},bi.get=function(t){return T(this[t=R(t)])?this[t]():this},bi.invalidAt=function(){return f(this).overflow},bi.isAfter=function(t,e){var i=x(t)?t:Ie(t);return!(!this.isValid()||!i.isValid())&&("millisecond"===(e=R(e)||"millisecond")?this.valueOf()>i.valueOf():i.valueOf()<this.clone().startOf(e).valueOf())},bi.isBefore=function(t,e){var i=x(t)?t:Ie(t);return!(!this.isValid()||!i.isValid())&&("millisecond"===(e=R(e)||"millisecond")?this.valueOf()<i.valueOf():this.clone().endOf(e).valueOf()<i.valueOf())},bi.isBetween=function(t,e,i,n){var a=x(t)?t:Ie(t),r=x(e)?e:Ie(e);return!!(this.isValid()&&a.isValid()&&r.isValid())&&(("("===(n=n||"()")[0]?this.isAfter(a,i):!this.isBefore(a,i))&&(")"===n[1]?this.isBefore(r,i):!this.isAfter(r,i)))},bi.isSame=function(t,e){var i,n=x(t)?t:Ie(t);return!(!this.isValid()||!n.isValid())&&("millisecond"===(e=R(e)||"millisecond")?this.valueOf()===n.valueOf():(i=n.valueOf(),this.clone().startOf(e).valueOf()<=i&&i<=this.clone().endOf(e).valueOf()))},bi.isSameOrAfter=function(t,e){return this.isSame(t,e)||this.isAfter(t,e)},bi.isSameOrBefore=function(t,e){return this.isSame(t,e)||this.isBefore(t,e)},bi.isValid=function(){return g(this)},bi.lang=ii,bi.locale=ei,bi.localeData=ni,bi.max=Fe,bi.min=Ae,bi.parsingFlags=function(){return h({},f(this))},bi.set=function(t,e){if("object"==typeof t)for(var i=function(t){var e=[];for(var i in t)e.push({unit:i,priority:W[i]});return e.sort(function(t,e){return t.priority-e.priority}),e}(t=L(t)),n=0;n<i.length;n++)this[i[n].unit](t[i[n].unit]);else if(T(this[t=R(t)]))return this[t](e);return this},bi.startOf=function(t){var e;if(void 0===(t=R(t))||"millisecond"===t||!this.isValid())return this;var i=this._isUTC?di:ui;switch(t){case"year":e=i(this.year(),0,1);break;case"quarter":e=i(this.year(),this.month()-this.month()%3,1);break;case"month":e=i(this.year(),this.month(),1);break;case"week":e=i(this.year(),this.month(),this.date()-this.weekday());break;case"isoWeek":e=i(this.year(),this.month(),this.date()-(this.isoWeekday()-1));break;case"day":case"date":e=i(this.year(),this.month(),this.date());break;case"hour":e=this._d.valueOf(),e-=li(e+(this._isUTC?0:this.utcOffset()*ri),oi);break;case"minute":e=this._d.valueOf(),e-=li(e,ri);break;case"second":e=this._d.valueOf(),e-=li(e,ai)}return this._d.setTime(e),n.updateOffset(this,!0),this},bi.subtract=Qe,bi.toArray=function(){var t=this;return[t.year(),t.month(),t.date(),t.hour(),t.minute(),t.second(),t.millisecond()]},bi.toObject=function(){var t=this;return{years:t.year(),months:t.month(),date:t.date(),hours:t.hours(),minutes:t.minutes(),seconds:t.seconds(),milliseconds:t.milliseconds()}},bi.toDate=function(){return new Date(this.valueOf())},bi.toISOString=function(t){if(!this.isValid())return null;var e=!0!==t,i=e?this.clone().utc():this;return i.year()<0||i.year()>9999?j(i,e?"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"):T(Date.prototype.toISOString)?e?this.toDate().toISOString():new Date(this.valueOf()+60*this.utcOffset()*1e3).toISOString().replace("Z",j(i,"Z")):j(i,e?"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYY-MM-DD[T]HH:mm:ss.SSSZ")},bi.inspect=function(){if(!this.isValid())return"moment.invalid(/* "+this._i+" */)";var t="moment",e="";this.isLocal()||(t=0===this.utcOffset()?"moment.utc":"moment.parseZone",e="Z");var i="["+t+'("]',n=0<=this.year()&&this.year()<=9999?"YYYY":"YYYYYY",a=e+'[")]';return this.format(i+n+"-MM-DD[T]HH:mm:ss.SSS"+a)},bi.toJSON=function(){return this.isValid()?this.toISOString():null},bi.toString=function(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")},bi.unix=function(){return Math.floor(this.valueOf()/1e3)},bi.valueOf=function(){return this._d.valueOf()-6e4*(this._offset||0)},bi.creationData=function(){return{input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict}},bi.year=Pt,bi.isLeapYear=function(){return Dt(this.year())},bi.weekYear=function(t){return ci.call(this,t,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy)},bi.isoWeekYear=function(t){return ci.call(this,t,this.isoWeek(),this.isoWeekday(),1,4)},bi.quarter=bi.quarters=function(t){return null==t?Math.ceil((this.month()+1)/3):this.month(3*(t-1)+this.month()%3)},bi.month=Yt,bi.daysInMonth=function(){return At(this.year(),this.month())},bi.week=bi.weeks=function(t){var e=this.localeData().week(this);return null==t?e:this.add(7*(t-e),"d")},bi.isoWeek=bi.isoWeeks=function(t){var e=jt(this,1,4).week;return null==t?e:this.add(7*(t-e),"d")},bi.weeksInYear=function(){var t=this.localeData()._week;return Ut(this.year(),t.dow,t.doy)},bi.isoWeeksInYear=function(){return Ut(this.year(),1,4)},bi.date=fi,bi.day=bi.days=function(t){if(!this.isValid())return null!=t?this:NaN;var e=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=t?(t=function(t,e){return"string"!=typeof t?t:isNaN(t)?"number"==typeof(t=e.weekdaysParse(t))?t:null:parseInt(t,10)}(t,this.localeData()),this.add(t-e,"d")):e},bi.weekday=function(t){if(!this.isValid())return null!=t?this:NaN;var e=(this.day()+7-this.localeData()._week.dow)%7;return null==t?e:this.add(t-e,"d")},bi.isoWeekday=function(t){if(!this.isValid())return null!=t?this:NaN;if(null!=t){var e=function(t,e){return"string"==typeof t?e.weekdaysParse(t)%7||7:isNaN(t)?null:t}(t,this.localeData());return this.day(this.day()%7?e:e-7)}return this.day()||7},bi.dayOfYear=function(t){var e=Math.round((this.clone().startOf("day")-this.clone().startOf("year"))/864e5)+1;return null==t?e:this.add(t-e,"d")},bi.hour=bi.hours=ae,bi.minute=bi.minutes=gi,bi.second=bi.seconds=pi,bi.millisecond=bi.milliseconds=yi,bi.utcOffset=function(t,e,i){var a,r=this._offset||0;if(!this.isValid())return null!=t?this:NaN;if(null!=t){if("string"==typeof t){if(null===(t=He(ot,t)))return this}else Math.abs(t)<16&&!i&&(t*=60);return!this._isUTC&&e&&(a=Be(this)),this._offset=t,this._isUTC=!0,null!=a&&this.add(a,"m"),r!==t&&(!e||this._changeInProgress?Ke(this,qe(t-r,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,n.updateOffset(this,!0),this._changeInProgress=null)),this}return this._isUTC?r:Be(this)},bi.utc=function(t){return this.utcOffset(0,t)},bi.local=function(t){return this._isUTC&&(this.utcOffset(0,t),this._isUTC=!1,t&&this.subtract(Be(this),"m")),this},bi.parseZone=function(){if(null!=this._tzm)this.utcOffset(this._tzm,!1,!0);else if("string"==typeof this._i){var t=He(rt,this._i);null!=t?this.utcOffset(t):this.utcOffset(0,!0)}return this},bi.hasAlignedHourOffset=function(t){return!!this.isValid()&&(t=t?Ie(t).utcOffset():0,(this.utcOffset()-t)%60==0)},bi.isDST=function(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()},bi.isLocal=function(){return!!this.isValid()&&!this._isUTC},bi.isUtcOffset=function(){return!!this.isValid()&&this._isUTC},bi.isUtc=je,bi.isUTC=je,bi.zoneAbbr=function(){return this._isUTC?"UTC":""},bi.zoneName=function(){return this._isUTC?"Coordinated Universal Time":""},bi.dates=S("dates accessor is deprecated. Use date instead.",fi),bi.months=S("months accessor is deprecated. Use month instead",Yt),bi.years=S("years accessor is deprecated. Use year instead",Pt),bi.zone=S("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",function(t,e){return null!=t?("string"!=typeof t&&(t=-t),this.utcOffset(t,e),this):-this.utcOffset()}),bi.isDSTShifted=S("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",function(){if(!o(this._isDSTShifted))return this._isDSTShifted;var t={};if(v(t,this),(t=Te(t))._a){var e=t._isUTC?c(t._a):Ie(t._a);this._isDSTShifted=this.isValid()&&w(t._a,e.toArray())>0}else this._isDSTShifted=!1;return this._isDSTShifted});var _i=I.prototype;function ki(t,e,i,n){var a=ce(),r=c().set(n,e);return a[i](r,t)}function wi(t,e,i){if(s(t)&&(e=t,t=void 0),t=t||"",null!=e)return ki(t,e,i,"month");var n,a=[];for(n=0;n<12;n++)a[n]=ki(t,n,i,"month");return a}function Mi(t,e,i,n){"boolean"==typeof t?(s(e)&&(i=e,e=void 0),e=e||""):(i=e=t,t=!1,s(e)&&(i=e,e=void 0),e=e||"");var a,r=ce(),o=t?r._week.dow:0;if(null!=i)return ki(e,(i+o)%7,n,"day");var l=[];for(a=0;a<7;a++)l[a]=ki(e,(a+o)%7,n,"day");return l}_i.calendar=function(t,e,i){var n=this._calendar[t]||this._calendar.sameElse;return T(n)?n.call(e,i):n},_i.longDateFormat=function(t){var e=this._longDateFormat[t],i=this._longDateFormat[t.toUpperCase()];return e||!i?e:(this._longDateFormat[t]=i.replace(/MMMM|MM|DD|dddd/g,function(t){return t.slice(1)}),this._longDateFormat[t])},_i.invalidDate=function(){return this._invalidDate},_i.ordinal=function(t){return this._ordinal.replace("%d",t)},_i.preparse=xi,_i.postformat=xi,_i.relativeTime=function(t,e,i,n){var a=this._relativeTime[i];return T(a)?a(t,e,i,n):a.replace(/%d/i,t)},_i.pastFuture=function(t,e){var i=this._relativeTime[t>0?"future":"past"];return T(i)?i(e):i.replace(/%s/i,e)},_i.set=function(t){var e,i;for(i in t)T(e=t[i])?this[i]=e:this["_"+i]=e;this._config=t,this._dayOfMonthOrdinalParseLenient=new RegExp((this._dayOfMonthOrdinalParse.source||this._ordinalParse.source)+"|"+/\d{1,2}/.source)},_i.months=function(t,e){return t?a(this._months)?this._months[t.month()]:this._months[(this._months.isFormat||Ft).test(e)?"format":"standalone"][t.month()]:a(this._months)?this._months:this._months.standalone},_i.monthsShort=function(t,e){return t?a(this._monthsShort)?this._monthsShort[t.month()]:this._monthsShort[Ft.test(e)?"format":"standalone"][t.month()]:a(this._monthsShort)?this._monthsShort:this._monthsShort.standalone},_i.monthsParse=function(t,e,i){var n,a,r;if(this._monthsParseExact)return function(t,e,i){var n,a,r,o=t.toLocaleLowerCase();if(!this._monthsParse)for(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[],n=0;n<12;++n)r=c([2e3,n]),this._shortMonthsParse[n]=this.monthsShort(r,"").toLocaleLowerCase(),this._longMonthsParse[n]=this.months(r,"").toLocaleLowerCase();return i?"MMM"===e?-1!==(a=Ct.call(this._shortMonthsParse,o))?a:null:-1!==(a=Ct.call(this._longMonthsParse,o))?a:null:"MMM"===e?-1!==(a=Ct.call(this._shortMonthsParse,o))?a:-1!==(a=Ct.call(this._longMonthsParse,o))?a:null:-1!==(a=Ct.call(this._longMonthsParse,o))?a:-1!==(a=Ct.call(this._shortMonthsParse,o))?a:null}.call(this,t,e,i);for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),n=0;n<12;n++){if(a=c([2e3,n]),i&&!this._longMonthsParse[n]&&(this._longMonthsParse[n]=new RegExp("^"+this.months(a,"").replace(".","")+"$","i"),this._shortMonthsParse[n]=new RegExp("^"+this.monthsShort(a,"").replace(".","")+"$","i")),i||this._monthsParse[n]||(r="^"+this.months(a,"")+"|^"+this.monthsShort(a,""),this._monthsParse[n]=new RegExp(r.replace(".",""),"i")),i&&"MMMM"===e&&this._longMonthsParse[n].test(t))return n;if(i&&"MMM"===e&&this._shortMonthsParse[n].test(t))return n;if(!i&&this._monthsParse[n].test(t))return n}},_i.monthsRegex=function(t){return this._monthsParseExact?(d(this,"_monthsRegex")||Vt.call(this),t?this._monthsStrictRegex:this._monthsRegex):(d(this,"_monthsRegex")||(this._monthsRegex=zt),this._monthsStrictRegex&&t?this._monthsStrictRegex:this._monthsRegex)},_i.monthsShortRegex=function(t){return this._monthsParseExact?(d(this,"_monthsRegex")||Vt.call(this),t?this._monthsShortStrictRegex:this._monthsShortRegex):(d(this,"_monthsShortRegex")||(this._monthsShortRegex=Nt),this._monthsShortStrictRegex&&t?this._monthsShortStrictRegex:this._monthsShortRegex)},_i.week=function(t){return jt(t,this._week.dow,this._week.doy).week},_i.firstDayOfYear=function(){return this._week.doy},_i.firstDayOfWeek=function(){return this._week.dow},_i.weekdays=function(t,e){var i=a(this._weekdays)?this._weekdays:this._weekdays[t&&!0!==t&&this._weekdays.isFormat.test(e)?"format":"standalone"];return!0===t?Gt(i,this._week.dow):t?i[t.day()]:i},_i.weekdaysMin=function(t){return!0===t?Gt(this._weekdaysMin,this._week.dow):t?this._weekdaysMin[t.day()]:this._weekdaysMin},_i.weekdaysShort=function(t){return!0===t?Gt(this._weekdaysShort,this._week.dow):t?this._weekdaysShort[t.day()]:this._weekdaysShort},_i.weekdaysParse=function(t,e,i){var n,a,r;if(this._weekdaysParseExact)return function(t,e,i){var n,a,r,o=t.toLocaleLowerCase();if(!this._weekdaysParse)for(this._weekdaysParse=[],this._shortWeekdaysParse=[],this._minWeekdaysParse=[],n=0;n<7;++n)r=c([2e3,1]).day(n),this._minWeekdaysParse[n]=this.weekdaysMin(r,"").toLocaleLowerCase(),this._shortWeekdaysParse[n]=this.weekdaysShort(r,"").toLocaleLowerCase(),this._weekdaysParse[n]=this.weekdays(r,"").toLocaleLowerCase();return i?"dddd"===e?-1!==(a=Ct.call(this._weekdaysParse,o))?a:null:"ddd"===e?-1!==(a=Ct.call(this._shortWeekdaysParse,o))?a:null:-1!==(a=Ct.call(this._minWeekdaysParse,o))?a:null:"dddd"===e?-1!==(a=Ct.call(this._weekdaysParse,o))?a:-1!==(a=Ct.call(this._shortWeekdaysParse,o))?a:-1!==(a=Ct.call(this._minWeekdaysParse,o))?a:null:"ddd"===e?-1!==(a=Ct.call(this._shortWeekdaysParse,o))?a:-1!==(a=Ct.call(this._weekdaysParse,o))?a:-1!==(a=Ct.call(this._minWeekdaysParse,o))?a:null:-1!==(a=Ct.call(this._minWeekdaysParse,o))?a:-1!==(a=Ct.call(this._weekdaysParse,o))?a:-1!==(a=Ct.call(this._shortWeekdaysParse,o))?a:null}.call(this,t,e,i);for(this._weekdaysParse||(this._weekdaysParse=[],this._minWeekdaysParse=[],this._shortWeekdaysParse=[],this._fullWeekdaysParse=[]),n=0;n<7;n++){if(a=c([2e3,1]).day(n),i&&!this._fullWeekdaysParse[n]&&(this._fullWeekdaysParse[n]=new RegExp("^"+this.weekdays(a,"").replace(".","\\.?")+"$","i"),this._shortWeekdaysParse[n]=new RegExp("^"+this.weekdaysShort(a,"").replace(".","\\.?")+"$","i"),this._minWeekdaysParse[n]=new RegExp("^"+this.weekdaysMin(a,"").replace(".","\\.?")+"$","i")),this._weekdaysParse[n]||(r="^"+this.weekdays(a,"")+"|^"+this.weekdaysShort(a,"")+"|^"+this.weekdaysMin(a,""),this._weekdaysParse[n]=new RegExp(r.replace(".",""),"i")),i&&"dddd"===e&&this._fullWeekdaysParse[n].test(t))return n;if(i&&"ddd"===e&&this._shortWeekdaysParse[n].test(t))return n;if(i&&"dd"===e&&this._minWeekdaysParse[n].test(t))return n;if(!i&&this._weekdaysParse[n].test(t))return n}},_i.weekdaysRegex=function(t){return this._weekdaysParseExact?(d(this,"_weekdaysRegex")||Qt.call(this),t?this._weekdaysStrictRegex:this._weekdaysRegex):(d(this,"_weekdaysRegex")||(this._weekdaysRegex=Xt),this._weekdaysStrictRegex&&t?this._weekdaysStrictRegex:this._weekdaysRegex)},_i.weekdaysShortRegex=function(t){return this._weekdaysParseExact?(d(this,"_weekdaysRegex")||Qt.call(this),t?this._weekdaysShortStrictRegex:this._weekdaysShortRegex):(d(this,"_weekdaysShortRegex")||(this._weekdaysShortRegex=Kt),this._weekdaysShortStrictRegex&&t?this._weekdaysShortStrictRegex:this._weekdaysShortRegex)},_i.weekdaysMinRegex=function(t){return this._weekdaysParseExact?(d(this,"_weekdaysRegex")||Qt.call(this),t?this._weekdaysMinStrictRegex:this._weekdaysMinRegex):(d(this,"_weekdaysMinRegex")||(this._weekdaysMinRegex=Jt),this._weekdaysMinStrictRegex&&t?this._weekdaysMinStrictRegex:this._weekdaysMinRegex)},_i.isPM=function(t){return"p"===(t+"").toLowerCase().charAt(0)},_i.meridiem=function(t,e,i){return t>11?i?"pm":"PM":i?"am":"AM"},de("en",{dayOfMonthOrdinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(t){var e=t%10,i=1===k(t%100/10)?"th":1===e?"st":2===e?"nd":3===e?"rd":"th";return t+i}}),n.lang=S("moment.lang is deprecated. Use moment.locale instead.",de),n.langData=S("moment.langData is deprecated. Use moment.localeData instead.",ce);var Si=Math.abs;function Di(t,e,i,n){var a=qe(e,i);return t._milliseconds+=n*a._milliseconds,t._days+=n*a._days,t._months+=n*a._months,t._bubble()}function Ci(t){return t<0?Math.floor(t):Math.ceil(t)}function Pi(t){return 4800*t/146097}function Ti(t){return 146097*t/4800}function Oi(t){return function(){return this.as(t)}}var Ii=Oi("ms"),Ai=Oi("s"),Fi=Oi("m"),Ri=Oi("h"),Li=Oi("d"),Wi=Oi("w"),Yi=Oi("M"),Ni=Oi("Q"),zi=Oi("y");function Vi(t){return function(){return this.isValid()?this._data[t]:NaN}}var Hi=Vi("milliseconds"),Ei=Vi("seconds"),Bi=Vi("minutes"),ji=Vi("hours"),Ui=Vi("days"),Gi=Vi("months"),qi=Vi("years"),Zi=Math.round,$i={ss:44,s:45,m:45,h:22,d:26,M:11},Xi=Math.abs;function Ki(t){return(t>0)-(t<0)||+t}function Ji(){if(!this.isValid())return this.localeData().invalidDate();var t,e,i=Xi(this._milliseconds)/1e3,n=Xi(this._days),a=Xi(this._months);t=_(i/60),e=_(t/60),i%=60,t%=60;var r=_(a/12),o=a%=12,s=n,l=e,u=t,d=i?i.toFixed(3).replace(/\.?0+$/,""):"",h=this.asSeconds();if(!h)return"P0D";var c=h<0?"-":"",f=Ki(this._months)!==Ki(h)?"-":"",g=Ki(this._days)!==Ki(h)?"-":"",m=Ki(this._milliseconds)!==Ki(h)?"-":"";return c+"P"+(r?f+r+"Y":"")+(o?f+o+"M":"")+(s?g+s+"D":"")+(l||u||d?"T":"")+(l?m+l+"H":"")+(u?m+u+"M":"")+(d?m+d+"S":"")}var Qi=We.prototype;return Qi.isValid=function(){return this._isValid},Qi.abs=function(){var t=this._data;return this._milliseconds=Si(this._milliseconds),this._days=Si(this._days),this._months=Si(this._months),t.milliseconds=Si(t.milliseconds),t.seconds=Si(t.seconds),t.minutes=Si(t.minutes),t.hours=Si(t.hours),t.months=Si(t.months),t.years=Si(t.years),this},Qi.add=function(t,e){return Di(this,t,e,1)},Qi.subtract=function(t,e){return Di(this,t,e,-1)},Qi.as=function(t){if(!this.isValid())return NaN;var e,i,n=this._milliseconds;if("month"===(t=R(t))||"quarter"===t||"year"===t)switch(e=this._days+n/864e5,i=this._months+Pi(e),t){case"month":return i;case"quarter":return i/3;case"year":return i/12}else switch(e=this._days+Math.round(Ti(this._months)),t){case"week":return e/7+n/6048e5;case"day":return e+n/864e5;case"hour":return 24*e+n/36e5;case"minute":return 1440*e+n/6e4;case"second":return 86400*e+n/1e3;case"millisecond":return Math.floor(864e5*e)+n;default:throw new Error("Unknown unit "+t)}},Qi.asMilliseconds=Ii,Qi.asSeconds=Ai,Qi.asMinutes=Fi,Qi.asHours=Ri,Qi.asDays=Li,Qi.asWeeks=Wi,Qi.asMonths=Yi,Qi.asQuarters=Ni,Qi.asYears=zi,Qi.valueOf=function(){return this.isValid()?this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*k(this._months/12):NaN},Qi._bubble=function(){var t,e,i,n,a,r=this._milliseconds,o=this._days,s=this._months,l=this._data;return r>=0&&o>=0&&s>=0||r<=0&&o<=0&&s<=0||(r+=864e5*Ci(Ti(s)+o),o=0,s=0),l.milliseconds=r%1e3,t=_(r/1e3),l.seconds=t%60,e=_(t/60),l.minutes=e%60,i=_(e/60),l.hours=i%24,o+=_(i/24),a=_(Pi(o)),s+=a,o-=Ci(Ti(a)),n=_(s/12),s%=12,l.days=o,l.months=s,l.years=n,this},Qi.clone=function(){return qe(this)},Qi.get=function(t){return t=R(t),this.isValid()?this[t+"s"]():NaN},Qi.milliseconds=Hi,Qi.seconds=Ei,Qi.minutes=Bi,Qi.hours=ji,Qi.days=Ui,Qi.weeks=function(){return _(this.days()/7)},Qi.months=Gi,Qi.years=qi,Qi.humanize=function(t){if(!this.isValid())return this.localeData().invalidDate();var e=this.localeData(),i=function(t,e,i){var n=qe(t).abs(),a=Zi(n.as("s")),r=Zi(n.as("m")),o=Zi(n.as("h")),s=Zi(n.as("d")),l=Zi(n.as("M")),u=Zi(n.as("y")),d=a<=$i.ss&&["s",a]||a<$i.s&&["ss",a]||r<=1&&["m"]||r<$i.m&&["mm",r]||o<=1&&["h"]||o<$i.h&&["hh",o]||s<=1&&["d"]||s<$i.d&&["dd",s]||l<=1&&["M"]||l<$i.M&&["MM",l]||u<=1&&["y"]||["yy",u];return d[2]=e,d[3]=+t>0,d[4]=i,function(t,e,i,n,a){return a.relativeTime(e||1,!!i,t,n)}.apply(null,d)}(this,!t,e);return t&&(i=e.pastFuture(+this,i)),e.postformat(i)},Qi.toISOString=Ji,Qi.toString=Ji,Qi.toJSON=Ji,Qi.locale=ei,Qi.localeData=ni,Qi.toIsoString=S("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",Ji),Qi.lang=ii,B("X",0,0,"unix"),B("x",0,0,"valueOf"),ut("x",at),ut("X",/[+-]?\d+(\.\d{1,3})?/),ft("X",function(t,e,i){i._d=new Date(1e3*parseFloat(t,10))}),ft("x",function(t,e,i){i._d=new Date(k(t))}),n.version="2.24.0",e=Ie,n.fn=bi,n.min=function(){return Re("isBefore",[].slice.call(arguments,0))},n.max=function(){return Re("isAfter",[].slice.call(arguments,0))},n.now=function(){return Date.now?Date.now():+new Date},n.utc=c,n.unix=function(t){return Ie(1e3*t)},n.months=function(t,e){return wi(t,e,"months")},n.isDate=l,n.locale=de,n.invalid=m,n.duration=qe,n.isMoment=x,n.weekdays=function(t,e,i){return Mi(t,e,i,"weekdays")},n.parseZone=function(){return Ie.apply(null,arguments).parseZone()},n.localeData=ce,n.isDuration=Ye,n.monthsShort=function(t,e){return wi(t,e,"monthsShort")},n.weekdaysMin=function(t,e,i){return Mi(t,e,i,"weekdaysMin")},n.defineLocale=he,n.updateLocale=function(t,e){if(null!=e){var i,n,a=re;null!=(n=ue(t))&&(a=n._config),e=O(a,e),(i=new I(e)).parentLocale=oe[t],oe[t]=i,de(t)}else null!=oe[t]&&(null!=oe[t].parentLocale?oe[t]=oe[t].parentLocale:null!=oe[t]&&delete oe[t]);return oe[t]},n.locales=function(){return D(oe)},n.weekdaysShort=function(t,e,i){return Mi(t,e,i,"weekdaysShort")},n.normalizeUnits=R,n.relativeTimeRounding=function(t){return void 0===t?Zi:"function"==typeof t&&(Zi=t,!0)},n.relativeTimeThreshold=function(t,e){return void 0!==$i[t]&&(void 0===e?$i[t]:($i[t]=e,"s"===t&&($i.ss=e-1),!0))},n.calendarFormat=function(t,e){var i=t.diff(e,"days",!0);return i<-6?"sameElse":i<-1?"lastWeek":i<0?"lastDay":i<1?"sameDay":i<2?"nextDay":i<7?"nextWeek":"sameElse"},n.prototype=bi,n.HTML5_FMT={DATETIME_LOCAL:"YYYY-MM-DDTHH:mm",DATETIME_LOCAL_SECONDS:"YYYY-MM-DDTHH:mm:ss",DATETIME_LOCAL_MS:"YYYY-MM-DDTHH:mm:ss.SSS",DATE:"YYYY-MM-DD",TIME:"HH:mm",TIME_SECONDS:"HH:mm:ss",TIME_MS:"HH:mm:ss.SSS",WEEK:"GGGG-[W]WW",MONTH:"YYYY-MM"},n}()}(tn={exports:{}},tn.exports),tn.exports),an={datetime:"MMM D, YYYY, h:mm:ss a",millisecond:"h:mm:ss.SSS a",second:"h:mm:ss a",minute:"h:mm a",hour:"hA",day:"MMM D",week:"ll",month:"MMM YYYY",quarter:"[Q]Q - YYYY",year:"YYYY"};si._date.override("function"==typeof nn?{_id:"moment",formats:function(){return an},parse:function(t,e){return"string"==typeof t&&"string"==typeof e?t=nn(t,e):t instanceof nn||(t=nn(t)),t.isValid()?t.valueOf():null},format:function(t,e){return nn(t).format(e)},add:function(t,e,i){return nn(t).add(e,i).valueOf()},diff:function(t,e,i){return nn.duration(nn(t).diff(nn(e))).as(i)},startOf:function(t,e,i){return t=nn(t),"isoWeek"===e?t.isoWeekday(i).valueOf():t.startOf(e).valueOf()},endOf:function(t,e){return nn(t).endOf(e).valueOf()},_create:function(t){return nn(t)}}:{}),ot._set("global",{plugins:{filler:{propagate:!0}}});var rn={dataset:function(t){var e=t.fill,i=t.chart,n=i.getDatasetMeta(e),a=n&&i.isDatasetVisible(e)&&n.dataset._children||[],r=a.length||0;return r?function(t,e){return e<r&&a[e]._view||null}:null},boundary:function(t){var e=t.boundary,i=e?e.x:null,n=e?e.y:null;return function(t){return{x:null===i?t.x:i,y:null===n?t.y:n}}}};function on(t,e,i){var n,a=t._model||{},r=a.fill;if(void 0===r&&(r=!!a.backgroundColor),!1===r||null===r)return!1;if(!0===r)return"origin";if(n=parseFloat(r,10),isFinite(n)&&Math.floor(n)===n)return"-"!==r[0]&&"+"!==r[0]||(n=e+n),!(n===e||n<0||n>=i)&&n;switch(r){case"bottom":return"start";case"top":return"end";case"zero":return"origin";case"origin":case"start":case"end":return r;default:return!1}}function sn(t){var e,i=t.el._model||{},n=t.el._scale||{},a=t.fill,r=null;if(isFinite(a))return null;if("start"===a?r=void 0===i.scaleBottom?n.bottom:i.scaleBottom:"end"===a?r=void 0===i.scaleTop?n.top:i.scaleTop:void 0!==i.scaleZero?r=i.scaleZero:n.getBasePosition?r=n.getBasePosition():n.getBasePixel&&(r=n.getBasePixel()),null!=r){if(void 0!==r.x&&void 0!==r.y)return r;if(ut.isFinite(r))return{x:(e=n.isHorizontal())?r:null,y:e?null:r}}return null}function ln(t,e,i){var n,a=t[e].fill,r=[e];if(!i)return a;for(;!1!==a&&-1===r.indexOf(a);){if(!isFinite(a))return a;if(!(n=t[a]))return!1;if(n.visible)return a;r.push(a),a=n.fill}return!1}function un(t){var e=t.fill,i="dataset";return!1===e?null:(isFinite(e)||(i="boundary"),rn[i](t))}function dn(t){return t&&!t.skip}function hn(t,e,i,n,a){var r;if(n&&a){for(t.moveTo(e[0].x,e[0].y),r=1;r<n;++r)ut.canvas.lineTo(t,e[r-1],e[r]);for(t.lineTo(i[a-1].x,i[a-1].y),r=a-1;r>0;--r)ut.canvas.lineTo(t,i[r],i[r-1],!0)}}var cn={id:"filler",afterDatasetsUpdate:function(t,e){var i,n,a,r,o=(t.data.datasets||[]).length,s=e.propagate,l=[];for(n=0;n<o;++n)r=null,(a=(i=t.getDatasetMeta(n)).dataset)&&a._model&&a instanceof Nt.Line&&(r={visible:t.isDatasetVisible(n),fill:on(a,n,o),chart:t,el:a}),i.$filler=r,l.push(r);for(n=0;n<o;++n)(r=l[n])&&(r.fill=ln(l,n,s),r.boundary=sn(r),r.mapper=un(r))},beforeDatasetDraw:function(t,e){var i=e.meta.$filler;if(i){var n=t.ctx,a=i.el,r=a._view,o=a._children||[],s=i.mapper,l=r.backgroundColor||ot.global.defaultColor;s&&l&&o.length&&(ut.canvas.clipArea(n,t.chartArea),function(t,e,i,n,a,r){var o,s,l,u,d,h,c,f=e.length,g=n.spanGaps,m=[],p=[],v=0,y=0;for(t.beginPath(),o=0,s=f+!!r;o<s;++o)d=i(u=e[l=o%f]._view,l,n),h=dn(u),c=dn(d),h&&c?(v=m.push(u),y=p.push(d)):v&&y&&(g?(h&&m.push(u),c&&p.push(d)):(hn(t,m,p,v,y),v=y=0,m=[],p=[]));hn(t,m,p,v,y),t.closePath(),t.fillStyle=a,t.fill()}(n,o,s,r,l,a._loop),ut.canvas.unclipArea(n))}}},fn=ut.noop,gn=ut.valueOrDefault;function mn(t,e){return t.usePointStyle&&t.boxWidth>e?e:t.boxWidth}ot._set("global",{legend:{display:!0,position:"top",fullWidth:!0,reverse:!1,weight:1e3,onClick:function(t,e){var i=e.datasetIndex,n=this.chart,a=n.getDatasetMeta(i);a.hidden=null===a.hidden?!n.data.datasets[i].hidden:null,n.update()},onHover:null,onLeave:null,labels:{boxWidth:40,padding:10,generateLabels:function(t){var e=t.data;return ut.isArray(e.datasets)?e.datasets.map(function(e,i){return{text:e.label,fillStyle:ut.isArray(e.backgroundColor)?e.backgroundColor[0]:e.backgroundColor,hidden:!t.isDatasetVisible(i),lineCap:e.borderCapStyle,lineDash:e.borderDash,lineDashOffset:e.borderDashOffset,lineJoin:e.borderJoinStyle,lineWidth:e.borderWidth,strokeStyle:e.borderColor,pointStyle:e.pointStyle,datasetIndex:i}},this):[]}}},legendCallback:function(t){var e=[];e.push('<ul class="'+t.id+'-legend">');for(var i=0;i<t.data.datasets.length;i++)e.push('<li><span style="background-color:'+t.data.datasets[i].backgroundColor+'"></span>'),t.data.datasets[i].label&&e.push(t.data.datasets[i].label),e.push("</li>");return e.push("</ul>"),e.join("")}});var pn=gt.extend({initialize:function(t){ut.extend(this,t),this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1},beforeUpdate:fn,update:function(t,e,i){var n=this;return n.beforeUpdate(),n.maxWidth=t,n.maxHeight=e,n.margins=i,n.beforeSetDimensions(),n.setDimensions(),n.afterSetDimensions(),n.beforeBuildLabels(),n.buildLabels(),n.afterBuildLabels(),n.beforeFit(),n.fit(),n.afterFit(),n.afterUpdate(),n.minSize},afterUpdate:fn,beforeSetDimensions:fn,setDimensions:function(){var t=this;t.isHorizontal()?(t.width=t.maxWidth,t.left=0,t.right=t.width):(t.height=t.maxHeight,t.top=0,t.bottom=t.height),t.paddingLeft=0,t.paddingTop=0,t.paddingRight=0,t.paddingBottom=0,t.minSize={width:0,height:0}},afterSetDimensions:fn,beforeBuildLabels:fn,buildLabels:function(){var t=this,e=t.options.labels||{},i=ut.callback(e.generateLabels,[t.chart],t)||[];e.filter&&(i=i.filter(function(i){return e.filter(i,t.chart.data)})),t.options.reverse&&i.reverse(),t.legendItems=i},afterBuildLabels:fn,beforeFit:fn,fit:function(){var t=this,e=t.options,i=e.labels,n=e.display,a=t.ctx,r=ut.options._parseFont(i),o=r.size,s=t.legendHitBoxes=[],l=t.minSize,u=t.isHorizontal();if(u?(l.width=t.maxWidth,l.height=n?10:0):(l.width=n?10:0,l.height=t.maxHeight),n)if(a.font=r.string,u){var d=t.lineWidths=[0],h=0;a.textAlign="left",a.textBaseline="top",ut.each(t.legendItems,function(t,e){var n=mn(i,o)+o/2+a.measureText(t.text).width;(0===e||d[d.length-1]+n+i.padding>l.width)&&(h+=o+i.padding,d[d.length-(e>0?0:1)]=i.padding),s[e]={left:0,top:0,width:n,height:o},d[d.length-1]+=n+i.padding}),l.height+=h}else{var c=i.padding,f=t.columnWidths=[],g=i.padding,m=0,p=0,v=o+c;ut.each(t.legendItems,function(t,e){var n=mn(i,o)+o/2+a.measureText(t.text).width;e>0&&p+v>l.height-c&&(g+=m+i.padding,f.push(m),m=0,p=0),m=Math.max(m,n),p+=v,s[e]={left:0,top:0,width:n,height:o}}),g+=m,f.push(m),l.width+=g}t.width=l.width,t.height=l.height},afterFit:fn,isHorizontal:function(){return"top"===this.options.position||"bottom"===this.options.position},draw:function(){var t=this,e=t.options,i=e.labels,n=ot.global,a=n.defaultColor,r=n.elements.line,o=t.width,s=t.lineWidths;if(e.display){var l,u=t.ctx,d=gn(i.fontColor,n.defaultFontColor),h=ut.options._parseFont(i),c=h.size;u.textAlign="left",u.textBaseline="middle",u.lineWidth=.5,u.strokeStyle=d,u.fillStyle=d,u.font=h.string;var f=mn(i,c),g=t.legendHitBoxes,m=t.isHorizontal();l=m?{x:t.left+(o-s[0])/2+i.padding,y:t.top+i.padding,line:0}:{x:t.left+i.padding,y:t.top+i.padding,line:0};var p=c+i.padding;ut.each(t.legendItems,function(n,d){var h=u.measureText(n.text).width,v=f+c/2+h,y=l.x,b=l.y;m?d>0&&y+v+i.padding>t.left+t.minSize.width&&(b=l.y+=p,l.line++,y=l.x=t.left+(o-s[l.line])/2+i.padding):d>0&&b+p>t.top+t.minSize.height&&(y=l.x=y+t.columnWidths[l.line]+i.padding,b=l.y=t.top+i.padding,l.line++),function(t,i,n){if(!(isNaN(f)||f<=0)){u.save();var o=gn(n.lineWidth,r.borderWidth);if(u.fillStyle=gn(n.fillStyle,a),u.lineCap=gn(n.lineCap,r.borderCapStyle),u.lineDashOffset=gn(n.lineDashOffset,r.borderDashOffset),u.lineJoin=gn(n.lineJoin,r.borderJoinStyle),u.lineWidth=o,u.strokeStyle=gn(n.strokeStyle,a),u.setLineDash&&u.setLineDash(gn(n.lineDash,r.borderDash)),e.labels&&e.labels.usePointStyle){var s=f*Math.SQRT2/2,l=t+f/2,d=i+c/2;ut.canvas.drawPoint(u,n.pointStyle,s,l,d)}else 0!==o&&u.strokeRect(t,i,f,c),u.fillRect(t,i,f,c);u.restore()}}(y,b,n),g[d].left=y,g[d].top=b,function(t,e,i,n){var a=c/2,r=f+a+t,o=e+a;u.fillText(i.text,r,o),i.hidden&&(u.beginPath(),u.lineWidth=2,u.moveTo(r,o),u.lineTo(r+n,o),u.stroke())}(y,b,n,h),m?l.x+=v+i.padding:l.y+=p})}},_getLegendItemAt:function(t,e){var i,n,a,r=this;if(t>=r.left&&t<=r.right&&e>=r.top&&e<=r.bottom)for(a=r.legendHitBoxes,i=0;i<a.length;++i)if(t>=(n=a[i]).left&&t<=n.left+n.width&&e>=n.top&&e<=n.top+n.height)return r.legendItems[i];return null},handleEvent:function(t){var e,i=this,n=i.options,a="mouseup"===t.type?"click":t.type;if("mousemove"===a){if(!n.onHover&&!n.onLeave)return}else{if("click"!==a)return;if(!n.onClick)return}e=i._getLegendItemAt(t.x,t.y),"click"===a?e&&n.onClick&&n.onClick.call(i,t.native,e):(n.onLeave&&e!==i._hoveredItem&&(i._hoveredItem&&n.onLeave.call(i,t.native,i._hoveredItem),i._hoveredItem=e),n.onHover&&e&&n.onHover.call(i,t.native,e))}});function vn(t,e){var i=new pn({ctx:t.ctx,options:e,chart:t});xe.configure(t,i,e),xe.addBox(t,i),t.legend=i}var yn={id:"legend",_element:pn,beforeInit:function(t){var e=t.options.legend;e&&vn(t,e)},beforeUpdate:function(t){var e=t.options.legend,i=t.legend;e?(ut.mergeIf(e,ot.global.legend),i?(xe.configure(t,i,e),i.options=e):vn(t,e)):i&&(xe.removeBox(t,i),delete t.legend)},afterEvent:function(t,e){var i=t.legend;i&&i.handleEvent(e)}},bn=ut.noop;ot._set("global",{title:{display:!1,fontStyle:"bold",fullWidth:!0,padding:10,position:"top",text:"",weight:2e3}});var xn=gt.extend({initialize:function(t){ut.extend(this,t),this.legendHitBoxes=[]},beforeUpdate:bn,update:function(t,e,i){var n=this;return n.beforeUpdate(),n.maxWidth=t,n.maxHeight=e,n.margins=i,n.beforeSetDimensions(),n.setDimensions(),n.afterSetDimensions(),n.beforeBuildLabels(),n.buildLabels(),n.afterBuildLabels(),n.beforeFit(),n.fit(),n.afterFit(),n.afterUpdate(),n.minSize},afterUpdate:bn,beforeSetDimensions:bn,setDimensions:function(){var t=this;t.isHorizontal()?(t.width=t.maxWidth,t.left=0,t.right=t.width):(t.height=t.maxHeight,t.top=0,t.bottom=t.height),t.paddingLeft=0,t.paddingTop=0,t.paddingRight=0,t.paddingBottom=0,t.minSize={width:0,height:0}},afterSetDimensions:bn,beforeBuildLabels:bn,buildLabels:bn,afterBuildLabels:bn,beforeFit:bn,fit:function(){var t=this,e=t.options,i=e.display,n=t.minSize,a=ut.isArray(e.text)?e.text.length:1,r=ut.options._parseFont(e),o=i?a*r.lineHeight+2*e.padding:0;t.isHorizontal()?(n.width=t.maxWidth,n.height=o):(n.width=o,n.height=t.maxHeight),t.width=n.width,t.height=n.height},afterFit:bn,isHorizontal:function(){var t=this.options.position;return"top"===t||"bottom"===t},draw:function(){var t=this,e=t.ctx,i=t.options;if(i.display){var n,a,r,o=ut.options._parseFont(i),s=o.lineHeight,l=s/2+i.padding,u=0,d=t.top,h=t.left,c=t.bottom,f=t.right;e.fillStyle=ut.valueOrDefault(i.fontColor,ot.global.defaultFontColor),e.font=o.string,t.isHorizontal()?(a=h+(f-h)/2,r=d+l,n=f-h):(a="left"===i.position?h+l:f-l,r=d+(c-d)/2,n=c-d,u=Math.PI*("left"===i.position?-.5:.5)),e.save(),e.translate(a,r),e.rotate(u),e.textAlign="center",e.textBaseline="middle";var g=i.text;if(ut.isArray(g))for(var m=0,p=0;p<g.length;++p)e.fillText(g[p],0,m,n),m+=s;else e.fillText(g,0,0,n);e.restore()}}});function _n(t,e){var i=new xn({ctx:t.ctx,options:e,chart:t});xe.configure(t,i,e),xe.addBox(t,i),t.titleBlock=i}var kn={},wn=cn,Mn=yn,Sn={id:"title",_element:xn,beforeInit:function(t){var e=t.options.title;e&&_n(t,e)},beforeUpdate:function(t){var e=t.options.title,i=t.titleBlock;e?(ut.mergeIf(e,ot.global.title),i?(xe.configure(t,i,e),i.options=e):_n(t,e)):i&&(xe.removeBox(t,i),delete t.titleBlock)}};for(var Dn in kn.filler=wn,kn.legend=Mn,kn.title=Sn,ai.helpers=ut,function(){function t(t,e,i){var n;return"string"==typeof t?(n=parseInt(t,10),-1!==t.indexOf("%")&&(n=n/100*e.parentNode[i])):n=t,n}function e(t){return null!=t&&"none"!==t}function i(i,n,a){var r=document.defaultView,o=ut._getParentNode(i),s=r.getComputedStyle(i)[n],l=r.getComputedStyle(o)[n],u=e(s),d=e(l),h=Number.POSITIVE_INFINITY;return u||d?Math.min(u?t(s,i,a):h,d?t(l,o,a):h):"none"}ut.where=function(t,e){if(ut.isArray(t)&&Array.prototype.filter)return t.filter(e);var i=[];return ut.each(t,function(t){e(t)&&i.push(t)}),i},ut.findIndex=Array.prototype.findIndex?function(t,e,i){return t.findIndex(e,i)}:function(t,e,i){i=void 0===i?t:i;for(var n=0,a=t.length;n<a;++n)if(e.call(i,t[n],n,t))return n;return-1},ut.findNextWhere=function(t,e,i){ut.isNullOrUndef(i)&&(i=-1);for(var n=i+1;n<t.length;n++){var a=t[n];if(e(a))return a}},ut.findPreviousWhere=function(t,e,i){ut.isNullOrUndef(i)&&(i=t.length);for(var n=i-1;n>=0;n--){var a=t[n];if(e(a))return a}},ut.isNumber=function(t){return!isNaN(parseFloat(t))&&isFinite(t)},ut.almostEquals=function(t,e,i){return Math.abs(t-e)<i},ut.almostWhole=function(t,e){var i=Math.round(t);return i-e<t&&i+e>t},ut.max=function(t){return t.reduce(function(t,e){return isNaN(e)?t:Math.max(t,e)},Number.NEGATIVE_INFINITY)},ut.min=function(t){return t.reduce(function(t,e){return isNaN(e)?t:Math.min(t,e)},Number.POSITIVE_INFINITY)},ut.sign=Math.sign?function(t){return Math.sign(t)}:function(t){return 0==(t=+t)||isNaN(t)?t:t>0?1:-1},ut.log10=Math.log10?function(t){return Math.log10(t)}:function(t){var e=Math.log(t)*Math.LOG10E,i=Math.round(e);return t===Math.pow(10,i)?i:e},ut.toRadians=function(t){return t*(Math.PI/180)},ut.toDegrees=function(t){return t*(180/Math.PI)},ut._decimalPlaces=function(t){if(ut.isFinite(t)){for(var e=1,i=0;Math.round(t*e)/e!==t;)e*=10,i++;return i}},ut.getAngleFromPoint=function(t,e){var i=e.x-t.x,n=e.y-t.y,a=Math.sqrt(i*i+n*n),r=Math.atan2(n,i);return r<-.5*Math.PI&&(r+=2*Math.PI),{angle:r,distance:a}},ut.distanceBetweenPoints=function(t,e){return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))},ut.aliasPixel=function(t){return t%2==0?0:.5},ut._alignPixel=function(t,e,i){var n=t.currentDevicePixelRatio,a=i/2;return Math.round((e-a)*n)/n+a},ut.splineCurve=function(t,e,i,n){var a=t.skip?e:t,r=e,o=i.skip?e:i,s=Math.sqrt(Math.pow(r.x-a.x,2)+Math.pow(r.y-a.y,2)),l=Math.sqrt(Math.pow(o.x-r.x,2)+Math.pow(o.y-r.y,2)),u=s/(s+l),d=l/(s+l),h=n*(u=isNaN(u)?0:u),c=n*(d=isNaN(d)?0:d);return{previous:{x:r.x-h*(o.x-a.x),y:r.y-h*(o.y-a.y)},next:{x:r.x+c*(o.x-a.x),y:r.y+c*(o.y-a.y)}}},ut.EPSILON=Number.EPSILON||1e-14,ut.splineCurveMonotone=function(t){var e,i,n,a,r,o,s,l,u,d=(t||[]).map(function(t){return{model:t._model,deltaK:0,mK:0}}),h=d.length;for(e=0;e<h;++e)if(!(n=d[e]).model.skip){if(i=e>0?d[e-1]:null,(a=e<h-1?d[e+1]:null)&&!a.model.skip){var c=a.model.x-n.model.x;n.deltaK=0!==c?(a.model.y-n.model.y)/c:0}!i||i.model.skip?n.mK=n.deltaK:!a||a.model.skip?n.mK=i.deltaK:this.sign(i.deltaK)!==this.sign(n.deltaK)?n.mK=0:n.mK=(i.deltaK+n.deltaK)/2}for(e=0;e<h-1;++e)n=d[e],a=d[e+1],n.model.skip||a.model.skip||(ut.almostEquals(n.deltaK,0,this.EPSILON)?n.mK=a.mK=0:(r=n.mK/n.deltaK,o=a.mK/n.deltaK,(l=Math.pow(r,2)+Math.pow(o,2))<=9||(s=3/Math.sqrt(l),n.mK=r*s*n.deltaK,a.mK=o*s*n.deltaK)));for(e=0;e<h;++e)(n=d[e]).model.skip||(i=e>0?d[e-1]:null,a=e<h-1?d[e+1]:null,i&&!i.model.skip&&(u=(n.model.x-i.model.x)/3,n.model.controlPointPreviousX=n.model.x-u,n.model.controlPointPreviousY=n.model.y-u*n.mK),a&&!a.model.skip&&(u=(a.model.x-n.model.x)/3,n.model.controlPointNextX=n.model.x+u,n.model.controlPointNextY=n.model.y+u*n.mK))},ut.nextItem=function(t,e,i){return i?e>=t.length-1?t[0]:t[e+1]:e>=t.length-1?t[t.length-1]:t[e+1]},ut.previousItem=function(t,e,i){return i?e<=0?t[t.length-1]:t[e-1]:e<=0?t[0]:t[e-1]},ut.niceNum=function(t,e){var i=Math.floor(ut.log10(t)),n=t/Math.pow(10,i);return(e?n<1.5?1:n<3?2:n<7?5:10:n<=1?1:n<=2?2:n<=5?5:10)*Math.pow(10,i)},ut.requestAnimFrame="undefined"==typeof window?function(t){t()}:window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(t){return window.setTimeout(t,1e3/60)},ut.getRelativePosition=function(t,e){var i,n,a=t.originalEvent||t,r=t.target||t.srcElement,o=r.getBoundingClientRect(),s=a.touches;s&&s.length>0?(i=s[0].clientX,n=s[0].clientY):(i=a.clientX,n=a.clientY);var l=parseFloat(ut.getStyle(r,"padding-left")),u=parseFloat(ut.getStyle(r,"padding-top")),d=parseFloat(ut.getStyle(r,"padding-right")),h=parseFloat(ut.getStyle(r,"padding-bottom")),c=o.right-o.left-l-d,f=o.bottom-o.top-u-h;return{x:i=Math.round((i-o.left-l)/c*r.width/e.currentDevicePixelRatio),y:n=Math.round((n-o.top-u)/f*r.height/e.currentDevicePixelRatio)}},ut.getConstraintWidth=function(t){return i(t,"max-width","clientWidth")},ut.getConstraintHeight=function(t){return i(t,"max-height","clientHeight")},ut._calculatePadding=function(t,e,i){return(e=ut.getStyle(t,e)).indexOf("%")>-1?i*parseInt(e,10)/100:parseInt(e,10)},ut._getParentNode=function(t){var e=t.parentNode;return e&&"[object ShadowRoot]"===e.toString()&&(e=e.host),e},ut.getMaximumWidth=function(t){var e=ut._getParentNode(t);if(!e)return t.clientWidth;var i=e.clientWidth,n=i-ut._calculatePadding(e,"padding-left",i)-ut._calculatePadding(e,"padding-right",i),a=ut.getConstraintWidth(t);return isNaN(a)?n:Math.min(n,a)},ut.getMaximumHeight=function(t){var e=ut._getParentNode(t);if(!e)return t.clientHeight;var i=e.clientHeight,n=i-ut._calculatePadding(e,"padding-top",i)-ut._calculatePadding(e,"padding-bottom",i),a=ut.getConstraintHeight(t);return isNaN(a)?n:Math.min(n,a)},ut.getStyle=function(t,e){return t.currentStyle?t.currentStyle[e]:document.defaultView.getComputedStyle(t,null).getPropertyValue(e)},ut.retinaScale=function(t,e){var i=t.currentDevicePixelRatio=e||"undefined"!=typeof window&&window.devicePixelRatio||1;if(1!==i){var n=t.canvas,a=t.height,r=t.width;n.height=a*i,n.width=r*i,t.ctx.scale(i,i),n.style.height||n.style.width||(n.style.height=a+"px",n.style.width=r+"px")}},ut.fontString=function(t,e,i){return e+" "+t+"px "+i},ut.longestText=function(t,e,i,n){var a=(n=n||{}).data=n.data||{},r=n.garbageCollect=n.garbageCollect||[];n.font!==e&&(a=n.data={},r=n.garbageCollect=[],n.font=e),t.font=e;var o=0;ut.each(i,function(e){null!=e&&!0!==ut.isArray(e)?o=ut.measureText(t,a,r,o,e):ut.isArray(e)&&ut.each(e,function(e){null==e||ut.isArray(e)||(o=ut.measureText(t,a,r,o,e))})});var s=r.length/2;if(s>i.length){for(var l=0;l<s;l++)delete a[r[l]];r.splice(0,s)}return o},ut.measureText=function(t,e,i,n,a){var r=e[a];return r||(r=e[a]=t.measureText(a).width,i.push(a)),r>n&&(n=r),n},ut.numberOfLabelLines=function(t){var e=1;return ut.each(t,function(t){ut.isArray(t)&&t.length>e&&(e=t.length)}),e},ut.color=G?function(t){return t instanceof CanvasGradient&&(t=ot.global.defaultColor),G(t)}:function(t){return console.error("Color.js not found!"),t},ut.getHoverColor=function(t){return t instanceof CanvasPattern||t instanceof CanvasGradient?t:ut.color(t).saturate(.5).darken(.1).rgbString()}}(),ai._adapters=si,ai.Animation=pt,ai.animationService=vt,ai.controllers=ue,ai.DatasetController=kt,ai.defaults=ot,ai.Element=gt,ai.elements=Nt,ai.Interaction=pe,ai.layouts=xe,ai.platform=Ve,ai.plugins=He,ai.Scale=fi,ai.scaleService=Ee,ai.Ticks=li,ai.Tooltip=Je,ai.helpers.each(en,function(t,e){ai.scaleService.registerScaleType(e,t,t._defaults)}),kn)kn.hasOwnProperty(Dn)&&ai.plugins.register(kn[Dn]);ai.platform.initialize();var Cn=ai;return"undefined"!=typeof window&&(window.Chart=ai),ai.Chart=ai,ai.Legend=kn.legend._element,ai.Title=kn.title._element,ai.pluginService=ai.plugins,ai.PluginBase=ai.Element.extend({}),ai.canvasHelpers=ai.helpers.canvas,ai.layoutService=ai.layouts,ai.LinearScaleBase=yi,ai.helpers.each(["Bar","Bubble","Doughnut","Line","PolarArea","Radar","Scatter"],function(t){ai[t]=function(e,i){return new ai(e,ai.helpers.merge(i||{},{type:t.charAt(0).toLowerCase()+t.slice(1)}))}}),Cn});
                                                                                                                                                                                                                                                                                                                                                                                                   CLOSEI~1PNG   kXX kX$  AC U S T O  M I Z E . P   N G CUSTOM~1PNG   kXX kXd  D       GIF   kXX kX  D       PNG   kXX kXo  BG      D _ P N L  _ C U S T .   P N D_PNL_~1PNG   kXX kXN;  BG    @  D _ P N L  @_ F R E E .   P N D_PNL_~2PNG   kXX kX$J!  AD _ P N L  _ O R T . P   N G D_PNL_~3PNG   kXX kX5"  AD _ P N L  _ T C P . P   N G D_PNL_~4PNG   kXX kXDG   DESC    GIF   kXX kXU6   PNG

   IHDR           szz   sRGB    gAMA  a   	pHYs    od   IDATXGk
06'q71l#%Dm{GF{W1FxVn%e4u*%*nSZX 0p Q@D@- `K@* J82\S"=[ s#T%aEsj]Qn(Z6lqDF4#K]U 8    IENDB`                                                                                                                                                                                                                            PNG

   IHDR   P   P      	pHYs    +    IDATxPd                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           V   W                                                                                                                                                                                                                                                                                                  +                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             TU        V   T                                                                                                                                                                                                                                                                                                              +                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               4   O   <                                                                                                                                              :    VV                                                                                                                     ##                                                                                                             !    CB                                                                                                                                                                                                                                             CB                                                                                                                                                                                                                                     #"                                                                                                                                                                                                                                                                                                                                                                                                                 Pb    IDAT                                     VU                                                                                                                                                                                                                          $                                                                                                  &                                                                                                                                                                                                               3   $                                                                                                   $   2                                                                                                                                                                                                                   P                                                                                                           P                                                                                                                                                                                                                   <                                                                                                           =                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 $                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         $                                                                                                  &                                                                                                                                                                                                               {                                                                                                   z                                                                                                                                                                                                                                                                                                                                                                                                                                                  #"                                                                                                                                                                                                                                     BB                                                                                                     !    BB                                                                                                             #"                                                                                                             :    UU                                                                                                                                                                                                                                                                3   O   =                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    $$                                                                                                                                                                                                     ((                                                                                                                                                                                                                                                                                                                             ;         IDAT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       $                                                                                                                                        '                                                                                                                                                                                   i                                                                                                                                         h                                                                                                                                                                           1                                                                                                                                           1                                                                                                                                                                                                                                                                                                                                     V   W                                                                                                                                                                                                                                                                                                +                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         TU        V   T                                                                                                                                                                                                                                                                                                              +                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       `  [IDAT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                +F[B[p    IENDB`                                                                                                                                                                                                                                                                                                                   GIF89al H      ttz}rujmx=BN`eq6UYbKNU(/=_gw\`hZct[duZanX_kccWTFmC(6,3YG" "%:V=+ ) ' K1lTv^1 1 . jKs5 :fnDY%d=BKPPb.h2alyt;{GR\l{Zo2@l$RuCpoinsy (.14qYcffhhjlkmWehjlr    ++++==IIkk!   ,    l H   	H*\!8Q"3jA:(S:e.cl%,g2 O `%@"-z( DeAP{R-VVb+>&-t-Zp4.'g|4@j5\x?=Kw!'4[FqZVm#8?MNn)~"0A|	p"!Llg#;?a?#g&j	F+A% CB#;p;,@sDf<C  O4Ce>&`.F=!s?
Fx!&dq GTp#<1a$Q&4`r%Xb
C @	OPS=7;hI9|QGvj\@GH aWqg[?U2( $+ (=5LZeh:7\!j[ AFXGqnq|in P@
[=*{;
!ldDbq[P>e$[/[<s=5$K%cAjxCZttR,9# TW]u <f= LxQBg	4A8S4D_A@#qmo%==35sl7A|?D4=>JNPnH?"2
BO\3ODH0C8TQ\-`
?@hG@@QJ<LTK `gx .P_p`x
G<lD@1wp8!g@<HD{ D%*A&NBc	,\ x'?.z@3f}<x4$#HAK08 wABp!a8r$XE*RqSl(%MRPE*Z0h0ZANA^f/kq
H2}R ROd "F7h.]/x1+rx@LE(D1
R<*n.? OI0e,7{qrdRT&Z E.d1]sNz%A6~'J	6]x.~PBHEV<AYxPF2\f 4C
ZHZh
[+@.6l "J*p*JtU] #PK	[Qu  C.A!H\e  BSc Te3;Wg>c
$@%$b*?B^U`2Zbm{[XA"f8?0QT"S]Fuq]&xtS];Te]"QnW;?sqhU~<Iz=OLW|( Ac]@8HF.# *l1@5'/``|r,d`>`E8^l)FA:@LY~,tg:.0F;H%WJ[h@.V",YD,5Wj:"0H[m0 d@qry`kl#59Qs!ao(lTGrA;\ `Cd51q'BM1[[36@ q <W!u4j['$D5(.C08z!nY@B08"iA
H	yg>!P!zOBl07Zp!Cplx]}lo[T'cCHqnDgM6m|5'y ;                                                                     PNG

   IHDR   l   H   [   	pHYs       
OiCCPPhotoshop ICC profile  xSgTS=BKKoR RB&*!	J!QEEQ,
!{k>H3Q5B.@
$p d!s# ~<<+" x M0B\t8K @zB @F&S  `cb P- `' { [!  eD h; VE X0 fK9 - 0IWfH    0Q) { `##x  FW<+*  x<$9E[-qWW.(I+6aa@.y24  x6_-"bbp@  t~,/;m%h^uf@ Wp~<<EJB[aW}g_Wl~<$2]GL	bG"IbX*QqD2"B)%d,>5 j>{-]cK'Xt  o(hw?G% fIq  ^D$.T?  D*A,`6B$BB
dr`)B(*`/@4Qhp.U=pa(	Aa!bX#!H$ Q"K5H1RT UH=r9\F; 2G1Q=C7Fdt1r=6h>C03l0.B8,	c"VcwE	6wB aAHXLXNH $4	7	Q'"K&b21XH,#/{C7$C2'ITFnR#,4H#dk9, +3![
b@qS(RjJ4e2AURT5ZBRQ4u9IKhhitNWGwg(gwLT071oUX**|
J&*/TUUT^S}FU3S	UPSSg;goT?~YYLOCQ_ cx,!ku5&|v*=9C3J3WRf?qtN	(~))4L1e\kXHQG6EYAJ'\'GgSS
M=:.kDwn^Loy}/TmGX$<5qo</QC]@Caa<FFi\$mm&&!&KMMRM);L;L5=12`ZxZ,eIZYnZ9YXUZ]F%NNgm}agbg}}=Z~sr:V:?}/gX3)iSGggsK.>.Jtq]z6i4)Y3sCQ?0k~OCOg#/c/Wwa>>r><72Y_7Oo_C#dz %gA[z|!?:eAAA!h!iP~aa~'W?pX15wCsDDDg1O9-J5*>.j<74?.fYXXIlK9.*6nl{/]py.,:@LN8A*%w%
yg"/6C\*NH*Mz5y$3,'LL:v m2=:1qB!Mggfven/kY-
BTZ(*geWf9+7KW-Xj9<qy
+V<*mOW~&zMk^kU
}]OX/Ya>(xodff-[nVE/(C<e;?TTTT6an{4[>UUMfeI?m]Nmq#=TR+Gw-6U#pDy	:v{vg/jBFS[b[O>zG4<YyJTig}~.`{cjotE;;\tWW:_mt<O\kz{f7y9=zo~r'w'O_@AC?[jwGC8>99?rCd&/~m|x31^VwwO| (hSc3-    cHRM  z%        u0  `  :  o_F  IDATxyT?U`aA0.1x,"1	$O4&QQ1b4!JQ%0k3koR^fez`XgzPJ1NmcVSYd 6hzW.3%'N,3ly%k;Nyj'J/1P5#a0/m&va{^3u<W9WMz	Qx&vb'*4A6lhazGKNy^am ad`d`dgUahsb&K,ZJy^4g
uRflJ+X[M~jjl$Mok_1%09s(--P(uR}>W]uaq#hRK:D#&3|Ip6MJ\Wm_yJ9n~dJ .J)>-Sz p$AL7[%RRXXXH)R"@BM	i|k"Ze*-pGC>r*Rh9[G;6MG5<.n 8(y]v ]g;.d-n-imv 
s1#U/|z~t$,q:t ]Jq'Qm7g Uy*Hibv}ID4!K-shre V8*VRv9zq,U.p=~"'_aY0xO!>F=CaIU8K4t]qluj*'QB!E>=MD1P&T4r\/D3GUMUyUM 8`[QM2.B{~r`owR* ,/i.1	uu>(:H&vtpMCLRf=qtC--CG45-%1NbI_+@ur	[)%c#H&F<xuIVlm~qYMFZjEi[@K(H9is #fa{qJAs;[R$(&R"5WBVZB!e3mq(HCGlOJ_>la#X1xOLG9$`fz2 s1*1	madVBu>V8P`a{ZIYSw/OP{4O|ba|/K'	NF,+{P		Hw	Dl:"DuH%\l:&[uM5;FnGQ2^>1eBSZQJEc XIIN%tmC22,u]O!RnYIm
t_rqq$,^uMisYdd{pOeS>_q>Q_SK+aHQM4g{0{%5va5.q9er1. 0W3<8*uRS8^"34	"fSM%brl=x?+x<CoP]2.\{]3u]4Mcqm'I$lN;1	,iy9*S+D$vlJkw:thofK w~''tJn6p#lqcF,l]c7&m{Efd43g_^\a#Y__a^y<ONGl&M[]EvmN2iNy]s|n<)cc\{%AA6FMvJ@*@WHkt*v_Am|>Wb=R-c2Otqc)GH!5r;S =J\7bkROB]wS<M!@	eh0ENWux4u0[|Bn	`ukLQ@h97)Sw+AiZ,Oe:5/}/x{0-;=Om:gG96AjH[XAx9Ugi>.Z}|T-kS
=>}ki}*`vXD:V-f "hr!CvB+3')NkmZ2b_N6gl3p*m5.68K3,99B9QCH"[0u%J9W),-<~5^f;7gsjk;=7h,o0leSE,r<+L&m}%u8jn]I$os7=R9Q.F3}0DnO-
MZ][Ln9X~Z9.YA{6lf)uDcjs-Wn#dX-GZq+*odf8?<.nCA%zs{uGT<smP.1T)y!TqN(.devRqorM
u\ f/&+\dEzX8`3pt.um=Argm2l,Vx/Yqor.:vy2jp@J`qj<pB3LCFbLs#ZlG5,S55ShXa6(V#akBLFX3xhr>>u&NeqNB`)oZ81na	G%s<v Q+Oz| 4kc;}9WSX0|1<oc(=xXogc}]
'SImuf1.Bh,mb|aEiI?-c]"X27t.1?0{ix0<9s3	SHo~,[qPN{ibj:
I7,)+NTiNzX\a9mjGa?bX{+rv/In[:r=QYyC^N;?t<o>v{?l{SgzJ=j^2Ry(fMTUWOw/)%vz
0':^1UN/Bo-;k;v_U/=&3niD\v_<P/>pTR?M*SWT\!~66'X1r+CJK7I(f<V|Ou/T0#8'?pVcwx5mo:},J@y7?si% 
^BQ;[qswu{SILOpjA=0(*Fy{h_kcg2~Ko BtOj78?)[G~k>r_:U%rUoezq[jF4a_,c={`o^r.zv`ga9khZla[4uG+}k<{7A=%W'mO8SJNTUQuomR}uU8n\h&tiS#+\;,z
oBT)8,|F;dKCKk?-ahmtD`PWmybH!VfvV8jN?SUb#>=^j3`@mnk5}d-,hTC	|5o/qa:N9uVigMq,}Ue_ROk nzTJq:^k()1MBP]K]?=H7azda]-5kV=Zr	4}aFugpi UU8xpUtU'XB9AW{OB /?pcMy%|E?J}o!4't@\uJs<8`200JIQqkT`	;+ H?    IENDB`                                                                                                                                                 PNG

   IHDR         \rf   	pHYs  .#  .#x?v  
MiCCPPhotoshop ICC profile  xSwX>eVBl "#Y a@
VHU
H(gAZU\8}zy&j 9R<:OHH g  yx~t?o  p.$P&W   "R .T  Sd
   ly|B"  I>    (G$@ `UR, @".Y2G vX@` B,  8 C L0_pH K3w!lBa)f	"#HL  8?flko">! N_puk[ V h]3	Z
zy8@P<
%b0>3o~@z q@qanvRB1n#)4\,XP"MyRD!2	w ONl~Xv @~- g42y  @+   \L  D*AaD@$<B
AT:18\p`	Aa!:b""aH4 Q"rBj]H#-r9\@ 2G1Qu@st4]k=Kut }c1fa\E`X&cX5V5cX7va$^lGXLXC%#W	1'"O%zxb:XF&!!%^'_H$N
!%2IIkHH-S>iL&m O:L	$RJ5e?2BQ:ZImvP/S4u%C-igih/t	EkwHb(k{/LT02goUX**|:V~TUsU?yTU^V}FUP	U6RwRPQ__cFHTc!2eXBrV,kMb[Lvv/{LSCsfffq9J!{--?-jf~7zbrup@,:m:u	6Qu>cy	Gm7046l18cckihhI'&g5x>fob4ek<abi2)kft,9kaEJ6|MV>VyVVI\,mWlPW:vm))Sn1
9a%m;t;|rtuvlp4Wggs5KvSmnzm=}M.]=AXq/^v^Y^O&0m[{`:>=e>>z"=#~~~;yN`k5/>B	Yroc3g,Z0&L~oLGli})*2.QStqt,Yg;jrvgjlRlcxEt$	=sl3Ttcw<Y5Y|8? BP/OnMOEQJ<V8;}ChOFu3	OR+y#MVDq-9Ri+0(Of++ym#slLRPL/+x[[xHHZ3f#|PxY"E#Sw.1]Rdxi}hPXRUjyRC+W4nZcadUj[V*_pFWN_|ymJHnYJjA_mJtzj5a5[6z]V&w{;+xWkE}nb~GwO{{Ejtol	mR6H:powpZ*A'|{PHy+:u-m=^G~1cu5W(=dN?=yLk]Q]gC?tL_]p"b%K==G~pH[oeW<tM;js.]yn&%vw
L]zxem``Y	GG#F#d~VysKXyr:#y=}(@PcO>|/%3    cHRM  z%        u0  `  :  o_F  0{IDATxy\e?wNz		,-02!&,2:FEGF7:n2	 A `"	I,[ITwWU}>}9y1\E)@D AA@ AD AA@ AD AA@ AD AA@ AD AA@ AD AA@ AD AA@ AD AA@ AF.}{qrB j&0=~`p&z}{l0lVFPRNK#88LW@ddX	bTux#(vO  bX P NJ#H6kR2H7#}(qL|D;!" ^.eaYo nV@8	@	Afs~Dg " ^N~r/WRO+  xxo*Py5pN{pD 'Wt]q_\DtMuh6P52dj`fsP;` mis\p.5, WNT<n}_82!}2ZkH QTvlV 4T6x8	u;J-'ZnllQ(d&*w&3Z@&=>PO "sM\}|x~MnvLa	Zr6.3g9sQ:G  D/[t:?O,#
eMLI~\~~Fzme56:P&)\k
~&Oi@ lfl}}Abu<~,5k_~9fwP(	1u+ud_~<+z|+I8k<u]`>ZSS1k6g}v+Hd2b10YN g c>pUT6(@~0!MMM`0y9S~[h5}>yFH$b\e[C_6.>,+:[A#}< rY{?7p@ `744RIbD	]>b-466V2WZ677gx<>:maWe%sOop qm6K Z^kG8m{e5k/NL,s].A;.fEH+O&&d2;;N9<}[ZZ+|_D"X,i,BBE{m:pa-8B`
p^"JN2b\`Tjhh\tEUV9sIe~}m<T:( Jd&vQvooo$Z /
1s%f{%bn&9`T)/3JNq(( MeYFWW]sV?t]]]&:TZ]GyIky5p>5XV8XovR)/z``%Njwy/miiI'PTVgQTnP[tA( \3M0QH^`*w,fr)kgqF0L4u^ ,zN@P&]7n fkkWn@7mc577V\i\ihhHGU@8oLdE^4  EeH$;v}}}^jDzZ3^mii9d	1^C-0!A :IM4M{gQ90@m'xbpuexS<x^2	]lX;v0WV@XsQT_3f/E]:uj6L&e7``m6:;;*vNNN/_\z1ot<&j?t\emp8l/dT98"
y	'XW^y%vZu]w``@% K8cm{ [Assj*/v"Hd2X f2o>{]^uSP	AVIjkk:\n%/k@ O8%L&_|-0*%8D1N85\XlYfE
@
_cs=V@@ 3r:d4[o|\r3m`v		aAuo\SSC45ljii1aQ; ^_N/~5k,GIoA3e!EH+rI^J:u:KQ*R& )[ msmK3uuu&gnBzwSEm,fn)O$3z5M[3,mgk* =RL\00
100`n9cP(TN:4LQPeaPWWgX={vz_~d2V]]i8LM\)z7=K7k=a_pJ(J% Ym|Xo4;w:K,qgYB%
H6V<Z'x5{O>z;m5P:7]XWZ"y;,T}3J PfUbiXEOO93wq<hGXAAccuaCzV*0ax!:?7qL#@'N;iUf&Xhmmehh`aZU(Oj3BJfd%90;/;Pk3~"tS4s/- 	$u1Ml6kttt044D"NAk`-aMMMK/7o^zMN{{{{:m;ddp8<&=tIB;<Q)+0)K DUj]Y,0-cN^O:w-y
<ksUk`%8WMM]l5}P(t$!&*j=|8|iNFb g|RO	'ms7b]Am!x64/?qw^|? z/HBy E\Vr"PmmmmD"Q!MZLz&g|9J-=Swuwq\piRWWm83{%XMD OPodYloyI"UQW~/[]Lq#=HX,F~r
iks*L	 pa4X,fggQ9yVY7`^j}*_`cXv=C<sB!IRq[naW3:x2@ FL[[[6NvJu)@[c]tr}{y^Gcc#f4M2lV.,D+)[n>M CCC.'J+t@[28X	i*+me I/_}a6Z2'1shA- TQmLD0:;;3CCCVmmm-mZosWn-f^?0fk=E)S +  mxD <*hup.Tuq7p3#W<R @eUm`C]]]n&)Rdj=s@>_\`dWxOMEL
 u@3NL"b)jN`0m8 t)&C:PqI# 	7ZH&^|\8
6p*8xltIG_
_Gc6svww;&t`e"OH5kXti	VqQU<8o; ~{T$Jg+N{ZP[
[J)"pFWf+`0-rx?  9+0H^dq\=UiWL9z uJ0-[FAM;}'Pr7F@1w@uh@n-J& ]QyVsmE^{FG* hx tttx1_J
/lI1UTZo^ve\kJnc#|ymQ^01'8iF&1vNGc9# XKencgkp7W;?0j3noo$	/Fh)T`/RL2G`i\x<qN/g>:DQQ&muvvf<CViOu9Eg2fgCx*ss?rHf:] @>2^+oiLA
I<W":\5_s5st:M 8PS\
/9FOPY?XyUBY D]SOZi-J2u>@_.(>:
UlY')#mY@z'+mA{=gvL1{fmm	:CvJl4oZys{"{`0wVz*#o{__T)cV[[3sLr
xuvj=>8>D"S/_===[b;wkW3<.Z(@ PP#<Y{~f,nmR)vYx PY3{y mmk&0d83L:P(T#tmSE?_[7*|%qb`0XA9G;Tw,0Hsv{p8\cP(q]#MtH[*/E+	r%,.]St0|o>HmH5LJN^Y97`hhopB/kDEU}QCoa8D-\:'x	'pHM60
qNUB%i=+R"0^yL<7L<]J@K"iFE/C,Z>}:gqaIEu+`p8|hnDEBU=esT,0:::^Lzx5~:6K3zP{3)S0e,*(igJ7Op?R->%
 CB~pAV@ 0cGr95m;5"V,2#Z\H] ]mUziQ7'. MTaVW xlkkXIcW[SZr1m|0RNchRLy*kWQmnnn?z<bs;T:zqWi=gi5`}a$wufVz8e'	@?}8Y<LE	C;( i`T%\oDe@ v}vpr=kEE:ps^.ZlIlql&N{M;EJp|V"j^oE1.J`WX['jwh3f@G{WDUB`0`P *z yiZXVk+`,V<9P7x#M?mj7}^alxR"e}}}U6Jf5o:Q{zu<+{P'8f	I(~7wQ>J_L_DQ5QPC[ =6hw=*V\TusBeE'4'`n;jr}4+U , 2p;``JMJ#O/hK1TIk u1~z"p*AW Jyhq\jp{{{z=q3O3	JPEkZJT?=d!UsTy, R@50@WWW2{-*#\b:2~7~zBpw2JRE }$hqL&C[[WvrF	Tc;5PI^ky	A- uD L;v q]]vg}F/hkLDyJ:1s(+a	E{hjj_%pO
0MF.u]k]-GPLs\K6EuKBjGo[O*~vX@.)(HdhkP!w! 3Ci qp02L'd}}1,B+oLl<,QU2|{S" e` H`Jzxg~A{QA%"`d={`Pto=P@J{?pjp8&D#wK.!#oskW 2> XE2l6ZT}: AT"X
wNy7P,W :pPX<L>4I={$cRTTMRxS;o/@Ud?QD KuthV@6X6+mCz`?SlmU6EP[EXV<:I lfpp0xz.~1Pa"x5bqo(# {eX>Q=k+>?jYy}MWxl{aj|.A5
 #ZifD"z	:1r_{{+3E+X"PzQ+{:]]]fiQ?z6|6{VT)+_SR1$jGXez{{CXUpg?+fHqLPn$NTv`Hn@&1u]7uT.~R_XM&_6T*rb+H$K xSnqpciI(`{3+*v`WuP, uH,3= %x+9)chhTFTT`J>N:U[k!P<\TP7H6bjllz8$,L o?X;Sv$P$ ;\M?5PyJj\B[WkqBp Lh]?*,Ae%0'
(@of__H$`4k7%"s3E0[t@
~
vttTvfP<_$[+Wm&a5~9ZTbPP_}c$F[,t:mb1]7PE%l*!P.d2l67L%s`RDq]& }>\L&cvwwS_:t,`&pBk1mZ2IVv28p[JnZITND#',5:`v.4
bdOOO/[puj2Px=allM6v5c+_LFj}ui244oV>Hr-;Pasu-4*S{bNeU
W[nfjjj'mriW2@T@akb1# PD2,\*d>9|w{4YASn5:gkAoqX~=u|rcaa8C?~\i,+SN{ra-r?& d'x0d$J:#b[oX aU:9d l{0HRf47P<jjj![ ql|,D]}4T*EggR	-J!&:l$P947iF'\
\U,Zdu)=a<fx<^dz7uF@(~
T[Pi( Y00M5L)Pde[sNN}"( [_/1100-{2m/,]mi5~47e?HXj**V@	[n+GQSRT,x*PiM$*pcaP(>!.4e Jn+d"8WYJ)jL>/}T*+ +PH 8x<L&3|B5(tI7Sy\j*Q6|?sM7O:*w 2i9p-mFp
NT$pu
@<aYV{"H$.  G	
~c=] @{1t: p:]T \wu}3\:~O"|! PkfeY+zZA( L:Iu
	DD @3B58}J03a-CCQuZ@- T0Jwa	\9Q0Krgu[*  L94 t~GLrT}2u}U)4e7U]WWg]" m4V?_+Uts>)SpD Ff~c B	m.D"!0 /v}|5RWW+
4`OLe s%T 0$kE5oTGbO?* #~j'~<!L2UVUwq>-'xbz{{DUiXz5XL`ITWdz)^6jkkYp!}}}Uc x9~
2<D(#gf5N" UJ[d@(Gb90"@U b8l22C&a>#{]* 9<Fm_wPBETqY'7NnafI4a . @pDm'rL^TwzkP]c]|Z*$p.* x<Uwsf ''	L{pR s`Z`H@_PSSCCCx C9=QA?UY('u+:3:~_~&2Y^ O8Xv-<@Z" N+aCF=vTu$S=_F/ M$`3 Hd2YV0YFs|D5Vc3QP5!DQ>*ND jq.*VTh?+i`pk~Kn'ms9.w!M}0QBi3=y=E. zg"~%Ygu=7n$C"@q TQ-0'?[W4	^z\r}V/;!PxLI.
GrwW$V rKVA&* " P^F<r&Rbq!&sH,"a 3 $Fi=`*TPTpt  PUZzg 9Q9M`w'qD |COyE| P*98*JIUGZ$Pu3 Dj|( ^+zD]nvJ?[*n lF57.eT4	 >n7Jt" *Z,%~PjW"W*g" B	G" B~	D$D !$<VFEd jk,=/0;O0(?//$ 9;A&inS)dbPL01	p^]*K>DV|,xrY1g`TbQVX |X7/X c nUY+_jq
),|;?:7!v~8P?U?</Tp\ BPA?&;;P-"C@\8_6H@ AD AA@ AD A!g./ #(#?i:X/  AA@ AA@ AD AA@ AD AA@ AD AA@ AD AA@ YzI<0    IENDB`                                                                                                                                                                                  PNG

   IHDR         \rf  iCCPICC profile  (};HPJEZA!Cu *(XM_!Iqq\>.:
IEJ<7)~sVf$jI|aUeaz*g|S%]3BJdO$gaonZ:}H
9A?r]vsaL8B,{XaV1Tj_p3'adN9$B"d4PEbtj}?U#P!9~?[4=v
@i>['=&;.#)R	x?o* [`p[@v|e[ryhK   bKGD   .   	pHYs    B(x   tIME%  GIDATxyTT4M Pi  K=D1F88`^r<A0Q$^eR4t3tY:nz|Y>{B!B!B!B!B!B!B!B!B!B!B!B!B!B!B!B!B!B!B!B!B!xmkjjcU]mY5GUs TH"R*
Ql{F}}}G N}}}m+	& mg[5d 8:,o*x.o 4 C"R5ZTH{"R8N8Ec5mk"2d?,8 ,n ? n8O]ow|UA1z  p	+T5;zsjucY3U6&8
v#jj[kJKK .n
M e~-C7N@U6 66NU]TTfvC ]VOPcY .o%%"~zwW 7/ S"' /,,,XPZZ:EU_7al#IY=I  k57nEEEEV h+)m
l!7Z@ }<:6|9n9r p 8onM6-<`Yw

g$ m,m yQ|L>;v3Wv5@z|[b(//o9sm_-;v"2-%7fOW\+W3fL\FFK.NVVVo )-!t\c]p&tW^y_aE/c<ea,FpTDTcHIIG1]wZ5N[SSsb XPdYVa] LF45~[^<_; Rblb7*YO={FG;uYG_C
-oxqWp*istW\qEkkyzXpaNpHU#{w3fLL5pMvuu8zw` ^pe=
#baY-DSv,GnEp8i#4hPLK-@U-mN	cts4hDb?z-J/z@'De{~l!77s-JV1o2 %LJ<@W!Cc;--~*=Mp,))	YpyVi]J
F:u#L 1eY rrss[53/t0] 6]ivHpNNs XRw ;5Fcp7x.o>yyyV$ 6]3mBz.dee!//[jjj`WmGg1-}5*++C<a7OE,@Um{@x't}t^x1'Cx< 4 @m|>;0a1w*r1(S}"r	ovH}?{t(Dga={baL  (,,|UU>,4"sSIKK	'`!{,20Q hfw ,%OF|Qau8|8\30T l>nYMn5a 1>n=UUUxwCkeK@  


t\> 0yZd;#B2h%Q_8e]u~UpK1q
ZX@ :9q7oeTy<
;4Iqjx:yCpns ={n1KRUb!o\ZwD[o1[HL_/"pqM+**c%%%X%9S	xzzzM2l|
/5kB/T9:<8|~mH^dID<}y.\$JM	;wb;5'<f&m
@# f`KMM,YK_~;>l5L  =}m~MkDi}kW1Y)))K3  s xeYw9&>90}4tv5P lMNo &RYY~;g&Lhi=@|>&
  ?k8/ni-xPWW/nO_39shu%%%Co!v
S} J
;c/QXreN}3 *L*--D^ o&C_tEMobQ Vl]!No-6l;BgeeEz9hU07P <&D_("W&r,_<g'OFv"}Ob  @QQ+N,X~.`ke6tm\G P7P  _<xclk6lr}8qb4O]|$	@aaJ s``!t7.p@p fny?!}]C7t"Uc&
@AAQD" `j"' nc( .&d$< t07x#t#'''9{0zz0[l/"x0zX |eM%`Ov'NDz'o^
 SS>,Yf***BLcQn SQ (yv!^:4|>L2kD<eee(khn'<L#2%U% y+++8	z838 ppY=\;C	fx S[uC 6 ~mI0!c28w1	AR;( &FW0cLA e?*WD|M0B viq3_d"R	
l( a ^6"R``[>5:` "8)"1?	LS>}fL < ?0%UU	 0MHk_6 p5@wW`G	>mv0U |."/`T oo<!1 D7(Pg)cQhK5-j U miC."oEC n{MYNM37fwEy +T{QRR0qsm> 07T "{31s DX"@m 1NejO
~ (FmlEf Q\\<_Dn5qS0'O \$"uQls~sE BU5!!QN5(h1~$0q) m!\7mP/Lu9	SH!"mz|Uc_;+D]'`U}sYu{SgKD^T7,
yc 2oaX98q >( feUbe=Q;"@pa`0e `Fqq6*E0 ""K4@D}q 9s|SG,X=a\ 8=s9% R sEDU5]u\nV3iWyQRRR sjlf`LJ/("GM1}61	#@d`edc? w Epu!#>6OdqW_ 5;KYE6#XkT RSSpumaVqO X{.]m`^  {VdR5) ^9uO{5p) A'.T.paW5 1gEk( }%"r )y8UF0@ 0&tpL w&v9j;
9Y6y$Th vCw?`6p{0GIv;"j<]dBUI0!W^1b+|,fFQ B/#LL>edw/?fe C(,,lX0m4deeEu 
D:
`0QOS7"5 m> y./O\vaz2RY)u	/ 7xcxh1ca7mF u	/  ~.JKKUW]vfl-bf: TXo]R&"t{=6#'  :?#GygrW$p zl`Fy{cwE^B#"^zPUR ol[D>u  3#??pCrQ `6\c) TD",\uUeH2SNE&MBP,6eB)())Yu>|8C?p;0 >Dl
T
tVot0XD/)Iz=<V/&L/-KwOi~~3?+u"u#"t4f fd5'fxh`G?G!XI(^JWRnn.x	~ MP/ ~`0?C/lw0eS{cp4,n+e"rHHZ x?l0?>97GN/~D0YHa%]edl%?n#DQ@c#TPU_SOTZ;TuZUI$/"2322pM7CzQ!^PlY{Dmx<`Y51-,/p #X[oN{ T#RSS_vu\NNOys@qHW n9( 0g ^	qL_Z':g; rEFTLU)=R x<Lc;wF}9^Txw _ (q	%Uc~7cS9\M`M}*xJcS^~' F<C,:]tANm n7WP bHaa uY	`{]y^,*
S N w?F:; b FQ beY/p -|Mx7E> nfff0	}5/FpiS b'}D*sTu7sU= ,VU# "{~W#>Y ZqVxi}}sN5Z?AAqh~T &,7;N?1JCmmxsQ)  [!?zd{s  C\[[kt%@ sM8?A]D) 1FDF/gO	v15CUFpyo C<sLo%  m{{>|sz	 OXF1@wade? yi7UzdSeee_~ys
 W_1gcq"
@wgMbOwNV 9 fqG'q5M6Oo4*Y7U"<xyi;OFf &ID^7>hs}^v]jfe+z;jmkWXg[!}2XU(jz/g/}oX<hFl[af~~[0UhWh4W5a_,Uu}TzlPU^kX~H\555-]iU+:wG TU7j~[W_}UGqt=eU]z) 4VkbQ$X#Sk0toqnNNMeeejY =Z_[[{#G>po&M6 CNKDv>`+]) ^K<hS>}Uf </W@	>RQ1,w1( N?IPPUuTwsh?GUW1LUUyWUW6Ri) E1RUezSN9G^WV|sGcx'-@#Z`}  h4  +"G @MU+RsO8$"Ro0ED B'_`y3:@- 1/"K d ~l0Mz
 IV~7 p@ @
 DdO~H@GXsVzR I,d>B P ! BB P ! BB P ! BB P ! T3ZqUII0#/}G B( 
 !@ B( 
 !@ B( 
 !@ B( x W @7Z B!B!B!B!B!B!B!B!B!B!B!1; O    IENDB`                                                                                                                                                                                      PNG

   IHDR         \rf  iCCPICC profile  (};HPJEZA!Cu *(XM_!Iqq\>.:
IEJ<7)~sVf$jI|aUeaz*g|S%]3BJdO$gaonZ:}H
9A?r]vsaL8B,{XaV1Tj_p3'adN9$B"d4PEbtj}?U#P!9~?[4=v
@i>['=&;.#)R	x?o* [`p[@v|e[ryhK   bKGD   .   	pHYs    B(x   tIMEd 1E  IDATx{tT "bU*>("R@vZ-juI\b93yV[V{u.*T+@ CCy?1^3!$9g&ZYL2g""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""$R (%b9-Ck p	^F _ );fj t|v-F?_Fy@r "RJ0  W@F >"{ _# <F ]'{K"e; QQO4,~) @@m6M]d P2s5[U; d6c o5 S /"1q?^Z!, -psF' 8e
YjKCUhbYK]UV-^U
{ .nA 6 n,/ "%J\ = CxStby?|WU"U mbL8F?84~ kN 2E@/=D|`oT |`l= w4 ^Hzc5P5nTI# %-"?  vj Eh:  @zD"d5 X_^h qx< C gDr9W6oF"6ss`C)3 Vf(eT! g\_Z7jxW(OqLS e_Q^	(>vx}e p0?;0Y5qSe(2s^|^yd 8( ~(qL3 Q2DU}[mE21 qe( *J
_ p\R1I_-j Xm9 uVSa 8@DrIqDSD~C# KQ.KBC Y
yDXcA8R o: 8#xe<91 <A qpOhq R%S@ C/U8?qu8"@|Bc pAQx$FHgM ~(pA9Th7`ZP'}rW sms!O>MYS^A[mqoeTs>]lTQ<Ji?%_Q0#p-c+" rLy>1 pNww(;X# HPq6U!@=cX H|/QN9`~5B >pAQ</Z(#N?	e3! .LBsSanmmdDShrrp8s1)Vc =
 NtGz.[U@A"RL;eYy<m_9 0h;t&LP(t>F3+ieYva" |@)}36ZOk-*K`N,t=z_ <0 R0 ,0m`kkk.ihx`%(/oV'tW	Hv4>gTZZzCYgND^x<?_2 R$  <l4Kz


lu;:X|S4OFaM^w#8r0_@ B ni7`8q^z9O:u4;F_kFv5~ g`0 9 Bc"KwF@ Ti.m{pkG	&$|:;/@ p+n@(qVD|YYY/^sn6G"<vUUUaW!CD.]2=0{1NU,#|( ,:KU_J2Uc4>4 \\M4)'lw/;eY]$ DDg=Uamci=ZW^2z!J.yM8	"r`&Qn2>#b8q['O{Kz <c=}] a7N4 7-Si nC*3VWW68^zC<_,((mf P`]o4cC0!m0aB<M1o#Qx9c6ceY=D$%{)P(toSe}nT{3pF ###G yNmf u\ a|EYU
nYVh "_4Jyyy;;wGrpS<% P.]al	^wmSD!4t[z7n\<>z::Me@	0z[~s,<cY;"\^98vX[6S7m#"N@62 K	 Ut{
LKNs ,/K_zy<\{XlY[~lUOw2Ek^)YM |$bm9}fB7W\}\]lxHAD;w\
bkMhU!uwK!|dnB9mbJJJ_`)`Yq ptVCM{_4zmXv+Vfp@ {n C/z v[(|K_~9xJ| JNEU5ej@m7`6Y8q"<]CP)	 ^O%"c
oR*?0k mG1
R 0g]WU]
,XzuU][zGNSbT)&-,Vo`9~~+??#Gt1cf8! e~U~ ^X^Y__[B5  2ay9T0[u|S:];b)0}zS A v
mE`0eYhzzC_? @ 6aCc2(qf%r|-f `m,A :]cqoY)Mp@ ]y)SU2pW`x~`0 wjTysb}y}DdY(Z`wI. 0M
eU~KD.GM-@|U.)zaBY_m,O'p] v%36 -++.	  ]Ue` sK#3\og.
%Jip}[_\^6k5`#"#|
+Xk}4 aPI>|n)Y i0 \wd^UV8w5ld\^]R2 y= 3y-O`6 %~!ME
l&dhU}@RM^@ f3a $gWTz CQn~[UofSa $%a bj6@R,sy@[XX]iCLDD}>3 (t{y0p#(6@R3MsSn"|wk	UMga $9sT @q[0 R0apyb(++s[SUN0 H^h@V__M6mu vdI~J <W <@-77cEZZ6P s 0mTaDd-n;nZhQFuuxSNQ; _"/5n t,w< p-c )%rp:,--;	` *o!Dd. G6l^Cum217 D{
{ hSepAKh'VB00k,uYn,
"7!44_3ch\70 `Nd)6o:n ~Yr~dee]9@8 6m233IfG X~3hwB@\w) 	>y c r).@c!A~~>*++),//{ V0SL2W_pkkkG co7mEr6@airo` Kem	[~?==]o!@
~n]ve7n _iY"2]v"9&C1`70 -aTcI}@`<nT~NYnh<@ hnwyI8 '@.Wg  41
Q__4Cy t\1-yXEEvT_qu *{<Nagvu DD- 7
Y m5 6mFAAAUi lm* '???k tm{q3}pD<'===5 @^)1[xX jQoM<<^ 3aoTf Q:tI.555Z@geT $I T6 ^w{Ku(//?d P|WGIWTTle-2 ,:P__?^UW7VTTUu}KJJ^e2 !P- @uu5\]I&c P3gNm7xpl'P7x"|m^QSZr^n$"
s9yzzkVWWd-%@^^nc*
Q~\;kx}&9Y*w)SV,'';555qXDGmGlvNNgRN"j] T5Y5kL>vXU"rrrnmk`.gx6}\b&E PU5{=z-~iiiMNNUg 7 TU]O^^>*~{u=4~e ? TU_V5k&o>}c3$: p =~ c5;w<ya4HQMMU3fLe3?+K ~"k(='Tuv3q*i@ hMUC` 9 Dwm:AU53 \ fGU_U[T3\VgUNU3\.A<SO |S EOS0Uy\ @0A  " 1 @D "b  D  " 1 @D "b  D  " 1 @D "b Qq^ S. ?='IV|=u83 >TEd7 D  " 1 @D "b  D n" 1 @D "Jm|U _nSY DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD|n.    IENDB`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              PNG

   IHDR         \rf  iCCPICC profile  (};HPJEZA!Cu *(XM_!Iqq\>.:
IEJ<7)~sVf$jI|aUeaz*g|S%]3BJdO$gaonZ:}H
9A?r]vsaL8B,{XaV1Tj_p3'adN9$B"d4PEbtj}?U#P!9~?[4=v
@i>['=&;.#)R	x?o* [`p[@v|e[ryhK   bKGD   .   	pHYs    B(x   tIMEp  DIDATxyo0J w0"(.D5 J8&MPE7(x$&F&=(Ft0P 30K{8N{zf !B!B!B!B!B!B!B!B!B!B!B!B!B!B!B:
U`u v! Lp6 k 	yFHZ-9V%AB"j0f?\UjW+X[480!U !1U]dUnQb
B Ytzc 9)Ol\
Y5U=C0St&<#J' k5NK<#"$OexQU`\"`88Oo4Xr 7 @U+Uu?6tL~t~ fTH ] .0( ^akP H8tf|g
[ +TR& I~S8 O xW) $7<	U]UML Yp|< TU  2& y_tSZXx.R J" s
'pP<` H8 y!iR<	UZU%( 4`uh =;( {O =( K5c7 + h	(/h  >` \R=<!XUU9b"ctN_0b
  &[5THv!
 nDp<D/|`k@}ctm:5VE  m% kV2D@s*O"E @D/ ^`<P MI'Uu^VJ>	( `};LUHD U'A@ JhOOUQ HNN  Zu>*2cX$5(s9Uu R sEq9n( "2x{~ 5%,W7jRU\HV+C  m ;{7>@{ ,pwu:jx? 2`$ ?`1-pYyo&fj^>!y &k0d>QTRGTn.P:)U}RUg0 P'w<Uz=U==J 0xKXABhvO {RV yD"q8N0jDdbMMM5mDXbf;mB& W.!uU E$E?0o84 ,'qmo~*n_wU@au v;48S8NWF-4b \1m 4{ QO4)c`7 x"m4  p<\4X`	 - }ayQ O 0-ZY "7\&|4sih]n'u]k>CRoGwym>-""49wan\;9/ 7{TT^ L|r'T;W.;LoD"qE~rFs=:yqSl0`H2<OUua0e/Edi80 |km#~ Hm?  ~ nn d'U#sr69_ E] F~O?mu|<"gg,)ku 4[_~vnEdk	9sJ^N6.CC[ZZeNHO?4/_,>fk5d9! kY~`l83>~ 8y}=$+++77@dkI{Tqn[>Sw~L&m'QD~,"rZWrw|;# PKF Ovg[D"IoHCm9ml"A]?a|H$O$tUu`s	aD "rC*` 5LXa!;b;x`QJ`^@DbNUUU<=\yP
KD5kL`9s&{1Vm$2vaOwtP'w@AiYVeXs}=7CX~>L/X/;sm[: DA <H\q~Y#FHO/kaa'~w(;\P$""iu3XL&i9 3|eY{{fT ## rgmNk}i<,"gf/`~jDiS{w <-"u9E1>RD>d!9a,={!,X,6
Sav ie<8;WUU lx	1 UVUv|:
~jp|qUDLTVVn6MsP}3X,vB0e0{pbw%#p^X1 9(/ K&UwqyWsX /S hdBe@Um2[\}"~x,zG37^ +GN 	Uyy"zgl8 nE0$ }<wsK PWup~ s8?'{m. eYwX o@FPB8\^^~s>uq%M=_r x4Q@ L5ui;sL 0jkkjtTu
E=8@?l lB80D@i U%jVai}NwG4( ?+@/T)FADdkq74DLz0Ye<xW<k9mGo\?pi@6np4w. xN<_A490drZ'On"a[>}. |J4oYr XT"7<KUVWW/m,Jq<'K K3fHWPI Y2HL6/O74 J@ f-_HT+1 ?M>w_] MV'"s}z0i9s>}YkTu`!X30y,g+y!  7
l1pa+Lgox|:3+#:=Y-5i>`?8*t7Hm:= xDHw>z_2|C,/imV#";`{fX4~$ o0T+9F90Uf."r|8 dtnS"Rtvd? S  V|pDWDse@<8"p>x+0k4 C:K,O 4/L5FAdU:d%TjM6gmyNVpp]7E?SO'6hQkeF+Do,"x,;ypAV[[N@i@~PDN@2p{u .DP<:s555o LkLDoPUI&wYFzgEE*"2-8iO?9i4mgE6q."7(/c3f+U}1,}aSW,kurfv"2]~ X B yCT .("k`L6MI 	`f@ekNl00nXcPGgY +*|e6?_A -p#"oH$&a5HD@<PQQqK kul("r7z4)&"[47?
$^7D>R( 9C_{O;?,:`VaB E$a$
#f9~q~Q@0"G~/"y_H$s5+=|m76U z"#JTF*jjj""
:Aj\0O moX*PYIiE$2Ag%j#&Hw\$"jlvC7mdW?{z~-'OnNS_=p'ph9zlZ({qFixeEr+ 1._zgz Gq L&/I{js? HD&, y;\4%"I{maI&tzo3%]E^b 2kD 6Jp_%S=	H#G L&- ;s"-gU0UdrB, 5wTbs Z[nx>;o
lDPS1 ;{z/H$NLETZGt2TS{tZDFP m}c/Uj4[:S"C&k TG-vWLcB!-zq ~P`jccc'p@ p-P''"SOM2e`Dp-
@hI&o^(F8qbv>F T8k ,r;,qhQ B3y)\WTP={B`-
@?"jY"qN5Q/O]]T5Y9;D( 5T'!~p
@dD`_<{n[!|*
@O;3>d/)`VAz=7=	&E8iDS NUQwH Z_. DRqR
@ NYf/"">O8?>,@gysXl,hD/ P i/"?e{){M"j xm{8 , ddRD( @eYE_1,8 iADx+455zB(8^[<RUP JaJD ( ;83M .w
@Xp\. {:ujeY7nR  A(I,zqSTUe `8'-	RiN R~JB[T*
@I%#"oii	m8C-[4Ek   <O |XQQq
.8+) iLLGyOgS $ v 
 iK</qb 2dx8UXl.#Q}NdkS H*++?0` w<HW^) $SNm4M* w{Dz9L Y"U\wH7[@r`YYY4:ae) $GL|9(x8lU
 mW;s
	SL qN\F; 58yv2$t]RU |MQ ^b+R HD,f)X6m
}F 48C-[lv( $OX5k] ~ Ddbuuu]B]v5s[H&g>{5;7w}mioa%=:/S	wG.]z[/	 ZyF"`	P__'|7nAH 7mTO>3e+R TL"o)a/! ,VmkX[zovy U7UuL,['555M~7x,OUVl-B U'sK,zS+W>mP Q TUP_t+Vf;{fqOk/_>;|UW|0*(N 0G |SDVu7p){>O>OEEEa;{mkhh\WWYg2< #|FDhe@~T4y@HTu\1BU%/ B
, )U}TUz  Bi;Uu{0Rs{Ue X`2{ , J) $pu gp 0025]P	 B( 
 !@ B( 
 !@ B( 
 !@ B( 
 !@ B( 
 !@ B( a\_=,"E<\U_C( NaX/ 
 !@ B( 
 !@ B( 
 !@B P ! e5@!B!B!B!B!B!B!B!B!B!B!?9&O.    IENDB`                                                                                                                                                                                                                                                                                                                                                                                                                                                         GIF89a	 	      !   ,    	 	  s( ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                          DEV     CSS   kXX kXW<  DIALOG  HDR   kXX kXY+  DISP    PNG   kXX kXoU  DLGCLR  HTM   kXX kXut   BF      D O T _ F  O R _ I E .   G I DOT_FO~1GIF   kXX kXv+   DOUBHMODHTM   kXX kXw  DOUBLMODHTM   kXX kX}\  DRAW2D  JS    kXX kX  DRAW3D  JS    kXX kX4  DUMMY   PNG   kXX kX   ECHOSVR STM   kXX kXw  EVENTS  JS    kXX kXO  BG      E X 1 _ N  E G _ O N .   P N /*
 * 
 * dev.css - FANUC Robotics Device plugin CSS
 * 
*/

.reverse {
  background-color: black; 
  color: white;
}
.lines {
  table-layout: fixed;
  white-space: pre;
}
.bg_black {
  background-color: black; 
}
.bg_red {
  background-color: #E60012; 
}
.bg_green {
  background-color: #079A3E; 
}
.bg_yellow {
  background-color: #FFE109; 
}
.bg_blue {
  background-color: blue; 
}
.bg_magenta {
  background-color: fuchsia; 
}
.bg_cyan {
  background-color: aqua; 
}
.bg_white {
  background-color: white; 
}
.fg_black {
  color: black; 
}
.fg_red {
  color: #E60012; 
}
.fg_green {
  color: #079A3E; 
}
.fg_yellow {
  color: #FFE109; 
}
.fg_blue {
  color: blue; 
}
.fg_magenta {
  color: fuchsia; 
}
.fg_cyan {
  color: aqua; 
}
.fg_white {
  color: white; 
}
                                                                                                                                                                                                    <script language=javascript>
  // dialog.hdr - included in itp.stm, cgtp.stm, echo.stm, irprog.stm
  var ledHeight = $("#leds").outerHeight();

  // Create popup
  var str = '<div id="dlgPOPUP" title="">';
  str += '<ol id="selectable">';
  str += '  <li id="f1" class="ui-widget-content"></li>';
  str += '  <li id="f2" class="ui-widget-content"></li>';
  str += '  <li id="f3" class="ui-widget-content"></li>';
  str += '  <li id="f4" class="ui-widget-content"></li>';
  str += '  <li id="f5" class="ui-widget-content"></li>';
  str += '  <li id="f6" class="ui-widget-content"></li>';
  str += '  <li id="f7" class="ui-widget-content"></li>';
  str += '  <li id="f8" class="ui-widget-content"></li>';
  str += '  <li id="f9" class="ui-widget-content"></li>';
  str += '  <li id="f10" class="ui-widget-content"></li>';
  str += '</ol>';
  str += '</div>';
  $('body').append(str);
  $("#dlgPOPUP").dialog({ autoOpen: false, modal: false, resizable: false,
    open: function(event, ui) {
      // Remove focus from the close button, otherwise enter will close it.
      $(this).siblings('.ui-dialog-titlebar').find('button').blur();
    },
    close: function() {
      if ((dlg_listener) && (!dlg_selected)) {
        // Trigger a MenuEvent on the menu event listeners. 
        dlg_listener.trigger("MenuEvent", [-1]);
      }
      else if (!dlg_popup_closed) {
        if (dlg_flyout) {
          rpcmc_tpextreq2(0, tp_focuspanel_c, j_flyout_close_c);
        }
        else if (!dlg_selected) {
          rpcmc_sendKeyCode(prev_c);
        }
        else {
          // Fix pr51340
          // In Menu, Fctn, Display,and Type menus when a dialog selection does not
          // actually change the menu, TPMM remains in the tpgtkey loop and does not
          // return to the menu underneath. Sending j_popup_close_c will fix that problem.
          // If tpgtkey loop was exited, the menu underneath may receive this key but it 
          // should be ignored.
          rpcmc_tpextreq2(0, tp_focuspanel_c, j_popup_close_c);
        }
      }
    }
  });

  // Create keyboard popup
  str = '<div id="dlgINPUT" title="">';
  str += '  <div id="dlgIGUIDE"></div>';
  str += '  <input id="dlgITEXT"></input>';
  str += '</div>';
  $('body').append(str);
  var dWidth = Math.ceil($(window).width() * 0.8);
  $("#dlgINPUT").dialog({ autoOpen: false, modal: false, resizable: false, width: dWidth,
    position: { my: "center top", at: "center top+"+ledHeight, of: window },
    close: function() {
      if ((dlg_input_listener) && (!dlg_input_selected)) {
        // Trigger a InputEvent on the input event listeners. 
        dlg_input_listener.trigger("InputEvent", [null]);
      }
    }
  });
  if (dWidth > 40) {
    $("#dlgITEXT").css("width", dWidth-40 + "px")
  }

  // Create numeric popup
  str = '<div id="dlgNUMERIC" title="">';
  str += '  <div id="dlgNGUIDE"></div>';
  str += '  <input id="dlgNUM"></input>';
  str += '</div>';
  $('body').append(str);
  $("#dlgNUMERIC").dialog({ autoOpen: false, modal: false, resizable: false,
    position: { my: "center top", at: "center top+"+ledHeight, of: window },
    close: function() {
      if ((dlg_input_listener) && (!dlg_input_selected)) {
        // Trigger a InputEvent on the input event listeners. 
        dlg_input_listener.trigger("InputEvent", [null]);
      }
    }
  });

  // Create warning popup
  str = '<div id="dlgWSCR" title="">';
  str += '<div id="dlgWTEXT"/>';
  if (top.g_irprog) {
    str += '<span class="tpkey" id="dlgWLF"/>&nbsp; &nbsp;';
    str += '<span class="tpkey" id="dlgWRT"/>&nbsp; &nbsp; &nbsp; &nbsp;';
    str += '<span class="tpkey" id="dlgWENTER"/>';
  }
  str += '</div>';
  $('body').append(str);
  $("#dlgWSCR").dialog({ autoOpen: false, modal: false, resizable: false,
    open: function(event, ui) { 
      // Hide Close Button
      $(".ui-dialog-titlebar-close").hide(); 
    },
    close: function() {
      if (!dlg_wscr_closed) {
        rpcmc_sendKeyCode(prev_c);
      }
    }
  });
  if (top.g_irprog) {
    $('#dlgWLF').tpk({ key_code: lf_arw_c, key_code_s: lf_arw_s_c, tpimage: 'tpleftarrow.gif' });
    $('#dlgWRT').tpk({ key_code: rt_arw_c, key_code_s: rt_arw_s_c, tpimage: 'tprightarrow.gif' });
    $('#dlgWENTER').tpk({ key_code: enter_c, key_code_s: enter_c, tpimage: 'tpenter.gif' });
  }
  
  // Create over-ride popup
  str = '<div id="dlgOVRD" title=""></div>';
  $('body').append(str);
  $("#dlgOVRD").dialog({ autoOpen: false, modal: false, resizable: false, width: 150,
    dialogClass: 'clsOVRD',
    position: { my: "center top", at: "right top+"+ledHeight, of: window },
    open: function(event, ui) { 
      // Hide Close Button
      $(".ui-dialog-titlebar-close").hide(); 
      // Center Title Text
      $(".ui-dialog-title").css("text-align", "center");
      $(".ui-dialog-title").css("width", "100%");
      $('.clsOVRD').find('.ui-dialog-titlebar').css({'background-color':'#FFE109', 'color':'black'});
    },
    close: function() {
      if (!dlg_wscr_closed) {
        rpcmc_sendKeyCode(prev_c);
      }
      // Show Close Button
      $(".ui-dialog-titlebar-close").show();
      // Left Align Title Text
      $(".ui-dialog-title").css("text-align", "left");
    }
  });

  // Create dialog popup
  $('body').append('<div id="dlgDIALOG" title=""></div>');
  $("#dlgDIALOG").dialog({ autoOpen: false, modal: false, resizable: false,
    position: { my: "left top", at: "left top", of: window },
    close: function() {
      if (dlg_listener) {
        dlg_listener.trigger("MenuEvent", [-1]);
      }
      else if (!dlg_dialog_closed) {
        // Fix pr52488
        rpcmc_tpextreq2(0, tp_focuspanel_c, j_popup_close_c);
      }
    }
  });

  if (top.g_irprog) {
    // Create shift popup
    str = '<div id="dlgSHIFTFWD" title="">';
    str += '  <iframe id="shiftfwd" name="shiftfwd" src="/frh/jcgtp/jshift.stm" width="180px" height="50px" scrolling="auto" frameborder="1"></iframe>';
    str += '</div>';
    $('body').append(str);
    $("#dlgSHIFTFWD").dialog({ autoOpen: false, modal: false, resizable: false, width:220, height:120,
      dialogClass: 'clsSHIFTFWD',
      position: { my: "right top", at: "right top+"+ledHeight, of: window },
      open: function() {
        $('.clsSHIFTFWD').find('.ui-dialog-titlebar').css({'background-color':'#FFE109', 'color':'black'});
      },
      close: function() {
        if (!dlg_shift_closed) {
          // User requested close
          top.sendKey ("Hold", 1);
          setTimeout (function() { // add timeout
            top.sendKey ("Hold", 0);
            top.sendKey ("R-shift", 0);
         	}, 500);
        }
        else {
          // Program stopped running
          top.sendKey("R-shift", 0);
        }
      }
    });
  }

  // Create numkey only keypad popup
  str = '<div id="dlgNUMPAD" title="">';
  str += '  <iframe id="numpad" name="numpad" src="/frh/jcgtp/jkeypad2.stm" width="200px" height="210px" scrolling="auto" frameborder="1"></iframe>';
  str += '</div>';
  $('body').append(str);
  $("#dlgNUMPAD").dialog({ autoOpen: false, modal: false, resizable: false, width: 240, 
    position: { my: "left top", at: "left bottom", of: window },
    close: function() {
      dlg_numpad_closed = true;
    }
  });

  if (top.g_all_menus) {
    // Create keypad popup
    str = '<div id="dlgKEYPAD" title="">';
    str += '  <iframe id="keypad" name="keypad" src="/frh/jcgtp/jkeypad.stm" width="335px" height="440px" scrolling="auto" frameborder="1"></iframe>';
    str += '</div>';
    $('body').append(str);
    $("#dlgKEYPAD").dialog({ autoOpen: false, modal: false, resizable: false, width: 368, 
      position: { my: "right top", at: "right top+"+ledHeight, of: window },
      close: function() {
        // Reload from cache so SHIFT is cleared
        keypad.location.reload(false);
        dlg_keypad_closed = true;
      }
    });

    // Create jogkey popup
    str = '<div id="dlgJOGKEY" title="">';
    str += '  <iframe id="jogkey" name="jogkey" src="/frh/jcgtp/jitpky2.stm" width="275px" height="380px" scrolling="auto" frameborder="1"></iframe>';
    str += '</div>';
    $('body').append(str);
    $("#dlgJOGKEY").dialog({ autoOpen: false, modal: false, resizable: false, width: 308, 
      position: { my: "right top", at: "right top+"+ledHeight, of: window },
      close: function() {
        // Reload from cache so SHIFT is cleared
        jogkey.location.reload(false);
        dlg_jogkey_closed = true;
      }
    });

    // Create MessageBox popup
    str = '<div id="dlgMSGBOX" title="">';
    str += '  <div>';
    str += '    <p id="dlgMSGTXT" class="dlg_msgbox_text">Message box text #dlgMSGTXT</p>';
    str += '  </div>';
    str += '  <div align="right">';
    str += '    <button type="button" id="dlgMSGBTN" class="dlg_msgbox_btn dlg_okbtn">Ok</button>';
    str += '  </div>';
    str += '</div>';
    $('body').append(str);
    $("#dlgMSGBOX").dialog({ autoOpen: false, modal: false, resizable: false, width: 450,
      open: function() {
        $('.dlg_okbtn').on('click', function (event) {
          $("#dlgMSGBOX").dialog("close");
        });
      },
      close: function() {
        dlg_msgbox_close();
      }
    });
  }

  // Create Reconnect popup
  str = '<div id="dlgPING" title="">';
  str += '  <div>';
  str += '    <p id="dlgPINGTXT1" class="dlg_ping_text"></p>';
  str += '  </div>';
  str += '  <div>';
  str += '    <p id="dlgPINGTXT2" class="dlg_ping_text"></p>';
  str += '  </div>';
  str += '  <div>';
  str += '    <p id="dlgPINGTXT3" class="dlg_ping_text"></p>';
  str += '  </div>';
  str += '</div>';
  $('body').append(str);
  $("#dlgPING").dialog({ autoOpen: false, modal: false, resizable: false,
    dialogClass: 'clsPING',
    open: function(event, ui) { 
      $('.clsPING').find('.ui-dialog-titlebar').css({'background-color':'#FFE109', 'color':'black'});
    },
    close: function() {
      top.close();
    }
  });

  // Create Wait to reconnect popup
  str = '<div id="dlgWTRC" title="">';
  str += '  <div>';
  str += '    <p id="dlgWTRCTXT1" class="dlg_wtrc_text"></p>';
  str += '  </div>';
  str += '  <div>';
  str += '    <p id="dlgWTRCTXT2" class="dlg_wtrc_text"></p>';
  str += '  </div>';
  str += '  <div>';
  str += '    <p id="dlgWTRCTXT3" class="dlg_wtrc_text"></p>';
  str += '  </div>';
  str += '</div>';
  $('body').append(str);
  $("#dlgWTRC").dialog({ autoOpen: false, modal: true, resizable: false,
    dialogClass: 'clsPING',
    open: function(event, ui) { 
      $(".ui-dialog-titlebar-close").hide(); 
      $('.ui-widget-overlay').css({'background-color':'black'});
    },
    close: function() {
      $(".ui-dialog-titlebar-close").show(); 
      $('.ui-widget-overlay').css({'background-color':'#aaa'});
      if (top.g_recon_proc && top.heartcheck_timer) {
        setTimeout(top.check_heartbeat, top.heartcheck_timer);
      }
      top.g_recon_proc = false;
    }
  });

</script>
                                         PNG

   IHDR   (   (   m   	pHYs       
MiCCPPhotoshop ICC profile  xSwX>eVBl "#Y a@
VHU
H(gAZU\8}zy&j 9R<:OHH g  yx~t?o  p.$P&W   "R .T  Sd
   ly|B"  I>    (G$@ `UR, @".Y2G vX@` B,  8 C L0_pH K3w!lBa)f	"#HL  8?flko">! N_puk[ V h]3	Z
zy8@P<
%b0>3o~@z q@qanvRB1n#)4\,XP"MyRD!2	w ONl~Xv @~- g42y  @+   \L  D*AaD@$<B
AT:18\p`	Aa!:b""aH4 Q"rBj]H#-r9\@ 2G1Qu@st4]k=Kut }c1fa\E`X&cX5V5cX7va$^lGXLXC%#W	1'"O%zxb:XF&!!%^'_H$N
!%2IIkHH-S>iL&m O:L	$RJ5e?2BQ:ZImvP/S4u%C-igih/t	EkwHb(k{/LT02goUX**|:V~TUsU?yTU^V}FUP	U6RwRPQ__cFHTc!2eXBrV,kMb[Lvv/{LSCsfffq9J!{--?-jf~7zbrup@,:m:u	6Qu>cy	Gm7046l18cckihhI'&g5x>fob4ek<abi2)kft,9kaEJ6|MV>VyVVI\,mWlPW:vm))Sn1
9a%m;t;|rtuvlp4Wggs5KvSmnzm=}M.]=AXq/^v^Y^O&0m[{`:>=e>>z"=#~~~;yN`k5/>B	Yroc3g,Z0&L~oLGli})*2.QStqt,Yg;jrvgjlRlcxEt$	=sl3Ttcw<Y5Y|8? BP/OnMOEQJ<V8;}ChOFu3	OR+y#MVDq-9Ri+0(Of++ym#slLRPL/+x[[xHHZ3f#|PxY"E#Sw.1]Rdxi}hPXRUjyRC+W4nZcadUj[V*_pFWN_|ymJHnYJjA_mJtzj5a5[6z]V&w{;+xWkE}nb~GwO{{Ejtol	mR6H:powpZ*A'|{PHy+:u-m=^G~1cu5W(=dN?=yLk]Q]gC?tL_]p"b%K==G~pH[oeW<tM;js.]yn&%vw
L]zxem``Y	GG#F#d~VysKXyr:#y=}(@PcO>|/%3    cHRM  z%        u0  `  :  o_F   IDATx1
0Y4fG,$d
]-IN
3W=jT 6bf4do/MBHj_D~m9'q5u   e>    IENDB`                                                                                                                                                                           <!DOCTYPE html>
<html>
<head>
<script>
top.dlg_dialog_inuse = 0;
</script>
</head>
<body>
</body>
</html>
                                                                                                                                                                                                                                                                                                                                                                                                            GIF89a    !   ,       D^ ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     <!DOCTYPE html>
<html>
<head>
<script src="jquery.js?version=V9.3028"></script>
<script src="jquery.iframewrap.js?version=V9.3028"></script>
<script src="jquery.foc.js?version=V9.3028"></script>
<script src="rx.js?version=V9.3028"></script>
<script>

top.clearDevSize();

$(document).ready(function() {
  iframe_size();
});

$(window).on("load", function () {
  if (top.g_irprog) {
    top.switchFocusProc();
  }
});

function iframe_size() {
  var h = prim_height;
  var w = prim_width;
  var hstat = $("#primstat").outerHeight();
  
  if (top.g_irprog) {
    hstat = top.H_PRIMSTAT;
    // iPad needs fixing
    prim_width = $(top.window).width() - top.w_tree;
  }
  else {
    prim_width = $("#primstat").width();
  }
  prim_height = (top.h_mainfrm - hstat - hstat) / 2;
  if ((h != prim_height) || (w != prim_width) || (top.g_irprog)) {
    mode_resize();
  }
  if (top.g_irprog) {
    top.setMultiWinCSS("doubhmod");
  }
}

function mode_resize() {
  var h = prim_height;
  if (top.g_irprog) {
    top.show_hide_keys();
  }
  if((top.keys_vis) || (top.g_irprog)){
    h -= (top.h_keys / 2);
    top.$("#mainfrm").css("height", top.h_mainfrm - top.h_keys);
  }
  var hstat = $("#primstat").outerHeight();
  $("#prim").css("height", h);
  $("#dual").css("height", h);
  $("#dualstat").css("top", h + hstat);
  $("#dual").css("top", h + hstat + hstat);
  if(top.g_irprog) {
    h += top.BORDER_WIDTH;
  }
  $("#prim").iframewrap({ width: prim_width,
                          height: h });
  $("#dual").iframewrap({ width: prim_width,
                          height: h });

  top.setDevSize(0, h, prim_width, 184, 631);
  top.setDevSize(1, h, prim_width, 176, 631);

  if (top.keys_vis) {
    if (first_time) {
      first_time = 0;
    }
    else {
      // vt220 window size change
      top.rpcmc_tpextreq2(0, tp_reconfig_c);
    }
  }
}

// Check to see if keys status has changed
function check_keys() {
  if (prim_visible || dual_visible) {
    // keys must be visible
    if (!top.keys_vis) {
      top.keys_vis = true;
      mode_resize();
    }
  }
  else if (top.keys_vis) {
    // ok to remove keys
    top.keys_vis = false;
    mode_resize();
  }   
} // check_keys

</script>
<style>
  body {
    margin: 0px;
    padding: 0px;
    overflow: hidden;
  }
  iframe { 
    margin: -4px;
    padding: 0px;
    border-color: black;
  }
</style>
</head>
<body>
<iframe id="primstat" name="primstat" src="focsbar1.htm" width="100%" height="38" scrolling="no"></iframe>
<iframe id="prim" name="prim" src="/frh/cgtp/blank.htm" onload="prim_connected()" width="100%" height="50%"></iframe>
<iframe id="dualstat" name="dualstat" src="focsbar2.htm" width="100%" height="38" scrolling="no"></iframe>
<iframe id="dual" name="dual" src="/frh/cgtp/blank.htm" onload="dual_connected()" width="100%" height="50%"></iframe>
</body>
</html>
                                                                                                                      <!DOCTYPE html>
<html>
<head>
<script src="jquery.js?version=V9.3028"></script>
<script src="jquery.iframewrap.js?version=V9.3028"></script>
<script src="jquery.foc.js?version=V9.3028"></script>
<script src="rx.js?version=V9.3028"></script>
<script>

top.clearDevSize();

$(document).ready(function() {
  iframe_size();
});

$(window).on("load", function () {
  if (top.g_irprog) {
    top.switchFocusProc();
  }
});

function iframe_size() {
  var h = prim_height;
  var w = prim_width;
  
  if (top.g_irprog) {
    prim_height = top.h_mainfrm - top.H_PRIMSTAT;
    // iPad needs fixing
    prim_width = ($(top.window).width() - top.w_tree) / 2;
    dual_width = prim_width;
  }
  else {
    prim_height = top.h_mainfrm - $("#primstat").outerHeight();
    prim_width = $("#primstat").width();
    dual_width = $("#dualstat").width();
  }
  if ((h != prim_height) || (w != prim_width) || (top.g_irprog)) {
    mode_resize();
  }
  if (top.g_irprog) {
    top.setMultiWinCSS("doublmod");
  }
}

function mode_resize() {
  var h = prim_height;
  if (top.g_irprog) {
    top.show_hide_keys();
  }
  if((top.keys_vis) || (top.g_irprog)){
    h -= top.h_keys;
    top.$("#mainfrm").css("height", top.h_mainfrm - top.h_keys);
  }
  $("#prim").css("height", h);
  $("#dual").css("height", h);
  if(top.g_irprog) {
    h += top.BORDER_WIDTH;
  }
  $("#prim").iframewrap({ width: prim_width,
                          height: h });
  $("#dual").iframewrap({ width: dual_width,
                          height: h });
  top.setDevSize(0, h, prim_width, 379, 313);
  top.setDevSize(1, h, dual_width, 379, 313);

  if (top.keys_vis) {
    if (first_time) {
      first_time = 0;
    }
    else {
      // vt220 window size change
      top.rpcmc_tpextreq2(0, tp_reconfig_c);
    }
  }
}

// Check to see if keys status has changed
function check_keys() {
  if (prim_visible || dual_visible) {
    // keys must be visible
    if (!top.keys_vis) {
      top.keys_vis = true;
      mode_resize();
    }
  }
  else if (top.keys_vis) {
    // ok to remove keys
    top.keys_vis = false;
    mode_resize();
  }   
} // check_keys

</script>
<style>
  body {
    margin: 0px;
    padding: 0px;
    overflow: hidden;
  }
  iframe { 
    margin: -4px;
    padding: 0px;
    border-color: black;
  }
  table {
    border-collapse: collapse;
    margin: 0px;
    padding: 0px;
    border: none;
  }
</style>
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
  <tr>
    <td width="50%">
<iframe id="primstat" name="primstat" src="focsbar1.htm" width="100%" height="38" scrolling="no"></iframe>
    </td>
    <td>
<iframe id="dualstat" name="dualstat" src="focsbar2.htm" width="100%" height="38" scrolling="no"></iframe>
    </td>
  </tr>
  <tr>
    <td>
<iframe id="prim" name="prim" src="/frh/cgtp/blank.htm" onload="prim_connected()" width="100%"></iframe>
    </td>
    <td>
<iframe id="dual" name="dual" src="/frh/cgtp/blank.htm" onload="dual_connected()" width="100%"></iframe>
    </td>
  </tr>
</table>
</body>
</html>
                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 *  This material is the joint property of FANUC America Corporation and
 *  FANUC LTD Japan, and must be returned to either FANUC America Corporation
 *  or FANUC LTD Japan immediately upon request.  This material and
 *  the information illustrated or contained herein may not be reproduced,
 *  copied, used, or transmitted in whole or in part in any way without the
 *  prior written consent of both FANUC America Corporation and FANUC LTD Japan.
 *  
 *           All Rights Reserved
 *           Copyright (C)   2017
 *           FANUC America Corporation
 *           FANUC LTD Japan
 *  +
 *  Module: draw2d.js
 *  
 *  Description:
 *    Draw2D plugin
 *
 *  Author: Michael Dow
 *          FANUC America Corporation
 *          3900 W. Hamlin Road
 *          Rochester Hills, Michigan    48309-3253
 *  
 *  Modification history:
 *  19-OCT-2017 DOWMW    pr50481 - Initial version
 *  15-FEB-2018 EVANSJA  pr50687b - Support for draw2d on dialog boxes.
 *  28-MAR-2018 DOWMW    pr50481a - Fix some bugs and add new features
 *  24-MAY-2019 DOWMW    v930pr50376b - Change logic for End of Transmission
 *  20-JUN-2019 DOWMW    pr51640 - Fixed lots of issues found during testing.
 *  20-SEP-2019 DOWMW    pr51640b - Fixed logic where ID is not needed.
 *  18-SEP-2020 DOWMW    pr51640c - Fixed some issues with invalid characters.
 *  -
*/

var canvasIDs = [];
var current_canvas = "canvas"

var enabledLayers = [0];
var invertY = 0; /* default origin to top */
//var combinedBuffer = '';
var drawEntities;
var drawEntities_array = [];
var forecolor = "#000000";
var backcolor = "#000000";
var fontsize = 12;

/** The table of color definition for DRAW2D*/
var colorTable = {
  red:        "#FF0000",
  orange:     "#FFC800",
  yellow:     "#FFFF00",
  gray:       "#808080",
  lightgray:  "#C0C0C0",
  darkgray:   "#404040",
  green:      "#00FF00",
  black:      "#000000",
  magenta:    "#FF00FF",
  cyan:       "#00FFFF",
  blue:       "#0000FF",
  white:      "#FFFFFF"
};

var drawEntities_temp = {
  combinedBuffer: "",
  text: {
    id: "",
    layer: 0,
    font: "",
    locate: [0, 0],
    color: 'black',
    bold: false,
    italic: false
  },
  line: {
    id: "",
    layer: 0,
    points: [0, 0, 1, 1], // Only 4 points allowed
    color: 'black',
  },
  path: {
    id: "",
    layer: 0,
    points: [],
    color: 'black',
  },
  circ: {
    id: "",
    layer: 0,
    locate: [0, 0],
    color: 'black',
    radius: 1,
    weight: 1,
    fillColor: "",
    halign: "",
    valign: "",
  },
  rect: {
    id: "",
    layer: 0,
    locate: [0, 0],
    color: 'black',
    height: 1,
    width: 1,
    fillColor: "",
    halign: "",
    valign: "",
    radius: 0,
  },
  diam: {
    id: "",
    layer: 0,
    locate: [0, 0],
    color: 'black',
    height: 1,
    width: 1,
    halign: "",
    valign: "",
  },
  imag: {
    id: "",
    layer: 0,
    locate: [0, 0],
    height: 1,
    width: 1,
    halign: "",
    valign: "",
    imagename: "",
  }
};

// Private functions 
// Create control only when PMON Server is ready
function draw2d_ServerReady(data) {
  // Initialize control data.
  draw2d_InitCtlData(data);

  // Create control.
  draw2d_CreateCtl(data);

  // Initialize events.
  draw2d_InitRobotEvent(true, data);

} // draw2d_ServerReady

function WebGLDetector() {

    try {
        var canvas = document.createElement('canvas'); return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
    } catch (e) {
        return false;
    }
}
// New instance of control.
function draw2d_NPP_New(data) {
  if (!WebGLDetector()) {
    window.location.href = "/frh/diageg/TPIF.htm#TPIF-266";
  }
  if (undefined != data.PipeMonRate) {
    data.PipeMonRate = Number(data.PipeMonRate);
  }

  SetCommonParams(data);
  if (data.IsDialog) {
    draw2d_ServerReady(data);
  }
  else { 
    top.rpcmc_getTaskIdx(data.fDeviceId, function(taskIdx) { 
      data.fTaskIdx = taskIdx;

      // Complete after top.rpcmc_getTaskIdx completes.
      draw2d_ServerReady(data);
    });
  }

} // draw2d_NPP_New

// Destroy instance of control.
function draw2d_NPP_Destroy(data) {

  // Uninitialize events.
  draw2d_InitRobotEvent(false, data);

  // Delete control.
  draw2d_DeleteCtl(data);

} // draw2d_NPP_Destroy

// Private functions

// Set the border.
function draw2d_SetBorder(data) {

  var border = parseInt(data.Border);
  if (border > 0) {
    data.$this.css({"border-style":"inset", "border-width":"' + border + 'px", "border-color":"white"});
  }
  else if (border < 0) {
    border *= -1;
    data.$this.css({"border-style":"inset", "border-width":"' + border + 'px", "border-color":"white"});
  }
  else {
    data.$this.css("border-style", "none");
  }

} // draw2d_SetBorder

// Update Control.
function draw2d_UpdateCtl(data) {


} // draw2d_UpdateCtl

function draw2d_SendPkt(fc, data, optional) {
} // draw2d_UpdateCtl

// Initialize or uninitialize pipe event.
function draw2d_InitPipeEvent(init, data) { 
  /* Get pipe data rate - Default 1sec */
  if (data.PipeMonRate < 0) {
    data.PipeMonRate = 1000;
  }
  
  // Notify PMON to start/stop monitoring our pipe
  if (init) {
    top.jQuery.filelis.bind('PipeEvent', data, draw2d_HandlePipeEvent); // Attach handler for PipeEvent
    top.rpcmc_startPipeMonitor(data.Pipe, data.PipeMonRate); // Start PMON monitor for our pipe
    // Attach handler for KeyReleasedEvent - This is used to listen to end of pipe transmission
    top.jQuery.keylis.bind('KeyReleasedEvent', draw2d_HandleKeyEvent);
  }
  else {
    top.rpcmc_stopPipeMonitor(data.Pipe); // Stop PMON monitor for our pipe
    top.jQuery.filelis.unbind('PipeEvent', draw2d_HandlePipeEvent); // Detach handler for PipeEvent.
    // Detach handler for KeyReleasedEvent.
    top.jQuery.keylis.unbind('KeyReleasedEvent', draw2d_HandleKeyEvent);
  }
} // draw2d_InitPipeEvent

// Replace any indirection with actual value.
function draw2d_IndirectReplace(data) {

  var l_ind;
  var pos;

 $.each(data, function( argn, argv ) { 
    if (typeof argv !== 'string') {
      return;
    }
    // Value contain !PaneId?
    if ((pos = argv.toLowerCase().indexOf("!paneid")) >= 0) {
      argv = argv.substring(0, pos) + data.fTaskIdx + argv.substring(pos+7);
      data[argn] = argv;
    }
  });
} // draw2d_IndirectReplace

// Initialize Control Data.
function draw2d_InitCtlData(data) {

  // Process parameters.
  // Name not supported
  // Border
  // Pipe
  // Scene
  // SubPane
  // Verbose not supported
  // ExecConnectId not required (only for ActiveX Controls)

  data.Pipe = data.Pipe.toUpperCase();
  draw2d_IndirectReplace(data);

  data.SubPane = parseInt(data.SubPane);

  if (data.BackColor == "") {
    data.BackColor = data.InvisibleColor;
  }
  else {
    data.BackColor = translateColor(data.BackColor);
  }
  backcolor = data.BackColor;
  if (data.ForeColor == "") {
    data.ForeColor = data.TextColor;
  }
  else {
    data.ForeColor = translateColor(data.ForeColor);
  }
  forecolor = data.ForeColor;

  if (data.FontSize !== "undefined" && parseFloat(data.FontSize) > 0) {
    fontsize = parseFloat(data.FontSize);
  }
} // draw2d_InitCtlData

// Initialize or uninitialize events for each type.
function draw2d_InitRobotEvent(init, data) {
  // Start/stop the Pipe Event.
  draw2d_InitPipeEvent(init, data);

} // draw2d_InitRobotEvent

// Create Control.
function draw2d_CreateCtl(data) {

  data.$this.css("display", "inline-block");

  if (data.width.indexOf("%") >= 0) {
    var w = top.getLegacyW(data.fDeviceId);
    var dec = parseFloat(data.width);
    data.width = Math.round(w*dec/100);
  }
  data.$this.css("width", data.width + "px");

  if (data.height.indexOf("%") >= 0) {
    var h = top.getLegacyH(data.fDeviceId);
    var dec = parseFloat(data.height);
    data.height = Math.round(h*dec/100);
  }
  data.$this.css("height", data.height + "px");

  data.$this.css("vertical-align", "top");
  draw2d_SetBorder(data);
  SetColors(data);
  SetFont(data);

  draw2d_InitDraw(data);

  // Attach handler for click event.
  data.$this.bind("click", data, draw2d_HandleClickEvent);

} // draw2d_CreateCtl

// Handle Control events.
function draw2d_CtlEvent(data) {

  var sb_state;

  if (data.IsEcho) {
    return;
  }
  if (data.dlgDismiss == "1") {
    // Dismiss dialog box.
    top.rpcmc_sendKeyCode(tk_cancel_c);
  }

} // draw2d_CtlEvent

// Delete Control Data.
function draw2d_DeleteCtl(data) {
} // draw2d_DeleteCtl

// Private functions

function draw2d_HandleKeyEvent(event, key) {
  // These keys came from the controller.
  /* Indicates the pipe transmission is complete */
  if (key == 4) {
    /* Erase buffer here incase processing later fails */
    var drawBuffer = drawEntities.combinedBuffer;
    drawEntities.combinedBuffer = '';
    /* Strip off sequence number if it contains it */
    if (drawBuffer.includes('?_=')) {
      drawBuffer = drawBuffer.substring(0, drawBuffer.indexOf('?_='));
    }
    draw2d_ParseData(drawBuffer);
  }
}

function draw2d_HandlePipeEvent(event, file, buffer) {
  event.preventDefault();
  var data = event.data || event;
  if (file == data.Pipe) {
    if(data.Id) {
      current_canvas = data.Id;
      for (var idx = 0; idx < canvasIDs.length; idx++) {
        if(canvasIDs[idx] == data.Id) {
          drawEntities = drawEntities_array[idx];
          current_canvas = canvasIDs[idx];
        }
      }
    }
    if (buffer.length > 0) {
      drawEntities.combinedBuffer = drawEntities.combinedBuffer.concat(buffer);
    }
  }
  return true;
} // draw2d_HandlePipeEvent

function draw2d_getXmlAsString(xmlDom){
  return (typeof XMLSerializer!=="undefined") ? 
         (new window.XMLSerializer()).serializeToString(xmlDom) : 
          xmlDom.xml;
} // draw2d_getXmlAsString

function draw2d_HandleClickEvent(event) {
  event.preventDefault();
  var data = event.data || event;
  draw2d_CtlEvent(data);
  return true;
} // draw2d_HandleClickEvent

function draw2d_invertY(yData) {
  if(invertY > 0) {
    return (invertY - yData);
  }
  else {
    return yData;
  }
}

function draw2d_DrawText(textData) {
  var ctx = document.getElementById(current_canvas).getContext("2d");

  /* Start Path */
  ctx.beginPath();

  /* Set Font Style */
  /* TODO - Lots of missing features, only supporting size */
  /* default fontsize */
  eval("ctx.font = \"" + fontsize + "px Arial\"");
  if (textData.font) {
    eval("ctx.font = \"" + textData.font + "px Arial\"");
  }

  /* Set font color */
  ctx.fillStyle = forecolor;
  if (typeof textData.color !== 'undefined') {
    if(!isNaN(textData.color) || textData.color.indexOf('#') == -1) {
      ctx.fillStyle = translateColor(parseInt(textData.color));
    }
    else {
      ctx.fillStyle = textData.color;
    }
  }

  /* TODO - Can we support bold and italic? */

  /* Set text halign - center by default (Spec doesnt even say it is supported) */
  ctx.textAlign = 'center';
  if (textData.halign) {
    if (textData.halign.toLowerCase() == "left") {
      ctx.textAlign = 'left';
    }
    else if (textData.halign.toLowerCase() == "right") {
      ctx.textAlign = 'right';
    }
    else if (textData.halign.toLowerCase() == "center") {
      // Do nothing
    }
  }
  
  /* Set circle valign - top by default (Spec doesnt even say it is supported) */
  ctx.textBaseline = 'top'
  if (textData.valign) {
    if (textData.valign.toLowerCase() == "top") {
      // Do nothing
    }
    else if (textData.valign.toLowerCase() == "bottom") {
      ctx.textBaseline = 'bottom'
    }
    else if (textData.valign.toLowerCase() == "middle") {
      ctx.textBaseline = 'middle'
    }
  }
  
  ctx.fillText(textData.string, textData.locate[0], draw2d_invertY(textData.locate[1]));

}

function draw2d_DrawLine(lineData) {
  var ctx = document.getElementById(current_canvas).getContext("2d");

  /* Start Path */
  ctx.beginPath();

  /* Plot Lines */
  /* First two points are the starting location */
  ctx.moveTo(lineData.points[0], draw2d_invertY(lineData.points[1]));
  for (var j = 2; j < lineData.points.length - 1; j += 2) {
    ctx.lineTo(lineData.points[j], draw2d_invertY(lineData.points[j + 1]));
  }

  /* Set line color */
  ctx.strokeStyle = forecolor
  if (typeof lineData.color !== 'undefined') {
    if(!isNaN(lineData.color) || lineData.color.indexOf('#') == -1) {
      ctx.strokeStyle = translateColor(parseInt(lineData.color));
    }
    else {
      ctx.strokeStyle = lineData.color;
    }
  }

  ctx.stroke();
}

function draw2d_DrawCircle(circleData) {
  var ctx = document.getElementById(current_canvas).getContext("2d");

  var locX, locY, radius;

  /* Start Path */
  ctx.beginPath();

  /* Set Circle Location */
  locX = circleData.locate[0];
  locY = draw2d_invertY(circleData.locate[1]);

  /* Set circle color */
  ctx.strokeStyle = forecolor;
  if (typeof circleData.color !== 'undefined') {
    if(!isNaN(circleData.color) || circleData.color.indexOf('#') == -1) {
      ctx.strokeStyle = translateColor(parseInt(circleData.color));
    }
    else {
      ctx.strokeStyle = circleData.color;
    }
  }

  /* Set circle radius */
  if (circleData.radius) {
    radius = circleData.radius;
  }

  /* Set circle weight */
  if (circleData.weight) {
    ctx.lineWidth = circleData.weight;
  }

  /* Set circle halign - center by default (Spec says left but that is not the logic) */
  if (circleData.halign) {
    if (circleData.halign.toLowerCase() == "left") {
      locX = locX + radius;
    }
    else if (circleData.halign.toLowerCase() == "right") {
      locX = locX - radius;
    }
    else if (circleData.halign.toLowerCase() == "center") {
      // Do nothing
    }
  }

  /* Set circle valign - middle by default (Spec says bottom but that is not the logic) */
  if (circleData.valign) {
    if (circleData.valign.toLowerCase() == "top") {
      locY = locY + radius;
    }
    else if (circleData.valign.toLowerCase() == "bottom") {
      locY = locY - radius;
    }
    else if (circleData.valign.toLowerCase() == "middle") {
      // Do Nothing
    }
  }

  /* Draw Circle */
  ctx.arc(parseInt(locX), parseInt(locY), radius, 0 * Math.PI, 2 * Math.PI); /* (x,y,r,startAngle,endAngle,counterclockwise) */

  /* Set circle fill color - Needs to go after ARC */
  if (typeof circleData.fillColor !== 'undefined') {
    if(!isNaN(circleData.fillColor) || circleData.fillColor.indexOf('#') == -1) {
      ctx.fillStyle = translateColor(parseInt(circleData.fillColor));
    }
    else {
      ctx.fillStyle = circleData.fillColor;
    }
    ctx.fill();
  }
  
  ctx.stroke();
}

function draw2d_DrawRectangle(rectData) {
  var ctx = document.getElementById(current_canvas).getContext("2d");

  var locX, locY, rectWidth, rectHeight;
  var cornerRadius = 0;

  /* Start Path */
  ctx.beginPath();

  /* Set Rectangle Location */
  locX = rectData.locate[0];
  locY = draw2d_invertY(rectData.locate[1]);

  /* Set Rectangle color */
  ctx.strokeStyle = forecolor;
  if (typeof rectData.color !== 'undefined') {
    if(!isNaN(rectData.color) || rectData.color.indexOf('#') == -1) {
      ctx.strokeStyle = translateColor(parseInt(rectData.color));
    }
    else {
      ctx.strokeStyle = rectData.color;
    }
  }

  /* Set Rectangle height */
  if (rectData.height) {
    rectHeight = rectData.height;
  }

  /* Set Rectangle width */
  if (rectData.width) {
    rectWidth = rectData.width;
  }
  
  /* Set Rectangle weight */
  if (rectData.weight) {
    ctx.lineWidth = rectData.weight;
  }

  /* Set Rectangle corner radius */
  if (rectData.radius) {
    cornerRadius = rectData.radius;
  }

  locX = locX - (rectWidth / 2);
  locY = locY - (rectHeight / 2);

  /* Set Rectangle halign - center by default (Spec says left but that is not the logic) */
  if (rectData.halign) {
    if (rectData.halign.toLowerCase() == "left") {
      locX = locX + (rectWidth / 2);
    }
    else if (rectData.halign.toLowerCase() == "right") {
      locX = locX - (rectWidth / 2);
    }
    else if (rectData.halign.toLowerCase() == "center") {
      // Do Nothing
    }
  }

  /* Set Rectangle valign - middle by default (Spec says bottom but that is not the logic) */
  if (rectData.valign) {
    if (rectData.valign.toLowerCase() == "top") {
      locY = locY + (rectHeight / 2);
    }
    else if (rectData.valign.toLowerCase() == "bottom") {
      locY = locY - (rectHeight / 2);
    }
    else if (rectData.valign.toLowerCase() == "middle") {
      // Do Nothing
    }
  }
  
  /* Set Rectangle corner radius */
  if (rectData.radius) {
    cornerRadius = rectData.radius;
    var r = locX + rectWidth;
    var b = locY + rectHeight;
    ctx.moveTo(locX + cornerRadius, locY);
    ctx.lineTo(r - cornerRadius, locY);
    ctx.quadraticCurveTo(r, locY, r, locY + cornerRadius);
    ctx.lineTo(r, locY + rectHeight - cornerRadius);
    ctx.quadraticCurveTo(r, b, r - cornerRadius, b);
    ctx.lineTo(locX + cornerRadius, b);
    ctx.quadraticCurveTo(locX, b, locX, b - cornerRadius);
    ctx.lineTo(locX, locY + cornerRadius);
    ctx.quadraticCurveTo(locX, locY, locX + cornerRadius, locY);
  }
  else {
    ctx.rect(locX, locY, rectWidth, rectHeight);
  }

  /* Set Rectangle fill color - Needs to go after the rect is drawn */
  if (typeof rectData.fillColor !== 'undefined') {
    if(!isNaN(rectData.fillColor) || rectData.fillColor.indexOf('#') == -1) {
      ctx.fillStyle = translateColor(parseInt(rectData.fillColor));
    }
    else {
      ctx.fillStyle = rectData.fillColor;
    }
    ctx.fill();
  }

  ctx.stroke();
}

function draw2d_DrawDiamond(diamData) {
  /* Basically we need to convert the diamond shape to 4 lines and pass to draw line */
  var ctx = document.getElementById(current_canvas).getContext("2d");
  var locX, locY, diamWidth, diamHeight;

  /* Set Diamond Location */
  locX = diamData.locate[0];
  locY = draw2d_invertY(diamData.locate[1]);

  /* Set Diamond height */
  if (diamData.height) {
    diamHeight = diamData.height;
  }

  /* Set Diamond width */
  if (diamData.width) {
    diamWidth = diamData.width;
  }
  
  /* Set Diamond weight */
  if (diamData.weight) {
    ctx.lineWidth = diamData.weight;
  }

  /* Set Diamond halign - center by default (Spec says left but that is not the logic) */
  if (diamData.halign) {
    if (diamData.halign.toLowerCase() == "left") {
      locX = locX + (diamWidth / 2);
    }
    else if (diamData.halign.toLowerCase() == "right") {
      locX = locX - (diamWidth / 2);
    }
    else if (diamData.halign.toLowerCase() == "center") {
      // Do Nothing
    }
  }

  /* Set Diamond valign - middle by default (Spec says bottom but that is not the logic) */
  if (diamData.valign) {
    if (diamData.valign.toLowerCase() == "top") {
      locY = locY + (diamHeight / 2);
    }
    else if (diamData.valign.toLowerCase() == "bottom") {
      locY = locY - (diamHeight / 2);
    }
    else if (diamData.valign.toLowerCase() == "middle") {
      // Do Nothing
    }
  }

  diamData.points = [];
  diamData.points[0] = locX;
  diamData.points[1] = locY - (diamHeight / 2);
  diamData.points[2] = locX + (diamWidth / 2);
  diamData.points[3] = locY;
  diamData.points[4] = locX;
  diamData.points[5] = locY + (diamHeight / 2);
  diamData.points[6] = locX - (diamWidth / 2);
  diamData.points[7] = locY;
  //diamData.points[8] = locX;
  //diamData.points[9] = locY - (diamHeight / 2);

  draw2d_DrawLine(diamData);
  ctx.closePath();
  ctx.stroke();
  
  /* Set Diamond fill color - Needs to go after the rect is drawn */
  if (typeof diamData.fillColor !== 'undefined') {
    if(!isNaN(diamData.fillColor) || diamData.fillColor.indexOf('#') == -1) {
      ctx.fillStyle = translateColor(parseInt(diamData.fillColor));
    }
    else {
      ctx.fillStyle = diamData.fillColor;
    }
    ctx.fill();
  }
}

function draw2d_DrawImage(imageData) {
  var ctx = document.getElementById(current_canvas).getContext("2d");
  var imageObj = new Image;

  var locX, locY, imagWidth, imagHeight;

  imageObj.onload = function () {
  
  /* Set Circle Location */
  locX = imageData.locate[0];
  locY = draw2d_invertY(imageData.locate[1]);

  /* Default height to size of image */
  imagHeight = this.height;
  imagWidth = this.width;
  
  /* Set Image height */
  if (imageData.height) {
    imagHeight = imageData.height;
  }

  /* Set Image width */
  if (imageData.width) {
    imagWidth = imageData.width;
  }

  locX = locX - (imagWidth/2); /* Origin center of image */
  /* Set Image halign - center by default (Spec says left but that is not the logic) */
  if (imageData.halign) {
    if (imageData.halign.toLowerCase() == "left") {
      locX = locX + (imagWidth / 2);
    }
    else if (imageData.halign.toLowerCase() == "right") {
      locX = locX - (imagWidth / 2);
    }
    else if (imageData.halign.toLowerCase() == "center") {
      // Do Nothing
    }
  }

  locY = locY - (imagHeight/2); /* Origin center of image */
  /* Set Image valign - middle by default (Spec says bottom but that is not the logic) */
  if (imageData.valign) {
    if (imageData.valign.toLowerCase() == "top") {
      locY = locY + (imagHeight / 2);
    }
    else if (imageData.valign.toLowerCase() == "bottom") {
      locY = locY - (imagHeight / 2);
    }
    else if (imageData.valign.toLowerCase() == "middle") {
      // Do Nothing
    }
  }
    
    ctx.drawImage(imageObj, locX, locY, imagWidth, imagHeight);
  };

  imageObj.src = imageData.imagename;
  //imageObj.src = "/mc/done.gif";
}

function draw2d_DeleteEntitieID(entitieID) 
{
    for (var i = 0; i < drawEntities.text.length; i++) {
      if(drawEntities.text[i].id == entitieID) {
        drawEntities.text.splice(i, 1);
      }
    }
    for (var i = 0; i < drawEntities.line.length; i++) {
      if (drawEntities.line[i].id == entitieID) {
        drawEntities.line.splice(i, 1);
      }
    }
    for (var i = 0; i < drawEntities.path.length; i++) {
      if (drawEntities.path[i].id == entitieID) {
        drawEntities.path.splice(i, 1);
      }
    }
    for (var i = 0; i < drawEntities.circ.length; i++) {
      if (drawEntities.circ[i].id == entitieID) {
        drawEntities.circ.splice(i, 1);
      }
    }
    for (var i = 0; i < drawEntities.rect.length; i++) {
      if (drawEntities.rect[i].id == entitieID) {
        drawEntities.rect.splice(i, 1);
      }
    }
    for (var i = 0; i < drawEntities.diam.length; i++) {
      if (drawEntities.diam[i].id == entitieID) {
        drawEntities.diam.splice(i, 1);
      }
    }
    for (var i = 0; i < drawEntities.imag.length; i++) {
      if (drawEntities.imag[i].id == entitieID) {
        drawEntities.imag.splice(i, 1);
      }
    }
}

function draw2d_DrawEntities() {

  var ctx = document.getElementById(current_canvas).getContext("2d");
  /* clear the canvas */
  ctx.fillStyle = backcolor;
  ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

  /* Sort the layers from lowest to highest */
  enabledLayers.sort(function (a, b) {
    return a - b
  })

  for (var idx = 0; idx < enabledLayers.length; idx++) {
    for (var i = 0; i < drawEntities.text.length; i++) {
      if(drawEntities.text[i].layer == enabledLayers[idx]) {
        draw2d_DrawText(drawEntities.text[i]);
      }
    }
    for (var i = 0; i < drawEntities.line.length; i++) {
      if (drawEntities.line[i].layer == enabledLayers[idx]) {
        draw2d_DrawLine(drawEntities.line[i]);
      }
    }
    for (var i = 0; i < drawEntities.path.length; i++) {
      if (drawEntities.path[i].layer == enabledLayers[idx]) {
        draw2d_DrawLine(drawEntities.path[i]);
      }
    }
    for (var i = 0; i < drawEntities.circ.length; i++) {
      if (drawEntities.circ[i].layer == enabledLayers[idx]) {
        draw2d_DrawCircle(drawEntities.circ[i]);
      }
    }
    for (var i = 0; i < drawEntities.rect.length; i++) {
      if (drawEntities.rect[i].layer == enabledLayers[idx]) {
        draw2d_DrawRectangle(drawEntities.rect[i]);
      }
    }
    for (var i = 0; i < drawEntities.diam.length; i++) {
      if (drawEntities.diam[i].layer == enabledLayers[idx]) {
        draw2d_DrawDiamond(drawEntities.diam[i]);
      }
    }
    for (var i = 0; i < drawEntities.imag.length; i++) {
      if (drawEntities.imag[i].layer == enabledLayers[idx]) {
        draw2d_DrawImage(drawEntities.imag[i]);
      }
    }
  }

}

function draw2d_InitDraw(data) {

  if (data) {
    if(data.Id) {
      canvasIDs.push(data.Id);
      current_canvas = data.Id;
      drawEntities_array.push(Object.assign({}, drawEntities_temp));
      drawEntities = drawEntities_array[drawEntities_array.length - 1];
      var test = drawEntities_temp;
      var objCopy = Object.assign({}, drawEntities_temp);
    }
    /* Create Canvas for the draw area */
    var out = '<canvas id="' + current_canvas + '"></canvas>';
    data.$this.html(out);
    var ctx = document.getElementById(current_canvas).getContext("2d");
    ctx.canvas.height = data.height;
    ctx.canvas.width = data.width;
    
    /* Set Invert if set true */
    if (data.InvertY !== undefined && data.InvertY === "1") {
      invertY = ctx.canvas.height; /* change origin to bottom */
    }
  }
  else {
    var ctx = document.getElementById(current_canvas).getContext("2d");
    /* clear the canvas */
    ctx.fillStyle = backcolor;
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  }
  
  drawEntities.text = [];
  drawEntities.line = [];
  drawEntities.path = [];
  drawEntities.circ = [];
  drawEntities.rect = [];
  drawEntities.diam = [];
  drawEntities.imag = [];
  //enabledLayers = []; /* Following old logic - Clear only clears screen, active lavers stay active */

  if (data && data.Data) {
    draw2d_ParseData(data.Data)
  }

}

function draw2d_ParseData(drawData) {

  var dataString = drawData.trim();
  //dataString = dataString.replace(/\s\s+/g, ' '); /* Replace whitespace with single space to split later */
  //dataString = dataString.replace(/'/g, '"');
  //var splitData = dataString.match(/(?:[^\s"]+|"[^"]*")+/g) /* Split data at spaces, but not if space is inside quotes */

  /* Replace single quote with double quote */
  dataString = dataString.replace(/'/g, '"');
  /* remove whitespace before and after equal sign */
  dataString = dataString.replace(/\s*=\s*/g, '=');
  /* remove invalid characters '?' */
  dataString = dataString.replace(/\uFFFD/g, '')
  var splitData = dataString.match(/(?:[^\s"]+|"[^"]*")+/g)

  var currentEntity, entityData;

  entityData = []
  entityData[0] = currentEntity = "none";

  var idx = 0;
  var bNewType = false;

  for (var i = 0; i < splitData.length; i++) {
    if (splitData[i]) {
      var tempLineData = splitData[i].trim();
      /* DEBUG */
      //console.log(tempLineData);
      if (tempLineData.toLocaleLowerCase() == "clear") {
        draw2d_InitDraw();
        continue;
      }

      /* Split data at equal, but not if equal is inside quotes */
      var subData = tempLineData.match(/(?:[^="]+|"[^"]*")+/g)
      if (subData[0].toLowerCase() === "text") {
        currentEntity = "text";
        bNewType = true;
      }
      else if (subData[0].toLowerCase() === "line") {
        currentEntity = "line";
        bNewType = true;
      }
      else if (subData[0].toLowerCase() === "path") {
        currentEntity = "path";
        bNewType = true;
      }
      else if (subData[0].toLowerCase() === "circ") {
        currentEntity = "circ";
        bNewType = true;
      }
      else if (subData[0].toLowerCase() === "rect") {
        currentEntity = "rect";
        bNewType = true;
      }
      else if (subData[0].toLowerCase() === "diam") {
        currentEntity = "diam";
        bNewType = true;
      }
      else if (subData[0].toLowerCase() === "imag") {
        currentEntity = "imag";
        bNewType = true;
      }
      else if (subData[0].toLowerCase() === "inverty") {
        invertY = 0;
        if (subData[1] == 1) {
          var ctx = document.getElementById(current_canvas).getContext("2d");
          invertY = ctx.canvas.height; /* change origin to bottom */
        }
        continue;
      }
      else if (subData[0].toLowerCase() === "delete") {
        draw2d_DeleteEntitieID(subData[1].toLowerCase());
        continue;
      }
      else if (subData[0].toLowerCase() === "verbose") {
        /* Not sure what this is */
        continue;
      }
      else if (subData[0].toLowerCase() === "layeron") {
        var bAddLayer;
        var tempLayers = subData[1].split(',');

        /* If enabled layers is empty just set the values */
        if (enabledLayers.length == 0) {
          enabledLayers = tempLayers;
          continue;
        }

        for (var idx1 = 0; idx1 < tempLayers.length; idx1++) {
          bAddLayer = true;
          for (var idx2 = 0; idx2 < enabledLayers.length; idx2++) {
            if (tempLayers[idx1] == enabledLayers[idx2]) {
              bAddLayer = false;
              break
            }
          }
          /* If layer is not already on the list, add layer */
          if (bAddLayer) {
            enabledLayers.push(parseInt(tempLayers[idx1]));
          }
        }
        continue;
      }
      else if (subData[0].toLowerCase() === "layeroff") {
        var bDelLayer;
        var tempLayers = subData[1].split(',');

        for (var idx1 = 0; idx1 < tempLayers.length; idx1++) {
          bDelLayer = false;
          for (var idx2 = 0; idx2 < enabledLayers.length; idx2++) {
            if (tempLayers[idx1] == enabledLayers[idx2]) {
              bAddLayer = true;
              break
            }
          }
          /* if layer was on the list, remove layer */
          if (bAddLayer) {
            enabledLayers.splice(idx2, 1);
          }
        }
        continue;
      }

      /* Clean up value text */
      if (subData[1] !== undefined) {
        /* remove quotes - They will be added in later if needed */
        subData[1] = subData[1].replace(/"/g, "");
        /* Remove leading and training whitespace */
        subData[1] = subData[1].trim();
      }

      /* Setup default color and font */
      if (subData[0].toLowerCase() === "fontsize") {
        if (subData[1] !== undefined) {
          fontsize = subData[1];
        }
      }
      else if (subData[0].toLowerCase() === "forecolor" || subData[0].toLowerCase() === "backcolor" || subData[0].toLowerCase() === "fontsize") { /* Setup default colors */
        if (subData[1] !== undefined) {
          var curColor = subData[1];
          /* Convert to hex and put in proper format */
          if (!isNaN(curColor) || curColor.indexOf('#') == -1) {
            curColor = translateColor(parseInt(curColor));
          }
          eval(subData[0].toLowerCase() + " = \"" + curColor + "\"");
        }
      }
      else if (currentEntity != "none") {
        if (bNewType) {
          bNewType = false;
          /* get index for entity type */
          idx = -1
          var tempID;
          var tempLength = eval("drawEntities." + currentEntity + ".length");
          if (tempLength > 0) {  //Need to check and see if new ID or not
            for (var idIdx = 0; idIdx < tempLength && idx == -1; idIdx++) {
              tempID = eval("drawEntities." + currentEntity + "[" + idIdx + "].id");
              if (subData[1] !== undefined && subData[1].toLowerCase() === tempID)
                idx = idIdx;
            }
          }
          if (idx == -1) { // No match found, make new index
            eval("drawEntities." + currentEntity + ".push([])");
            tempLength = eval("drawEntities." + currentEntity + ".length");
            idx = tempLength - 1;
            if (subData[1] !== undefined) {
              tempID = eval("drawEntities." + currentEntity + "[" + idx + "].id = \"" + subData[1].toLowerCase() + "\"");
            }
            eval("drawEntities." + currentEntity + "[" + idx + "].layer = 0");
          }
        }
        else {
          if (subData[0].toLowerCase() === "points" || subData[0].toLowerCase() === "locate") {
            var pointData = subData[1].replace(/[^\d.]+/g, ",");
            pointData = pointData.split(',');
            /* Initilize array if it does not exist or it is not a path */
            if (eval("drawEntities." + currentEntity + "[" + idx + "]." + subData[0].toLowerCase() + " === undefined") || currentEntity != "path") {
              eval("drawEntities." + currentEntity + "[" + idx + "]." + subData[0].toLowerCase() + " = []");
            }
            for (var numPoint = 0; numPoint < pointData.length; numPoint++) {
              //eval("drawEntities." + currentEntity + "[" + idx + "]." + subData[0].toLowerCase() + "[" + numPoint + "] = " + pointData[numPoint]);
              eval("drawEntities." + currentEntity + "[" + idx + "]." + subData[0].toLowerCase() + ".push(" + pointData[numPoint] + ")");
            }
          }
          else if (subData[0].toLowerCase() === "halign" || subData[0].toLowerCase() === "valign" || subData[0].toLowerCase() === "imagename" || subData[0].toLowerCase() === "string") {
            eval("drawEntities." + currentEntity + "[" + idx + "]." + subData[0].toLowerCase() + " = \"" + subData[1] + "\"");
          }
          else if (subData[0].toLowerCase() === "fill") { /* Since fill is a function the name fill was causing issues */
            /* Default to unfill by setting to background color */
            eval("drawEntities." + currentEntity + "[" + idx + "].fillColor = \"" + backcolor + "\"");
            if (subData[1] !== undefined) {
              var curColor = subData[1];
              /* Convert to hex and put in proper format */
              if (!isNaN(curColor) || curColor.indexOf('#') == -1) {
                curColor = translateColor(parseInt(curColor));
              }
              eval("drawEntities." + currentEntity + "[" + idx + "].fillColor = \"" + curColor + "\"");
            }
          }
          else if (subData[0].toLowerCase() === "color") { /* Since color can be multiple types it was causing issues */
            /* Default to forecolor color */
            eval("drawEntities." + currentEntity + "[" + idx + "].color = \"" + forecolor + "\"");
            if (subData[1] !== undefined) {
              var curColor = subData[1];
              /* Convert to hex and put in proper format */
              if (!isNaN(curColor) || curColor.indexOf('#') == -1) {
                curColor = translateColor(parseInt(curColor));
              }
              eval("drawEntities." + currentEntity + "[" + idx + "].color = \"" + curColor + "\"");
            }
          }
          else if (colorTable[subData[0].toLowerCase()]) { /* If the color just comes in as a name */
            eval("drawEntities." + currentEntity + "[" + idx + "].color = \"" + colorTable[subData[0].toLowerCase()] + "\"");
          }
          /* font */
          else if (subData[0].toLowerCase() === "font") {
            /* Sometimes there was junk after the size, remove junk after number */
            subData[1] = subData[1].replace(/[^\d]+$/,'')
            if (subData[1].substring(0, 1) == '+' || subData[1].substring(0, 1) == '-') {
              if (eval("drawEntities." + currentEntity + "[" + idx + "]." + subData[0].toLowerCase() + " === undefined")) {
                eval("drawEntities." + currentEntity + "[" + idx + "]." + subData[0].toLowerCase() + " = 0");
              }
              eval("drawEntities." + currentEntity + "[" + idx + "]." + subData[0].toLowerCase() + " " + subData[1].substring(0, 1) + "= " + subData[1].substring(1, subData[1].length));
            }
            else {
              eval("drawEntities." + currentEntity + "[" + idx + "]." + subData[0].toLowerCase() + " = " + subData[1]);
            }
          }
          else {
              eval("drawEntities." + currentEntity + "[" + idx + "]." + subData[0].toLowerCase() + " = " + subData[1]);
          }
        }
      }
      else {
        /* Do not know command */
      }
    }
  }

  draw2d_DrawEntities();

}                                                                                                                                                                                                                                                            /*
 *  This material is the joint property of FANUC Robotics America  and
 *  FANUC  LTD  Japan,  and  must be returned to either FANUC Robotics
 *  America or FANUC LTD Japan immediately upon request.  This material  and
 *  the  information  illustrated or contained herein may not be reproduced,
 *  copied, used, or transmitted in whole or in part in any way without  the
 *  prior written consent of both FANUC Robotics America and FANUC LTD
 *  Japan.
 *
 *           All Rights Reserved
 *           Copyright (C)   2016
 *           FANUC Robotics America
 *           FANUC LTD Japan
 *
 *  +
 *  Module: draw3d.js
 *
 *  Description:
 *    Draw3d plugin
 *
 *  Author: Judy Evans
 *          FANUC Robotics America
 *          3900 W. Hamlin Road
 *          Rochester Hills, Michigan    48309-3253
 *
 *  Modification history:
 *  15-APR-2015 EVANSJA Initial version
 *  29-JUN-2016 EVANSJA All functions require unique names
 *  05-JAN-2017 EVANSJA Remove the "Under construction" XML
 *  18-Aug-2017  Krause   WebGL pr50347 Attach to actual webgl objects !  Automode
 *  18-SEP-2017 EVANSJA pr50432 - Move common javascript to util.js
 *  26-Sep-2017  Krause   WebGL pr50402 detect capability, use GL init commands
 *  15-FEB-2018 EVANSJA  pr50687b - Support for draw3d on dialog boxes.
 *  26-Mar-2018  Krause   WebGL pr50817 make mouse events work
 *  26-Mar-2018  Krause   WebGL pr50817c resize events from framework
 *  26-May-2019  Krause   pr51560 Multi-connection
 *  28-Jun-2019  Krause   Fpr51560 fix touch events
 *  -
*/
// tpglpkt.h
var TPGL_INITDRAW_FC = 2;
var TPGL_DELTADRAW_FC = 3;
var TPGL_INTERACT_FC = 4;
var TPGL_EXIT_FC = 5;
var TPGL_SELECT_FC = 6;
var TPGL_FINISHED_FC = 7;
var TPGL_OCXEXIT_FC = 8;
var TPGL_INITECHO_FC = 9;
var TPGL_REINITDRAW_FC = 10;
var TPGL_STATICDATA_FC = 11;
var TPGL_DISCONNECT_FC = 12;
var TPGL_KARELREQ_FC = 14;
var TPGL_KARELCAN_FC = 15;
var TPGL_TOGGLESCENE_FC = 16;
var TPGL_SOFTKEY_FC = 17;
var TPGL_ENDEDIT_FC = 18;
var TPGL_DISCOECHO_FC = 19;
var TPGL_4DMENU_FC = 20;

var TPGL_4DMENU_SEL_FC = 26;
var TPGL_INITWGLDRAW_FC = 27;    /* TPGL_INITDRAW_FC but initiated from WebGL */
var TPGL_INITWGLECHO_FC = 28;    /* TPGL_INITECHO_FC but initiated from WebGL */

var SV3D = 1398158149;  // 'SV3D'

// Private functions
// Create control only when PMON Server is ready
function draw3d_ServerReady(data) {
  // Initialize control data.
  draw3d_InitCtlData(data);

  // Create control.
  //draw3d_CreateCtl(data);

  // Initialize events.
  draw3d_InitRobotEvent(true, data);

  // Create GLWorld
  //GLWorld_new(data);
  // Need the name of the primary pipe to create the scene
  var canvas = new FRCCanvas(top.g_webgl);
  var connect = FRCCanvas.GetConnect(data.Pipe, document.URL);
  var scene = FRCCanvas.GetScene(data.Pipe);  // This will create the scene if it doesn't exist yet
  connect.ctrl_data = data;
  scene.ctrl_data = data;
  scene.standalone = false;
  connect.standalone = false;
  connect.standalone = false;
  connect.logged_in = true;

 // scene.showFPS = true;
  data.glscene = scene;
  data.glconnect= connect;

  scene.Initialize();
  var canvasid = data.Pipe.substring(0, data.Pipe.length - 4);

  var test = document.getElementById(canvasid);

  canvasid = '#' + canvasid;

 // var test = document.getElementById(GLCANVAS)
  $(canvasid).bind("mousedown", data, draw3d_HandleMouseDownEvent);
  $(canvasid).bind("mouseup", data, draw3d_HandleMouseUpEvent);
  $(canvasid).bind("mousemove", data, draw3d_HandleMouseMoveEvent);
  $(canvasid).bind("click", data, draw3d_HandleClickEvent);
  $(canvasid).bind("dblclick", data, draw3d_HandleDblClickEvent);
  $(canvasid).bind("focusin", data, draw3d_HandleFocusEvent);

  $(canvasid).bind('touchstart', data, draw3d_HandleTouchStartEvent);
  $(canvasid).bind('touchend', data, draw3d_HandleTouchEndEvent);
  $(canvasid).bind('touchmove', data, draw3d_HandleTouchMoveEvent);

  $(window).resize(function () {
      FRCCanvas.ResizeWindow();
   });

  // Send packet to init draw
  var pkt_id;
  if (data.IsEcho) {
    pkt_id = TPGL_INITWGLECHO_FC;
    scene.EchoMode();
  }
  else {
      pkt_id = TPGL_INITWGLDRAW_FC;
  }
  top.rpcmc_ossndpkt_ext3d(PKT_TYP7, 0, SSC_TPGL, pkt_id, TID_SV3D, SV3D, top.g_version, data.fTaskIdx, data.SubPane, data.Scene);

} // draw3d_ServerReady

function WebGLDetector() {

    try {
        var canvas = document.createElement('canvas'); return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
    } catch (e) {
        return false;
    }
}
// New instance of control.
function draw3d_NPP_New(data) {
  if (!WebGLDetector()) {
    window.location.href = "/frh/diageg/TPIF.htm#TPIF-266";
  }

  SetCommonParams(data);
  if (data.IsDialog) {
    draw3d_ServerReady(data);
  }
  else {
    top.rpcmc_getTaskIdx(data.fDeviceId, function(taskIdx) {
      data.fTaskIdx = taskIdx;

      // Complete after top.rpcmc_getTaskIdx completes.
      draw3d_ServerReady(data);
    });
  }

} // draw3d_NPP_New

// Destroy instance of control.
function draw3d_NPP_Destroy(data) {

  // Uninitialize events.
  draw3d_InitRobotEvent(false, data);

  // Delete control.
  draw3d_DeleteCtl(data);

} // draw3d_NPP_Destroy

// Private functions

// Set the border.
function draw3d_SetBorder(data) {

  var border = parseInt(data.Border);
  if (border > 0) {
    data.$this.css({"border-style":"inset", "border-width":"' + border + 'px", "border-color":"white"});
  }
  else if (border < 0) {
    border *= -1;
    data.$this.css({"border-style":"inset", "border-width":"' + border + 'px", "border-color":"white"});
  }
  else {
    data.$this.css("border-style", "none");
  }

} // draw3d_SetBorder

// Update Control.
function draw3d_UpdateCtl(data) {


} // draw3d_UpdateCtl

function draw3d_SendPkt(fc, data, optional) {
    top.rpcmc_ossndpkt_ext3d(PKT_TYP7, 0, SSC_TPGL, fc, TID_SV3D, SV3D, top.g_version, data.fTaskIdx, data.SubPane, data.Scene, optional);
} // draw3d_UpdateCtl

// Initialize or uninitialize pipe event.
function draw3d_InitPipeEvent(init, data) {

  // Notify PMON to start/stop monitoring our pipe
  if (init) {
    top.jQuery.filelis.bind('PipeEvent', data, draw3d_HandlePipeEvent); // Attach handler for PipeEvent
    top.rpcmc_startPipeMonitor(data.Pipe, NOT_A_SHORT); // Start PMON monitor for our pipe
  }
  else {
    top.rpcmc_stopPipeMonitor(data.Pipe); // Stop PMON monitor for our pipe
    top.jQuery.filelis.unbind('PipeEvent', draw3d_HandlePipeEvent); // Detach handler for PipeEvent.
  }
} // draw3d_InitPipeEvent

// Replace any indirection with actual value.
function draw3d_IndirectReplace(data) {

  var l_ind;
  var pos;

 $.each(data, function( argn, argv ) {
    if (typeof argv !== 'string') {
      return;
    }
    // Value contain !PaneId?
    if ((pos = argv.toLowerCase().indexOf("!paneid")) >= 0) {
      argv = argv.substring(0, pos) + data.fTaskIdx + argv.substring(pos+7);
      data[argn] = argv;
    }
  });
} // draw3d_IndirectReplace

// Initialize Control Data.
function draw3d_InitCtlData(data) {

  // Process parameters.
  // Name not supported
  // Border
  // Pipe
  // Scene
  // SubPane
  // Verbose not supported
  // ExecConnectId not required (only for ActiveX Controls)

  data.Pipe = data.Pipe.toUpperCase();
  draw3d_IndirectReplace(data);

  data.SubPane = parseInt(data.SubPane);

  // Need the name of the primary pipe to create the scene
  //scene = new FRCScene(true, data.Pipe);

  if (data.BackColor == "") {
    data.BackColor = data.InvisibleColor;
  }
  else {
    data.BackColor = translateColor(data.BackColor);
  }
  if (data.ForeColor == "") {
    data.ForeColor = data.TextColor;
  }
  else {
    data.ForeColor = translateColor(data.ForeColor);
  }

} // draw3d_InitCtlData

// Initialize or uninitialize events for each type.
function draw3d_InitRobotEvent(init, data) {
  // Start/stop the Pipe Event.
  draw3d_InitPipeEvent(init, data);

} // draw3d_InitRobotEvent

// Create Control.
function draw3d_CreateCtl(data) {

  var out = '<div id="' + data.Id + '">Loading</div>';
  data.$this.html(out);

  data.$this.css("display", "inline-block");
  if (data.width.indexOf("%") >= 0) {
    data.$this.css("width", data.width);
  }
  else {
    data.$this.css("width", data.width + "px");
  }
  if (data.height.indexOf("%") >= 0) {
    data.$this.css("height", data.height);
  }
  else {
    data.$this.css("height", data.height + "px");
  }
  data.$this.css("vertical-align", "top");
  draw3d_SetBorder(data);
  SetColors(data);
  SetFont(data);

  // Attach handler for mousedown event.
  data.$this.bind("mousedown", data, draw3d_HandleMouseDownEvent);

  // Attach handler for mouseup event.
  data.$this.bind("mouseup", data, draw3d_HandleMouseUpEvent);

  // Attach handler for mouseout event.
  data.$this.bind("mouseout", data, draw3d_HandleMouseUpEvent);

} // draw3d_CreateCtl

// Handle Control events.
function draw3d_CtlEvent(data) {

  var sb_state;

  if (data.IsEcho) {
    return;
  }
  if (data.dlgDismiss == "1") {
    // Dismiss dialog box.
    top.rpcmc_sendKeyCode(tk_cancel_c);
  }

} // draw3d_CtlEvent

// Delete Control Data.
function draw3d_DeleteCtl(data) {
    // Web page is exiting cannot do normal send
    //top.rpcmc_ossndpkt_ext3d(PKT_TYP7, 0, SSC_TPGL, TPGL_OCXEXIT_FC, TID_SV3D, SV3D, top.g_version,
    //    data.fTaskIdx, data.SubPane, data.Scene);

    // OCX_EXIT functionality is handled in PMON when the pipe monitor is closed
} // draw3d_DeleteCtl

// Private functions
function draw3d_HandlePipeEvent(event, file, buffer) {
  event.preventDefault();
  var data = event.data || event;
  if (file == data.Pipe) {
    if (buffer.length > 0) {
      var buffer2 = buffer;
      //data.$this.html('<xmp>' + buffer2 + '</xmp>');
      FRCCanvas.XMLPipe(data.glconnect, buffer2);
//      scene.XMLPipe(data.Pipe, buffer2);
    }
    if (!data.IsEcho) {
      var scene = FRCCanvas.GetScene(data.Pipe);
      var view = "&view=" + scene.View();
      if (buffer.substr(buffer.length - 7, 6) == "<EOF/>") {
        setTimeout(() => {
          top.rpcmc_ossndpkt_ext3d(PKT_TYP7, 0, SSC_TPGL, TPGL_DELTADRAW_FC, TID_SV3D, SV3D, top.g_version, data.fTaskIdx, data.SubPane, data.Scene, view);
        }, 300);
      }
    }
  }
  return true;
} // draw3d_HandlePipeEvent

function draw3d_getXmlAsString(xmlDom){
  return (typeof XMLSerializer!=="undefined") ?
         (new window.XMLSerializer()).serializeToString(xmlDom) :
          xmlDom.xml;
} // draw3d_getXmlAsString

function draw3d_HandleMouseDownEvent(event) {
  event.preventDefault();
  var data = event.data || event;
  data.glscene.onMouseDown(event.clientX, event.clientY, event.button);
  return true;
} // draw3d_HandleMouseDownEvent

function draw3d_HandleMouseUpEvent(event) {
  event.preventDefault();
  var data = event.data || event;
  data.glscene.onMouseUp(event.clientX, event.clientY, event.button);
  return true;
} // draw3d_HandleMouseUpEvent

function draw3d_HandleMouseMoveEvent(event) {
  event.preventDefault();
  var data = event.data || event;
  data.glscene.onMouseMove(event.clientX, event.clientY, event.button);
  return true;
} // draw3d_HandleMouseMoveEvent

function draw3d_HandleClickEvent(event) {
    event.preventDefault();
    var data = event.data || event;
    draw3d_CtlEvent(data);
    data.glscene.onClick(event);
    return true;
} // draw3d_HandleClickEvent

function draw3d_HandleDblClickEvent(event) {
    event.preventDefault();
    var data = event.data || event;
    data.glscene.onDblClick(event);
    return true;
} // draw3d_HandleDblClickEvent

//$(canvasid).bind('touchstart', draw3d_HandleTouchStartEvent, false);
//$(canvasid).bind('touchend', draw3d_HandleTouchEndEvent, false);
//$(canvasid).bind('touchmove', draw3d_HandleTouchMoveEvent, false);
// Touch events
function draw3d_HandleTouchStartEvent(event) {
  event.preventDefault();
  var data = event.data || event;
  draw3d_CtlEvent(data);
  var oevent = event.originalEvent;
  data.glscene.onMouseDown(oevent.touches[0].pageX, oevent.touches[0].pageY, oevent.touches.length - 1);
  return true;
} // draw3d_HandleTouchStartEvent

function draw3d_HandleTouchEndEvent(event) {
  event.preventDefault();
    var data = event.data || event;
    var oevent = event.originalEvent;

    draw3d_CtlEvent(data);
    data.glscene.onMouseUp(oevent.changedTouches[0].clientX, oevent.changedTouches[0].clientY, 0);
  return true;
} // draw3d_HandleTouchEndEvent

function draw3d_HandleTouchMoveEvent(event) {
  event.preventDefault();
  var data = event.data || event;
  draw3d_CtlEvent(data);
  var oevent = event.originalEvent;
  data.glscene.onMouseMove(oevent.touches[0].pageX, oevent.touches[0].pageY, oevent.touches.length - 1);
  return true;
} // draw3d_HandleTouchMoveEvent

// Don't think this ever triggers, never say never
function draw3d_HandleFocusEvent(event) {
    // This event never triggers
    event.preventDefault();
    var data = event.data || event;
    data.glscene.onFocus(event);
    return true;
} // draw3d_HandleFocusEvent
                                                                                                                                                                                                                                                                                                                                                  PNG

   IHDR   <   <   N%   sRGB    gAMA  a   	pHYs    od   YIDAThC	   1~C[;)VJ+JiRZ)VJ+JiRZ)VJ+JiRZ)VJ+ye,gu    IENDB`                                                                                                                                                                                                                                                                                                                            <html>
<head>
<!-- #if KORDER = FVRC -->
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Cache-Control" content="no-cache">
  <meta http-equiv="Expires" content="0">
<!-- #else -->
<meta http-equiv="Cache-Control" content="public">
<!-- #endif -->
<title>CGTP Server</title>
</head>
<body>
  <object classid="clsid:FDEA8328-5417-4CE1-BA6C-1C5FB45BF7A3" id="friPmonServer1" 
          width="640" height="1">
    <param name="_Version" value="65536">
    <param name="_StockProps" value="0">
    <param name="page" value = "jecho">
    <param name="frame" value = "cgtpfrm">
  </object>
  <object classid="clsid:525AA6B6-CC65-4BDE-BD31-0F05DAE49026" id="friKeyClient1" 
          width="640" height="1">
    <param name="_Version" value="65536">
    <param name="_StockProps" value="0">
  </object>
  <object classid="clsid:1B45F2BA-5545-4A16-866A-B31B407904B5" id="friFunctionKeys1" 
          width="10" height="1">
    <param name="_Version" value="65536">
    <param name="_StockProps" value="0">
    <param name = "device" value = "TPFK">
    <param name = "page" value = "funckeys">
  </object>
</body>
</html>
                                                                                                                                                                                                                                                                                                                                                                                                         // events.js - When cgtpmain does not exist, use this to get controller events

// Safari's iPad/iPhone does not support multiple threads
var _nowait = 0;
//if (navigator.userAgent.indexOf("Safari") >= 0) {
//  _nowait = 1;
//}

$.ajaxSetup({
  // Disable caching of AJAX responses */ 
  cache: false
});

var g_connect_id = -1;

// Try to find global connect_id
function GetConnectId() {
  if (g_connect_id == -1) {
    g_connect_id = 0;
    if (typeof (top.g_connect_id) != 'undefined') {
      g_connect_id = top.g_connect_id;
    }
    else if (typeof (top.opener) != 'undefined') {
      if (top.opener) {
        if (typeof (top.opener.top.g_connect_id) != 'undefined') {
          g_connect_id = top.opener.top.g_connect_id;
        }
      }
    }
    if (typeof (g_connect_id) == 'undefined') {
      g_connect_id = 0;
    }
  }
}

// Ask COMET for events.
function startEvents() {
  // Handle ajax errors
  jQuery(document).ajaxError(function(event, request, settings, exception) {
    if (request.status == 204) {
      // No content
    }
    else if (request.status == 12152) {
      // Connection Closed by Server?
    }
    else if (exception) {
      top.rpcmc_rprintf('[events.js] exception: ' + exception + ' setting: ' + settings.url);
    }
    else {
      top.rpcmc_rprintf('[events.js] status: ' + request.status + ' setting: ' + settings.url);
    }
    getnextevent();
  });

  // Restart events from the robot.
  restartEvents();

} // startEvents

// Ask COMET to stop events.
function restartEvents() {
  // Clear the old events from the robot
  GetConnectId();
  $.getJSON('/COMET/rpc?func=PMON_CAN_PKT&connect_id=' + g_connect_id, function(json) {

    // Now start events
    getnextevent();
  });

} // stopEvents

// Ask COMET for the next event.
function getnextevent() {
  GetConnectId();
  $.getJSON("/COMET/rpc?func=PMON_GET_PKT&connect_id=" + g_connect_id + "&nowait=" + _nowait, function(json) {
    //alert("[EVENT] " + JSON.stringify(json));
    try {
      if (undefined != json.FANUC.PMEV) {
        for (var idx = 0; idx < json.FANUC.PMEV.length; idx++) {
          switch (parseInt(json.FANUC.PMEV[idx].subsys_code)) {
          case SSC_PMON:
            switch (parseInt(json.FANUC.PMEV[idx].pmev_type)) {
            case PMEV_IO_C:
              // Trigger an IOBooleanEvent on the io event listeners. 
              top.jQuery.iolis.trigger("IOBooleanEvent", [
                json.FANUC.PMEV[idx].type,
                json.FANUC.PMEV[idx].index,
                json.FANUC.PMEV[idx].value]);
              break;
            case PMEV_SAFE_IO_C:
              // Trigger an SafetyIOEvent on the io event listeners. 
              top.jQuery.iolis.trigger("SafetyIOEvent", [
                json.FANUC.PMEV[idx].type,
                json.FANUC.PMEV[idx].index,
                json.FANUC.PMEV[idx].value]);
              break;
            case PMEV_IO_MGTH_C:
              // Trigger an HandleIOEvent on the io event listeners. 
              top.jQuery.iolis.trigger("HandleIOEvent", [
                json.FANUC.PMEV[idx].type,
                json.FANUC.PMEV[idx].index,
                json.FANUC.PMEV[idx].value,
                json.FANUC.PMEV[idx].jpos1,
              json.FANUC.PMEV[idx].pos1]);
              break;
            case PMEV_VAR_C:
              // Trigger a VarEvent on the var event listeners.  
              top.jQuery.varlis.trigger("VarEvent", [
                json.FANUC.PMEV[idx].prog_name,
                json.FANUC.PMEV[idx].var_name,
                json.FANUC.PMEV[idx].type_code,
                json.FANUC.PMEV[idx].value]);
              break;
            } // switch(pmev_type)
            break;
          } // switch(subsys_code)
        } // for each event
      } // if PMEV
    } catch (err) { /* nop */ };

    getnextevent();
  });
} // getnextevent

if (window.top === window.self) {
  // global object to hold event listeners
  jQuery.iolis = jQuery({});
  jQuery.varlis = jQuery({});

  // Start events from the robot
  startEvents();
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                 EX1_NE~1PNG   kXX kXT  EX1_OFF PNG   kXX kX   EX1_ON  PNG   kXX kX
  BG    q  E X 1 _ P  qO S _ O N .   P N EX1_PO~1PNG   kXX kXW  BG      E X 2 _ N  E G _ O N .   P N EX2_NE~1PNG   kXX kXx  EX2_OFF PNG   kXX kX*  EX2_ON  PNG   kXX kX6  BG    p  E X 2 _ P  pO S _ O N .   P N EX2_PO~1PNG   kXX kXB|  BG      E X 3 _ N  E G _ O N .   P N PNG

   IHDR  O        IDATxk'1jl<krEr5CD
rzs^?`/zW7B)iZ@$"],Xdli3?2ygg;]r9   ^C         x  O   	  @<  '     x  O   	  @<  '     x  O   @>EQt.Gb+X ' aBZsq@<	ILj6U>wzh![kKL! '>!rZR(@<	kHH!=O`]?cQ 'c
r@8aq>jxX35u2,
U. OCazZ,=l' !s0L<(O@@C5"
%'	Hg>sN<	([?Ut+O[GbQAOs
g6E$ }mr6am=FiZ`xY!/6
 gd`6QY-| |'m{pB8Z:}ex1pP(-mrNiDN>+OpB8,WHc		.*)jsu	"Z.DS#
E#n @< R:"%@<p0(!4Q'0cm'	 B@x99pD@U.; Od`KXlQiNOX NXYx'{b}	(O`8&:\Xw-]~
g@8Hc8s!] 3Ohs J\q	rNO9Q	2{)?P @
,\	1x
's9-`gu,
O Hz	S^}h''0Xa'B@xo@(O`<~6U>(GAlR;z/7{(Z]]=xwy\'z<.iL@;=aG>xh{R?>:<oF`+KEQdee7% !1M8 K!S goe??'u.p>m_l+~z6mgx}|	XbSXF}F[7n(>U>]P$DjSE)>w<^:_}-%3/;YD`a}"MGwbi~.SY*Wfda  S{y[n~-NV}lpu7>O>(vk7gnO<YY.Kn/R3f$mXKdjE"*;
HfxZgodf:3wbg?/]_"jGs 1;P7li:/#SVoQ,ujm}Gj]~N5{he@9
#ZQD4?6N	C  @<mqWqWF	9u\}~	E>w{Yz2wof7O`` Z"Kn92tQN\% 	+(?s{*	8_POuc#nK{=y|B[d zJDehRa|_=mgGb=i=[mkoqDJH<V(*K.	goQ*
CB/ysdeekZE0'z;qW\y	55I'B(G,O8b+60 6(QxB8 
Sm1=[QplQ,-d}J7F @@`?F	  OJy18l! a;|P"%\}~kGTu4w1%y>M8eS@?"A NP<u2lZO{] 4_g`8WTk<n-0  G#QxB@ 	Sm"E( Nc3[n"
 N m" ':SqKsY|i|OS+|x{d[6{@ Sl{Z_0{ocoW"  	)0|0|koE( N]k}S'++c7gnSt+O	)  	OWkl! @8N6X/kG@QzqP|pA8z6i<-,-wQ< >pqE_u#(:F8"
CZoN}x '"=;rdL8B@p"IqEn_#
oN ({ N$%nSEQipSYuO<uPFQE[l;w^/G( NZFQE]Z}}OW6O(Hx-F$5"@<NFGwA8JqET6jqx 'O("[l96RZgl!zw|A8*qEDQU wK~&GQm`q0=wB8ZE\m`}y  	_"F]aZ{J+T4\ i?(w2kpr|Rkqx+L\+T!r	:< 0tpi9y|B-QDwwqqlqO.5S2~_}z6i:qbia@_\|Kv'0`F!(N 2o#g=&
X'Zm#]mjmFq1fY^Y]#Nl\"S#7>:<ci8B<!6{v),o+MN8okO>"F
Wavlqr+~%>N$GmQ:<vk@4?'UrNrB]`];N hf?Tu\X40sFU3s>9ips	bh8p*D8x	y:	&<c@8x'
y]6@8	uH89
 	`cC8	]%kk;	!#?Z8! \4i]!y'@<wZ6!*; !+	t4>_!]5Ks)}^ymck]8Ag8^iKWxvI8! zh@43Xq@^;'^N  f3O![];kZK;?$ >b/x>,	x*[8y@8xC(	 P''@@A	O n G8y]NxJ(DT$N  E`V4yNxN$	P(	r\`(#I2^ymjCpq	RP`pu'@@!s	P?DTI8! |	R<<w?;ps	R)	Pd>DT{V8m{f<mv=	Hg;|p=^yzK_O	'hCt9'	Ph<o<	'O@gC5XhG09pdpX6hOI8x2<(hw`$!ld\b-' C$-?'	lCD&  "J4  R	 L ' `@<@*bJ,  Sb	 H '  v     x  O   	  @<  '     x  O   	  @<  '         O   	  @<  '     RreJ    IENDB`                                                                                                                                                                            PNG

   IHDR  O        IDATxkw'1t61aYt{)z3Da.?`/M7B)EI$b"k3-cHzs~<|yPx9~?wskmm-   ^S    <  O        <  O           <  O        <   <  O   @>ZE3]!b+g ' *TsqG@x'YI"SW < 	PS|=P)(@x'  y^[!0 <so5CU+j'"5SS'^cKuiE-&FuW83O@
K:WC' E>[})cN	[//$_qp	rlS}QgU	-4k.( m{jcF=h0899_6 gYmO@IswmW| mrsk@x4K'z=Y,vn ar	rHBZ 	(j'@3uo
P	O	j.l(j'EKG2ohztAEz{~Nq 	48_@x46'( /q=oZ[3 O-\l(q
 ?	^q`|5eO`q)W3](Hy#&mc	#Hy5):p>}o9
NDenS <:Cx#O;,	5xOV2p	5h<@g}
}@!e]}h'k@AN z	4hYP`jkX+' x!UPw0!=y|'>:1za}ZZ}(CSTD ;u|>\Q3yvo?x#d#X8P,4QEOVV^}y]X@zmuys^L?3!@Ag	O+Mcwww0Gv}v|HmX-3o/&u<C<Wy2rp6g<_;(6&	/>] $DgoM7xoNRf?EQtc}=~ZsJ?!'lef|tj@/N=U*/?=>Z-<@FdB!67+MV;>6RF3O?$5P8~>sjox2X*/V;^,YR3s=v%rRZl6o.#Ggo]v|/Votw=Bh@	*~_qltxb>['koF|6=:q7qD6Xsw	SSf6hFz5$<a VkggiuuP]n6Q:2K9w,=YYKwrEO`R 'jil>+_;>rpY5f}K@+"z.hl5w&q0_02Nxm[oG_}jIon pv~X8Po/z;XOyU[?3zYkJA}qKpc3bapT^Kg&.=YYkm@Q?{_pY<${B_)W6Xs"L ?IqGY(Bx  <K3sIEp6(QJ7F&b @P?F V8<oaE:F~qGT"'L a;|tn0Kf7OF&Y0^p}of7pKZ6KEs	A @p:$v]' hf-J]ZGq =p8"kEOl tiE70N8?{3x60 z7O6Yj;M g);^*/gu6=M/l+M'F'c7VWpG|xZ8};_SOO_?3^5D0))Z>wVWW}mz_7) #'++c7fot;O	Yv ='Rkla vQFY8Bx
D=El43W=6;}VF?O(< >Snm16R:|78_}ug$uZ"IqEG^oN&s k!G m1ppq?o: $)nbappY8Bx:OeGQuwwqja=< $%nEQepSYuOx"(nv]{,G@/6(s2qI%Hf\
SmQqV(U#'4 @)\qEDQU b[c#j?c jV("};_*,To!<u@"Ym=#4{"	>IRjmwr"N  z#)hZE-;~0-w*~$ i6:"Dpr~TkcqOO<bRya Pw6zV<*}n"{#fJ&?=%44EFj&MSlx>jOWR=El28t8Xx88pg4p	4(` <efv{	j)jV.{eq=okZE;ubB\qDkJI6@-y6_<t\KXdfuOm{5B<Gpy^|m16Rjt];.>p{W}5tPro6(,4='^vT^,'hPbu)B]4PcZ&B4Z[G,hTqS]w5V\#cQ:<hp'Pz@x<	n<hL	P <	B^Fc@xAz[Y# hXPZprpAxv_ <Ffk!dC}=:d$@eo 	44rYiX@C~ <wZjg_Z[ hP$h4^d^w!|<FG5p'mw'\sH |fi\,m|I~' 
//oel'N-5kB~q3O!v"-g'@St-'s7O  I"@!8'hd}!^ OinAd^0 y %D'\k Md0	LIPN?5O 9rkmM2|]schw %4Y{' <-r@xM}!uIp'HMv-wk&,_\s (!5V=NWyaS65xC.Cxd&Mk OoK#<A:@f <Yj ]w1' Cg]M-,#0W: 	bYs'a2% OF#,%P-dtbIcGMdx#D	M O QB   %0 < H	L O 0%, < L	K O V   @jt;        <  O        <   <  O        <  O           <  O     @J?w\o    IENDB`                                                                                                                                                                                                                                                                            PNG

   IHDR  O        `IDATxkw'1j%t68+nv/j\!"Ao(EEijPJ3-mrQR-@97I0E,X59{3us#}I{N;|NGX   i   '   	  @x     '   	  @x  @x     '   	  @x     '   '   	  dO(.0Sb<y 	h|pR?G@x'26)1	 $L!@ 8!05z)(@x	&A

 	IBZ<	a@xc$BMFQJ[@x',ZdKGhY
N
H`.O@IZ+%L <'[p
K;Ax	N
$>H	Qc0V P?+f^!=<Ax
NBl^5e1O@ IHlNm2/os<OJHg(&A
[D&)Ya6?$08)^['7Dyni C	j '@Dp(HAA&ylH6;ODsB 	PP+@x2o\P <"%@v4(80B 'zv,>
$@	P/ <
OF0n<7u~ K16d,6;ye ;y"z&n(6
'PVHc<y 	![v$<V=<AF
NIJ=syd(8A3|O Q}n.^
$_P@xLuBp e	'Px !#sB'PpHOSVEO 8	N (0$@(,X|haS@xKEwj$CW/tu3/3YM>B#sFQzjKrp	wL\hw7{.y-3koq5%<E@S3s;G?WUp0TS"_-[f.7k?=V<`uo@M)Y;>yZ-q}SE;g_Q$y!5^H;Z/NQE7g	OiN_95|D5Zj/<Ytn>Q#I-[fFww9W0w/8+[xE$Z	Y$<=G.w;?8:3/w|d(7}<O>s+  `nR7a{w;~ss,|w9_X+w<7pt{z;w3GQB,NZN|~wv:6p~r>/\_ot{mHU?'lZ}wO;F|vv&G4QW'N{PSfG4QD0^MBp0 j+OkgdRv(n60C=W_B9w,=]]%{F@Jj 8oTMN-;v	hz^Wv QsEd''0Cj^g7GrS3/5 JnB+]^W~vtxp-<.kq7.X[[;T#nWj@Q<o,O,	,|vEZ6n_}T:_xnR$REi~nj&;On6
$-XPLS5XF&h Pi|EO u5kaBz=xzMCb_EO	SyC%40 6=4 O4J\R(K;5cP*qD)ii!<aH		n0{K?pGgeQIgg}.@u|n}^{7oSo48/,U45Xg		 
MyjB7_].{ N!1j=_k@_{iSUjF: j:QqDEOl mmZF&] PImw<m"'L S>/\;tUI l;q4^y`3<Y{gmO5F>|;><->=;i;sWgg_L FCsJ~a*}}ws}j7nf
 V<JkSU?|1;OMR2;Q(b##L JElSBT(b?8jLPq`F?O}+]=S65M9P}4Zv:57kE.R{e	L BO	(}~#L Lq"r}'cqRYVR#O(KI T%^(eftxTZ	Om("h7kgd40ZJ5(qe{;WGO4T <'QD)q,34R\Ro+'  f\q"(J5mT8B1r_P+U\(R"zw\](=7R#nkqq8BQ f{	5f(wr"r}qq8 U2WQqxdW+P"vh[vyxk^OF4KF'{|aaUy Bxo9sjR-U(s7:>3R[EBxh|FgtxpieL8lWxw/.?!!
-b8
{ <fmBE4xhQm*5_{-;sjR\81%m)/^"&QF_NGO E{ vpJsxApmE>OEjmkgd/{p+0A^klk8Pk{NRx/,O@YI=kDTD9>P(P{*}nH:EZ|\$m1nW#U=q<bOa'O %IMN8uB	&,]wO <IBVy.(T$x.@F.:GF'P
:(\`Ey@#y-_-d$z:
$@Po 	4W"=t*{3]'u@aPlVG hW_N/b>*OYHgn.
	^$$8@%epL*@CD 8PYgu\*dVF	{M58X({x-dw7wC2xsc!Xh$za@xLJ	<uR# 	G(JpP@xI(' xP 	MTy6]'5  (!*Ip %D/4	N|@xS`:\O"@	Px-:EBeU Hl>y@(eJpOb %8	Nr@x]&	s8d<A^N=q7>;O(E8%8a'PjBTkHp2Wr@-(]['sLm^s.O@J!o
Nw>nPi=K5Z's2v e%0 g&y' %JQZ&8ew5(@)TB+d50@)=L}ZB9
 Fy' J'A$Vs*O@B%4 < D	M O R   %0 <@aJX@x@  $ '  `t   	  @x     '   	  @x        '   	  @x     '   	   	  @x     '   	   Ps
kHP    IENDB`                                                                                                       PNG

   IHDR  O        IDATxkg71O@t=qdfes.=.).zDa/uFi)lhm\TK(sS4ltdy
I}og:r  @N   @<  '           x  O   '           x  O   	         !|tmEQtXA;uUn}-\|z@<'1>
 'rKI1
  XS(@<	1" 	B@	N&!Z<pN	o@<	\=Nhyy5	N94zX#/NgN\4e*mY  I<*eX.@<x2qI{u	$aN>5arQ8awc!d+Opr0V+"bQF	O@ $o8E a=Q8ap4Z{d 0/3 ge{,aO@
I<{P3wxvn a=Q8!He[X  pPf/&?:wZtr	rN't]uZ '24c-x|m 	phvD@<p&FDP  D9Bq:@<pB8! 	CpPe	O -7'
XrsNgNr:h;l/(bM@t9p^~:0vU6,cMxA+Cq
-\|KPyDc"(A@4j'Y4yp'p	rN ([x@|	2NY%V(O 0d$(1'N+CB! ^u @8a0NJ	n@6X	(<	{pX/ @8zi`Jqp	}H<>?O>}[zPJX(W^w~-K8AvG5g?[==;}g}|,gEx<.c[3'R;m@N&.!SJLNe?~w0'_	#kl+~F6l\,,~{>+h}>	Cu85)]}z[7n(>p:^wI;<<8wSw&7'>x%FEQtsxrvv~qjO=wiu	XX?dSU[|;kbiv&c/Y'2U'd=xj/{o_zuyyy}|jlf#?~I}'0uozvXv;cOFca\_gnwo;Iv#iN]ZJ~~HGd ngF85s|?+]_"=jF 3Plc?YO8CTfoQ,jl}G4k{._6Qtm, ?!bv5'b=G4kbivfe^MC8'rE8/^s]%?vE'H^_bq)IX>gHU];(B<p Z JWn:4pQNsXp$4(Q?ug"c	j_\\ SmPJ?dWKzu %DT-
g?w>zHz6tM uc+m 6}+}O}/a2BkgD9+gN]x4Ri=v,-x/~NJ+Odp"Abx IDV~WBS
m1eE' PSL7O' @@x
KqE'08A[_\_7O)SiZ(B8 FF6O   xY6$E'1qD%Y(B<! 2vP"Uz~mt#}hQpG=]OkozG(j,m'  `A vu)	' N!_3kaX}Yeo+O)Tk<nj 'Wkm!P pVq qgm MVw D?ug"biv&<ij,{39]Oyy(p|NS3|w>z5>z|-tSy<6meOQ  -~0,//kWqC8Zs
 S+fZ3GKK#7i7'>x1WR 'O<F8B@pjmZ6O)"V.C>I[F?o'P }#@<CF#C+Vo
(	`c-"
g{vXoN|x 	rD<@Fv:4p*m! @8"
}c/	oA<_.{^:r$GU	( N$%nc/EQa`SYuO<QFQE7m/# '-n([.yOcq#
 l#MY_`mQq7QD%+/&#
 N +n(JDlPJq6QDEQ"nP88[kB8B<A"]m}O#*$x(gjD;#J@p5rZFCN~#G0{p*~PM2@*s Yb+`2KSf<<ZE/]a*fgj]J#W g@8Ac\yZ7~>W}Kk(^8br8^xOg?dU(4BSM1G6{5~F'*oi-Etm0w8D4Wbiw?!!p	b"
-b@
8
`^ yeo5	(`bmleo,e{-Tk_Ob	O2,zakjmm9(	4?ZO?$nz7xb>9]r0`}bMe?&nz7xXn/
J6@u\)Q (0H9N`7\?^!J &+ib\Hj=ghW@`2Xe4((~~: <IVNx>xac=O `mzU!<.m08(x2	'(H@,'PdvI[6s	d$GY' @@&:-?z@<nop\ hK&RdsU4]5p;!%WxB$p!]6rptUqXZ3'!6@8xU =O&
(/LzdX89{M2uP$='rDnd(	 P''@@A'PjX2#~ 	P4)DTzI8\x)DT0'@@%NikOB@!N[_!M4*7D@s=*pOB@	'3  EJD5/7<A}n;]9'faB	'z	P9DTk!sA>c{8 J<;| #D$W cj]Y wg=' #%vyV]I3<9x2PXhE0=O@J<hK' %hu`$i:@<(DC$dV?w	O@J<!D 	 % O )x@H	&  BJ0   K ' X@<  	     x  O   	  @<  '         O   	  @<  '            	  @<  '         7P?uU    IENDB`                                                                                                                                                                         PNG

   IHDR  O        ?IDATxOluz
D(je""x9!`7E" CrBB	hk)kU#"h
pln<r}*{<>y---   f	   '   	  @x     '   	  @x  @x     '   	  @x     '   '   	   ^ KR4uV4b3 fTsAG@x'^0E^zurFOU[ <j#H!@hrA-	RPN!A

H<~5 e@x'k@pBusJa)| <`LV$o+@!@A[ZwA`z[X*zX(	P <m5yj!])$D@5I	XSj& (Ao{uWZ1C}.ZU!h9;P <)o4pjC]Q#<	P=N5nf>5rLw '@EJfPMN&P:F}BOS@xR4j}zW$DA68m
W\'PO9FmNAFZh"Nr
'(PpBpBO 8!8!@!@hQ7SzT	(@!"|_ @d)8Yl(P < 2"J	'F\B!*c$@.A	4 8	PO&T6<[ZrA-Z4~o/GO	hvK 	N<!K+ h)6I+Vl|o @A6	'R\YN?Xj{Z*@\MNzda=]$4]('(PpfVFABO 8AnwZi~NC	44!@j%' 	
'lA
>Z((@xKZwRi{v@xEprPP <
k OBx@J	4^w}I( ?'g>z}{vkz@y{]^}J5~n8AF|=\iMzQ5?|o77'zno\7RsX\z>
xtwSh :qLk@>g %<lzp\;hlWw9%@o3g{C/\9Z=1w\HN .=>WyW|\TT84PcK.z~	f{d4t{c=zCk_.~j=~/5;XcGF("uW]VCO(}nFff=~`t() 'N~::p
2<n8cZuJ+9^><5=3^M7{-&XK Pb;nYX\
z+gfzsc^K	v`TDAq"OB;55+Z1("Z\v}8o~wij710OP.`hF;nx"9ahdpD"JR_x6n81cA?'@{>(_cPDT*g)jxtw @)Nq{WJ4(wSQET*S<u1nYk){|hSNg84(s("n,.w`t.F-t!<0 1Z(IUa</5_

-z^s4Z"z}RUhGG<?_yTUnY
Ohl
b"<M7(OzA);x(+c;A7  n/7=_9W+t`d?/t}A72.L{+U*H,4c.g 1a!!*C=V8 {,}wz:6nZOh^z'uOP <Js/kPD~sA: PdS3qb/#	:u0w'
Ap 
MxJS3qhdz E,o#ff5(QXO948zE4?SB!N QK"uz'<Y PvKcGFXw=SNWRx'wHgI+O:0Hu<ykQ-;7ff~WjEyZaw=ck:8"h*AR6. ]/[wa6/GO<{48@OU"JR)l\zhoyB# NAvZ{]<%=eKvNN @{z/=kwflLzWy;h\z-7=BcGF_|1g~uoo: q`t:(bOoBKx"3( _HjPkv>eO ttSA'5(b~]r8N$
 'h);X_CR
aom  6|fvL_vnPo
)aJRijzfirJ+>> 4!llOuj)>4pK7;Ot7ommmA* 0a?J67Y_JQv|;M NI8=4X\
P{<EuzGww NLFH18"]0
 'Z#lPJ_=0H3R"g^>k eP+z?3T!<q8}"8A214P$lkCqTB@W_c%hPDo\-~7^LQpr`=w<.<  'h!)Eto~_844P  
Q}d?p|y#ff:v5sIx(?'r hRTjkkbC{_865=33Cw= 	w`tRTj_~jxT#Sff	rr_OcA"JRiHS28KSm( XAR|$x)skoN[,$'
Gd4]SXM4Zq] jd)hPjR+v>4p  E	Q*xCN'jN=#\#/K
`EJ?vrZS(H%]STa(?X=wBpYEtnPk@D((}O?ExB  	"h1p_XcGFvpUR
O>d(;4[ZyUdOxd?p=Gvff86#O%.v vVxsq<Vn)]Z;HS3wV]a^Zn/j/S3YOzHQ3<?uKQE48@=>&Uz.Z0F{p'DNApb5L[iS;>NKP_zoCAa,hp'6(7z
cA#'dBl4fEk_zu2s^B>'A"xrG{wl;U(7%j'vA"};V;e3g{WxuSP&kqXIa7uKK 6YHg1<YIpyaE]48hP^y"8$	:}`		'`&{@p	4ZMZwZy 8h4Iq=PouHp
 <J]N>/'@v < Enk!~:!8fI 	(
YYhZi~|o'@x
R^Yq6!8Z HBZv4,~^i5u^lYNv@Gk a'kLdC%d::r @8E9QhDp|pHhVvkgB$y'hJIk	N <BUk'N <!('' 

		'@"8>/'@xB}b' <%b
PBTzC @]Wh= 8q Gp	--)#IsdCc	2BSoucD|' 
Jprl#8Pd?@	Q&		5OMgo~{g	2JOSN <PBTkr}:W'7z85OnwO '4g]E:YL'aCh9PCIs7<	N <9j5ujha!'6<&N$<	N <9n5{$080D5<	N <9m5|1dIp	qC  & ' )	 	 AJ`@x@   aJX@x@  $ '  h        <  O        <   <  O        <  O           <  O     @F/aPd    IENDB`                                                                                                                                                                                                                                                                                                                                                                                                        PNG

   IHDR  O        IDATxole~
D(je"!|xa(d&/7 BPDNjt]*A4iA8n.I/^l|Nog   	   '   	  @x     '   	  @x  @x     '   	  @x     '   '   	   Y6A<:[4b3 *`N>0E+jL]BjKB'@pBM5}~ 	rA-	RPN!A

hy^QC	6@S\5j5`Ac;kpbYbEk%oaa 	PW#Er9O@
K:WC' C>[})Q*<G^Qy['(X/C}t.jDMdhYu!DP-.PnoFiOJ-F=@6l
HH1j 96zlp(8!8Ac Y"8	PADe[-@:y''1u^@-hNj'@3u
PI	O	j$XBSCj' de#D9ohzdt@Ev{~Nq95hp 8!@hlNP3 <Ypc [X"52lF^mQj&'FZS,&@xcx0hoei=:(<D#4<&kd{`MF
NE==f	
c kQO$w#OQ8iNyIwpOVrPM@}^kPc:=>	48P < {
 <|6z	>H4*mO8!?ON[-/wGK};z:R{V*;sSO<&u)c][c#C3X=4k4?w=//ES?{Y	 }:y&8{0#(,)%fS_gFkcISy28;lgWGj|+ow3tpR3hcSI@	4~@.N>WyWTTz=9N..>I@/>[L #Caz?z//6ZG_])IFz_:n9{'	Nq/^zmLs C>Q?d_c#C57N~pb8)a85td9#"[4sZ}J7=\66;WpiG}z/%A {_XK^?~X\|<][6oz>{`-Qe=~@-Q:5kZj9qo*X~{Y^?zEY-\67Z65U@ Ulz w'N{hZ'PDebqoYp^4pDEAOsyx/O~DQ>fHb "lS?'m=MN 
SjE]/oJ7lOY(R]7y`||qfpr:} _%SZ%nO3//-mR"//]wpb.-ZBxII ZHAqOZZ|8sRu2B#uK=T#CqJ*l*j,}'HA7mp|t4]+WUwOiCqX;k6s[a_'o teMw-z}q74624wvz{?

OL*JZHhy?\7~	L//g,}wzlSBxZ\kwS-qI-_laF4 PdSI-7Fv`
O81 4$@xJ#fSI-pBlop|G3I-r,lZ](Y!@"u{'< CMB};zJ;;Wzx!ul%H:8Huy8](4?Pw//~ gJVNyZeZn{GpDOU; Z. }[3]^ydOpv.A\zloy@  <uzo]OG<{..>\'o dm4?P?=Wy'lm[l|S
M{"No;b
 ^'	{"NO
{I-	'[ @/)6Vk+WE:[}. N7{]E,.]>5T%{N SvE-~J7;aN  8}QN3\_^z`oK<s]\ymrJ7>[ i9MIZto\nyW%ly7nC'e 9%EL~RF-P[|RY'K NQcQ4T9yr%3Oqfz=I4<D
{ =:)PjX8"Nd PjX8"x#/LxJ8E6;WrXRO?$g9:9ivO:Y(LI}c]V-T!<qDR l5,>Of9t[^r A}A-KB]=.g1uKQ3_c#C3N B	O)PDop2]8GfFKYurR =d-Qxxd(tf(/u*Zh;loP <eC*{ oPhf+Opio]O; zjwpb gFjN5^y~tyLw-[("%.kd..>vn?d z)	[("%.kd.|NTpuIxIPK/BP2'lT/#\66Up5)lT/#.-h gBOPD@kN=GG*'K l_PPD@mMw-zsTkTx"vn?Yk8M=h h;G*QElTk8=#{]'4 F&h"{}xsT*QOhM k3+|2K'xxd(t!{0N<<Gmv1 U_l[PDOuZ3Hs;oV]a>{#I.LS|x?J}Ffo)BQ>?-qRyL?j=Z7m`36jf]u.	ju
j4j6Z(WoPX[8%oIvZyQE/~c#C3aa,l	2l66#8A\&'aEZ!mnyi`^+Oy .jc]
[(4kasc=.z<?q'h(2S' jz.k	1IhfjW#cF-@r<ip7O.|~DEu`	3O1&|w@Y<P)M.l@BRh\km h`~Kj;=OANT~OQ: :~wq~' wou++vHLfJYY'uhtxKfx6$8aC6tfpXgq3<tN@p	#}E@=O!@kNsH<AXnO:/l M73Ax4G(' M
	='@$q/@xMBwb'@x4O
PBTzC}.D+498	Li~: <*PXVVW0(#>w|a	2B;=Gp9'@EBp@\hxiA\_z!<AFi'@3&Jj6r:VrdptnS5bdxmC]~q&M5PKZ]G ?<A:@cqfdP"v9{ <98kjhaqR <9,k=L>-cI-x,KTP-t V;j' d!Jh@x@  & ' )	 	 AJ`@xL)a	 	 aJX@x@    2&      '   	  @x     '   	   	  @x     '   	  @x        '   	  @x     2-    IENDB`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           PNG

   IHDR  O        qIDATxOle~
D(je""x9!`7E"P|A&R&r#	!("@MRATftq0mj<;3GZikgyfyy   @6C    <  O        <  O           <  O        <   <  O   j7>\(
1Rq=}1 <  8Tkhj7'@p%a

 	GB'@` 	)(y	'dL0(  #@
59FqsJaS@x'PA  fyr)ka)a]'E\X{`h0e6<8)P \pMB@e>6CvhU9
N .o{s9d'Y/SX0Fl>	HIpR--(57!]9
NXo9s<OJ
lx	P!9+Nd8{n1_!9
NN+qujOb$@	P	NIM$3lv G	("8!@Vd@1$o,(@Tq,4e;D	P <1'%@(ztA'Zv,>
$@	P/ <
OFj<QoY^y*dZ'cQ`ys<F!'P+?N^CD+ NVZ++Mcp5cBtpN$8L18u<0YB=qHH))/M%=sy(8A#iHnS <D.F];]0D	"r');8I~NC	 rzS?(O_ <	Y]
u@!j~>Ny	I{vP@xIp(5@-'
7@a{X:@p"`q7gg?_7<tGyDTRkOu}@HspI5Q8K_Q?<?@=OW8Kysii7?8{kN	O 8yoUH" iZ)dk|FPZSBLM|koV;(;N1|X#@%?(mf\mAf)N'P| <%C}cA0Z5~t<NRqwy"K.@rj#`h:3Y5GPW.}*_G#/\<t|lHADwzBP_S57HAD.,^=,<@
uDA<;;nrwzT*u=7g+(N~Ri> ` J:ysJO:3zsii(1=Sxo|/jO$t#E(`!Mv~_AlVhF>F}w<Rx"9/7W1_^{>!@[n {'G538EDis^KqD"
Be;1SA??y]@{>(]4QDP(gg!jyrg;^j` V+wzy+J]A"zm9QDT
:eolS50w>eCK4Z)n'N=n.-5i1JKKCAudQv]OM Bz}RYXk<svvdNU`F{e5jD>,QW<K*h*l,q'Lb"<m(NT:~<?]VXon~M fK/W:xpuwSbMOAt_)TRTZ{,}}7,LYpK+bA=Ad*[j$n4c?~xUc!<a/]D#	u\	jqcq5b/q>xak t
j13;?W(6>2S~Wx )GLM(^60!C:8=xzM,[@s=q5,jQI"u?LM
q&b hT(^/8	0 ~C 9GQk=_NWTt<~U&^Yd{$P]GQDS\Z=S1+**;Or5
 G"\M'm<0uZ)7)kfBPky	N,vZ7Dc6s<k~j/h"
B!]z9< NJyjB7[{>l]p0]z-o[ mK;3{.}6Wy7]zM7XyJ##AkmQkpz~WV 7HZEN:|yxKq< PAxJuE`f5vp@qt@p"Y6tf5XXz8l}>S'L Sz?FRvm[NW{]0 N_X[FKKCa7is
)a
BajzfkrR+}x#u )oOS:top\jcwyjoo_}jkk+ j4<$&3P*46jR4SI@zh4p`hCv:=;~$<-r;QaD5X#iua&k hF+5qD]Gq]QE45=3~^'4g<:vG`A&6QE<<YXz8p+a?3<?F&o8xS5(NnRab~g8j',{jn5(mi)M_	|'0Z-$<%@P=?PX8viu2KEzzl_^o]bF:	O!eAm)3)
/<T1wcS3A?34Pz&y @M.{Fw)
k+Nuofv~nf\OzzjQ(
;e]^8zm9d 5(
[[2WK.}nXpiIx5,miZ_N/D)uE|_%4vpWx	zgP;UPOWz~l	 P3!A	jQ(xCN'*N5#\#R1 O_P+VPBo7X>_wifGkmJ"7D	EQNnE[0Fpj$(sJ"7D	EQN{'w6{\' F4_X	a:J;TR+=/V$^y} qr+k5f\[}2NQE<1a#A;L3svn.-'7HS;OX ZyZa8{vZ("v}#* MMw{{dknV&ETixzN4o~q3<?uKQE8b_s=[?|Mvo>Bv@\,?0Dt[{p' {
JvoO8mEVx{v

cA#^Pv
"Iy!mB5E/UxAa,q ,o	&5(N!]wvtS3QnCF4}%QDoj<y7-V:>3{'q'PhXTkD!D%a7E8:Fj6)ify?bA|X$m1nW#U-!>v@BXhpu'P
'P$&Xp'o:N
=>
D].5@]'PH\~^uRO`!@	u'P ",7@xT-_c	u'P #*?ZpB'PHZiX@5@%uuRg 	6HxIM/@,/;; 'N-
i\'i,Mgn.
	^$mIpB=th7(4.WF4"@x(*,X^-TF	5O"
PorT,}|;!\-r`f,yza@x\K	:# %8	N <$jObIP 	MR]|'Nj  <'1(!*Ip %De/4	N|@xS`Z=\O"@	Px%,/>BD2e1'H	E6B	N	Pl'\OK_h0C	Rs,-9?"oq,B	N	c*1@z9m2SG.-96s9' J!o
Nw=NP{S^'s2v cK(0 f&y' #JQ&8w5d(@)TB3d5d0@)d=L4:-kn	pRivhDHB#j^	hRIbIs9' JG  & ' )	 	 AJ`@x@   aJX@x@  $ '  h3        <  O        <   <  O        <  O           <  O     @Jmts    IENDB`                                                                                                                                                                                                                                                                                                                                                      PNG

   IHDR  O        CIDATx_li91bJf7d/ZD%5h${7{php+MfJ]t9:vwf?Obbx>o}y-//   n   '   	  @x     '   	  @x  @x     '   	  @x     '   '   	   ^ B6A+up9Z8 #X <K'aF1
'@p%a

 	G O 8$H!@ 8!0	RP@xN_1!O`@\m'w0ng6W 	)T+f>Wq9<E.4e*,=,e~08	O
fJ)]cO@
KZ;'I1'4?H)sCrQpB!Wm"UgC	+OdI1"fQ5G	'IH0 ]l'nn-[ <)NF5`|tmrlSd	M*v\ 	H`p])[<;7 `(8!8"- 	IR0c>@f9N	M$us(8!8BO$@)1@x'Z[$ymTB N1GBSCs' dP <)-qHo@xB
q; 	''(0'@x	E$@)1'@x	ZRp|"@k[^vAc
9Y-ErE	,4O!'[YN^.+1'@x	RW4lBtpN$8L J3h$H { g=OS^4}H+O(R@m5
@x	2,=\ <
NYXIg

'Pd$8)&# <	(Zt

@p"eJRWRh%sZ}uN(L' NYa%@'P>@N$^WQO!:?g?z=ugj~`qg}Y}R={n'{ {9g?ro74Gj~n|/Rk\Z~?gci	'
%HZ"8%\8xs %<%lYvH\+h@Yq"CQb<2sjVtk:
{@pBd'0AxJaj^> xJRwawyK*5^V;F{bh`,NAtsii:7K#<1gJ~.:>wt4Jp "Ot	Xfzdhb@A<%8EicWO 8BVY?GSugOU:/JvD=^&XIA	B1|x6m\tc7^caswnXB{v`%amPHyj
sCf|_Vhs>G*QD6vH,4_JB!'|k`oXF;yzjcwT:G(mcxp7`j4QDP(!ukOL<dO^b54QDP(gg)jg#}uy!8 S
mq{VYTju("JRw+.FY-kt!8w2 Emq;q	usii8QDQE\Zol[5=	 (BQO*k->PxxRUjY
NXJ@#2PT#Iea:Wt.5	5\'n[`qkoSkPWt}kc}[A  bJ.Wy'>-XX^vAR.Lg+JHhy?\W>O
NB(gpMPg2tsiixjV_un8$w S58ED8t<h`
N  @NA#f("$h`
O 4 A#gf'jQ[XN`x#G/qES5F_I!Np jQI"u:^oH-	 (hC{GGQDvT*uONT:*	C2NTk#Q(W{n.-W'RGpKPcici3OzOqD
OY3E
BX{~Wp&F5.H|OQ??5SFB.go3< NJ[yju{`X*/-=.{]^8.oS[{Bp 1}4s];A6m\z;:tF|)k~`oa  my$x"jN'Nyyxq, @pVh/Y"]14<Xl=
 'eNoVV'<J N
S?FROU]
 '/-FKKaqyNS:
DwrR;}x#<W S8u1<r<jcwsru^r N63P*44*8DYux$(+P  85f9749kSUg#  @p0"AEQVp0
 'Z#QJh^7H#"Jgf']1{3}]C\'
1}!JsW4s%kFBx"s( o:~h{;4 A"}[7W|s3|5t;;
P(	`.KPbM+}o:yJx
 'h!)El/\<4<XL  
jQ{bh }y#f:7rIx"(7o0Ax.{{GGB=UzzpD'{  Neo#Bf@z;5m>)E
-8S( MPBP%xZG|uwSN#@Bi Fp)uEjG\~c$h?"@m)Qj*qA^eCx
 'HEE
?>vndqD{0(?_0,QDiWY/WjGDGa"n>UADX((ghVQ'NN4JXM+5k%Ew4{\'rO 	0(b{GGV_x
UTkO>wt_2@Cupet.ZW3s5xbh GVfVZ4|#kL7{\<A~u:}KQEGTZAwo}n>
E5FV >Tc~d+oq3240}KQE8b_s=[?|Cvo1|-zd0\I.
 SeoZ}>gBBy
JvoKDa"~`oy=DPY'R.^(6\fFyxTPj!< -'@L9[!Gp$|vF<}[7t|zfv"qO	G3WE!]<ibsz<WxKX+5^V
qD!D%aEq8zoRumy?bA| X$sU9R,f'@Px)2P(P|byVg@B3> O @A4I]Uk1 < Es^(1
 <  /@ddY- 	(2[$gI<VpAx
2''@x\6i(Z%}s~ P--{z-/ kSeU!QV4~VqMNnV@h!NI
OV'sHC PIY"=:~bi{ndLs1AO E'jE_^2*q!- e`rTNCz	Z6Aj8$pK2

"	pAx(('' 8_N*Ni 	)@	QM5O E'!*[I1'@E 	 
ikS\X
rk'H	'B	N	' (!*$8|C	R{t|p!<AJ	AGfJp"], <-PBTsHZ=j	\-ySc98@	O}~PC!w-}
h#V cV|Z7Fgs %<)x5d(@	O
f&k< 	`zh}Ze  %<Fe\ 	hHbIE2+s' JxB  & ' )	 	 AJ`@x@   aJX@x@  $ '  h7        <  O        <   <  O        <  O           <  O     @J ^kK    IENDB`                                                                                                                                                                                                                                                                                                                                                                                                    EX3_NE~1PNG   kXX kXOa  EX3_OFF PNG   kXX kX[  EX3_ON  PNG   kXX kXg  BG    w  E X 3 _ P  wO S _ O N .   P N EX3_PO~1PNG   kXX kXsi  FAST    PNG   kXX kX  FCTN    PNG   kXX kX  FLEXDEV STM   kXX kX  FLEXMOD STM   kXX kX  FOC     CSS   kXX kX  FOCSBAR1HTM   kXX kX7  FOCSBAR2HTM   kXX kXT  FOCSBAR3HTM   kXX kXT  FOCSBAR4HTM   kXX kX  BS      PNG

   IHDR  O        (IDATx_lVe.8QmTE6DBB4pcws#Lq8LZ,]3 Yvy{|>7}}   h   @x     '   	  @x     '   '   	  @x     '   	  @x  @x     @1BgZiq09V OyVg#wW <
Z 	0A

@  O9$H!@'PsP2
 <1

e{ 8aPr%| <`,|@  "=%oaaJ~O	hA3GZr	OBO@
@E9"4'<	P <+t9lr	OV-R7r_+0?Ft++P <)/py!D$@Al
Van,-s <,NF9Flr,4)s ]!,r	O@BsOOBd@	x5}ecIB=(XpRHM\vE.t
NN4U( 	''((@x2E]pJOX@	
"bBSC(@1'{
'@DFr/(@pPPC"D@q!8	PK@x1N  !7'P)8)97zErF	,cZn8	s#^j;Ek| @4	P <jq|d{@p"#i}.3$u}=OP@OJ#XXy'h9((Z	'SV?@x1(8a';(@p\Ipr.7@nB	[y^((@x:em?>!@
+y.@!@
*H@6(@x}Yn7Q;Z[[*~i\U0r|f>DcJ'}oQ=|F-.'~[}};?rR6SCT^ kx({j=6< ~;_n7<~Ow{{6Ntu/ls!,ZqQp9ce$C SOYJ7ZAjs	> U|<^
.S{^{Vja( 1{0Oh?<R5v~ko}lZcc\~cPa}4Tl?;9R5w~eOxbRmm=uKNwn2
H!0?eF7\]%tSQo~zyS7[*+*(NH$@r}Dw`wa}lQvzrJ>uK;[N-'A`?V{m6c'oDmcfS]al^zr>aoVD)sSV\0%xk=;N?GxlO^QD|"K c%cmO<)-4SW@g>!@[#_{^pn{=FAm{R?/<V'jqq^8BE#sx:%@qDEOa-;{mX8a  o=6,^R](sJEA\YV{K'KW/!@haeQg/jmFAT!rJ-< (?<z=;_Mckr-'+PT>;9+_ecWK
[`|AOMtz~kC+_juKZ7UB Xzaj0y$n.<X34??TEQDC	QF!<ssH,Wm]h\s'(HrC|;-2-u^|W(bQ^Z*%P vG>U&&.]=4XU{+O PF<R qETyG5y(b~h11y+FO>YG52 F'>,w
 @ajQc&,uMB @$	O)sP5_kjo8ttd!lsV8.8!yTm~z5_Kj8ttd!l}mO>  %D5Z/q]/>QknE\~c0}RI	N|3P-k\_z'km]odZ/Df ff/fXV (hPV,=]"3.{IrS
keroHq	 NGI4B @pfRh]dF6;s=  8<zET7hV8{p(o{  85Wc{;9<3{uSNz/^-	P  8<z}brz*U<)W3uQ3:>{m<gNxl$j3-T4<)__O:?oUf-]gSaO>,\yZ|o~r;E
PF 'H$)_aW*#o}A_Jx;n*Nt&V*@Y )Z9Ny7#l=]m?R/W^{%,M+Oe#{.S>(  gzaDk	q  )(b5RFKOJEx9/_yXp>wS%"Nu&^..<(8}"8A2*OF}/^pT#64P	/FJE58}WaR4k;}nC Nj/9R*QD^{gg5 @pEtu?9}y^GOP`cAp)64AzvaH[= NGTO Xl`4u2*QDN63]Z  ("QoGy:3msj}{sOsIg>'k}aQ"JY/03N)QD)zR?:}+_	{_Uwq{fNE NW,\KxUSSFE5 ( +{'("T5W87\u'DtmW8fK}lR!QV`.}O4hr"5v%#nmD}Qm'j[|pb;ttd!*8nmm= 'HFT7G~Z#QgeFLkhwn
2g}j*hk|n7n\5>ir"<Gr+Ti$<w9n[W ioV}c;[-uR%"]8bt|bWG'vwQ5_toG|gN$78o)uR%"]]J>1ycmJ#<mImh(;)0HZq(-O^6??eo-~avw;Q>zp)01W0O(z-G9mysue{	*(tK5oT8"b#oU@<km>#Qa,k#' +.z%)2[Ni>fE++Qmyje.K>Q"zW{wB/uK#`~"8h~;gt}1/S]SY#+O|4*uw;GJO\>	!Gm6&a<D{.*6N 8,^WYXP,WcaU#co$8A< b^48(0/|~x"8
$	uO> 8
-LZW:5@p'Ph @8#(
/(Zpr@x{^uny 	(r;~KvZOh<<(o		@ tVw?w=O @AwV{z,,: c@WV4~Vu	(H/iX*@b37rg9@N@p	p\(4"8A>	Yb+s3tI'	=O$:Is	N <(+'N <!('' 

		'@"8 < EOB$8!8PQ
M'@xN4PN' 

		
ea_AQFc1N=V #U}{'#8PPs	'@"J/4	NNP<yo
5_q7Q=Od'(  89@x(rdy+8=Iqp3Sc_\'8dSyW$8AlrBqFsH5r_$8A>Yy
9s8V'
: 4YqYQgN-,$WbYGDi9'	' bF#GY8XOO@Nei"Yaix@xr\ +& ' (	 	 AJ`@x@  & ' D  % ' +	 	   3Z     <  O        <  O   O        <  O          <  O       QW0nd^G    IENDB`                                                                                                                                                               PNG

   IHDR  O        IDATxOlw (be"P/"lESE"PrA&UqIBBJ1j j	Vvdd7Q&=3G}}   &      '   	  @x     '   	   	  @x     '   	  @x        '  j	 _ 'bkZv
qG@x'YI5@x,h!u%L!@ 8<P)(@x'  4y^QC	a@x6c*.5j
(V+j'"5ST3^cdKudil"W/iKYO@B&q5R3 	HF 	H>LccN	H"qp	26PQ <	ZOmHAn7n#4'J-F=@2l26Z05cPj' {7k =PpBp"\>'d$@P.MB?;cZxr	2HBZ 	0)"8	PO/W0N@xIe@-&?QpC@xLz$tAEr	O 86,(cj'0 ' y'Fo,/; K[2k#Qy5f@vj#dux2j'8F$m}{r-(H<D#8|MG	GyMR)8eHtd(8A=?)@Fy
'0!NJ$w4gp-ZIIpr,7@P# <bPi}Ba'0zY}>O8AxEprPw[ {
 <53>i	7FQ3g-zq</d!ogQs<fd=>x^wG7=b-?KY1^ua}Tq;^L2.~^6P?.2?WRk{#D9[@fmqEc&'VGSLLN`?/L7FjuW/#{&,p[Lf#5O}r,,^=P3h]vy>;V)#WyeQO<{+]1+Loz#&	(OvI`x9WC);-,^=01u2W:[Xz@xJbRmm=sNM!Pft^B73;?[+l*g,$P?{hKK^S&x"O7G7F&g8r8_?	{lZVEN%'Lm?HVlxwuv,=>1u2wsii85=@{/=62mj%'
mPKdNB-wJ#us	{|O<GaQD|" v=D,0:OPV/]mW_?:9E =zjA56qu[vq^T8BFcQO[5#(Bx"k1DZ}YA (o*/f^B7G5xFAWzlz39^/qqkd
s,PVKKQ":;KiA~OC/','0t*gF=>hr^zwJ>OsXpzs)G'}0ur<J}/B?|b'D[;1<8p$[:\j;wUzj7x@y8=6?4e>[:|vQFzO1L+7j ";^z6Hz2`cvL+tsiiPQ%<a:'=a^i	oL9+/_y86X|Ph  l~G~p,j3s.rE-9aU+<V  4O)8brzfQ"JO~ZQ/`b{dj13{"J>IG5"J>}Xw y;GURa!{oO 74#{w6(W>|rY'n[v1t~QDn.->6vcqCC\ '9|#{=lwVGLNz7vHXuLpKR0={V{J8|8b=(baDb=A fYSI= 7=b3O X&aQ%q:73{*s6^#)5her0 `Nb#(7' LxM+(\G^{^2 Xu'Wr{~vuuZu|ko| s7}}{r-/<~wbdna)?=sb69f`x3siZR4^;}wn[vwus?}VZt )kZ/\=:<5Y3Rg3sa?>~/<[?ye 0GCsJb3|~[^.w7=w>W=>iB Nxi7'N_lFvwW>3OEQ_{/A '[fb3swaDk8` bX8BxRE69=3\|a6X;jt*QwZ	_v	O`2}{1*FG.^pYJGktM1[LbDmD52]ag*iv|wnz?5Ses QPxFxqQ8 X)Q@oC"q?7u/]Agwqg s*eown 5k&GS=)EA!ixOWzl<a jApk/oGT~vuv,
Os*}n=wwG=UR_B$>YsjQe|a40A}SKQ"
Y/LGOu=_jE[u'`0	 9~~]vjAPAmN	{&P/mj%QDA27X'Dtoz.q(V{B7F^;eR0=QwIk b/Kiqk#&N
^_
OT,7eR_
NGZ[[ @pZj}V4|rTp2fdnib"]QA_)vNPo/7sA/lz*(mw
33sPaw}=wE{U\  j{u}Wy_:8gj:;w/tR)"]8brzf3c]N}MDOBiH1#^}k:#CTJb}8bB{=Oc[Tk5:L 4ZNv1.;~;	OVMjuoex4i=e"ANQdM5]VEX3OX>oCP^$imeWQ??GG5N/y!5<8p$+"Zkv=fYI?~'dSsoG(s^O~(bxpH}-/r3>7FPjbf:@r/c^%w3zgf'n -vS_Zx9Z_u38Vcq\K.b0Ru1@Sb_$-J_Mg5*GyZq	L@Xx'p|&"o{Dlvp	3O`bBM> 	LPPUj]k:'0Qz|Zc+&,(u-8_ <]i46?&0R[q%m=O`"4|Q@x$,Zq~w1{0 jY^vu 4B\$lUI_q:kq>s	LtxK$,}f@c'<7S:1	'@/y&iZ8nC<	D/?i|a+{n`rDBp `DBp `$q/&M2-@xL(@	QM5OIw!*]8'dJ 	0"@!8ajY^6Ei&P<ABdf/0l0tj'o<Ao&n".yn=|<AB8e/9O(!qXe{I\Xs' =o6te^wHAJudz~VHg @:@cqfdQhRWY:81fhlbWYL+: 	HbND#r<9O@&x08J.M1$ 	HD%4 < D	M O R   %0 <@"0%, < X	H O   j   O        <  O          <  O        <  O   O        <  O   	X7ZP[    IENDB`                                                                                                                                                                                                                                                                                PNG

   IHDR  O        dIDATx_le.85V6qSI:Fm)7wws#Lq8LZ,]3 Y]s{9'>P(   j   '   	  @x     '   	  @x  @x     '   	  @x     '   '   	   Z+dc\.=o14SQk O@	V ODfR-I| 	)(@x':A

@pIB'@pB`q'CC1<O``05r(d4)} 8!8`
PP--ud)8)BSR" <	N])a<l	HxpR'@s9' !I)!|l2 *]ge_!rH;Ob_<R!h/U' !IlNdqd(8aQ_l!o11rx E'#0C29m2VH""4	M
?>s' Iq"=!gc6OC28m2VT4> IP 5+Ng3w!<Ae
5'@QDpBB bH:+@EYP <"BYhJwP;@x"
NF/!JB	PH%	O 8I*Xg/@}B]	8'IP_@x6'( ,y k)A
[q2 f7Cs4D{q"|\X^(@p"8ndP\J|uLPy$=9^G8y))8%)$ag7Cy'b?);Iu
'Pd9i%C+@!"s;-@"*]'!8e{(<kP 	b(`i	'Ph'JB]	hYp@}	,{uN4Gs]g']w,o|B#jN]7{kW?+o)77s:{`%]x)R1+
iQiN
cGz|?j?D2.~^<P?q7R1+G*ioI[N	q>:!@kS~Wsv|3~3AlY]d{T_S"O<pP%9sWEKVji
?q5xxogMx;{796j5c^~cX$:*(?89VJ5w(zOW~O_'<%1upo3?^sg}Z;q!|?Q#+7Z[)tS3aoH-..n(UJWNH?P7J^R&N=W7S?|Uy=v?^zlG-KNU3lxvv=~|dP1>xkz-zlxpXkjN.Fi=kET3Jt)L7iFu3	z|#O<'AG("EzkA{44a>6%eD3a*%?T=39|G'>5p{Q4k^ZU8{:y\4(Bp"~h64Hc\Pu'n|YI (n;;n|QDAdI.-..nkD"r\_w?SM4=W/RoAeI{/\X
k>_N\.b?{l	L N^4Yo^wkY)bdNT`z{e5JTz}G'fpsc}7j.<a,/n[@omp=aMmUzj7y@:mk8Mph^6Si~N5XRN$=taY+bA=adZb$uDgG|3CPv'ehvnYeZ/_xaQULL @P}=H	#e.rS3.JE,9A'R31 PAxJS(<	Y("BGLMiDr_.SUz\.mr:=1 nWX Q5(_O~?	 PA}dQD7::Vu^wx
f{xVo_W(R7+:uv]s@xv$$V~3<uUaqR[Fj\v'0:'<}715}dz6/urQ~	O$f =[xjB7]xS IXcTz$YzzOFvk$<P<M0 gKhQC&[ @-bh]hz67?s=&] @5?X}"z5o~.+<QW^u|heuwMza/ vmk=oyg,'NRj#a9k&a0 4G'I|Z+9}y=zzKs_	m:=o >MQw/\jmxx:}mkkYb|{65=;t~[riO2 ?Rx=6zRZKwqL8s?~wakv @pjk-H{h0t|dYm+Gzzx^_ZNXv
%#n{?/I '@Q5R"q bT8BxrE,7>9-Kx&mO{0rEmx:UZ]u&o |v^h c Q@<+Um;4C=&qM$OXQ@p\a"6^ugT5#o_a<JO;4R)SL5ZK{&u PcF}=nm_&wH1foP[AxJ.{;r\kkm[#n]L a]vr+VnS=)ErnN}8"t}no&{ HF\.wkr5en~Shs}n=wOVTrz|S5/T=d^,QD1K8N($qQ^>o=/;=1  W*ZK=/yJxJF\.WAmW?#,&vE/T(QD.kvAIz	J5^w"AD^
;v#nmF;&^-]1vXKE\D=	5z)(}>AD_Ooiqk#O`sW_OT-?R;ttU @p(>kW,Uo.,::VN}gWX1^kZciR"##aA/_+C?@=snVqm#8z)(w3S3vHxj;n{W :igGa]v{8-vR9"J8b|rjW'vuw{a5^4(ODDqc[*QDSocjTOOtp_Mq{M?;$z'FCpN8
{dn;[Gq`t[.{Kfo]/<.aS'.{Euo;>_ygrwi{TQJm0qD4%m),-^"&\Fs<8Bx"}we/g%i$AuOJvpgxkDl}jJ6#9mA~k14x3|+0Ak'C;m;r75}gjzv&)c$<&R?v;{4dB3Uh=oSLTFJP(Q6n
*dg nq>
EvJ[ <Bo<|W <Dq7;~`	u
'P	'P<qU[#%@x/(7]'(
@!8P@x,(O{C'PH-iq}?vPw@xRp'@xftRT_w-]'u@a,]Ppv 4ccSl]$.kd^7Cy/xKvx$8@24(m$.z$"@x(Y],8Y9QhDptp4Ien<A(4b (fZVHhI 'P(IpBm 	P$P@xKZ OhH*Xg#8uR 	P<(@	QM~ E(!*}Ip2R z@xEJ0MR(EPgoAn!.4y|c	B.Pt@x[(Ip2 %DE'=y\{;=wd<l	g[oPl@x@ D5v's5\NE<|xk	HpR--7S]- %i^gzW'HR3FB< PYI;cAxRva*kaIX2_AxRw&yd58@)4:`#pj^	HiRcI
s9' JG  & ' )	 	 AJ`@x@   aJX@x@  $ '  h5        <  O        <   <  O        <  O           <  O     @By+?]    IENDB`                                                                                                   PNG

   IHDR  O        0IDATx_lVe.8VkV%mht8]/ZEwBHnf$@4&X5%\ :S^`w|n=9y}y   h   @x     '   	  @x     '   '   	  @x     '   	  @x  @x     *k!l8ttd1`x(`4=/Vj[6'Hb@*  |&aj1
'@p%a

 	E'@` 	)(v<	'/PO`@LrN((c\EbNNhz#-.Rp\hJUXzX$s 	H`pvYZR,;'IQ'w <		NbN}R,7VB/+E^5UgC	H+OdI1V(DQj <		NM'Da>@l2P+o#la>N$08e{=Eb0'),c#<.''Yl'@pBp.'	Musd(8!8BO$@)1@x'[$ymT%s''*X	MQf@p
'hF	HhAErNdRP' ' 	'= X 	'K \sr
9i-X	 Plam'c <	$\r 'qHbg$98H0<AB{jIO?	(YV C	Q<&Ljd-v)Y?p(8a'+(@pBoRcJk^((@x(q]uJ'PN
J
'vJ9O 8>Pb@qVnu#oa~3\WQ?q9>np\++Q>zj.~}WRxR6K
iQiNC90(xPQ{ls&fj<vJ{{7twvUr_JfY5B'PpJ%-,
N)p>9q$<\v}R+hS{U6>b2<2I<_j}XAwK}o~I
[4 	Eyo)^zgSGJ^twZ>slNPG'z#lPsbwotD?OxJbRml<}[O{Nw4
0?1(Uj*wO\=odB+XYcI!ypc~U!+}TGw|c96m\v}`lbrw=o[fo;<kXrNN2~yogCme.Qordg=f(YS@bkrN%8&kRSL7iZ<]{}#O<'aWQDlZ0Oc\hPp{/ =	*{>	{#=J4<_ZO3g|`%#4_:>/?iil!<X<aR @ yT=6,UAS%1QDW6 k}	#PK\9WL!@QmaeIg/j2WL mz9a@p 
t*DhR~FhU9SDTC9J E)J?#Q?%W/_/Od$n[fp6tTjj  JJlZw{L6uw3mDjib,LKsZXXxX<Kp2F8srE=iyN75X!m-s]"8NTvVcppiig|GFK7<RW>a  ?ognU&f/^-4XY{U)VH	 i <@TjQ?q~Bp	?~#&NvQD1~/yT)J|.*(yOp jR"q7%<i PPKS18X(TY[uXkF'13u)_NR?ttd1leiL Nf$5@	Q$V~+yk/R~"^>>}Z	NPzab3|O;'N!^FsWN__+2< VZxw[7<RZw	 $n/5kOwgeZrSjQ
YXX( INPZ4(~L @pzbh?Cdj6(7?}=  8e=zE7?5~BW^> @ P}]'<gSG^?}>F NG'F^N~kUJT	3}Q361{mj3KA/_?N6rr5+yNS%|q/|Nvoxp_sU3V-S3aX<^`?X"D(  $-_aXXXW#oaC^}S#]X7@TP1??:~6oZ}nwWMsWVK?M  8>Q=}?vtFHF GP  8Q;E,SL(bl^K@c;>TLjR/}&< d\]5UyD59|Vmv|z4}FDj	U`.eITM3/}*UN;s[Wy+OTL"@9*  8A'<@Thk!@D5E5zoKd4@qsk`Accm#n]( H.{;s[A^jloKT	O	("Q#*ZGX\ jApk+<\{Z['*jG3TR #8T9d,QD>K8BqJje|a8Bxy/O{7{uowA j[~~WM_n|w*QDA]3s8=GP1`nS)Q" 5hnZw{L{8BxB":k]l[Q,WDm;~%@}OTB"Z[DtwvEm6XntD._ /jRxlQ,.CGGSo3I
 ''[#~eV1?bTp4z~Kjhw
2~Z*N@=/ =t%Sj,gFmE3uT.BGS}W;*6Ph @pJy|uU#wTxt%}[|-(oK#&&w{}lbrw}u_c)#^O*-#[*QDKksrdg'Nvoxp_Mq{?Y6vLNBTZ)( {T+Ixt[R]BWkO
 sYI*uo&kkm+g^|'+*(tk)ooT82*m	,KV/`.\Fs28Bx"M:Wt!s8+L#	*]dq>fY+~N$zo/4SP>QDoR/[^vcO5_ eP`~bNf~3{L}1/S3I#X|x((*).cJxY)yZ5\C.b0RP2N`S	BMEJ=P`u2"FU9H1r< Kao@B '8&(7Vp>` O @AqK#c@x.P81
 <  /@xdi-oN-f~KU'{@4<(m		@"M
lq+9
h/pKJ&'`] pH,N6a~YUHbqU$Ul$'Zq_U&	a!@{>^Lb3W3& 	'@"j
ioH<A+@|0>J
's\Hs!u2<kdkI|N <( RpN
io 

	'@BBpBp	Hm!O @bIA] O E$8XPx}@x(\D	PNik 

		2aqTdW+&@eXyz* 
JpRH;	_*'o<AB{]q79$'H(!(*QYH9O EU1RD;Wr@)	\-ySc9$8@	O}~PClRB(Z.*@zXy)%de P1R<;{(IapP4sv1' EJxRe-,"0)SO@
DD-R,;(Zj84P,4(8P$1'@xR'(	 	 !Jh@x@  & ' )	 	 % ' )a	 	 J@@x  HFC    <  O        <  O           <  O        <   <  O        <  $5d)    IENDB`                                                                                                                                                       PNG

   IHDR   #      mat   gAMA  a  
)iCCPicm  HwTS7PkhRHH.*1	J "6DTpDQ2(C"QDqpIdy~kg} LX	Xg` l pBF|l *? Y"1 P\8=W%O4M0J"Y2Vs,[|e92<se'9`2&ctI@o|N6 (.sSdl-c(2-y H_/XZ.$&\SM07#1Yr fYym";8980m-m(]v^DW~ emi ]P`/ u}q|^R,g+\Kk)/C_|Rax8t1C^7nfzDpu$/EDL L[B@X!@~ (* 	{d+}G}WL$cGD2QZ4  E@@ A(q`1D `'u46ptc48.`R0)
@Rt CXCP%CBH@Rf[(t CQhz#0	Zl`O828.p|OX
?:0FBx$	!i@H[EE1PLV6QP>U(j
MFk t,:.FW8c1L&9aX:rbl1
{{{;}#tp8_\<N+UZp'pWpeF|~?!(	HB*a-F8KKxA$NpXI<D<O%%QHf$6)$!m!'"" Fdr<YLBn&!'Q*X*(V+(t*\QxW4TT\XxDqH^HQZTtT2UF9T9CyrG,CQ((g(cTOeSuFY8C3Rioh)JJJq)2au;U-UOU&6+yJF3}w@iikj8tm954#4Wh:TCUMGCc
d1t5uu%3zzQzzz	,$S:!,]b6u=2V307n5kB6q7Yf`rc2M3mz67K112-NBLleZ---,YX[mhmonh}bhShc-\\v}ngncwjba1
cmfwB;y9v:Y|KKyr\]nDnRw]w{}GgAg^^"lgJ)o{SsW7wo)6Z@}AAAE=!pH`w}		aQ`"""DDIz_xHcbW^uc,p<>8"Ey.,X%%G1-9Kl.oo/O$&'=JvM<RTTNM)=&=qTH	232\6%
5eC4D^2S&7:Hr0o`M'}^Z][[`tUzW.Z=oik(.,/|.f]OV~[E76l(8iMKx%KK+JonW_}elVV(W./scG;PaWQKKZ\]eP}uJHWM{fyVUWZn`z}}96F7I~~}--epu`xlo$A{}g]m\9%>x{=Vs\x	N>ucKz=s/ol|?y^d]ps~:;/;]7|WpQoH!VsnYs}~4] =>=:`;c'?e~!aD#G&}'/?^xI?+\wx20;5\_etWf^Qs-mw3+?~O~66    cHRM  z&         u0  `  :  pQ<   bKGD Z T S77   	pHYs    +   tIME#  IDATXKaISj4A%S)Ph!tpjt	V.7v|jh8(v!o-y:E	ry{}aP,l}CJ4F_m}CS\dd]1<.Ou+&t)0p`20--Wa @=b!IB?A	!$xlp]|P?g{g_`+ef+wF'&x4fP%h=P\=6i^L<C]C^t#%r4r`xfU~Txrdh*  'f_ @5'<ecB]pZf\N}hj 5.MU;?YLO9;oh-lBzZrrdgp}Md[&nE7z&0p`7/Oq    IENDB`                                                                                                                                                                                                                                                                                                     PNG

   IHDR   (   (   m   	pHYs       
MiCCPPhotoshop ICC profile  xSwX>eVBl "#Y a@
VHU
H(gAZU\8}zy&j 9R<:OHH g  yx~t?o  p.$P&W   "R .T  Sd
   ly|B"  I>    (G$@ `UR, @".Y2G vX@` B,  8 C L0_pH K3w!lBa)f	"#HL  8?flko">! N_puk[ V h]3	Z
zy8@P<
%b0>3o~@z q@qanvRB1n#)4\,XP"MyRD!2	w ONl~Xv @~- g42y  @+   \L  D*AaD@$<B
AT:18\p`	Aa!:b""aH4 Q"rBj]H#-r9\@ 2G1Qu@st4]k=Kut }c1fa\E`X&cX5V5cX7va$^lGXLXC%#W	1'"O%zxb:XF&!!%^'_H$N
!%2IIkHH-S>iL&m O:L	$RJ5e?2BQ:ZImvP/S4u%C-igih/t	EkwHb(k{/LT02goUX**|:V~TUsU?yTU^V}FUP	U6RwRPQ__cFHTc!2eXBrV,kMb[Lvv/{LSCsfffq9J!{--?-jf~7zbrup@,:m:u	6Qu>cy	Gm7046l18cckihhI'&g5x>fob4ek<abi2)kft,9kaEJ6|MV>VyVVI\,mWlPW:vm))Sn1
9a%m;t;|rtuvlp4Wggs5KvSmnzm=}M.]=AXq/^v^Y^O&0m[{`:>=e>>z"=#~~~;yN`k5/>B	Yroc3g,Z0&L~oLGli})*2.QStqt,Yg;jrvgjlRlcxEt$	=sl3Ttcw<Y5Y|8? BP/OnMOEQJ<V8;}ChOFu3	OR+y#MVDq-9Ri+0(Of++ym#slLRPL/+x[[xHHZ3f#|PxY"E#Sw.1]Rdxi}hPXRUjyRC+W4nZcadUj[V*_pFWN_|ymJHnYJjA_mJtzj5a5[6z]V&w{;+xWkE}nb~GwO{{Ejtol	mR6H:powpZ*A'|{PHy+:u-m=^G~1cu5W(=dN?=yLk]Q]gC?tL_]p"b%K==G~pH[oeW<tM;js.]yn&%vw
L]zxem``Y	GG#F#d~VysKXyr:#y=}(@PcO>|/%3    cHRM  z%        u0  `  :  o_F  GIDATxm0E78HF
%[wi=K  'iNHaX"t%=}9Ilxi% 1IKIu0>XUc<H[ pl1$p	z&g;LPtb}kE$I^^w?50`z]S
v ^;l/+1+0*z^Tfy/83$Q5X'U<d[.n[4@e=;_="{0} ??    IENDB`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      <!DOCTYPE html>
<html>
<head>
<meta charset='<!-- #echo var={_CHARSET} -->' />
<link rel="stylesheet" type="text/css" href="dev.css?version=V9.40373">
<script src="jquery.js?version=V9.40373"></script>
<script src="rx.js?version=V9.40373"></script>
<script src="jquery.dev.js?version=V9.40373"></script>
<script src="jquery.sendkey.js?version=V9.40373"></script>
<script>
var dev_name = "<!-- #echo var=_device -->";
var font_sz = "<!-- #echo var=_font -->";
var lines = "<!-- #echo var=_lines -->";
var columns = "<!-- #echo var=_columns -->";

if (isNaN(lines)) {
  lines = 0;
}
else {
  lines = Number(lines);
}

if (isNaN(columns)) {
  columns = 0;
}
else {
  columns = Number(columns);
}

if (isNaN(font_sz)) {
  font_sz = 0;
}
else {
  font_sz = Number(font_sz);
}

if (dev_name == 'TP2') {
  dev_id = 1;
}
else if (dev_name == 'TP3') {
  dev_id = 2;
}
else {
  dev_id = 0;
}
$(window).on("unload", function() {
  $('#dev1').unbind('dev');
});
</script>
<style>
  body {
    margin: 0px 0px 0px 8px;
    padding: 0px;
<!--#if _width = 0 -->
    overflow: hidden;
<!--#endif -->
  }
</style>
</head>
<body bgcolor="<!-- #echo var=_BGCOLOR -->">
  <div id="dev1">
  <script>
    var line_h;
    if (top.g_android) {
      switch (top.g_lang_suffix) {
        case 'ja':
        case 'ch':
          if (font_sz >= 24) {
            line_h = 7 / 6;
          }
          else {
            line_h = 6 / 5;
          }
          break;
        default :
          line_h = 4 / 3;
          break;
      }
      $('#dev1').css('line-height', line_h);
    }
    if (top.g_ipad) {
      line_h = 6 / 5;
      $('#dev1').css('line-height', line_h);
    }
    if ((font_sz > 0) && (font_sz < 100)) {
      $('#dev1').css('font-size', font_sz);
    }
    if (font_sz >= 24) {
      $('#dev1').css('font-weight', 'bold');
    }

    if (font_sz == 100) {
      // 08-JAN-2019 EVANSJA pr51304 - Support resizing the font for User menu.
      $('#dev1').dev({ name: dev_name, device_id: dev_id, resize_font: true, resize_rows: lines, resize_cols: columns });
    }
    else {
      $('#dev1').dev({ name: dev_name, device_id: dev_id });
    }
  </script>
  </div>
</body>
</html>
                                                                                                                                                                                                                                                                                             <html>
<head>
<script type="text/javascript">
if (top.g_msie) {
  var zoom_str = "<!-- #echo var = _zoom -->%";
  var fname = "<!-- #echo var = _fname -->".toLowerCase();
  if (typeof(top.cgtpfrm) != "undefined") {
    var fele = top.cgtpfrm.mainfrm.document.getElementById(fname);
  }
  else {
    var fele = top.mainfrm.document.getElementById(fname);
  }
  if (fele !== undefined) fele.style.zoom = zoom_str;
}
</script>
</head>
<body>
</body>
</html>
                                      /*
 * 
 * foc.css - FANUC Robotics FocusBar plugin CSS
 * 
*/

.focusbar_focus {
  background-color: #3A3A3B;
  color: white;
  font-size: large;
  width: 100%;
  height: 30px;
}

.focusbar_nofocus {
  background-color: #C0C0C0;
  color: #404040;
  font-size: large;
  width: 100%;
  height: 30px;
}

.focusimg {
  width: 24px;
  height: 24px;
  vertical-align: middle;
  border-style: none;
}

/* Copied from jquery-ui.css ui-button */
.focusbutton { 
  display: inline-block; 
  position: relative; 
  padding: 0; 
  margin-right: .1em; 
  text-decoration: none !important; 
  cursor: pointer; 
  text-align: center; 
  zoom: 1; 
  overflow: visible;
}

.focusbar_treeview {
  color: #404040;
  width: 100%;
  height: 30px;
}

.indicator {
  padding: 0px;
  font-size: 16px;
  font-weight: bold;
  border-style: none;
  cursor:pointer;
}
                                                                                                                                 <!DOCTYPE html>
<html>
<head>
<title></title>
<link rel="stylesheet" type="text/css" href="foc.css?version=V9.40373">
<script src="jquery.js?version=V9.40373"></script>
<script src="rx.js?version=V9.40373"></script>
<script src="jquery.foc.js?version=V9.40373"></script>
<script src="jquery.sendkey.js?version=V9.40373"></script>
<script>
$(window).on("unload", function() {
  $('#foc1').unbind('foc');
});
</script>
</head>
<body>
  <div class="focusbar_nofocus" id="foc1">
  <script>
    $('#foc1').foc();
  </script>
  </div>
</body>
</html>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         <!DOCTYPE html>
<html>
<head>
<title></title>
<link rel="stylesheet" type="text/css" href="foc.css?version=V9.40373">
<script src="jquery.js?version=V9.40373"></script>
<script src="rx.js?version=V9.40373"></script>
<script src="jquery.foc.js?version=V9.40373"></script>
<script src="jquery.sendkey.js?version=V9.40373"></script>
<script>
$(window).on("unload", function() {
  $('#foc2').unbind('foc');
});
</script>
</head>
<body>
  <div class="focusbar_nofocus" id="foc2">
  <script>
    $('#foc2').foc({ name: 'TP2', device_id: 1 });
  </script>
  </div>
</body>
</html>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <!DOCTYPE html>
<html>
<head>
<title></title>
<link rel="stylesheet" type="text/css" href="foc.css?version=V9.40373">
<script src="jquery.js?version=V9.40373"></script>
<script src="rx.js?version=V9.40373"></script>
<script src="jquery.foc.js?version=V9.40373"></script>
<script src="jquery.sendkey.js?version=V9.40373"></script>
<script>
$(window).on("unload", function() {
  $('#foc3').unbind('foc');
});
</script>
</head>
<body>
  <div class="focusbar_nofocus" id="foc3">
  <script>
    $('#foc3').foc({ name: 'TP3', device_id: 2 });
  </script>
  </div>
</body>
</html>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <!-- Focus Bar for iRProgrammer TreeView -->
<!DOCTYPE html>
<html>
<head>
<title></title>
<link rel="stylesheet" type="text/css" href="foc.css?version=V9.40373">
<script src="jquery.js?version=V9.40373"></script>
<script src="rx.js?version=V9.40373"></script>
<script src="jquery.foc.js?version=V9.40373"></script>
<script src="jquery.sendkey.js?version=V9.40373"></script>
<script>
$(window).on("unload", function() {
  $('#foc4').unbind('foc');
});
</script>
</head>
<body bgcolor="#E1E7EC">
  <div class="focusbar_treeview" id="foc4">
  <script>
    $('#foc4').foc({ name: '', device_id: 4 });
  </script>
  </div>
</body>
</html>
                                                                                                                                                                                                                                                                                                                                                                              F R C G L  H E L P E R   . J FRCGLH~1JS    kXX kX) FRCSNGL STM   kXX kX3 K  FRCWEBGLJS    kXX kX4 e GRID    JS    kXX kXg"> BN . P N G  [    G R I D F  [O R J J O G   G I GRIDFO~1PNG   kXX kXk# BI N O R .  P N G     G R I D F  O R J O I N   T M GRIDFO~2PNG   kXX kXI$ BN . P N G      G R I D I  O _ D O W N   _ O GRIDIO~1PNG   kXX kX%+  BG      G R I D I  O _ O F F .   P N (function (k, Ba) { "object" === typeof exports && "undefined" !== typeof module ? Ba(exports) : "function" === typeof define && define.amd ? define(["exports"], Ba) : (k = k || self, Ba(k.THREE = {})); })(this, function (k) {
    function Ba() { }
    function w(a, b) { this.x = a || 0; this.y = b || 0; }
    function ua(a, b, c, d) { this._x = a || 0; this._y = b || 0; this._z = c || 0; this._w = void 0 !== d ? d : 1; }
    function n(a, b, c) { this.x = a || 0; this.y = b || 0; this.z = c || 0; }
    function Y() { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]; 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."); }
    function W(a, b, c, d, e, f, g, h, l, m) {
        Object.defineProperty(this, "id", { value: Ri++ });
        this.uuid = L.generateUUID();
        this.name = "";
        this.image = void 0 !== a ? a : W.DEFAULT_IMAGE;
        this.mipmaps = [];
        this.mapping = void 0 !== b ? b : W.DEFAULT_MAPPING;
        this.wrapS = void 0 !== c ? c : 1001;
        this.wrapT = void 0 !== d ? d : 1001;
        this.magFilter = void 0 !== e ? e : 1006;
        this.minFilter = void 0 !== f ? f : 1008;
        this.anisotropy = void 0 !== l ? l : 1;
        this.format = void 0 !== g ? g : 1023;
        this.type = void 0 !== h ? h : 1009;
        this.offset = new w(0, 0);
        this.repeat = new w(1, 1);
        this.center = new w(0, 0);
        this.rotation =
            0;
        this.matrixAutoUpdate = !0;
        this.matrix = new Y;
        this.generateMipmaps = !0;
        this.premultiplyAlpha = !1;
        this.flipY = !0;
        this.unpackAlignment = 4;
        this.encoding = void 0 !== m ? m : 3E3;
        this.version = 0;
        this.onUpdate = null;
    }
    function aa(a, b, c, d) { this.x = a || 0; this.y = b || 0; this.z = c || 0; this.w = void 0 !== d ? d : 1; }
    function la(a, b, c) {
        this.width = a;
        this.height = b;
        this.scissor = new aa(0, 0, a, b);
        this.scissorTest = !1;
        this.viewport = new aa(0, 0, a, b);
        c = c || {};
        this.texture = new W(void 0, void 0, c.wrapS, c.wrapT, c.magFilter, c.minFilter, c.format, c.type, c.anisotropy, c.encoding);
        this.texture.image = {};
        this.texture.image.width = a;
        this.texture.image.height = b;
        this.texture.generateMipmaps = void 0 !== c.generateMipmaps ? c.generateMipmaps : !1;
        this.texture.minFilter = void 0 !== c.minFilter ? c.minFilter : 1006;
        this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0;
        this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0;
        this.depthTexture = void 0 !== c.depthTexture ? c.depthTexture : null;
    }
    function Of(a, b, c) { la.call(this, a, b, c); this.samples = 4; }
    function U() {
        this.elements = [1, 0, 0, 0, 0,
            1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
    function Qb(a, b, c, d) { this._x = a || 0; this._y = b || 0; this._z = c || 0; this._order = d || Qb.DefaultOrder; }
    function Pf() { this.mask = 1; }
    function B() {
        Object.defineProperty(this, "id", { value: Si++ });
        this.uuid = L.generateUUID();
        this.name = "";
        this.type = "Object3D";
        this.parent = null;
        this.children = [];
        this.up = B.DefaultUp.clone();
        var a = new n, b = new Qb, c = new ua, d = new n(1, 1, 1);
        b._onChange(function () {
            c.setFromEuler(b, !1);
        });
        c._onChange(function () { b.setFromQuaternion(c, void 0, !1); });
        Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: a }, rotation: { configurable: !0, enumerable: !0, value: b }, quaternion: { configurable: !0, enumerable: !0, value: c }, scale: { configurable: !0, enumerable: !0, value: d }, modelViewMatrix: { value: new U }, normalMatrix: { value: new Y } });
        this.matrix = new U;
        this.matrixWorld = new U;
        this.matrixAutoUpdate = B.DefaultMatrixAutoUpdate;
        this.matrixWorldNeedsUpdate = !1;
        this.layers = new Pf;
        this.visible = !0;
        this.receiveShadow = this.castShadow = !1;
        this.frustumCulled = !0;
        this.renderOrder = 0;
        this.userData = {};
    }
    function wd() { B.call(this); this.type = "Scene"; this.overrideMaterial = this.fog = this.background = null; this.autoUpdate = !0; "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })); }
    function ab(a, b) { this.min = void 0 !== a ? a : new n(Infinity, Infinity, Infinity); this.max = void 0 !== b ? b : new n(-Infinity, -Infinity, -Infinity); }
    function Qf(a, b, c, d, e) {
        var f;
        var g = 0;
        for (f =
            a.length - 3; g <= f; g += 3) {
            Rb.fromArray(a, g);
            var h = e.x * Math.abs(Rb.x) + e.y * Math.abs(Rb.y) + e.z * Math.abs(Rb.z), l = b.dot(Rb), m = c.dot(Rb), q = d.dot(Rb);
            if (Math.max(-Math.max(l, m, q), Math.min(l, m, q)) > h)
                return !1;
        }
        return !0;
    }
    function nb(a, b) { this.center = void 0 !== a ? a : new n; this.radius = void 0 !== b ? b : 0; }
    function Sb(a, b) { this.origin = void 0 !== a ? a : new n; this.direction = void 0 !== b ? b : new n; }
    function R(a, b, c) { this.a = void 0 !== a ? a : new n; this.b = void 0 !== b ? b : new n; this.c = void 0 !== c ? c : new n; }
    function H(a, b, c) {
        return void 0 === b && void 0 ===
            c ? this.set(a) : this.setRGB(a, b, c);
    }
    function Rf(a, b, c) { 0 > c && (c += 1); 1 < c && --c; return c < 1 / 6 ? a + 6 * (b - a) * c : .5 > c ? b : c < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - c) : a; }
    function Sf(a) { return .04045 > a ? .0773993808 * a : Math.pow(.9478672986 * a + .0521327014, 2.4); }
    function Tf(a) { return .0031308 > a ? 12.92 * a : 1.055 * Math.pow(a, .41666) - .055; }
    function zc(a, b, c, d, e, f) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.normal = d && d.isVector3 ? d : new n;
        this.vertexNormals = Array.isArray(d) ? d : [];
        this.color = e && e.isColor ? e : new H;
        this.vertexColors = Array.isArray(e) ? e : [];
        this.materialIndex =
            void 0 !== f ? f : 0;
    }
    function M() {
        Object.defineProperty(this, "id", { value: Ti++ });
        this.uuid = L.generateUUID();
        this.name = "";
        this.type = "Material";
        this.fog = !0;
        this.blending = 1;
        this.side = 0;
        this.vertexTangents = this.flatShading = !1;
        this.vertexColors = 0;
        this.opacity = 1;
        this.transparent = !1;
        this.blendSrc = 204;
        this.blendDst = 205;
        this.blendEquation = 100;
        this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null;
        this.depthFunc = 3;
        this.depthWrite = this.depthTest = !0;
        this.stencilWriteMask = 255;
        this.stencilFunc = 519;
        this.stencilRef =
            0;
        this.stencilFuncMask = 255;
        this.stencilZPass = this.stencilZFail = this.stencilFail = 7680;
        this.stencilWrite = !1;
        this.clippingPlanes = null;
        this.clipShadows = this.clipIntersection = !1;
        this.shadowSide = null;
        this.colorWrite = !0;
        this.precision = null;
        this.polygonOffset = !1;
        this.polygonOffsetUnits = this.polygonOffsetFactor = 0;
        this.dithering = !1;
        this.alphaTest = 0;
        this.premultipliedAlpha = !1;
        this.toneMapped = this.visible = !0;
        this.userData = {};
        this.needsUpdate = !0;
    }
    function Ga(a) {
        M.call(this);
        this.type = "MeshBasicMaterial";
        this.color =
            new H(16777215);
        this.lightMap = this.map = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.envMap = this.alphaMap = this.specularMap = null;
        this.combine = 0;
        this.reflectivity = 1;
        this.refractionRatio = .98;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.wireframeLinejoin = this.wireframeLinecap = "round";
        this.morphTargets = this.skinning = !1;
        this.setValues(a);
    }
    function O(a, b, c) {
        if (Array.isArray(a))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "";
        this.array =
            a;
        this.itemSize = b;
        this.count = void 0 !== a ? a.length / b : 0;
        this.normalized = !0 === c;
        this.dynamic = !1;
        this.updateRange = { offset: 0, count: -1 };
        this.version = 0;
    }
    function xd(a, b, c) { O.call(this, new Int8Array(a), b, c); }
    function yd(a, b, c) { O.call(this, new Uint8Array(a), b, c); }
    function zd(a, b, c) { O.call(this, new Uint8ClampedArray(a), b, c); }
    function Ad(a, b, c) { O.call(this, new Int16Array(a), b, c); }
    function Tb(a, b, c) { O.call(this, new Uint16Array(a), b, c); }
    function Bd(a, b, c) { O.call(this, new Int32Array(a), b, c); }
    function Ub(a, b, c) {
        O.call(this, new Uint32Array(a), b, c);
    }
    function A(a, b, c) { O.call(this, new Float32Array(a), b, c); }
    function Cd(a, b, c) { O.call(this, new Float64Array(a), b, c); }
    function jh() { this.vertices = []; this.normals = []; this.colors = []; this.uvs = []; this.uvs2 = []; this.groups = []; this.morphTargets = {}; this.skinWeights = []; this.skinIndices = []; this.boundingSphere = this.boundingBox = null; this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1; }
    function kh(a) {
        if (0 === a.length)
            return -Infinity;
        for (var b = a[0], c = 1, d = a.length; c < d; ++c)
            a[c] > b && (b = a[c]);
        return b;
    }
    function E() { Object.defineProperty(this, "id", { value: Ui += 2 }); this.uuid = L.generateUUID(); this.name = ""; this.type = "BufferGeometry"; this.index = null; this.attributes = {}; this.morphAttributes = {}; this.groups = []; this.boundingSphere = this.boundingBox = null; this.drawRange = { start: 0, count: Infinity }; this.userData = {}; }
    function ja(a, b) {
        B.call(this);
        this.type = "Mesh";
        this.geometry = void 0 !== a ? a : new E;
        this.material = void 0 !== b ? b : new Ga({ color: 16777215 * Math.random() });
        this.drawMode =
            0;
        this.updateMorphTargets();
    }
    function lh(a, b, c, d, e, f, g, h) { if (null === (1 === b.side ? d.intersectTriangle(g, f, e, !0, h) : d.intersectTriangle(e, f, g, 2 !== b.side, h)))
        return null; Ee.copy(h); Ee.applyMatrix4(a.matrixWorld); b = c.ray.origin.distanceTo(Ee); return b < c.near || b > c.far ? null : { distance: b, point: Ee.clone(), object: a }; }
    function Fe(a, b, c, d, e, f, g, h, l, m, q) {
        Vb.fromBufferAttribute(e, l);
        Wb.fromBufferAttribute(e, m);
        Xb.fromBufferAttribute(e, q);
        e = a.morphTargetInfluences;
        if (b.morphTargets && f && e) {
            Uf.set(0, 0, 0);
            Vf.set(0, 0, 0);
            Wf.set(0, 0, 0);
            for (var u = 0, t = f.length; u < t; u++) {
                var k = e[u], p = f[u];
                0 !== k && (mh.fromBufferAttribute(p, l), nh.fromBufferAttribute(p, m), oh.fromBufferAttribute(p, q), Uf.addScaledVector(mh.sub(Vb), k), Vf.addScaledVector(nh.sub(Wb), k), Wf.addScaledVector(oh.sub(Xb), k));
            }
            Vb.add(Uf);
            Wb.add(Vf);
            Xb.add(Wf);
        }
        if (a = lh(a, b, c, d, Vb, Wb, Xb, Dd))
            g && (Ac.fromBufferAttribute(g, l), Bc.fromBufferAttribute(g, m), Cc.fromBufferAttribute(g, q), a.uv = R.getUV(Dd, Vb, Wb, Xb, Ac, Bc, Cc, new w)), h && (Ac.fromBufferAttribute(h, l), Bc.fromBufferAttribute(h, m), Cc.fromBufferAttribute(h, q), a.uv2 = R.getUV(Dd, Vb, Wb, Xb, Ac, Bc, Cc, new w)), g = new zc(l, m, q), R.getNormal(Vb, Wb, Xb, g.normal), a.face = g;
        return a;
    }
    function F() {
        Object.defineProperty(this, "id", { value: Vi += 2 });
        this.uuid = L.generateUUID();
        this.name = "";
        this.type = "Geometry";
        this.vertices = [];
        this.colors = [];
        this.faces = [];
        this.faceVertexUvs = [[]];
        this.morphTargets = [];
        this.morphNormals = [];
        this.skinWeights = [];
        this.skinIndices = [];
        this.lineDistances = [];
        this.boundingSphere = this.boundingBox = null;
        this.groupsNeedUpdate = this.lineDistancesNeedUpdate =
            this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1;
    }
    function Yb(a) { var b = {}, c; for (c in a) {
        b[c] = {};
        for (var d in a[c]) {
            var e = a[c][d];
            e && (e.isColor || e.isMatrix3 || e.isMatrix4 || e.isVector2 || e.isVector3 || e.isVector4 || e.isTexture) ? b[c][d] = e.clone() : Array.isArray(e) ? b[c][d] = e.slice() : b[c][d] = e;
        }
    } return b; }
    function Da(a) { for (var b = {}, c = 0; c < a.length; c++) {
        var d = Yb(a[c]), e;
        for (e in d)
            b[e] = d[e];
    } return b; }
    function ma(a) {
        M.call(this);
        this.type = "ShaderMaterial";
        this.defines = {};
        this.uniforms = {};
        this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
        this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
        this.linewidth = 1;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1;
        this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 };
        this.defaultAttributeValues = { color: [1, 1,
                1], uv: [0, 0], uv2: [0, 0] };
        this.index0AttributeName = void 0;
        this.uniformsNeedUpdate = !1;
        void 0 !== a && (void 0 !== a.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(a));
    }
    function bb() { B.call(this); this.type = "Camera"; this.matrixWorldInverse = new U; this.projectionMatrix = new U; this.projectionMatrixInverse = new U; }
    function na(a, b, c, d) {
        bb.call(this);
        this.type = "PerspectiveCamera";
        this.fov = void 0 !== a ? a : 50;
        this.zoom = 1;
        this.near = void 0 !==
            c ? c : .1;
        this.far = void 0 !== d ? d : 2E3;
        this.focus = 10;
        this.aspect = void 0 !== b ? b : 1;
        this.view = null;
        this.filmGauge = 35;
        this.filmOffset = 0;
        this.updateProjectionMatrix();
    }
    function Dc(a, b, c, d) {
        B.call(this);
        this.type = "CubeCamera";
        var e = new na(90, 1, a, b);
        e.up.set(0, -1, 0);
        e.lookAt(new n(1, 0, 0));
        this.add(e);
        var f = new na(90, 1, a, b);
        f.up.set(0, -1, 0);
        f.lookAt(new n(-1, 0, 0));
        this.add(f);
        var g = new na(90, 1, a, b);
        g.up.set(0, 0, 1);
        g.lookAt(new n(0, 1, 0));
        this.add(g);
        var h = new na(90, 1, a, b);
        h.up.set(0, 0, -1);
        h.lookAt(new n(0, -1, 0));
        this.add(h);
        var l = new na(90, 1, a, b);
        l.up.set(0, -1, 0);
        l.lookAt(new n(0, 0, 1));
        this.add(l);
        var m = new na(90, 1, a, b);
        m.up.set(0, -1, 0);
        m.lookAt(new n(0, 0, -1));
        this.add(m);
        d = d || { format: 1022, magFilter: 1006, minFilter: 1006 };
        this.renderTarget = new Ab(c, c, d);
        this.renderTarget.texture.name = "CubeCamera";
        this.update = function (a, b) {
            null === this.parent && this.updateMatrixWorld();
            var c = a.getRenderTarget(), d = this.renderTarget, q = d.texture.generateMipmaps;
            d.texture.generateMipmaps = !1;
            a.setRenderTarget(d, 0);
            a.render(b, e);
            a.setRenderTarget(d, 1);
            a.render(b, f);
            a.setRenderTarget(d, 2);
            a.render(b, g);
            a.setRenderTarget(d, 3);
            a.render(b, h);
            a.setRenderTarget(d, 4);
            a.render(b, l);
            d.texture.generateMipmaps = q;
            a.setRenderTarget(d, 5);
            a.render(b, m);
            a.setRenderTarget(c);
        };
        this.clear = function (a, b, c, d) { for (var e = a.getRenderTarget(), f = this.renderTarget, g = 0; 6 > g; g++)
            a.setRenderTarget(f, g), a.clear(b, c, d); a.setRenderTarget(e); };
    }
    function Ab(a, b, c) { la.call(this, a, b, c); }
    function Zb(a, b, c, d, e, f, g, h, l, m, q, u) {
        W.call(this, null, f, g, h, l, m, d, e, q, u);
        this.image = { data: a || null,
            width: b || 1, height: c || 1 };
        this.magFilter = void 0 !== l ? l : 1003;
        this.minFilter = void 0 !== m ? m : 1003;
        this.flipY = this.generateMipmaps = !1;
        this.unpackAlignment = 1;
        this.needsUpdate = !0;
    }
    function cb(a, b) { this.normal = void 0 !== a ? a : new n(1, 0, 0); this.constant = void 0 !== b ? b : 0; }
    function Ed(a, b, c, d, e, f) { this.planes = [void 0 !== a ? a : new cb, void 0 !== b ? b : new cb, void 0 !== c ? c : new cb, void 0 !== d ? d : new cb, void 0 !== e ? e : new cb, void 0 !== f ? f : new cb]; }
    function Xf() {
        function a(e, f) { !1 !== c && (d(e, f), b.requestAnimationFrame(a)); }
        var b = null, c = !1, d = null;
        return { start: function () { !0 !== c && null !== d && (b.requestAnimationFrame(a), c = !0); }, stop: function () { c = !1; }, setAnimationLoop: function (a) { d = a; }, setContext: function (a) { b = a; } };
    }
    function Wi(a) {
        function b(b, c) {
            var d = b.array, e = b.dynamic ? 35048 : 35044, h = a.createBuffer();
            a.bindBuffer(c, h);
            a.bufferData(c, d, e);
            b.onUploadCallback();
            c = 5126;
            d instanceof Float32Array ? c = 5126 : d instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : d instanceof Uint16Array ? c = 5123 : d instanceof
                Int16Array ? c = 5122 : d instanceof Uint32Array ? c = 5125 : d instanceof Int32Array ? c = 5124 : d instanceof Int8Array ? c = 5120 : d instanceof Uint8Array && (c = 5121);
            return { buffer: h, type: c, bytesPerElement: d.BYTES_PER_ELEMENT, version: b.version };
        }
        var c = new WeakMap;
        return { get: function (a) { a.isInterleavedBufferAttribute && (a = a.data); return c.get(a); }, remove: function (b) { b.isInterleavedBufferAttribute && (b = b.data); var d = c.get(b); d && (a.deleteBuffer(d.buffer), c.delete(b)); }, update: function (d, e) {
                d.isInterleavedBufferAttribute && (d = d.data);
                var f = c.get(d);
                if (void 0 === f)
                    c.set(d, b(d, e));
                else if (f.version < d.version) {
                    var g = d, h = g.array, l = g.updateRange;
                    a.bindBuffer(e, f.buffer);
                    !1 === g.dynamic ? a.bufferData(e, h, 35044) : -1 === l.count ? a.bufferSubData(e, 0, h) : 0 === l.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (a.bufferSubData(e, l.offset * h.BYTES_PER_ELEMENT, h.subarray(l.offset, l.offset + l.count)), l.count = -1);
                    f.version = d.version;
                }
            } };
    }
    function Fd(a, b, c, d) { F.call(this); this.type = "PlaneGeometry"; this.parameters = { width: a, height: b, widthSegments: c, heightSegments: d }; this.fromBufferGeometry(new $b(a, b, c, d)); this.mergeVertices(); }
    function $b(a, b, c, d) {
        E.call(this);
        this.type = "PlaneBufferGeometry";
        this.parameters = { width: a, height: b, widthSegments: c, heightSegments: d };
        a = a || 1;
        b = b || 1;
        var e = a / 2, f = b / 2;
        c = Math.floor(c) || 1;
        d = Math.floor(d) || 1;
        var g = c + 1, h = d + 1, l = a / c, m = b / d, q = [], u = [], t = [], k = [];
        for (a = 0; a < h; a++) {
            var p = a * m - f;
            for (b = 0; b <
                g; b++)
                u.push(b * l - e, -p, 0), t.push(0, 0, 1), k.push(b / c), k.push(1 - a / d);
        }
        for (a = 0; a < d; a++)
            for (b = 0; b < c; b++)
                e = b + g * (a + 1), f = b + 1 + g * (a + 1), h = b + 1 + g * a, q.push(b + g * a, e, h), q.push(e, f, h);
        this.setIndex(q);
        this.addAttribute("position", new A(u, 3));
        this.addAttribute("normal", new A(t, 3));
        this.addAttribute("uv", new A(k, 2));
    }
    function Xi(a, b, c, d) {
        function e(a, c) { b.buffers.color.setClear(a.r, a.g, a.b, c, d); }
        var f = new H(0), g = 0, h, l, m = null, q = 0;
        return { getClearColor: function () { return f; }, setClearColor: function (a, b) {
                f.set(a);
                g = void 0 !== b ?
                    b : 1;
                e(f, g);
            }, getClearAlpha: function () { return g; }, setClearAlpha: function (a) { g = a; e(f, g); }, render: function (b, d, k, p) {
                d = d.background;
                k = a.vr;
                (k = k.getSession && k.getSession()) && "additive" === k.environmentBlendMode && (d = null);
                null === d ? (e(f, g), m = null, q = 0) : d && d.isColor && (e(d, 1), p = !0, m = null, q = 0);
                (a.autoClear || p) && a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil);
                if (d && (d.isCubeTexture || d.isWebGLRenderTargetCube)) {
                    void 0 === l && (l = new ja(new Gd(1, 1, 1), new ma({ type: "BackgroundCubeMaterial", uniforms: Yb(db.cube.uniforms),
                        vertexShader: db.cube.vertexShader, fragmentShader: db.cube.fragmentShader, side: 1, depthTest: !1, depthWrite: !1, fog: !1 })), l.geometry.removeAttribute("normal"), l.geometry.removeAttribute("uv"), l.onBeforeRender = function (a, b, c) { this.matrixWorld.copyPosition(c.matrixWorld); }, Object.defineProperty(l.material, "map", { get: function () { return this.uniforms.tCube.value; } }), c.update(l));
                    p = d.isWebGLRenderTargetCube ? d.texture : d;
                    l.material.uniforms.tCube.value = p;
                    l.material.uniforms.tFlip.value = d.isWebGLRenderTargetCube ?
                        1 : -1;
                    if (m !== d || q !== p.version)
                        l.material.needsUpdate = !0, m = d, q = p.version;
                    b.unshift(l, l.geometry, l.material, 0, 0, null);
                }
                else if (d && d.isTexture) {
                    void 0 === h && (h = new ja(new $b(2, 2), new ma({ type: "BackgroundMaterial", uniforms: Yb(db.background.uniforms), vertexShader: db.background.vertexShader, fragmentShader: db.background.fragmentShader, side: 0, depthTest: !1, depthWrite: !1, fog: !1 })), h.geometry.removeAttribute("normal"), Object.defineProperty(h.material, "map", { get: function () { return this.uniforms.t2D.value; } }), c.update(h));
                    h.material.uniforms.t2D.value = d;
                    !0 === d.matrixAutoUpdate && d.updateMatrix();
                    h.material.uniforms.uvTransform.value.copy(d.matrix);
                    if (m !== d || q !== d.version)
                        h.material.needsUpdate = !0, m = d, q = d.version;
                    b.unshift(h, h.geometry, h.material, 0, 0, null);
                }
            } };
    }
    function Yi(a, b, c, d) {
        var e;
        this.setMode = function (a) { e = a; };
        this.render = function (b, d) { a.drawArrays(e, b, d); c.update(d, e); };
        this.renderInstances = function (f, g, h, l) {
            if (0 !== l) {
                if (d.isWebGL2) {
                    f = a;
                    var m = "drawArraysInstanced";
                }
                else if (f = b.get("ANGLE_instanced_arrays"), m = "drawArraysInstancedANGLE",
                    null === f) {
                    console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    return;
                }
                f[m](e, g, h, l);
                c.update(h, e, l);
            }
        };
    }
    function Zi(a, b, c) {
        function d(b) {
            if ("highp" === b) {
                if (0 < a.getShaderPrecisionFormat(35633, 36338).precision && 0 < a.getShaderPrecisionFormat(35632, 36338).precision)
                    return "highp";
                b = "mediump";
            }
            return "mediump" === b && 0 < a.getShaderPrecisionFormat(35633, 36337).precision && 0 < a.getShaderPrecisionFormat(35632, 36337).precision ?
                "mediump" : "lowp";
        }
        var e, f = "undefined" !== typeof WebGL2RenderingContext && a instanceof WebGL2RenderingContext, g = void 0 !== c.precision ? c.precision : "highp", h = d(g);
        h !== g && (console.warn("THREE.WebGLRenderer:", g, "not supported, using", h, "instead."), g = h);
        c = !0 === c.logarithmicDepthBuffer;
        h = a.getParameter(34930);
        var l = a.getParameter(35660), m = a.getParameter(3379), q = a.getParameter(34076), u = a.getParameter(34921), t = a.getParameter(36347), k = a.getParameter(36348), p = a.getParameter(36349), v = 0 < l, x = f || !!b.get("OES_texture_float"), n = v && x, y = f ? a.getParameter(36183) : 0;
        return { isWebGL2: f, getMaxAnisotropy: function () { if (void 0 !== e)
                return e; var c = b.get("EXT_texture_filter_anisotropic"); return e = null !== c ? a.getParameter(c.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0; }, getMaxPrecision: d, precision: g, logarithmicDepthBuffer: c, maxTextures: h, maxVertexTextures: l, maxTextureSize: m, maxCubemapSize: q, maxAttributes: u, maxVertexUniforms: t, maxVaryings: k, maxFragmentUniforms: p, vertexTextures: v, floatFragmentTextures: x, floatVertexTextures: n, maxSamples: y };
    }
    function $i() {
        function a() {
            m.value !==
                d && (m.value = d, m.needsUpdate = 0 < e);
            c.numPlanes = e;
            c.numIntersection = 0;
        }
        function b(a, b, d, e) { var f = null !== a ? a.length : 0, g = null; if (0 !== f) {
            g = m.value;
            if (!0 !== e || null === g) {
                e = d + 4 * f;
                b = b.matrixWorldInverse;
                l.getNormalMatrix(b);
                if (null === g || g.length < e)
                    g = new Float32Array(e);
                for (e = 0; e !== f; ++e, d += 4)
                    h.copy(a[e]).applyMatrix4(b, l), h.normal.toArray(g, d), g[d + 3] = h.constant;
            }
            m.value = g;
            m.needsUpdate = !0;
        } c.numPlanes = f; return g; }
        var c = this, d = null, e = 0, f = !1, g = !1, h = new cb, l = new Y, m = { value: null, needsUpdate: !1 };
        this.uniform = m;
        this.numIntersection =
            this.numPlanes = 0;
        this.init = function (a, c, g) { var h = 0 !== a.length || c || 0 !== e || f; f = c; d = b(a, g, 0); e = a.length; return h; };
        this.beginShadows = function () { g = !0; b(null); };
        this.endShadows = function () { g = !1; a(); };
        this.setState = function (c, h, l, k, p, v) { if (!f || null === c || 0 === c.length || g && !l)
            g ? b(null) : a();
        else {
            l = g ? 0 : e;
            var q = 4 * l, u = p.clippingState || null;
            m.value = u;
            u = b(c, k, q, v);
            for (c = 0; c !== q; ++c)
                u[c] = d[c];
            p.clippingState = u;
            this.numIntersection = h ? this.numPlanes : 0;
            this.numPlanes += l;
        } };
    }
    function aj(a) {
        var b = {};
        return { get: function (c) {
                if (void 0 !==
                    b[c])
                    return b[c];
                switch (c) {
                    case "WEBGL_depth_texture":
                        var d = a.getExtension("WEBGL_depth_texture") || a.getExtension("MOZ_WEBGL_depth_texture") || a.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        d = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        d = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                            a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        d = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default: d = a.getExtension(c);
                }
                null === d && console.warn("THREE.WebGLRenderer: " + c + " extension not supported.");
                return b[c] = d;
            } };
    }
    function bj(a, b, c) {
        function d(a) {
            var e = a.target;
            a = f.get(e);
            null !== a.index && b.remove(a.index);
            for (var h in a.attributes)
                b.remove(a.attributes[h]);
            e.removeEventListener("dispose", d);
            f.delete(e);
            if (h = g.get(a))
                b.remove(h), g.delete(a);
            c.memory.geometries--;
        }
        function e(a) { var c = [], d = a.index, e = a.attributes.position; if (null !== d) {
            var f = d.array;
            d = d.version;
            e = 0;
            for (var h = f.length; e < h; e += 3) {
                var k = f[e + 0], p = f[e + 1], v = f[e + 2];
                c.push(k, p, p, v, v, k);
            }
        }
        else
            for (f = e.array, d = e.version, e = 0, h = f.length / 3 - 1; e < h; e += 3)
                k = e + 0, p = e + 1, v = e + 2, c.push(k, p, p, v, v, k); c = new (65535 < kh(c) ? Ub : Tb)(c, 1); c.version = d; b.update(c, 34963); (f = g.get(a)) && b.remove(f); g.set(a, c); }
        var f = new WeakMap, g = new WeakMap;
        return { get: function (a, b) { var e = f.get(b); if (e)
                return e; b.addEventListener("dispose", d); b.isBufferGeometry ? e = b : b.isGeometry && (void 0 === b._bufferGeometry && (b._bufferGeometry = (new E).setFromObject(a)), e = b._bufferGeometry); f.set(b, e); c.memory.geometries++; return e; }, update: function (a) { var c = a.index, d = a.attributes; null !== c && b.update(c, 34963); for (var e in d)
                b.update(d[e], 34962); a = a.morphAttributes; for (e in a) {
                c = a[e];
                d = 0;
                for (var f = c.length; d < f; d++)
                    b.update(c[d], 34962);
            } }, getWireframeAttribute: function (a) {
                var b = g.get(a);
                if (b) {
                    var c = a.index;
                    null !== c && b.version < c.version && e(a);
                }
                else
                    e(a);
                return g.get(a);
            } };
    }
    function cj(a, b, c, d) {
        var e, f, g;
        this.setMode = function (a) { e = a; };
        this.setIndex = function (a) { f = a.type; g = a.bytesPerElement; };
        this.render = function (b, d) { a.drawElements(e, d, f, b * g); c.update(d, e); };
        this.renderInstances = function (h, l, m, q) {
            if (0 !== q) {
                if (d.isWebGL2) {
                    h = a;
                    var u = "drawElementsInstanced";
                }
                else if (h = b.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === h) {
                    console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    return;
                }
                h[u](e, m, f, l * g, q);
                c.update(m, e, q);
            }
        };
    }
    function dj(a) {
        var b = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        return { memory: { geometries: 0, textures: 0 }, render: b, programs: null, autoReset: !0, reset: function () { b.frame++; b.calls = 0; b.triangles = 0; b.points = 0; b.lines = 0; }, update: function (a, d, e) {
                e = e || 1;
                b.calls++;
                switch (d) {
                    case 4:
                        b.triangles += a / 3 * e;
                        break;
                    case 5:
                    case 6:
                        b.triangles += e * (a - 2);
                        break;
                    case 1:
                        b.lines += a / 2 * e;
                        break;
                    case 3:
                        b.lines += e * (a - 1);
                        break;
                    case 2:
                        b.lines += e * a;
                        break;
                    case 0:
                        b.points += e * a;
                        break;
                    default: console.error("THREE.WebGLInfo: Unknown draw mode:", d);
                }
            } };
    }
    function ej(a, b) { return Math.abs(b[1]) - Math.abs(a[1]); }
    function fj(a) {
        var b = {}, c = new Float32Array(8);
        return { update: function (d, e, f, g) {
                var h = d.morphTargetInfluences, l = h.length;
                d = b[e.id];
                if (void 0 === d) {
                    d = [];
                    for (var m = 0; m < l; m++)
                        d[m] = [m, 0];
                    b[e.id] = d;
                }
                var q = f.morphTargets && e.morphAttributes.position;
                f = f.morphNormals && e.morphAttributes.normal;
                for (m = 0; m < l; m++) {
                    var u = d[m];
                    0 !== u[1] && (q && e.removeAttribute("morphTarget" + m), f && e.removeAttribute("morphNormal" + m));
                }
                for (m = 0; m < l; m++)
                    u = d[m], u[0] = m, u[1] = h[m];
                d.sort(ej);
                for (m = 0; 8 > m; m++) {
                    if (u = d[m])
                        if (h = u[0], l = u[1]) {
                            q && e.addAttribute("morphTarget" + m, q[h]);
                            f && e.addAttribute("morphNormal" + m, f[h]);
                            c[m] = l;
                            continue;
                        }
                    c[m] = 0;
                }
                g.getUniforms().setValue(a, "morphTargetInfluences", c);
            } };
    }
    function gj(a, b, c, d) { var e = {}; return { update: function (a) { var f = d.render.frame, h = a.geometry, l = b.get(a, h); e[l.id] !== f && (h.isGeometry && l.updateFromObject(a), b.update(l), e[l.id] = f); a.isInstancedMesh && c.update(a.instanceMatrix, 34962); return l; }, dispose: function () { e = {}; } }; }
    function ob(a, b, c, d, e, f, g, h, l, m) {
        a =
            void 0 !== a ? a : [];
        W.call(this, a, void 0 !== b ? b : 301, c, d, e, f, void 0 !== g ? g : 1022, h, l, m);
        this.flipY = !1;
    }
    function Ec(a, b, c, d) { W.call(this, null); this.image = { data: a || null, width: b || 1, height: c || 1, depth: d || 1 }; this.minFilter = this.magFilter = 1003; this.wrapR = 1001; this.flipY = this.generateMipmaps = !1; this.needsUpdate = !0; }
    function Fc(a, b, c, d) {
        W.call(this, null);
        this.image = { data: a || null, width: b || 1, height: c || 1, depth: d || 1 };
        this.minFilter = this.magFilter = 1003;
        this.wrapR = 1001;
        this.flipY = this.generateMipmaps = !1;
        this.needsUpdate =
            !0;
    }
    function Gc(a, b, c) { var d = a[0]; if (0 >= d || 0 < d)
        return a; var e = b * c, f = ph[e]; void 0 === f && (f = new Float32Array(e), ph[e] = f); if (0 !== b)
        for (d.toArray(f, 0), d = 1, e = 0; d !== b; ++d)
            e += c, a[d].toArray(f, e); return f; }
    function La(a, b) { if (a.length !== b.length)
        return !1; for (var c = 0, d = a.length; c < d; c++)
        if (a[c] !== b[c])
            return !1; return !0; }
    function Ha(a, b) { for (var c = 0, d = b.length; c < d; c++)
        a[c] = b[c]; }
    function qh(a, b) { var c = rh[b]; void 0 === c && (c = new Int32Array(b), rh[b] = c); for (var d = 0; d !== b; ++d)
        c[d] = a.allocateTextureUnit(); return c; }
    function hj(a, b) { var c = this.cache; c[0] !== b && (a.uniform1f(this.addr, b), c[0] = b); }
    function ij(a, b) { var c = this.cache; if (void 0 !== b.x) {
        if (c[0] !== b.x || c[1] !== b.y)
            a.uniform2f(this.addr, b.x, b.y), c[0] = b.x, c[1] = b.y;
    }
    else
        La(c, b) || (a.uniform2fv(this.addr, b), Ha(c, b)); }
    function jj(a, b) {
        var c = this.cache;
        if (void 0 !== b.x) {
            if (c[0] !== b.x || c[1] !== b.y || c[2] !== b.z)
                a.uniform3f(this.addr, b.x, b.y, b.z), c[0] = b.x, c[1] = b.y, c[2] = b.z;
        }
        else if (void 0 !== b.r) {
            if (c[0] !== b.r || c[1] !== b.g || c[2] !== b.b)
                a.uniform3f(this.addr, b.r, b.g, b.b), c[0] = b.r, c[1] = b.g,
                    c[2] = b.b;
        }
        else
            La(c, b) || (a.uniform3fv(this.addr, b), Ha(c, b));
    }
    function kj(a, b) { var c = this.cache; if (void 0 !== b.x) {
        if (c[0] !== b.x || c[1] !== b.y || c[2] !== b.z || c[3] !== b.w)
            a.uniform4f(this.addr, b.x, b.y, b.z, b.w), c[0] = b.x, c[1] = b.y, c[2] = b.z, c[3] = b.w;
    }
    else
        La(c, b) || (a.uniform4fv(this.addr, b), Ha(c, b)); }
    function lj(a, b) { var c = this.cache, d = b.elements; void 0 === d ? La(c, b) || (a.uniformMatrix2fv(this.addr, !1, b), Ha(c, b)) : La(c, d) || (sh.set(d), a.uniformMatrix2fv(this.addr, !1, sh), Ha(c, d)); }
    function mj(a, b) {
        var c = this.cache, d = b.elements;
        void 0 === d ? La(c, b) || (a.uniformMatrix3fv(this.addr, !1, b), Ha(c, b)) : La(c, d) || (th.set(d), a.uniformMatrix3fv(this.addr, !1, th), Ha(c, d));
    }
    function nj(a, b) { var c = this.cache, d = b.elements; void 0 === d ? La(c, b) || (a.uniformMatrix4fv(this.addr, !1, b), Ha(c, b)) : La(c, d) || (uh.set(d), a.uniformMatrix4fv(this.addr, !1, uh), Ha(c, d)); }
    function oj(a, b, c) { var d = this.cache, e = c.allocateTextureUnit(); d[0] !== e && (a.uniform1i(this.addr, e), d[0] = e); c.safeSetTexture2D(b || vh, e); }
    function pj(a, b, c) {
        var d = this.cache, e = c.allocateTextureUnit();
        d[0] !== e && (a.uniform1i(this.addr, e), d[0] = e);
        c.setTexture2DArray(b || qj, e);
    }
    function rj(a, b, c) { var d = this.cache, e = c.allocateTextureUnit(); d[0] !== e && (a.uniform1i(this.addr, e), d[0] = e); c.setTexture3D(b || sj, e); }
    function tj(a, b, c) { var d = this.cache, e = c.allocateTextureUnit(); d[0] !== e && (a.uniform1i(this.addr, e), d[0] = e); c.safeSetTextureCube(b || wh, e); }
    function uj(a, b) { var c = this.cache; c[0] !== b && (a.uniform1i(this.addr, b), c[0] = b); }
    function vj(a, b) { var c = this.cache; La(c, b) || (a.uniform2iv(this.addr, b), Ha(c, b)); }
    function wj(a, b) { var c = this.cache; La(c, b) || (a.uniform3iv(this.addr, b), Ha(c, b)); }
    function xj(a, b) { var c = this.cache; La(c, b) || (a.uniform4iv(this.addr, b), Ha(c, b)); }
    function yj(a) {
        switch (a) {
            case 5126: return hj;
            case 35664: return ij;
            case 35665: return jj;
            case 35666: return kj;
            case 35674: return lj;
            case 35675: return mj;
            case 35676: return nj;
            case 35678:
            case 36198: return oj;
            case 35679: return rj;
            case 35680: return tj;
            case 36289: return pj;
            case 5124:
            case 35670: return uj;
            case 35667:
            case 35671: return vj;
            case 35668:
            case 35672: return wj;
            case 35669:
            case 35673: return xj;
        }
    }
    function zj(a, b) { a.uniform1fv(this.addr, b); }
    function Aj(a, b) { a.uniform1iv(this.addr, b); }
    function Bj(a, b) { a.uniform2iv(this.addr, b); }
    function Cj(a, b) { a.uniform3iv(this.addr, b); }
    function Dj(a, b) { a.uniform4iv(this.addr, b); }
    function Ej(a, b) { b = Gc(b, this.size, 2); a.uniform2fv(this.addr, b); }
    function Fj(a, b) { b = Gc(b, this.size, 3); a.uniform3fv(this.addr, b); }
    function Gj(a, b) { b = Gc(b, this.size, 4); a.uniform4fv(this.addr, b); }
    function Hj(a, b) {
        b = Gc(b, this.size, 4);
        a.uniformMatrix2fv(this.addr, !1, b);
    }
    function Ij(a, b) { b = Gc(b, this.size, 9); a.uniformMatrix3fv(this.addr, !1, b); }
    function Jj(a, b) { b = Gc(b, this.size, 16); a.uniformMatrix4fv(this.addr, !1, b); }
    function Kj(a, b, c) { var d = b.length, e = qh(c, d); a.uniform1iv(this.addr, e); for (a = 0; a !== d; ++a)
        c.safeSetTexture2D(b[a] || vh, e[a]); }
    function Lj(a, b, c) { var d = b.length, e = qh(c, d); a.uniform1iv(this.addr, e); for (a = 0; a !== d; ++a)
        c.safeSetTextureCube(b[a] || wh, e[a]); }
    function Mj(a) {
        switch (a) {
            case 5126: return zj;
            case 35664: return Ej;
            case 35665: return Fj;
            case 35666: return Gj;
            case 35674: return Hj;
            case 35675: return Ij;
            case 35676: return Jj;
            case 35678: return Kj;
            case 35680: return Lj;
            case 5124:
            case 35670: return Aj;
            case 35667:
            case 35671: return Bj;
            case 35668:
            case 35672: return Cj;
            case 35669:
            case 35673: return Dj;
        }
    }
    function Nj(a, b, c) { this.id = a; this.addr = c; this.cache = []; this.setValue = yj(b.type); }
    function xh(a, b, c) { this.id = a; this.addr = c; this.cache = []; this.size = b.size; this.setValue = Mj(b.type); }
    function yh(a) { this.id = a; this.seq = []; this.map = {}; }
    function Bb(a, b) {
        this.seq = [];
        this.map = {};
        for (var c = a.getProgramParameter(b, 35718), d = 0; d < c; ++d) {
            var e = a.getActiveUniform(b, d), f = a.getUniformLocation(b, e.name), g = this, h = e.name, l = h.length;
            for (Yf.lastIndex = 0;;) {
                var m = Yf.exec(h), q = Yf.lastIndex, u = m[1], k = m[3];
                "]" === m[2] && (u |= 0);
                if (void 0 === k || "[" === k && q + 2 === l) {
                    h = g;
                    e = void 0 === k ? new Nj(u, e, f) : new xh(u, e, f);
                    h.seq.push(e);
                    h.map[e.id] = e;
                    break;
                }
                else
                    k = g.map[u], void 0 === k && (k = new yh(u), u = g, g = k, u.seq.push(g), u.map[g.id] = g), g = k;
            }
        }
    }
    function zh(a, b, c) { b = a.createShader(b); a.shaderSource(b, c); a.compileShader(b); return b; }
    function Ah(a) { switch (a) {
        case 3E3: return ["Linear", "( value )"];
        case 3001: return ["sRGB", "( value )"];
        case 3002: return ["RGBE", "( value )"];
        case 3004: return ["RGBM", "( value, 7.0 )"];
        case 3005: return ["RGBM", "( value, 16.0 )"];
        case 3006: return ["RGBD", "( value, 256.0 )"];
        case 3007: return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        case 3003: return ["LogLuv", "( value )"];
        default: throw Error("unsupported encoding: " + a);
    } }
    function Bh(a, b, c) {
        var d = a.getShaderParameter(b, 35713), e = a.getShaderInfoLog(b).trim();
        if (d && "" === e)
            return "";
        a = a.getShaderSource(b).split("\n");
        for (b = 0; b < a.length; b++)
            a[b] = b + 1 + ": " + a[b];
        a = a.join("\n");
        return "THREE.WebGLShader: gl.getShaderInfoLog() " + c + "\n" + e + a;
    }
    function Ge(a, b) { b = Ah(b); return "vec4 " + a + "( vec4 value ) { return " + b[0] + "ToLinear" + b[1] + "; }"; }
    function Oj(a, b) { b = Ah(b); return "vec4 " + a + "( vec4 value ) { return LinearTo" + b[0] + b[1] + "; }"; }
    function Pj(a, b) {
        switch (b) {
            case 1:
                b = "Linear";
                break;
            case 2:
                b = "Reinhard";
                break;
            case 3:
                b = "Uncharted2";
                break;
            case 4:
                b = "OptimizedCineon";
                break;
            case 5:
                b =
                    "ACESFilmic";
                break;
            default: throw Error("unsupported toneMapping: " + b);
        }
        return "vec3 " + a + "( vec3 color ) { return " + b + "ToneMapping( color ); }";
    }
    function Qj(a, b, c) {
        a = a || {};
        return [a.derivatives || b.envMapCubeUV || b.bumpMap || b.tangentSpaceNormalMap || b.clearcoatNormalMap || b.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (a.fragDepth || b.logarithmicDepthBuffer) && c.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", a.drawBuffers && c.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" :
                "", (a.shaderTextureLOD || b.envMap) && c.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Hd).join("\n");
    }
    function Rj(a) { var b = [], c; for (c in a) {
        var d = a[c];
        !1 !== d && b.push("#define " + c + " " + d);
    } return b.join("\n"); }
    function Hd(a) { return "" !== a; }
    function Ch(a, b) {
        return a.replace(/NUM_DIR_LIGHTS/g, b.numDirLights).replace(/NUM_SPOT_LIGHTS/g, b.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, b.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, b.numPointLights).replace(/NUM_HEMI_LIGHTS/g, b.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, b.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, b.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, b.numPointLightShadows);
    }
    function Dh(a, b) { return a.replace(/NUM_CLIPPING_PLANES/g, b.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, b.numClippingPlanes - b.numClipIntersection); }
    function Zf(a, b) { a = N[b]; if (void 0 === a)
        throw Error("Can not resolve #include <" + b + ">"); return a.replace($f, Zf); }
    function Eh(a, b, c, d) {
        a = "";
        for (b = parseInt(b); b < parseInt(c); b++)
            a +=
                d.replace(/\[ i \]/g, "[ " + b + " ]").replace(/UNROLLED_LOOP_INDEX/g, b);
        return a;
    }
    function Fh(a) { var b = "precision " + a.precision + " float;\nprecision " + a.precision + " int;"; "highp" === a.precision ? b += "\n#define HIGH_PRECISION" : "mediump" === a.precision ? b += "\n#define MEDIUM_PRECISION" : "lowp" === a.precision && (b += "\n#define LOW_PRECISION"); return b; }
    function Sj(a) {
        var b = "SHADOWMAP_TYPE_BASIC";
        1 === a.shadowMapType ? b = "SHADOWMAP_TYPE_PCF" : 2 === a.shadowMapType ? b = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === a.shadowMapType && (b = "SHADOWMAP_TYPE_VSM");
        return b;
    }
    function Tj(a, b) { var c = "ENVMAP_TYPE_CUBE"; if (a.envMap)
        switch (b.envMap.mapping) {
            case 301:
            case 302:
                c = "ENVMAP_TYPE_CUBE";
                break;
            case 306:
            case 307:
                c = "ENVMAP_TYPE_CUBE_UV";
                break;
            case 303:
            case 304:
                c = "ENVMAP_TYPE_EQUIREC";
                break;
            case 305: c = "ENVMAP_TYPE_SPHERE";
        } return c; }
    function Uj(a, b) { var c = "ENVMAP_MODE_REFLECTION"; if (a.envMap)
        switch (b.envMap.mapping) {
            case 302:
            case 304: c = "ENVMAP_MODE_REFRACTION";
        } return c; }
    function Vj(a, b) {
        var c = "ENVMAP_BLENDING_MULTIPLY";
        if (a.envMap)
            switch (b.combine) {
                case 0:
                    c = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                case 1:
                    c = "ENVMAP_BLENDING_MIX";
                    break;
                case 2: c = "ENVMAP_BLENDING_ADD";
            }
        return c;
    }
    function Wj(a, b, c, d, e, f) {
        var g = a.getContext(), h = d.defines, l = e.vertexShader, m = e.fragmentShader, q = Sj(f), u = Tj(f, d), k = Uj(f, d), r = Vj(f, d), p = 0 < a.gammaFactor ? a.gammaFactor : 1, v = f.isWebGL2 ? "" : Qj(d.extensions, f, b), x = Rj(h), n = g.createProgram(), y = (h = a.getRenderTarget()) && h.isWebGLMultiviewRenderTarget ? h.numViews : 0;
        d.isRawShaderMaterial ? (h = [x].filter(Hd).join("\n"), 0 < h.length && (h += "\n"), b = [v, x].filter(Hd).join("\n"), 0 < b.length && (b +=
            "\n")) : (h = [Fh(f), "#define SHADER_NAME " + e.name, x, f.instancing ? "#define USE_INSTANCING" : "", f.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + p, "#define MAX_BONES " + f.maxBones, f.useFog && f.fog ? "#define USE_FOG" : "", f.useFog && f.fogExp2 ? "#define FOG_EXP2" : "", f.map ? "#define USE_MAP" : "", f.envMap ? "#define USE_ENVMAP" : "", f.envMap ? "#define " + k : "", f.lightMap ? "#define USE_LIGHTMAP" : "", f.aoMap ? "#define USE_AOMAP" : "", f.emissiveMap ? "#define USE_EMISSIVEMAP" : "", f.bumpMap ? "#define USE_BUMPMAP" :
                "", f.normalMap ? "#define USE_NORMALMAP" : "", f.normalMap && f.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", f.normalMap && f.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", f.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", f.displacementMap && f.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", f.specularMap ? "#define USE_SPECULARMAP" : "", f.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", f.metalnessMap ? "#define USE_METALNESSMAP" : "", f.alphaMap ? "#define USE_ALPHAMAP" : "", f.vertexTangents ?
                "#define USE_TANGENT" : "", f.vertexColors ? "#define USE_COLOR" : "", f.vertexUvs ? "#define USE_UV" : "", f.flatShading ? "#define FLAT_SHADED" : "", f.skinning ? "#define USE_SKINNING" : "", f.useVertexTexture ? "#define BONE_TEXTURE" : "", f.morphTargets ? "#define USE_MORPHTARGETS" : "", f.morphNormals && !1 === f.flatShading ? "#define USE_MORPHNORMALS" : "", f.doubleSided ? "#define DOUBLE_SIDED" : "", f.flipSided ? "#define FLIP_SIDED" : "", f.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", f.shadowMapEnabled ? "#define " + q : "", f.sizeAttenuation ?
                "#define USE_SIZEATTENUATION" : "", f.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", f.logarithmicDepthBuffer && (f.isWebGL2 || b.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;",
            "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;",
            "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Hd).join("\n"), b = [v, Fh(f), "#define SHADER_NAME " + e.name, x, f.alphaTest ? "#define ALPHATEST " + f.alphaTest + (f.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + p, f.useFog && f.fog ? "#define USE_FOG" : "", f.useFog && f.fogExp2 ? "#define FOG_EXP2" : "", f.map ? "#define USE_MAP" : "", f.matcap ? "#define USE_MATCAP" : "", f.envMap ? "#define USE_ENVMAP" :
                "", f.envMap ? "#define " + u : "", f.envMap ? "#define " + k : "", f.envMap ? "#define " + r : "", f.lightMap ? "#define USE_LIGHTMAP" : "", f.aoMap ? "#define USE_AOMAP" : "", f.emissiveMap ? "#define USE_EMISSIVEMAP" : "", f.bumpMap ? "#define USE_BUMPMAP" : "", f.normalMap ? "#define USE_NORMALMAP" : "", f.normalMap && f.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", f.normalMap && f.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", f.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", f.specularMap ? "#define USE_SPECULARMAP" :
                "", f.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", f.metalnessMap ? "#define USE_METALNESSMAP" : "", f.alphaMap ? "#define USE_ALPHAMAP" : "", f.sheen ? "#define USE_SHEEN" : "", f.vertexTangents ? "#define USE_TANGENT" : "", f.vertexColors ? "#define USE_COLOR" : "", f.vertexUvs ? "#define USE_UV" : "", f.gradientMap ? "#define USE_GRADIENTMAP" : "", f.flatShading ? "#define FLAT_SHADED" : "", f.doubleSided ? "#define DOUBLE_SIDED" : "", f.flipSided ? "#define FLIP_SIDED" : "", f.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", f.shadowMapEnabled ? "#define " +
                q : "", f.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", f.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", f.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", f.logarithmicDepthBuffer && (f.isWebGL2 || b.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", (d.extensions && d.extensions.shaderTextureLOD || f.envMap) && (f.isWebGL2 || b.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== f.toneMapping ? "#define TONE_MAPPING" :
                "", 0 !== f.toneMapping ? N.tonemapping_pars_fragment : "", 0 !== f.toneMapping ? Pj("toneMapping", f.toneMapping) : "", f.dithering ? "#define DITHERING" : "", f.outputEncoding || f.mapEncoding || f.matcapEncoding || f.envMapEncoding || f.emissiveMapEncoding ? N.encodings_pars_fragment : "", f.mapEncoding ? Ge("mapTexelToLinear", f.mapEncoding) : "", f.matcapEncoding ? Ge("matcapTexelToLinear", f.matcapEncoding) : "", f.envMapEncoding ? Ge("envMapTexelToLinear", f.envMapEncoding) : "", f.emissiveMapEncoding ? Ge("emissiveMapTexelToLinear", f.emissiveMapEncoding) :
                "", f.outputEncoding ? Oj("linearToOutputTexel", f.outputEncoding) : "", f.depthPacking ? "#define DEPTH_PACKING " + d.depthPacking : "", "\n"].filter(Hd).join("\n"));
        l = l.replace($f, Zf);
        l = Ch(l, f);
        l = Dh(l, f);
        m = m.replace($f, Zf);
        m = Ch(m, f);
        m = Dh(m, f);
        l = l.replace(Gh, Eh);
        m = m.replace(Gh, Eh);
        f.isWebGL2 && !d.isRawShaderMaterial && (q = !1, u = /^\s*#version\s+300\s+es\s*\n/, d.isShaderMaterial && null !== l.match(u) && null !== m.match(u) && (q = !0, l = l.replace(u, ""), m = m.replace(u, "")), h = "#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" +
            h, b = ["#version 300 es\n\n#define varying in", q ? "" : "out highp vec4 pc_fragColor;", q ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"].join("\n") +
            "\n" + b, 0 < y && (h = h.replace("#version 300 es\n", ["#version 300 es\n\n#extension GL_OVR_multiview2 : require", "layout(num_views = " + y + ") in;", "#define VIEW_ID gl_ViewID_OVR"].join("\n")), h = h.replace("uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;", ["uniform mat4 modelViewMatrices[" + y + "];", "uniform mat4 projectionMatrices[" + y + "];", "uniform mat4 viewMatrices[" + y + "];", "uniform mat3 normalMatrices[" + y + "];", "#define modelViewMatrix modelViewMatrices[VIEW_ID]\n#define projectionMatrix projectionMatrices[VIEW_ID]\n#define viewMatrix viewMatrices[VIEW_ID]\n#define normalMatrix normalMatrices[VIEW_ID]"].join("\n")),
            b = b.replace("#version 300 es\n", "#version 300 es\n\n#extension GL_OVR_multiview2 : require\n#define VIEW_ID gl_ViewID_OVR"), b = b.replace("uniform mat4 viewMatrix;", ["uniform mat4 viewMatrices[" + y + "];", "#define viewMatrix viewMatrices[VIEW_ID]"].join("\n"))));
        m = b + m;
        l = zh(g, 35633, h + l);
        m = zh(g, 35632, m);
        g.attachShader(n, l);
        g.attachShader(n, m);
        void 0 !== d.index0AttributeName ? g.bindAttribLocation(n, 0, d.index0AttributeName) : !0 === f.morphTargets && g.bindAttribLocation(n, 0, "position");
        g.linkProgram(n);
        if (a.debug.checkShaderErrors) {
            a =
                g.getProgramInfoLog(n).trim();
            f = g.getShaderInfoLog(l).trim();
            q = g.getShaderInfoLog(m).trim();
            k = u = !0;
            if (!1 === g.getProgramParameter(n, 35714))
                u = !1, r = Bh(g, l, "vertex"), p = Bh(g, m, "fragment"), console.error("THREE.WebGLProgram: shader error: ", g.getError(), "35715", g.getProgramParameter(n, 35715), "gl.getProgramInfoLog", a, r, p);
            else if ("" !== a)
                console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", a);
            else if ("" === f || "" === q)
                k = !1;
            k && (this.diagnostics = { runnable: u, material: d, programLog: a, vertexShader: { log: f, prefix: h },
                fragmentShader: { log: q, prefix: b } });
        }
        g.deleteShader(l);
        g.deleteShader(m);
        var V;
        this.getUniforms = function () { void 0 === V && (V = new Bb(g, n)); return V; };
        var P;
        this.getAttributes = function () { if (void 0 === P) {
            for (var a = {}, b = g.getProgramParameter(n, 35721), c = 0; c < b; c++) {
                var d = g.getActiveAttrib(n, c).name;
                a[d] = g.getAttribLocation(n, d);
            }
            P = a;
        } return P; };
        this.destroy = function () { g.deleteProgram(n); this.program = void 0; };
        this.name = e.name;
        this.id = Xj++;
        this.code = c;
        this.usedTimes = 1;
        this.program = n;
        this.vertexShader = l;
        this.fragmentShader =
            m;
        this.numMultiviewViews = y;
        return this;
    }
    function Yj(a, b, c) {
        function d(a, b) { if (a)
            a.isTexture ? c = a.encoding : a.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), c = a.texture.encoding);
        else
            var c = 3E3; 3E3 === c && b && (c = 3007); return c; }
        var e = [], f = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong",
            MeshToonMaterial: "phong", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, g = "precision supportsVertexTextures instancing map mapEncoding matcap matcapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap tangentSpaceNormalMap clearcoatNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors vertexTangents fog useFog fogExp2 flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering sheen".split(" ");
        this.getParameters = function (b, e, g, q, u, k, r) {
            var h = f[b.type];
            if (r.isSkinnedMesh) {
                var l = r.skeleton.bones;
                if (c.floatVertexTextures)
                    l = 1024;
                else {
                    var m = Math.min(Math.floor((c.maxVertexUniforms - 20) / 4), l.length);
                    m < l.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + l.length + " bones. This GPU supports " + m + "."), l = 0) : l = m;
                }
            }
            else
                l = 0;
            m = c.precision;
            null !== b.precision && (m = c.getMaxPrecision(b.precision), m !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", m, "instead."));
            var t = a.getRenderTarget();
            return { isWebGL2: c.isWebGL2, shaderID: h, precision: m, instancing: !0 === r.isInstancedMesh, supportsVertexTextures: c.vertexTextures, outputEncoding: d(t ? t.texture : null, a.gammaOutput), map: !!b.map, mapEncoding: d(b.map, a.gammaInput), matcap: !!b.matcap, matcapEncoding: d(b.matcap, a.gammaInput), envMap: !!b.envMap, envMapMode: b.envMap && b.envMap.mapping, envMapEncoding: d(b.envMap, a.gammaInput), envMapCubeUV: !!b.envMap && (306 === b.envMap.mapping || 307 === b.envMap.mapping), lightMap: !!b.lightMap, aoMap: !!b.aoMap,
                emissiveMap: !!b.emissiveMap, emissiveMapEncoding: d(b.emissiveMap, a.gammaInput), bumpMap: !!b.bumpMap, normalMap: !!b.normalMap, objectSpaceNormalMap: 1 === b.normalMapType, tangentSpaceNormalMap: 0 === b.normalMapType, clearcoatNormalMap: !!b.clearcoatNormalMap, displacementMap: !!b.displacementMap, roughnessMap: !!b.roughnessMap, metalnessMap: !!b.metalnessMap, specularMap: !!b.specularMap, alphaMap: !!b.alphaMap, gradientMap: !!b.gradientMap, sheen: !!b.sheen, combine: b.combine, vertexTangents: b.normalMap && b.vertexTangents, vertexColors: b.vertexColors,
                vertexUvs: !!b.map || !!b.bumpMap || !!b.normalMap || !!b.specularMap || !!b.alphaMap || !!b.emissiveMap || !!b.roughnessMap || !!b.metalnessMap || !!b.clearcoatNormalMap, fog: !!q, useFog: b.fog, fogExp2: q && q.isFogExp2, flatShading: b.flatShading, sizeAttenuation: b.sizeAttenuation, logarithmicDepthBuffer: c.logarithmicDepthBuffer, skinning: b.skinning && 0 < l, maxBones: l, useVertexTexture: c.floatVertexTextures, morphTargets: b.morphTargets, morphNormals: b.morphNormals, maxMorphTargets: a.maxMorphTargets, maxMorphNormals: a.maxMorphNormals,
                numDirLights: e.directional.length, numPointLights: e.point.length, numSpotLights: e.spot.length, numRectAreaLights: e.rectArea.length, numHemiLights: e.hemi.length, numDirLightShadows: e.directionalShadowMap.length, numPointLightShadows: e.pointShadowMap.length, numSpotLightShadows: e.spotShadowMap.length, numClippingPlanes: u, numClipIntersection: k, dithering: b.dithering, shadowMapEnabled: a.shadowMap.enabled && 0 < g.length, shadowMapType: a.shadowMap.type, toneMapping: b.toneMapped ? a.toneMapping : 0, physicallyCorrectLights: a.physicallyCorrectLights,
                premultipliedAlpha: b.premultipliedAlpha, alphaTest: b.alphaTest, doubleSided: 2 === b.side, flipSided: 1 === b.side, depthPacking: void 0 !== b.depthPacking ? b.depthPacking : !1 };
        };
        this.getProgramCode = function (b, c) { var d = []; c.shaderID ? d.push(c.shaderID) : (d.push(b.fragmentShader), d.push(b.vertexShader)); if (void 0 !== b.defines)
            for (var e in b.defines)
                d.push(e), d.push(b.defines[e]); for (e = 0; e < g.length; e++)
            d.push(c[g[e]]); d.push(b.onBeforeCompile.toString()); d.push(a.gammaOutput); d.push(a.gammaFactor); return d.join(); };
        this.acquireProgram =
            function (c, d, f, g) { for (var h, l = 0, m = e.length; l < m; l++) {
                var q = e[l];
                if (q.code === g) {
                    h = q;
                    ++h.usedTimes;
                    break;
                }
            } void 0 === h && (h = new Wj(a, b, g, c, d, f), e.push(h)); return h; };
        this.releaseProgram = function (a) { if (0 === --a.usedTimes) {
            var b = e.indexOf(a);
            e[b] = e[e.length - 1];
            e.pop();
            a.destroy();
        } };
        this.programs = e;
    }
    function Zj() { var a = new WeakMap; return { get: function (b) { var c = a.get(b); void 0 === c && (c = {}, a.set(b, c)); return c; }, remove: function (b) { a.delete(b); }, update: function (b, c, d) { a.get(b)[c] = d; }, dispose: function () { a = new WeakMap; } }; }
    function ak(a, b) { return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.program !== b.program ? a.program.id - b.program.id : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id; }
    function bk(a, b) { return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id; }
    function Hh() {
        function a(a, d, e, m, q, u) {
            var g = b[c];
            void 0 === g ? (g = { id: a.id,
                object: a, geometry: d, material: e, program: e.program || f, groupOrder: m, renderOrder: a.renderOrder, z: q, group: u }, b[c] = g) : (g.id = a.id, g.object = a, g.geometry = d, g.material = e, g.program = e.program || f, g.groupOrder = m, g.renderOrder = a.renderOrder, g.z = q, g.group = u);
            c++;
            return g;
        }
        var b = [], c = 0, d = [], e = [], f = { id: -1 };
        return { opaque: d, transparent: e, init: function () { c = 0; d.length = 0; e.length = 0; }, push: function (b, c, f, m, q, u) { b = a(b, c, f, m, q, u); (!0 === f.transparent ? e : d).push(b); }, unshift: function (b, c, f, m, q, u) {
                b = a(b, c, f, m, q, u);
                (!0 === f.transparent ?
                    e : d).unshift(b);
            }, sort: function () { 1 < d.length && d.sort(ak); 1 < e.length && e.sort(bk); } };
    }
    function ck() { function a(c) { c = c.target; c.removeEventListener("dispose", a); b.delete(c); } var b = new WeakMap; return { get: function (c, d) { var e = b.get(c); if (void 0 === e) {
            var f = new Hh;
            b.set(c, new WeakMap);
            b.get(c).set(d, f);
            c.addEventListener("dispose", a);
        }
        else
            f = e.get(d), void 0 === f && (f = new Hh, e.set(d, f)); return f; }, dispose: function () { b = new WeakMap; } }; }
    function dk() {
        var a = {};
        return { get: function (b) {
                if (void 0 !== a[b.id])
                    return a[b.id];
                switch (b.type) {
                    case "DirectionalLight":
                        var c = { direction: new n, color: new H, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new w };
                        break;
                    case "SpotLight":
                        c = { position: new n, direction: new n, color: new H, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new w };
                        break;
                    case "PointLight":
                        c = { position: new n, color: new H, distance: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new w, shadowCameraNear: 1, shadowCameraFar: 1E3 };
                        break;
                    case "HemisphereLight":
                        c = { direction: new n, skyColor: new H, groundColor: new H };
                        break;
                    case "RectAreaLight": c = { color: new H, position: new n, halfWidth: new n, halfHeight: new n };
                }
                return a[b.id] = c;
            } };
    }
    function ek(a, b) { return (b.castShadow ? 1 : 0) - (a.castShadow ? 1 : 0); }
    function fk() {
        for (var a = new dk, b = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadowMap: [], spotShadowMatrix: [],
            rectArea: [], point: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, c = 0; 9 > c; c++)
            b.probe.push(new n);
        var d = new n, e = new U, f = new U;
        return { setup: function (c, h, l) {
                for (var g = 0, q = 0, u = 0, k = 0; 9 > k; k++)
                    b.probe[k].set(0, 0, 0);
                var r = h = 0, p = 0, v = 0, n = 0, z = 0, y = 0, V = 0;
                l = l.matrixWorldInverse;
                c.sort(ek);
                k = 0;
                for (var P = c.length; k < P; k++) {
                    var C = c[k], Cb = C.color, w = C.intensity, A = C.distance, wa = C.shadow && C.shadow.map ? C.shadow.map.texture : null;
                    if (C.isAmbientLight)
                        g += Cb.r *
                            w, q += Cb.g * w, u += Cb.b * w;
                    else if (C.isLightProbe)
                        for (wa = 0; 9 > wa; wa++)
                            b.probe[wa].addScaledVector(C.sh.coefficients[wa], w);
                    else if (C.isDirectionalLight) {
                        var G = a.get(C);
                        G.color.copy(C.color).multiplyScalar(C.intensity);
                        G.direction.setFromMatrixPosition(C.matrixWorld);
                        d.setFromMatrixPosition(C.target.matrixWorld);
                        G.direction.sub(d);
                        G.direction.transformDirection(l);
                        if (G.shadow = C.castShadow)
                            w = C.shadow, G.shadowBias = w.bias, G.shadowRadius = w.radius, G.shadowMapSize = w.mapSize, b.directionalShadowMap[h] = wa, b.directionalShadowMatrix[h] =
                                C.shadow.matrix, z++;
                        b.directional[h] = G;
                        h++;
                    }
                    else if (C.isSpotLight) {
                        G = a.get(C);
                        G.position.setFromMatrixPosition(C.matrixWorld);
                        G.position.applyMatrix4(l);
                        G.color.copy(Cb).multiplyScalar(w);
                        G.distance = A;
                        G.direction.setFromMatrixPosition(C.matrixWorld);
                        d.setFromMatrixPosition(C.target.matrixWorld);
                        G.direction.sub(d);
                        G.direction.transformDirection(l);
                        G.coneCos = Math.cos(C.angle);
                        G.penumbraCos = Math.cos(C.angle * (1 - C.penumbra));
                        G.decay = C.decay;
                        if (G.shadow = C.castShadow)
                            w = C.shadow, G.shadowBias = w.bias, G.shadowRadius =
                                w.radius, G.shadowMapSize = w.mapSize, b.spotShadowMap[p] = wa, b.spotShadowMatrix[p] = C.shadow.matrix, V++;
                        b.spot[p] = G;
                        p++;
                    }
                    else if (C.isRectAreaLight)
                        G = a.get(C), G.color.copy(Cb).multiplyScalar(w), G.position.setFromMatrixPosition(C.matrixWorld), G.position.applyMatrix4(l), f.identity(), e.copy(C.matrixWorld), e.premultiply(l), f.extractRotation(e), G.halfWidth.set(.5 * C.width, 0, 0), G.halfHeight.set(0, .5 * C.height, 0), G.halfWidth.applyMatrix4(f), G.halfHeight.applyMatrix4(f), b.rectArea[v] = G, v++;
                    else if (C.isPointLight) {
                        G =
                            a.get(C);
                        G.position.setFromMatrixPosition(C.matrixWorld);
                        G.position.applyMatrix4(l);
                        G.color.copy(C.color).multiplyScalar(C.intensity);
                        G.distance = C.distance;
                        G.decay = C.decay;
                        if (G.shadow = C.castShadow)
                            w = C.shadow, G.shadowBias = w.bias, G.shadowRadius = w.radius, G.shadowMapSize = w.mapSize, G.shadowCameraNear = w.camera.near, G.shadowCameraFar = w.camera.far, b.pointShadowMap[r] = wa, b.pointShadowMatrix[r] = C.shadow.matrix, y++;
                        b.point[r] = G;
                        r++;
                    }
                    else
                        C.isHemisphereLight && (G = a.get(C), G.direction.setFromMatrixPosition(C.matrixWorld),
                            G.direction.transformDirection(l), G.direction.normalize(), G.skyColor.copy(C.color).multiplyScalar(w), G.groundColor.copy(C.groundColor).multiplyScalar(w), b.hemi[n] = G, n++);
                }
                b.ambient[0] = g;
                b.ambient[1] = q;
                b.ambient[2] = u;
                c = b.hash;
                if (c.directionalLength !== h || c.pointLength !== r || c.spotLength !== p || c.rectAreaLength !== v || c.hemiLength !== n || c.numDirectionalShadows !== z || c.numPointShadows !== y || c.numSpotShadows !== V)
                    b.directional.length = h, b.spot.length = p, b.rectArea.length = v, b.point.length = r, b.hemi.length = n, b.directionalShadowMap.length =
                        z, b.pointShadowMap.length = y, b.spotShadowMap.length = V, b.directionalShadowMatrix.length = z, b.pointShadowMatrix.length = y, b.spotShadowMatrix.length = V, c.directionalLength = h, c.pointLength = r, c.spotLength = p, c.rectAreaLength = v, c.hemiLength = n, c.numDirectionalShadows = z, c.numPointShadows = y, c.numSpotShadows = V, b.version = gk++;
            }, state: b };
    }
    function Ih() {
        var a = new fk, b = [], c = [];
        return { init: function () { b.length = 0; c.length = 0; }, state: { lightsArray: b, shadowsArray: c, lights: a }, setupLights: function (d) { a.setup(b, c, d); }, pushLight: function (a) { b.push(a); },
            pushShadow: function (a) { c.push(a); } };
    }
    function hk() { function a(c) { c = c.target; c.removeEventListener("dispose", a); b.delete(c); } var b = new WeakMap; return { get: function (c, d) { if (!1 === b.has(c)) {
            var e = new Ih;
            b.set(c, new WeakMap);
            b.get(c).set(d, e);
            c.addEventListener("dispose", a);
        }
        else
            !1 === b.get(c).has(d) ? (e = new Ih, b.get(c).set(d, e)) : e = b.get(c).get(d); return e; }, dispose: function () { b = new WeakMap; } }; }
    function Db(a) {
        M.call(this);
        this.type = "MeshDepthMaterial";
        this.depthPacking = 3200;
        this.morphTargets = this.skinning = !1;
        this.displacementMap =
            this.alphaMap = this.map = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.fog = !1;
        this.setValues(a);
    }
    function Eb(a) { M.call(this); this.type = "MeshDistanceMaterial"; this.referencePosition = new n; this.nearDistance = 1; this.farDistance = 1E3; this.morphTargets = this.skinning = !1; this.displacementMap = this.alphaMap = this.map = null; this.displacementScale = 1; this.displacementBias = 0; this.fog = !1; this.setValues(a); }
    function Jh(a, b, c) {
        function d(b, c, d, e, f, g) {
            var h = b.geometry;
            var l = m;
            var p = b.customDepthMaterial;
            d.isPointLight && (l = q, p = b.customDistanceMaterial);
            p ? l = p : (p = !1, c.morphTargets && (h && h.isBufferGeometry ? p = h.morphAttributes && h.morphAttributes.position && 0 < h.morphAttributes.position.length : h && h.isGeometry && (p = h.morphTargets && 0 < h.morphTargets.length)), b.isSkinnedMesh && !1 === c.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", b), b = b.isSkinnedMesh && c.skinning, h = 0, p && (h |= 1), b && (h |= 2), l = l[h]);
            a.localClippingEnabled && !0 ===
                c.clipShadows && 0 !== c.clippingPlanes.length && (h = l.uuid, p = c.uuid, b = u[h], void 0 === b && (b = {}, u[h] = b), h = b[p], void 0 === h && (h = l.clone(), b[p] = h), l = h);
            l.visible = c.visible;
            l.wireframe = c.wireframe;
            l.side = 3 === g ? null != c.shadowSide ? c.shadowSide : c.side : null != c.shadowSide ? c.shadowSide : k[c.side];
            l.clipShadows = c.clipShadows;
            l.clippingPlanes = c.clippingPlanes;
            l.clipIntersection = c.clipIntersection;
            l.wireframeLinewidth = c.wireframeLinewidth;
            l.linewidth = c.linewidth;
            d.isPointLight && l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(d.matrixWorld),
                l.nearDistance = e, l.farDistance = f);
            return l;
        }
        function e(c, g, h, l, m) {
            if (!1 !== c.visible) {
                if (c.layers.test(g.layers) && (c.isMesh || c.isLine || c.isPoints) && (c.castShadow || c.receiveShadow && 3 === m) && (!c.frustumCulled || f.intersectsObject(c))) {
                    c.modelViewMatrix.multiplyMatrices(h.matrixWorldInverse, c.matrixWorld);
                    var q = b.update(c), u = c.material;
                    if (Array.isArray(u))
                        for (var k = q.groups, p = 0, t = k.length; p < t; p++) {
                            var r = k[p], v = u[r.materialIndex];
                            v && v.visible && (v = d(c, v, l, h.near, h.far, m), a.renderBufferDirect(h, null, q, v, c, r));
                        }
                    else
                        u.visible && (v = d(c, u, l, h.near, h.far, m), a.renderBufferDirect(h, null, q, v, c, null));
                }
                c = c.children;
                q = 0;
                for (u = c.length; q < u; q++)
                    e(c[q], g, h, l, m);
            }
        }
        var f = new Ed, g = new w, h = new w, l = new aa, m = Array(4), q = Array(4), u = {}, k = { 0: 1, 1: 0, 2: 2 }, r = new ma({ defines: { SAMPLE_RATE: .25, HALF_SAMPLE_RATE: .125 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new w }, radius: { value: 4 } }, vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n  \n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = decodeHalfRGBA ( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = pow( squared_mean - mean * mean, 0.5 );\n  gl_FragColor = encodeHalfRGBA( vec2( mean, std_dev ) );\n}" }), p = r.clone();
        p.defines.HORIZONAL_PASS = 1;
        var v = new E;
        v.addAttribute("position", new O(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
        var n = new ja(v, r);
        for (v = 0; 4 !== v; ++v) {
            var z = 0 !== (v & 1), y = 0 !== (v & 2), V = new Db({ depthPacking: 3201, morphTargets: z, skinning: y });
            m[v] = V;
            z = new Eb({ morphTargets: z, skinning: y });
            q[v] = z;
        }
        var P = this;
        this.enabled = !1;
        this.autoUpdate = !0;
        this.needsUpdate = !1;
        this.type = 1;
        this.render = function (d, m, q) {
            if (!1 !== P.enabled && (!1 !== P.autoUpdate || !1 !== P.needsUpdate) && 0 !== d.length) {
                var u = a.getRenderTarget(), k = a.getActiveCubeFace(), t = a.getActiveMipmapLevel(), v = a.state;
                v.setBlending(0);
                v.buffers.color.setClear(1, 1, 1, 1);
                v.buffers.depth.setTest(!0);
                v.setScissorTest(!1);
                for (var x = 0, y = d.length; x < y; x++) {
                    var z = d[x], T = z.shadow;
                    if (void 0 === T)
                        console.warn("THREE.WebGLShadowMap:", z, "has no shadow.");
                    else {
                        g.copy(T.mapSize);
                        var X = T.getFrameExtents();
                        g.multiply(X);
                        h.copy(T.mapSize);
                        if (g.x > c || g.y > c)
                            console.warn("THREE.WebGLShadowMap:", z, "has shadow exceeding max texture size, reducing"), g.x > c && (h.x = Math.floor(c / X.x),
                                g.x = h.x * X.x, T.mapSize.x = h.x), g.y > c && (h.y = Math.floor(c / X.y), g.y = h.y * X.y, T.mapSize.y = h.y);
                        null !== T.map || T.isPointLightShadow || 3 !== this.type || (X = { minFilter: 1006, magFilter: 1006, format: 1023 }, T.map = new la(g.x, g.y, X), T.map.texture.name = z.name + ".shadowMap", T.mapPass = new la(g.x, g.y, X), T.camera.updateProjectionMatrix());
                        null === T.map && (X = { minFilter: 1003, magFilter: 1003, format: 1023 }, T.map = new la(g.x, g.y, X), T.map.texture.name = z.name + ".shadowMap", T.camera.updateProjectionMatrix());
                        a.setRenderTarget(T.map);
                        a.clear();
                        X = T.getViewportCount();
                        for (var V = 0; V < X; V++) {
                            var C = T.getViewport(V);
                            l.set(h.x * C.x, h.y * C.y, h.x * C.z, h.y * C.w);
                            v.viewport(l);
                            T.updateMatrices(z, q, V);
                            f = T.getFrustum();
                            e(m, q, T.camera, z, this.type);
                        }
                        T.isPointLightShadow || 3 !== this.type || (z = T, T = q, X = b.update(n), r.uniforms.shadow_pass.value = z.map.texture, r.uniforms.resolution.value = z.mapSize, r.uniforms.radius.value = z.radius, a.setRenderTarget(z.mapPass), a.clear(), a.renderBufferDirect(T, null, X, r, n, null), p.uniforms.shadow_pass.value = z.mapPass.texture, p.uniforms.resolution.value =
                            z.mapSize, p.uniforms.radius.value = z.radius, a.setRenderTarget(z.map), a.clear(), a.renderBufferDirect(T, null, X, p, n, null));
                    }
                }
                P.needsUpdate = !1;
                a.setRenderTarget(u, k, t);
            }
        };
    }
    function ik(a, b, c, d) {
        function e(b, c, d) { var e = new Uint8Array(4), f = a.createTexture(); a.bindTexture(b, f); a.texParameteri(b, 10241, 9728); a.texParameteri(b, 10240, 9728); for (b = 0; b < d; b++)
            a.texImage2D(c + b, 0, 6408, 1, 1, 0, 6408, 5121, e); return f; }
        function f(c, e) {
            z[c] = 1;
            0 === y[c] && (a.enableVertexAttribArray(c), y[c] = 1);
            V[c] !== e && ((d.isWebGL2 ? a : b.get("ANGLE_instanced_arrays"))[d.isWebGL2 ?
                "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](c, e), V[c] = e);
        }
        function g(b) { !0 !== P[b] && (a.enable(b), P[b] = !0); }
        function h(b) { !1 !== P[b] && (a.disable(b), P[b] = !1); }
        function l(b, d, e, f, l, m, q, u) {
            if (0 === b)
                A && (h(3042), A = !1);
            else if (A || (g(3042), A = !0), 5 !== b) {
                if (b !== B || u !== T) {
                    if (100 !== wa || 100 !== E)
                        a.blendEquation(32774), E = wa = 100;
                    if (u)
                        switch (b) {
                            case 1:
                                a.blendFuncSeparate(1, 771, 1, 771);
                                break;
                            case 2:
                                a.blendFunc(1, 1);
                                break;
                            case 3:
                                a.blendFuncSeparate(0, 0, 769, 771);
                                break;
                            case 4:
                                a.blendFuncSeparate(0, 768, 0, 770);
                                break;
                            default: console.error("THREE.WebGLState: Invalid blending: ", b);
                        }
                    else
                        switch (b) {
                            case 1:
                                a.blendFuncSeparate(770, 771, 1, 771);
                                break;
                            case 2:
                                a.blendFunc(770, 1);
                                break;
                            case 3:
                                a.blendFunc(0, 769);
                                break;
                            case 4:
                                a.blendFunc(0, 768);
                                break;
                            default: console.error("THREE.WebGLState: Invalid blending: ", b);
                        }
                    H = I = ag = G = null;
                    B = b;
                    T = u;
                }
            }
            else {
                l = l || d;
                m = m || e;
                q = q || f;
                if (d !== wa || l !== E)
                    a.blendEquationSeparate(c.convert(d), c.convert(l)), wa = d, E = l;
                if (e !== G || f !== ag || m !== I || q !== H)
                    a.blendFuncSeparate(c.convert(e), c.convert(f), c.convert(m), c.convert(q)), G = e, ag = f, I = m, H = q;
                B = b;
                T = null;
            }
        }
        function m(b) {
            X !==
                b && (b ? a.frontFace(2304) : a.frontFace(2305), X = b);
        }
        function q(b) { 0 !== b ? (g(2884), b !== bg && (1 === b ? a.cullFace(1029) : 2 === b ? a.cullFace(1028) : a.cullFace(1032))) : h(2884); bg = b; }
        function u(b, c, d) { if (b) {
            if (g(32823), ha !== c || bc !== d)
                a.polygonOffset(c, d), ha = c, bc = d;
        }
        else
            h(32823); }
        function k(b) { void 0 === b && (b = 33984 + D - 1); Pa !== b && (a.activeTexture(b), Pa = b); }
        var r = new function () {
            var b = !1, c = new aa, d = null, e = new aa(0, 0, 0, 0);
            return { setMask: function (c) { d === c || b || (a.colorMask(c, c, c, c), d = c); }, setLocked: function (a) { b = a; }, setClear: function (b, d, f, g, h) { !0 === h && (b *= g, d *= g, f *= g); c.set(b, d, f, g); !1 === e.equals(c) && (a.clearColor(b, d, f, g), e.copy(c)); }, reset: function () { b = !1; d = null; e.set(-1, 0, 0, 0); } };
        }, p = new function () {
            var b = !1, c = null, d = null, e = null;
            return { setTest: function (a) { a ? g(2929) : h(2929); }, setMask: function (d) { c === d || b || (a.depthMask(d), c = d); }, setFunc: function (b) {
                    if (d !== b) {
                        if (b)
                            switch (b) {
                                case 0:
                                    a.depthFunc(512);
                                    break;
                                case 1:
                                    a.depthFunc(519);
                                    break;
                                case 2:
                                    a.depthFunc(513);
                                    break;
                                case 3:
                                    a.depthFunc(515);
                                    break;
                                case 4:
                                    a.depthFunc(514);
                                    break;
                                case 5:
                                    a.depthFunc(518);
                                    break;
                                case 6:
                                    a.depthFunc(516);
                                    break;
                                case 7:
                                    a.depthFunc(517);
                                    break;
                                default: a.depthFunc(515);
                            }
                        else
                            a.depthFunc(515);
                        d = b;
                    }
                }, setLocked: function (a) { b = a; }, setClear: function (b) { e !== b && (a.clearDepth(b), e = b); }, reset: function () { b = !1; e = d = c = null; } };
        }, v = new function () {
            var b = !1, c = null, d = null, e = null, f = null, l = null, m = null, q = null, u = null;
            return { setTest: function (a) { b || (a ? g(2960) : h(2960)); }, setMask: function (d) { c === d || b || (a.stencilMask(d), c = d); }, setFunc: function (b, c, g) { if (d !== b || e !== c || f !== g)
                    a.stencilFunc(b, c, g), d = b, e = c, f = g; },
                setOp: function (b, c, d) { if (l !== b || m !== c || q !== d)
                    a.stencilOp(b, c, d), l = b, m = c, q = d; }, setLocked: function (a) { b = a; }, setClear: function (b) { u !== b && (a.clearStencil(b), u = b); }, reset: function () { b = !1; u = q = m = l = f = e = d = c = null; } };
        }, n = a.getParameter(34921), z = new Uint8Array(n), y = new Uint8Array(n), V = new Uint8Array(n), P = {}, C = null, w = null, A = null, B = null, wa = null, G = null, ag = null, E = null, I = null, H = null, T = !1, X = null, bg = null, ac = null, ha = null, bc = null, D = a.getParameter(35661), dg = !1;
        n = 0;
        n = a.getParameter(7938);
        -1 !== n.indexOf("WebGL") ? (n = parseFloat(/^WebGL ([0-9])/.exec(n)[1]),
            dg = 1 <= n) : -1 !== n.indexOf("OpenGL ES") && (n = parseFloat(/^OpenGL ES ([0-9])/.exec(n)[1]), dg = 2 <= n);
        var Pa = null, eg = {}, F = new aa, O = new aa, K = {};
        K[3553] = e(3553, 3553, 1);
        K[34067] = e(34067, 34069, 6);
        r.setClear(0, 0, 0, 1);
        p.setClear(1);
        v.setClear(0);
        g(2929);
        p.setFunc(3);
        m(!1);
        q(1);
        g(2884);
        l(0);
        return { buffers: { color: r, depth: p, stencil: v }, initAttributes: function () { for (var a = 0, b = z.length; a < b; a++)
                z[a] = 0; }, enableAttribute: function (a) { f(a, 0); }, enableAttributeAndDivisor: f, disableUnusedAttributes: function () {
                for (var b = 0, c = y.length; b !==
                    c; ++b)
                    y[b] !== z[b] && (a.disableVertexAttribArray(b), y[b] = 0);
            }, enable: g, disable: h, getCompressedTextureFormats: function () { if (null === C && (C = [], b.get("WEBGL_compressed_texture_pvrtc") || b.get("WEBGL_compressed_texture_s3tc") || b.get("WEBGL_compressed_texture_etc1") || b.get("WEBGL_compressed_texture_astc")))
                for (var c = a.getParameter(34467), d = 0; d < c.length; d++)
                    C.push(c[d]); return C; }, useProgram: function (b) { return w !== b ? (a.useProgram(b), w = b, !0) : !1; }, setBlending: l, setMaterial: function (a, b) {
                2 === a.side ? h(2884) : g(2884);
                var c = 1 === a.side;
                b && (c = !c);
                m(c);
                1 === a.blending && !1 === a.transparent ? l(0) : l(a.blending, a.blendEquation, a.blendSrc, a.blendDst, a.blendEquationAlpha, a.blendSrcAlpha, a.blendDstAlpha, a.premultipliedAlpha);
                p.setFunc(a.depthFunc);
                p.setTest(a.depthTest);
                p.setMask(a.depthWrite);
                r.setMask(a.colorWrite);
                b = a.stencilWrite;
                v.setTest(b);
                b && (v.setMask(a.stencilWriteMask), v.setFunc(a.stencilFunc, a.stencilRef, a.stencilFuncMask), v.setOp(a.stencilFail, a.stencilZFail, a.stencilZPass));
                u(a.polygonOffset, a.polygonOffsetFactor, a.polygonOffsetUnits);
            }, setFlipSided: m, setCullFace: q, setLineWidth: function (b) { b !== ac && (dg && a.lineWidth(b), ac = b); }, setPolygonOffset: u, setScissorTest: function (a) { a ? g(3089) : h(3089); }, activeTexture: k, bindTexture: function (b, c) { null === Pa && k(); var d = eg[Pa]; void 0 === d && (d = { type: void 0, texture: void 0 }, eg[Pa] = d); if (d.type !== b || d.texture !== c)
                a.bindTexture(b, c || K[b]), d.type = b, d.texture = c; }, compressedTexImage2D: function () { try {
                a.compressedTexImage2D.apply(a, arguments);
            }
            catch (Z) {
                console.error("THREE.WebGLState:", Z);
            } },
            texImage2D: function () { try {
                a.texImage2D.apply(a, arguments);
            }
            catch (Z) {
                console.error("THREE.WebGLState:", Z);
            } }, texImage3D: function () { try {
                a.texImage3D.apply(a, arguments);
            }
            catch (Z) {
                console.error("THREE.WebGLState:", Z);
            } }, scissor: function (b) { !1 === F.equals(b) && (a.scissor(b.x, b.y, b.z, b.w), F.copy(b)); }, viewport: function (b) { !1 === O.equals(b) && (a.viewport(b.x, b.y, b.z, b.w), O.copy(b)); }, reset: function () {
                for (var b = 0; b < y.length; b++)
                    1 === y[b] && (a.disableVertexAttribArray(b), y[b] = 0);
                P = {};
                Pa = C = null;
                eg = {};
                bg = X = B = w = null;
                r.reset();
                p.reset();
                v.reset();
            } };
    }
    function jk(a, b, c, d, e, f, g) {
        function h(a, b) { return E ? new OffscreenCanvas(a, b) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"); }
        function l(a, b, c, d) {
            var e = 1;
            if (a.width > d || a.height > d)
                e = d / Math.max(a.width, a.height);
            if (1 > e || !0 === b) {
                if ("undefined" !== typeof HTMLImageElement && a instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && a instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && a instanceof ImageBitmap)
                    return d = b ? L.floorPowerOfTwo : Math.floor,
                        b = d(e * a.width), e = d(e * a.height), void 0 === G && (G = h(b, e)), c = c ? h(b, e) : G, c.width = b, c.height = e, c.getContext("2d").drawImage(a, 0, 0, b, e), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + a.width + "x" + a.height + ") to (" + b + "x" + e + ")."), c;
                "data" in a && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + a.width + "x" + a.height + ").");
            }
            return a;
        }
        function m(a) { return L.isPowerOfTwo(a.width) && L.isPowerOfTwo(a.height); }
        function q(a, b) {
            return a.generateMipmaps && b && 1003 !== a.minFilter && 1006 !==
                a.minFilter;
        }
        function u(b, c, e, f) { a.generateMipmap(b); d.get(c).__maxMipLevel = Math.log(Math.max(e, f)) * Math.LOG2E; }
        function k(a, c) {
            if (!e.isWebGL2)
                return a;
            var d = a;
            6403 === a && (5126 === c && (d = 33326), 5131 === c && (d = 33325), 5121 === c && (d = 33321));
            6407 === a && (5126 === c && (d = 34837), 5131 === c && (d = 34843), 5121 === c && (d = 32849));
            6408 === a && (5126 === c && (d = 34836), 5131 === c && (d = 34842), 5121 === c && (d = 32856));
            33325 === d || 33326 === d || 34842 === d || 34836 === d ? b.get("EXT_color_buffer_float") : (34843 === d || 34837 === d) && console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.");
            return d;
        }
        function r(a) { return 1003 === a || 1004 === a || 1005 === a ? 9728 : 9729; }
        function p(b) { b = b.target; b.removeEventListener("dispose", p); var c = d.get(b); void 0 !== c.__webglInit && (a.deleteTexture(c.__webglTexture), d.remove(b)); b.isVideoTexture && wa.delete(b); g.memory.textures--; }
        function v(b) {
            b = b.target;
            b.removeEventListener("dispose", v);
            var c = d.get(b), e = d.get(b.texture);
            if (b) {
                void 0 !== e.__webglTexture && a.deleteTexture(e.__webglTexture);
                b.depthTexture && b.depthTexture.dispose();
                if (b.isWebGLRenderTargetCube)
                    for (e =
                        0; 6 > e; e++)
                        a.deleteFramebuffer(c.__webglFramebuffer[e]), c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer[e]);
                else
                    a.deleteFramebuffer(c.__webglFramebuffer), c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer);
                if (b.isWebGLMultiviewRenderTarget) {
                    a.deleteTexture(c.__webglColorTexture);
                    a.deleteTexture(c.__webglDepthStencilTexture);
                    g.memory.textures -= 2;
                    e = 0;
                    for (var f = c.__webglViewFramebuffers.length; e < f; e++)
                        a.deleteFramebuffer(c.__webglViewFramebuffers[e]);
                }
                d.remove(b.texture);
                d.remove(b);
            }
            g.memory.textures--;
        }
        function n(a, b) { var e = d.get(a); if (a.isVideoTexture) {
            var f = g.render.frame;
            wa.get(a) !== f && (wa.set(a, f), a.update());
        } if (0 < a.version && e.__version !== a.version)
            if (f = a.image, void 0 === f)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
            else if (!1 === f.complete)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                C(e, a, b);
                return;
            } c.activeTexture(33984 + b); c.bindTexture(3553, e.__webglTexture); }
        function z(b, g) {
            if (6 === b.image.length) {
                var h = d.get(b);
                if (0 < b.version && h.__version !== b.version) {
                    P(h, b);
                    c.activeTexture(33984 + g);
                    c.bindTexture(34067, h.__webglTexture);
                    a.pixelStorei(37440, b.flipY);
                    var p = b && b.isCompressedTexture;
                    g = b.image[0] && b.image[0].isDataTexture;
                    for (var t = [], r = 0; 6 > r; r++)
                        t[r] = p || g ? g ? b.image[r].image : b.image[r] : l(b.image[r], !1, !0, e.maxCubemapSize);
                    var v = t[0], n = m(v) || e.isWebGL2, x = f.convert(b.format), y = f.convert(b.type), z = k(x, y);
                    V(34067, b, n);
                    if (p) {
                        for (r = 0; 6 > r; r++) {
                            var T = t[r].mipmaps;
                            for (p = 0; p < T.length; p++) {
                                var X = T[p];
                                1023 !== b.format && 1022 !== b.format ? -1 < c.getCompressedTextureFormats().indexOf(x) ? c.compressedTexImage2D(34069 + r, p, z, X.width, X.height, 0, X.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : c.texImage2D(34069 + r, p, z, X.width, X.height, 0, x, y, X.data);
                            }
                        }
                        h.__maxMipLevel = T.length - 1;
                    }
                    else {
                        T = b.mipmaps;
                        for (r = 0; 6 > r; r++)
                            if (g)
                                for (c.texImage2D(34069 + r, 0, z, t[r].width, t[r].height, 0, x, y, t[r].data), p = 0; p < T.length; p++)
                                    X = T[p], X = X.image[r].image, c.texImage2D(34069 +
                                        r, p + 1, z, X.width, X.height, 0, x, y, X.data);
                            else
                                for (c.texImage2D(34069 + r, 0, z, x, y, t[r]), p = 0; p < T.length; p++)
                                    X = T[p], c.texImage2D(34069 + r, p + 1, z, x, y, X.image[r]);
                        h.__maxMipLevel = T.length;
                    }
                    q(b, n) && u(34067, b, v.width, v.height);
                    h.__version = b.version;
                    if (b.onUpdate)
                        b.onUpdate(b);
                }
                else
                    c.activeTexture(33984 + g), c.bindTexture(34067, h.__webglTexture);
            }
        }
        function y(a, b) { c.activeTexture(33984 + b); c.bindTexture(34067, d.get(a).__webglTexture); }
        function V(c, g, h) {
            h ? (a.texParameteri(c, 10242, f.convert(g.wrapS)), a.texParameteri(c, 10243, f.convert(g.wrapT)), 32879 !== c && 35866 !== c || a.texParameteri(c, 32882, f.convert(g.wrapR)), a.texParameteri(c, 10240, f.convert(g.magFilter)), a.texParameteri(c, 10241, f.convert(g.minFilter))) : (a.texParameteri(c, 10242, 33071), a.texParameteri(c, 10243, 33071), 32879 !== c && 35866 !== c || a.texParameteri(c, 32882, 33071), 1001 === g.wrapS && 1001 === g.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), a.texParameteri(c, 10240, r(g.magFilter)), a.texParameteri(c, 10241, r(g.minFilter)), 1003 !== g.minFilter && 1006 !== g.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
            !(h = b.get("EXT_texture_filter_anisotropic")) || 1015 === g.type && null === b.get("OES_texture_float_linear") || 1016 === g.type && null === (e.isWebGL2 || b.get("OES_texture_half_float_linear")) || !(1 < g.anisotropy || d.get(g).__currentAnisotropy) || (a.texParameterf(c, h.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(g.anisotropy, e.getMaxAnisotropy())), d.get(g).__currentAnisotropy = g.anisotropy);
        }
        function P(b, c) { void 0 === b.__webglInit && (b.__webglInit = !0, c.addEventListener("dispose", p), b.__webglTexture = a.createTexture(), g.memory.textures++); }
        function C(b, d, g) {
            var h = 3553;
            d.isDataTexture2DArray && (h = 35866);
            d.isDataTexture3D && (h = 32879);
            P(b, d);
            c.activeTexture(33984 + g);
            c.bindTexture(h, b.__webglTexture);
            a.pixelStorei(37440, d.flipY);
            a.pixelStorei(37441, d.premultiplyAlpha);
            a.pixelStorei(3317, d.unpackAlignment);
            g =
                e.isWebGL2 ? !1 : 1001 !== d.wrapS || 1001 !== d.wrapT || 1003 !== d.minFilter && 1006 !== d.minFilter;
            g = g && !1 === m(d.image);
            g = l(d.image, g, !1, e.maxTextureSize);
            var p = m(g) || e.isWebGL2, t = f.convert(d.format), r = f.convert(d.type), v = k(t, r);
            V(h, d, p);
            var n = d.mipmaps;
            if (d.isDepthTexture) {
                v = 6402;
                if (1015 === d.type) {
                    if (!e.isWebGL2)
                        throw Error("Float Depth Texture only supported in WebGL2.0");
                    v = 36012;
                }
                else
                    e.isWebGL2 && (v = 33189);
                1026 === d.format && 6402 === v && 1012 !== d.type && 1014 !== d.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                    d.type = 1012, r = f.convert(d.type));
                1027 === d.format && (v = 34041, 1020 !== d.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), d.type = 1020, r = f.convert(d.type)));
                c.texImage2D(3553, 0, v, g.width, g.height, 0, t, r, null);
            }
            else if (d.isDataTexture)
                if (0 < n.length && p) {
                    for (var x = 0, y = n.length; x < y; x++)
                        h = n[x], c.texImage2D(3553, x, v, h.width, h.height, 0, t, r, h.data);
                    d.generateMipmaps = !1;
                    b.__maxMipLevel = n.length - 1;
                }
                else
                    c.texImage2D(3553, 0, v, g.width, g.height, 0, t, r, g.data), b.__maxMipLevel =
                        0;
            else if (d.isCompressedTexture) {
                x = 0;
                for (y = n.length; x < y; x++)
                    h = n[x], 1023 !== d.format && 1022 !== d.format ? -1 < c.getCompressedTextureFormats().indexOf(t) ? c.compressedTexImage2D(3553, x, v, h.width, h.height, 0, h.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : c.texImage2D(3553, x, v, h.width, h.height, 0, t, r, h.data);
                b.__maxMipLevel = n.length - 1;
            }
            else if (d.isDataTexture2DArray)
                c.texImage3D(35866, 0, v, g.width, g.height, g.depth, 0, t, r, g.data), b.__maxMipLevel =
                    0;
            else if (d.isDataTexture3D)
                c.texImage3D(32879, 0, v, g.width, g.height, g.depth, 0, t, r, g.data), b.__maxMipLevel = 0;
            else if (0 < n.length && p) {
                x = 0;
                for (y = n.length; x < y; x++)
                    h = n[x], c.texImage2D(3553, x, v, t, r, h);
                d.generateMipmaps = !1;
                b.__maxMipLevel = n.length - 1;
            }
            else
                c.texImage2D(3553, 0, v, t, r, g), b.__maxMipLevel = 0;
            q(d, p) && u(3553, d, g.width, g.height);
            b.__version = d.version;
            if (d.onUpdate)
                d.onUpdate(d);
        }
        function w(b, e, g, h) {
            var l = f.convert(e.texture.format), m = f.convert(e.texture.type), q = k(l, m);
            c.texImage2D(h, 0, q, e.width, e.height, 0, l, m, null);
            a.bindFramebuffer(36160, b);
            a.framebufferTexture2D(36160, g, h, d.get(e.texture).__webglTexture, 0);
            a.bindFramebuffer(36160, null);
        }
        function A(b, c, d) {
            a.bindRenderbuffer(36161, b);
            if (c.depthBuffer && !c.stencilBuffer)
                d ? (d = B(c), a.renderbufferStorageMultisample(36161, d, 33189, c.width, c.height)) : a.renderbufferStorage(36161, 33189, c.width, c.height), a.framebufferRenderbuffer(36160, 36096, 36161, b);
            else if (c.depthBuffer && c.stencilBuffer)
                d ? (d = B(c), a.renderbufferStorageMultisample(36161, d, 35056, c.width, c.height)) :
                    a.renderbufferStorage(36161, 34041, c.width, c.height), a.framebufferRenderbuffer(36160, 33306, 36161, b);
            else {
                b = f.convert(c.texture.format);
                var e = f.convert(c.texture.type);
                b = k(b, e);
                d ? (d = B(c), a.renderbufferStorageMultisample(36161, d, b, c.width, c.height)) : a.renderbufferStorage(36161, b, c.width, c.height);
            }
            a.bindRenderbuffer(36161, null);
        }
        function B(a) { return e.isWebGL2 && a.isWebGLMultisampleRenderTarget ? Math.min(e.maxSamples, a.samples) : 0; }
        var wa = new WeakMap, G, E = "undefined" !== typeof OffscreenCanvas && null !== (new OffscreenCanvas(1, 1)).getContext("2d"), I = 0, H = !1, D = !1;
        this.allocateTextureUnit = function () { var a = I; a >= e.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + a + " texture units while this GPU supports only " + e.maxTextures); I += 1; return a; };
        this.resetTextureUnits = function () { I = 0; };
        this.setTexture2D = n;
        this.setTexture2DArray = function (a, b) { var e = d.get(a); 0 < a.version && e.__version !== a.version ? C(e, a, b) : (c.activeTexture(33984 + b), c.bindTexture(35866, e.__webglTexture)); };
        this.setTexture3D = function (a, b) {
            var e = d.get(a);
            0 < a.version &&
                e.__version !== a.version ? C(e, a, b) : (c.activeTexture(33984 + b), c.bindTexture(32879, e.__webglTexture));
        };
        this.setTextureCube = z;
        this.setTextureCubeDynamic = y;
        this.setupRenderTarget = function (h) {
            var l = d.get(h), p = d.get(h.texture);
            h.addEventListener("dispose", v);
            p.__webglTexture = a.createTexture();
            g.memory.textures++;
            var t = !0 === h.isWebGLRenderTargetCube, r = !0 === h.isWebGLMultisampleRenderTarget, x = !0 === h.isWebGLMultiviewRenderTarget, y = m(h) || e.isWebGL2;
            if (t) {
                l.__webglFramebuffer = [];
                for (var z = 0; 6 > z; z++)
                    l.__webglFramebuffer[z] =
                        a.createFramebuffer();
            }
            else if (l.__webglFramebuffer = a.createFramebuffer(), r)
                if (e.isWebGL2) {
                    l.__webglMultisampledFramebuffer = a.createFramebuffer();
                    l.__webglColorRenderbuffer = a.createRenderbuffer();
                    a.bindRenderbuffer(36161, l.__webglColorRenderbuffer);
                    r = f.convert(h.texture.format);
                    var C = f.convert(h.texture.type);
                    r = k(r, C);
                    C = B(h);
                    a.renderbufferStorageMultisample(36161, C, r, h.width, h.height);
                    a.bindFramebuffer(36160, l.__webglMultisampledFramebuffer);
                    a.framebufferRenderbuffer(36160, 36064, 36161, l.__webglColorRenderbuffer);
                    a.bindRenderbuffer(36161, null);
                    h.depthBuffer && (l.__webglDepthRenderbuffer = a.createRenderbuffer(), A(l.__webglDepthRenderbuffer, h, !0));
                    a.bindFramebuffer(36160, null);
                }
                else
                    console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            else if (x) {
                z = h.width;
                var P = h.height;
                r = h.numViews;
                a.bindFramebuffer(36160, l.__webglFramebuffer);
                var G = b.get("OVR_multiview2");
                g.memory.textures += 2;
                C = a.createTexture();
                a.bindTexture(35866, C);
                a.texParameteri(35866, 10240, 9728);
                a.texParameteri(35866, 10241, 9728);
                a.texImage3D(35866, 0, 32856, z, P, r, 0, 6408, 5121, null);
                G.framebufferTextureMultiviewOVR(36160, 36064, C, 0, 0, r);
                var wa = a.createTexture();
                a.bindTexture(35866, wa);
                a.texParameteri(35866, 10240, 9728);
                a.texParameteri(35866, 10241, 9728);
                a.texImage3D(35866, 0, 35056, z, P, r, 0, 34041, 34042, null);
                G.framebufferTextureMultiviewOVR(36160, 33306, wa, 0, 0, r);
                P = Array(r);
                for (z = 0; z < r; ++z)
                    P[z] = a.createFramebuffer(), a.bindFramebuffer(36160, P[z]), a.framebufferTextureLayer(36160, 36064, C, 0, z);
                l.__webglColorTexture = C;
                l.__webglDepthStencilTexture =
                    wa;
                l.__webglViewFramebuffers = P;
                a.bindFramebuffer(36160, null);
                a.bindTexture(35866, null);
            }
            if (t) {
                c.bindTexture(34067, p.__webglTexture);
                V(34067, h.texture, y);
                for (z = 0; 6 > z; z++)
                    w(l.__webglFramebuffer[z], h, 36064, 34069 + z);
                q(h.texture, y) && u(34067, h.texture, h.width, h.height);
                c.bindTexture(34067, null);
            }
            else
                x || (c.bindTexture(3553, p.__webglTexture), V(3553, h.texture, y), w(l.__webglFramebuffer, h, 36064, 3553), q(h.texture, y) && u(3553, h.texture, h.width, h.height), c.bindTexture(3553, null));
            if (h.depthBuffer) {
                l = d.get(h);
                p = !0 ===
                    h.isWebGLRenderTargetCube;
                if (h.depthTexture) {
                    if (p)
                        throw Error("target.depthTexture not supported in Cube render targets");
                    if (h && h.isWebGLRenderTargetCube)
                        throw Error("Depth Texture with cube render targets is not supported");
                    a.bindFramebuffer(36160, l.__webglFramebuffer);
                    if (!h.depthTexture || !h.depthTexture.isDepthTexture)
                        throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    d.get(h.depthTexture).__webglTexture && h.depthTexture.image.width === h.width && h.depthTexture.image.height ===
                        h.height || (h.depthTexture.image.width = h.width, h.depthTexture.image.height = h.height, h.depthTexture.needsUpdate = !0);
                    n(h.depthTexture, 0);
                    l = d.get(h.depthTexture).__webglTexture;
                    if (1026 === h.depthTexture.format)
                        a.framebufferTexture2D(36160, 36096, 3553, l, 0);
                    else if (1027 === h.depthTexture.format)
                        a.framebufferTexture2D(36160, 33306, 3553, l, 0);
                    else
                        throw Error("Unknown depthTexture format");
                }
                else if (p)
                    for (l.__webglDepthbuffer = [], p = 0; 6 > p; p++)
                        a.bindFramebuffer(36160, l.__webglFramebuffer[p]), l.__webglDepthbuffer[p] =
                            a.createRenderbuffer(), A(l.__webglDepthbuffer[p], h);
                else
                    a.bindFramebuffer(36160, l.__webglFramebuffer), l.__webglDepthbuffer = a.createRenderbuffer(), A(l.__webglDepthbuffer, h);
                a.bindFramebuffer(36160, null);
            }
        };
        this.updateRenderTargetMipmap = function (a) { var b = a.texture, f = m(a) || e.isWebGL2; if (q(b, f)) {
            f = a.isWebGLRenderTargetCube ? 34067 : 3553;
            var g = d.get(b).__webglTexture;
            c.bindTexture(f, g);
            u(f, b, a.width, a.height);
            c.bindTexture(f, null);
        } };
        this.updateMultisampleRenderTarget = function (b) {
            if (b.isWebGLMultisampleRenderTarget)
                if (e.isWebGL2) {
                    var c = d.get(b);
                    a.bindFramebuffer(36008, c.__webglMultisampledFramebuffer);
                    a.bindFramebuffer(36009, c.__webglFramebuffer);
                    c = b.width;
                    var f = b.height, g = 16384;
                    b.depthBuffer && (g |= 256);
                    b.stencilBuffer && (g |= 1024);
                    a.blitFramebuffer(0, 0, c, f, 0, 0, c, f, g, 9728);
                }
                else
                    console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        };
        this.safeSetTexture2D = function (a, b) {
            a && a.isWebGLRenderTarget && (!1 === H && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),
                H = !0), a = a.texture);
            n(a, b);
        };
        this.safeSetTextureCube = function (a, b) { a && a.isWebGLRenderTargetCube && (!1 === D && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), D = !0), a = a.texture); a && a.isCubeTexture || Array.isArray(a.image) && 6 === a.image.length ? z(a, b) : y(a, b); };
    }
    function Kh(a, b, c) {
        return { convert: function (a) {
                if (1E3 === a)
                    return 10497;
                if (1001 === a)
                    return 33071;
                if (1002 === a)
                    return 33648;
                if (1003 === a)
                    return 9728;
                if (1004 === a)
                    return 9984;
                if (1005 === a)
                    return 9986;
                if (1006 === a)
                    return 9729;
                if (1007 === a)
                    return 9985;
                if (1008 === a)
                    return 9987;
                if (1009 === a)
                    return 5121;
                if (1017 === a)
                    return 32819;
                if (1018 === a)
                    return 32820;
                if (1019 === a)
                    return 33635;
                if (1010 === a)
                    return 5120;
                if (1011 === a)
                    return 5122;
                if (1012 === a)
                    return 5123;
                if (1013 === a)
                    return 5124;
                if (1014 === a)
                    return 5125;
                if (1015 === a)
                    return 5126;
                if (1016 === a) {
                    if (c.isWebGL2)
                        return 5131;
                    var d = b.get("OES_texture_half_float");
                    if (null !== d)
                        return d.HALF_FLOAT_OES;
                }
                if (1021 === a)
                    return 6406;
                if (1022 === a)
                    return 6407;
                if (1023 ===
                    a)
                    return 6408;
                if (1024 === a)
                    return 6409;
                if (1025 === a)
                    return 6410;
                if (1026 === a)
                    return 6402;
                if (1027 === a)
                    return 34041;
                if (1028 === a)
                    return 6403;
                if (100 === a)
                    return 32774;
                if (101 === a)
                    return 32778;
                if (102 === a)
                    return 32779;
                if (200 === a)
                    return 0;
                if (201 === a)
                    return 1;
                if (202 === a)
                    return 768;
                if (203 === a)
                    return 769;
                if (204 === a)
                    return 770;
                if (205 === a)
                    return 771;
                if (206 === a)
                    return 772;
                if (207 === a)
                    return 773;
                if (208 === a)
                    return 774;
                if (209 === a)
                    return 775;
                if (210 === a)
                    return 776;
                if (33776 === a || 33777 === a || 33778 === a || 33779 === a)
                    if (d = b.get("WEBGL_compressed_texture_s3tc"),
                        null !== d) {
                        if (33776 === a)
                            return d.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (33777 === a)
                            return d.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (33778 === a)
                            return d.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (33779 === a)
                            return d.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                    }
                if (35840 === a || 35841 === a || 35842 === a || 35843 === a)
                    if (d = b.get("WEBGL_compressed_texture_pvrtc"), null !== d) {
                        if (35840 === a)
                            return d.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (35841 === a)
                            return d.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (35842 === a)
                            return d.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (35843 === a)
                            return d.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                    }
                if (36196 ===
                    a && (d = b.get("WEBGL_compressed_texture_etc1"), null !== d))
                    return d.COMPRESSED_RGB_ETC1_WEBGL;
                if (37808 === a || 37809 === a || 37810 === a || 37811 === a || 37812 === a || 37813 === a || 37814 === a || 37815 === a || 37816 === a || 37817 === a || 37818 === a || 37819 === a || 37820 === a || 37821 === a)
                    if (d = b.get("WEBGL_compressed_texture_astc"), null !== d)
                        return a;
                if (103 === a || 104 === a) {
                    if (c.isWebGL2) {
                        if (103 === a)
                            return 32775;
                        if (104 === a)
                            return 32776;
                    }
                    d = b.get("EXT_blend_minmax");
                    if (null !== d) {
                        if (103 === a)
                            return d.MIN_EXT;
                        if (104 === a)
                            return d.MAX_EXT;
                    }
                }
                if (1020 === a) {
                    if (c.isWebGL2)
                        return 34042;
                    d = b.get("WEBGL_depth_texture");
                    if (null !== d)
                        return d.UNSIGNED_INT_24_8_WEBGL;
                }
                return 0;
            } };
    }
    function fg(a, b, c, d) { la.call(this, a, b, d); this.stencilBuffer = this.depthBuffer = !1; this.numViews = c; }
    function kk(a, b) {
        function c(a) { if (a.isArrayCamera)
            return a.cameras; q[0] = a; return q; }
        function d(a) { if (void 0 === a.isArrayCamera)
            return !0; a = a.cameras; if (a.length > r)
            return !1; for (var b = 1, c = a.length; b < c; b++)
            if (a[0].viewport.z !== a[b].viewport.z || a[0].viewport.w !== a[b].viewport.w)
                return !1; return !0; }
        var e = a.extensions, f = a.properties, g, h, l, m, q, u, k, r = 0;
        this.isAvailable = function () { if (void 0 === k) {
            var a = e.get("OVR_multiview2");
            if (k = null !== a && !1 === b.getContextAttributes().antialias)
                for (r = b.getParameter(a.MAX_VIEWS_OVR), g = new fg(0, 0, 2), u = new w, m = [], l = [], q = [], a = 0; a < r; a++)
                    m[a] = new U, l[a] = new Y;
        } return k; };
        this.attachCamera = function (b) {
            if (!1 !== d(b)) {
                (h = a.getRenderTarget()) ? u.set(h.width, h.height) : a.getDrawingBufferSize(u);
                if (b.isArrayCamera) {
                    var c = b.cameras[0].viewport;
                    g.setSize(c.z, c.w);
                    g.setNumViews(b.cameras.length);
                }
                else
                    g.setSize(u.x, u.y), g.setNumViews(2);
                a.setRenderTarget(g);
            }
        };
        this.detachCamera = function (c) { if (g === a.getRenderTarget()) {
            a.setRenderTarget(h);
            var d = g, e = d.numViews, l = f.get(d).__webglViewFramebuffers, m = d.width;
            d = d.height;
            if (c.isArrayCamera)
                for (var q = 0; q < e; q++) {
                    var k = c.cameras[q].viewport, p = k.x, r = k.y, t = p + k.z;
                    k = r + k.w;
                    b.bindFramebuffer(36008, l[q]);
                    b.blitFramebuffer(0, 0, m, d, p, r, t, k, 16384, 9728);
                }
            else
                b.bindFramebuffer(36008, l[0]), b.blitFramebuffer(0, 0, m, d, 0, 0, u.x, u.y, 16384, 9728);
        } };
        this.updateCameraProjectionMatricesUniform =
            function (a, d) { a = c(a); for (var e = 0; e < a.length; e++)
                m[e].copy(a[e].projectionMatrix); d.setValue(b, "projectionMatrices", m); };
        this.updateCameraViewMatricesUniform = function (a, d) { a = c(a); for (var e = 0; e < a.length; e++)
            m[e].copy(a[e].matrixWorldInverse); d.setValue(b, "viewMatrices", m); };
        this.updateObjectMatricesUniforms = function (a, d, e) {
            d = c(d);
            for (var f = 0; f < d.length; f++)
                m[f].multiplyMatrices(d[f].matrixWorldInverse, a.matrixWorld), l[f].getNormalMatrix(m[f]);
            e.setValue(b, "modelViewMatrices", m);
            e.setValue(b, "normalMatrices", l);
        };
    }
    function Hc() { B.call(this); this.type = "Group"; }
    function Jd(a) { na.call(this); this.cameras = a || []; }
    function Lh(a, b, c) {
        Mh.setFromMatrixPosition(b.matrixWorld);
        Nh.setFromMatrixPosition(c.matrixWorld);
        var d = Mh.distanceTo(Nh), e = b.projectionMatrix.elements, f = c.projectionMatrix.elements, g = e[14] / (e[10] - 1);
        c = e[14] / (e[10] + 1);
        var h = (e[9] + 1) / e[5], l = (e[9] - 1) / e[5], m = (e[8] - 1) / e[0], q = (f[8] + 1) / f[0];
        e = g * m;
        f = g * q;
        q = d / (-m + q);
        m = q * -m;
        b.matrixWorld.decompose(a.position, a.quaternion, a.scale);
        a.translateX(m);
        a.translateZ(q);
        a.matrixWorld.compose(a.position, a.quaternion, a.scale);
        a.matrixWorldInverse.getInverse(a.matrixWorld);
        b = g + q;
        g = c + q;
        a.projectionMatrix.makePerspective(e - m, f + (d - m), h * c / g * b, l * c / g * b, b, g);
    }
    function gg(a) {
        function b() { return null !== h && !0 === h.isPresenting; }
        function c() {
            if (b()) {
                var c = h.getEyeParameters("left");
                e = 2 * c.renderWidth * r;
                f = c.renderHeight * r;
                Cb = a.getPixelRatio();
                a.getSize(C);
                a.setDrawingBufferSize(e, f, 1);
                y.viewport.set(0, 0, e / 2, f);
                V.viewport.set(e / 2, 0, e / 2, f);
                B.start();
                g.dispatchEvent({ type: "sessionstart" });
            }
            else
                g.enabled &&
                    a.setDrawingBufferSize(C.width, C.height, Cb), B.stop(), g.dispatchEvent({ type: "sessionend" });
        }
        function d(a, b) { null !== b && 4 === b.length && a.set(b[0] * e, b[1] * f, b[2] * e, b[3] * f); }
        var e, f, g = this, h = null, l = null, m = null, q = [], u = new U, k = new U, r = 1, p = "local-floor";
        "undefined" !== typeof window && "VRFrameData" in window && (l = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", c, !1));
        var v = new U, x = new ua, z = new n, y = new na;
        y.viewport = new aa;
        y.layers.enable(1);
        var V = new na;
        V.viewport = new aa;
        V.layers.enable(2);
        var P = new Jd([y, V]);
        P.layers.enable(1);
        P.layers.enable(2);
        var C = new w, Cb, A = [];
        this.enabled = !1;
        this.getController = function (a) { var b = q[a]; void 0 === b && (b = new Hc, b.matrixAutoUpdate = !1, b.visible = !1, q[a] = b); return b; };
        this.getDevice = function () { return h; };
        this.setDevice = function (a) { void 0 !== a && (h = a); B.setContext(a); };
        this.setFramebufferScaleFactor = function (a) { r = a; };
        this.setReferenceSpaceType = function (a) { p = a; };
        this.setPoseTarget = function (a) { void 0 !== a && (m = a); };
        this.getCamera = function (a) {
            var c = "local-floor" === p ?
                1.6 : 0;
            if (!1 === b())
                return a.position.set(0, c, 0), a.rotation.set(0, 0, 0), a;
            h.depthNear = a.near;
            h.depthFar = a.far;
            h.getFrameData(l);
            if ("local-floor" === p) {
                var e = h.stageParameters;
                e ? u.fromArray(e.sittingToStandingTransform) : u.makeTranslation(0, c, 0);
            }
            c = l.pose;
            e = null !== m ? m : a;
            e.matrix.copy(u);
            e.matrix.decompose(e.position, e.quaternion, e.scale);
            null !== c.orientation && (x.fromArray(c.orientation), e.quaternion.multiply(x));
            null !== c.position && (x.setFromRotationMatrix(u), z.fromArray(c.position), z.applyQuaternion(x),
                e.position.add(z));
            e.updateMatrixWorld();
            y.near = a.near;
            V.near = a.near;
            y.far = a.far;
            V.far = a.far;
            y.matrixWorldInverse.fromArray(l.leftViewMatrix);
            V.matrixWorldInverse.fromArray(l.rightViewMatrix);
            k.getInverse(u);
            "local-floor" === p && (y.matrixWorldInverse.multiply(k), V.matrixWorldInverse.multiply(k));
            a = e.parent;
            null !== a && (v.getInverse(a.matrixWorld), y.matrixWorldInverse.multiply(v), V.matrixWorldInverse.multiply(v));
            y.matrixWorld.getInverse(y.matrixWorldInverse);
            V.matrixWorld.getInverse(V.matrixWorldInverse);
            y.projectionMatrix.fromArray(l.leftProjectionMatrix);
            V.projectionMatrix.fromArray(l.rightProjectionMatrix);
            Lh(P, y, V);
            a = h.getLayers();
            a.length && (a = a[0], d(y.viewport, a.leftBounds), d(V.viewport, a.rightBounds));
            a: for (a = 0; a < q.length; a++) {
                c = q[a];
                b: {
                    e = a;
                    for (var f = navigator.getGamepads && navigator.getGamepads(), g = 0, r = 0, t = f.length; g < t; g++) {
                        var n = f[g];
                        if (n && ("Daydream Controller" === n.id || "Gear VR Controller" === n.id || "Oculus Go Controller" === n.id || "OpenVR Gamepad" === n.id || n.id.startsWith("Oculus Touch") || n.id.startsWith("HTC Vive Focus") ||
                            n.id.startsWith("Spatial Controller"))) {
                            if (r === e) {
                                e = n;
                                break b;
                            }
                            r++;
                        }
                    }
                    e = void 0;
                }
                if (void 0 !== e && void 0 !== e.pose) {
                    if (null === e.pose)
                        break a;
                    f = e.pose;
                    !1 === f.hasPosition && c.position.set(.2, -.6, -.05);
                    null !== f.position && c.position.fromArray(f.position);
                    null !== f.orientation && c.quaternion.fromArray(f.orientation);
                    c.matrix.compose(c.position, c.quaternion, c.scale);
                    c.matrix.premultiply(u);
                    c.matrix.decompose(c.position, c.quaternion, c.scale);
                    c.matrixWorldNeedsUpdate = !0;
                    c.visible = !0;
                    f = "Daydream Controller" === e.id ? 0 :
                        1;
                    void 0 === A[a] && (A[a] = !1);
                    A[a] !== e.buttons[f].pressed && (A[a] = e.buttons[f].pressed, !0 === A[a] ? c.dispatchEvent({ type: "selectstart" }) : (c.dispatchEvent({ type: "selectend" }), c.dispatchEvent({ type: "select" })));
                }
                else
                    c.visible = !1;
            }
            return P;
        };
        this.getStandingMatrix = function () { return u; };
        this.isPresenting = b;
        var B = new Xf;
        this.setAnimationLoop = function (a) { B.setAnimationLoop(a); b() && B.start(); };
        this.submitFrame = function () { b() && h.submitFrame(); };
        this.dispose = function () {
            "undefined" !== typeof window && window.removeEventListener("vrdisplaypresentchange", c);
        };
        this.setFrameOfReferenceType = function () { console.warn("THREE.WebVRManager: setFrameOfReferenceType() has been deprecated."); };
    }
    function Oh(a, b) {
        function c() { return null !== l && null !== m; }
        function d(a) { for (var b = 0; b < k.length; b++)
            r[b] === a.inputSource && k[b].dispatchEvent({ type: a.type }); }
        function e() { a.setFramebuffer(null); a.setRenderTarget(a.getRenderTarget()); y.stop(); h.dispatchEvent({ type: "sessionend" }); }
        function f(a) { m = a; y.setContext(l); y.start(); h.dispatchEvent({ type: "sessionstart" }); }
        function g(a, b) {
            null ===
                b ? a.matrixWorld.copy(a.matrix) : a.matrixWorld.multiplyMatrices(b.matrixWorld, a.matrix);
            a.matrixWorldInverse.getInverse(a.matrixWorld);
        }
        var h = this, l = null, m = null, q = "local-floor", u = null, k = [], r = [], p = new na;
        p.layers.enable(1);
        p.viewport = new aa;
        var n = new na;
        n.layers.enable(2);
        n.viewport = new aa;
        var x = new Jd([p, n]);
        x.layers.enable(1);
        x.layers.enable(2);
        this.enabled = !1;
        this.getController = function (a) { var b = k[a]; void 0 === b && (b = new Hc, b.matrixAutoUpdate = !1, b.visible = !1, k[a] = b); return b; };
        this.setFramebufferScaleFactor =
            function () { };
        this.setReferenceSpaceType = function (a) { q = a; };
        this.getSession = function () { return l; };
        this.setSession = function (a) {
            l = a;
            null !== l && (l.addEventListener("select", d), l.addEventListener("selectstart", d), l.addEventListener("selectend", d), l.addEventListener("end", e), l.updateRenderState({ baseLayer: new XRWebGLLayer(l, b) }), l.requestReferenceSpace(q).then(f), r = l.inputSources, l.addEventListener("inputsourceschange", function () {
                r = l.inputSources;
                console.log(r);
                for (var a = 0; a < k.length; a++)
                    k[a].userData.inputSource =
                        r[a];
            }));
        };
        this.getCamera = function (a) { if (c()) {
            var b = a.parent, d = x.cameras;
            g(x, b);
            for (var e = 0; e < d.length; e++)
                g(d[e], b);
            a.matrixWorld.copy(x.matrixWorld);
            a = a.children;
            e = 0;
            for (b = a.length; e < b; e++)
                a[e].updateMatrixWorld(!0);
            Lh(x, p, n);
            return x;
        } return a; };
        this.isPresenting = c;
        var z = null, y = new Xf;
        y.setAnimationLoop(function (b, c) {
            u = c.getViewerPose(m);
            if (null !== u) {
                var d = u.views, e = l.renderState.baseLayer;
                a.setFramebuffer(e.framebuffer);
                for (var f = 0; f < d.length; f++) {
                    var g = d[f], h = e.getViewport(g), q = x.cameras[f];
                    q.matrix.fromArray(g.transform.inverse.matrix).getInverse(q.matrix);
                    q.projectionMatrix.fromArray(g.projectionMatrix);
                    q.viewport.set(h.x, h.y, h.width, h.height);
                    0 === f && x.matrix.copy(q.matrix);
                }
            }
            for (f = 0; f < k.length; f++) {
                d = k[f];
                if (e = r[f])
                    if (e = c.getPose(e.targetRaySpace, m), null !== e) {
                        d.matrix.fromArray(e.transform.matrix);
                        d.matrix.decompose(d.position, d.rotation, d.scale);
                        d.visible = !0;
                        continue;
                    }
                d.visible = !1;
            }
            z && z(b);
        });
        this.setAnimationLoop = function (a) { z = a; };
        this.dispose = function () { };
        this.getStandingMatrix = function () {
            console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed.");
            return new U;
        };
        this.getDevice = function () { console.warn("THREE.WebXRManager: getDevice() has been deprecated."); };
        this.setDevice = function () { console.warn("THREE.WebXRManager: setDevice() has been deprecated."); };
        this.setFrameOfReferenceType = function () { console.warn("THREE.WebXRManager: setFrameOfReferenceType() has been deprecated."); };
        this.submitFrame = function () { };
    }
    function hg(a) {
        var b;
        function c() {
            ra = new aj(J);
            Ea = new Zi(J, ra, a);
            !1 === Ea.isWebGL2 && (ra.get("WEBGL_depth_texture"), ra.get("OES_texture_float"),
                ra.get("OES_texture_half_float"), ra.get("OES_texture_half_float_linear"), ra.get("OES_standard_derivatives"), ra.get("OES_element_index_uint"), ra.get("ANGLE_instanced_arrays"));
            ra.get("OES_texture_float_linear");
            la = new Kh(J, ra, Ea);
            ba = new ik(J, ra, la, Ea);
            ba.scissor(ca.copy(ja).multiplyScalar(fa).floor());
            ba.viewport(W.copy(ia).multiplyScalar(fa).floor());
            ea = new dj(J);
            Y = new Zj;
            R = new jk(J, ra, ba, Y, Ea, la, ea);
            pa = new Wi(J);
            xa = new bj(J, pa, ea);
            sa = new gj(J, xa, pa, ea);
            ya = new fj(J);
            oa = new Yj(F, ra, Ea);
            va = new ck;
            ua =
                new hk;
            ma = new Xi(F, ba, sa, A);
            Aa = new Yi(J, ra, ea, Ea);
            Ba = new cj(J, ra, ea, Ea);
            ea.programs = oa.programs;
            F.capabilities = Ea;
            F.extensions = ra;
            F.properties = Y;
            F.renderLists = va;
            F.state = ba;
            F.info = ea;
        }
        function d(a) { a.preventDefault(); console.log("THREE.WebGLRenderer: Context Lost."); O = !0; }
        function e() { console.log("THREE.WebGLRenderer: Context Restored."); O = !1; c(); }
        function f(a) { a = a.target; a.removeEventListener("dispose", f); g(a); Y.remove(a); }
        function g(a) { var b = Y.get(a).program; a.program = void 0; void 0 !== b && oa.releaseProgram(b); }
        function h(a, b) { a.render(function (a) { F.renderBufferImmediate(a, b); }); }
        function l(a, b, c, d) {
            if (!1 !== a.visible) {
                if (a.layers.test(b.layers))
                    if (a.isGroup)
                        c = a.renderOrder;
                    else if (a.isLOD)
                        !0 === a.autoUpdate && a.update(b);
                    else if (a.isLight)
                        D.pushLight(a), a.castShadow && D.pushShadow(a);
                    else if (a.isSprite) {
                        if (!a.frustumCulled || cg.intersectsSprite(a)) {
                            d && Fb.setFromMatrixPosition(a.matrixWorld).applyMatrix4(Id);
                            var e = sa.update(a), f = a.material;
                            f.visible && G.push(a, e, f, c, Fb.z, null);
                        }
                    }
                    else if (a.isImmediateRenderObject)
                        d &&
                            Fb.setFromMatrixPosition(a.matrixWorld).applyMatrix4(Id), G.push(a, null, a.material, c, Fb.z, null);
                    else if (a.isMesh || a.isLine || a.isPoints)
                        if (a.isSkinnedMesh && a.skeleton.frame !== ea.render.frame && (a.skeleton.update(), a.skeleton.frame = ea.render.frame), !a.frustumCulled || cg.intersectsObject(a))
                            if (d && Fb.setFromMatrixPosition(a.matrixWorld).applyMatrix4(Id), e = sa.update(a), f = a.material, Array.isArray(f))
                                for (var g = e.groups, h = 0, m = g.length; h < m; h++) {
                                    var q = g[h], k = f[q.materialIndex];
                                    k && k.visible && G.push(a, e, k, c, Fb.z, q);
                                }
                            else
                                f.visible && G.push(a, e, f, c, Fb.z, null);
                a = a.children;
                h = 0;
                for (m = a.length; h < m; h++)
                    l(a[h], b, c, d);
            }
        }
        function m(a, b, c, d) { for (var e = 0, f = a.length; e < f; e++) {
            var g = a[e], h = g.object, l = g.geometry, m = void 0 === d ? g.material : d;
            g = g.group;
            if (c.isArrayCamera)
                if (Pa = c, ka.enabled && ta.isAvailable())
                    q(h, b, c, l, m, g);
                else
                    for (var k = c.cameras, u = 0, p = k.length; u < p; u++) {
                        var r = k[u];
                        h.layers.test(r.layers) && (ba.viewport(W.copy(r.viewport)), D.setupLights(r), q(h, b, r, l, m, g));
                    }
            else
                Pa = null, q(h, b, c, l, m, g);
        } }
        function q(a, c, d, e, f, g) {
            a.onBeforeRender(F, c, d, e, f, g);
            D = ua.get(c, Pa || d);
            a.modelViewMatrix.multiplyMatrices(d.matrixWorldInverse, a.matrixWorld);
            a.normalMatrix.getNormalMatrix(a.modelViewMatrix);
            if (a.isImmediateRenderObject) {
                ba.setMaterial(f);
                var l = k(d, c.fog, f, a);
                bc = b = null;
                S = !1;
                h(a, l);
            }
            else
                F.renderBufferDirect(d, c.fog, e, f, a, g);
            a.onAfterRender(F, c, d, e, f, g);
            D = ua.get(c, Pa || d);
        }
        function u(a, b, c) {
            var d = Y.get(a), e = D.state.lights, h = e.state.version;
            c = oa.getParameters(a, e.state, D.state.shadowsArray, b, Oa.numPlanes, Oa.numIntersection, c);
            var l = oa.getProgramCode(a, c), m = d.program, q = !0;
            if (void 0 === m)
                a.addEventListener("dispose", f);
            else if (m.code !== l)
                g(a);
            else {
                if (d.lightsStateVersion !== h)
                    d.lightsStateVersion = h;
                else if (void 0 !== c.shaderID)
                    return;
                q = !1;
            }
            q && (c.shaderID ? (l = db[c.shaderID], d.shader = { name: a.type, uniforms: Yb(l.uniforms), vertexShader: l.vertexShader, fragmentShader: l.fragmentShader }) : d.shader = { name: a.type, uniforms: a.uniforms, vertexShader: a.vertexShader, fragmentShader: a.fragmentShader }, a.onBeforeCompile(d.shader, F), l = oa.getProgramCode(a, c), m = oa.acquireProgram(a, d.shader, c, l), d.program = m, a.program = m);
            c = m.getAttributes();
            if (a.morphTargets)
                for (l = a.numSupportedMorphTargets = 0; l < F.maxMorphTargets; l++)
                    0 <= c["morphTarget" + l] && a.numSupportedMorphTargets++;
            if (a.morphNormals)
                for (l = a.numSupportedMorphNormals = 0; l < F.maxMorphNormals; l++)
                    0 <= c["morphNormal" + l] && a.numSupportedMorphNormals++;
            c = d.shader.uniforms;
            if (!a.isShaderMaterial && !a.isRawShaderMaterial || !0 === a.clipping)
                d.numClippingPlanes = Oa.numPlanes, d.numIntersection = Oa.numIntersection, c.clippingPlanes = Oa.uniform;
            d.fog =
                b;
            d.needsLights = a.isMeshLambertMaterial || a.isMeshPhongMaterial || a.isMeshStandardMaterial || a.isShadowMaterial || a.isShaderMaterial && !0 === a.lights;
            d.lightsStateVersion = h;
            d.needsLights && (c.ambientLightColor.value = e.state.ambient, c.lightProbe.value = e.state.probe, c.directionalLights.value = e.state.directional, c.spotLights.value = e.state.spot, c.rectAreaLights.value = e.state.rectArea, c.pointLights.value = e.state.point, c.hemisphereLights.value = e.state.hemi, c.directionalShadowMap.value = e.state.directionalShadowMap,
                c.directionalShadowMatrix.value = e.state.directionalShadowMatrix, c.spotShadowMap.value = e.state.spotShadowMap, c.spotShadowMatrix.value = e.state.spotShadowMatrix, c.pointShadowMap.value = e.state.pointShadowMap, c.pointShadowMatrix.value = e.state.pointShadowMatrix);
            a = d.program.getUniforms();
            a = Bb.seqWithValue(a.seq, c);
            d.uniformsList = a;
        }
        function k(a, b, c, d) {
            R.resetTextureUnits();
            var e = Y.get(c), f = D.state.lights;
            He && (qa || a !== Q) && Oa.setState(c.clippingPlanes, c.clipIntersection, c.clipShadows, a, e, a === Q && c.id === ha);
            !1 === c.needsUpdate && (void 0 === e.program ? c.needsUpdate = !0 : c.fog && e.fog !== b ? c.needsUpdate = !0 : e.needsLights && e.lightsStateVersion !== f.state.version ? c.needsUpdate = !0 : void 0 === e.numClippingPlanes || e.numClippingPlanes === Oa.numPlanes && e.numIntersection === Oa.numIntersection || (c.needsUpdate = !0));
            c.needsUpdate && (u(c, b, d), c.needsUpdate = !1);
            var g = !1, h = !1, l = !1;
            f = e.program;
            var m = f.getUniforms(), q = e.shader.uniforms;
            ba.useProgram(f.program) && (l = h = g = !0);
            c.id !== ha && (ha = c.id, h = !0);
            if (g || Q !== a) {
                0 < f.numMultiviewViews ?
                    ta.updateCameraProjectionMatricesUniform(a, m) : m.setValue(J, "projectionMatrix", a.projectionMatrix);
                Ea.logarithmicDepthBuffer && m.setValue(J, "logDepthBufFC", 2 / (Math.log(a.far + 1) / Math.LN2));
                Q !== a && (Q = a, l = h = !0);
                if (c.isShaderMaterial || c.isMeshPhongMaterial || c.isMeshStandardMaterial || c.envMap)
                    g = m.map.cameraPosition, void 0 !== g && g.setValue(J, Fb.setFromMatrixPosition(a.matrixWorld));
                if (c.isMeshPhongMaterial || c.isMeshLambertMaterial || c.isMeshBasicMaterial || c.isMeshStandardMaterial || c.isShaderMaterial || c.skinning)
                    0 <
                        f.numMultiviewViews ? ta.updateCameraViewMatricesUniform(a, m) : m.setValue(J, "viewMatrix", a.matrixWorldInverse);
            }
            if (c.skinning && (m.setOptional(J, d, "bindMatrix"), m.setOptional(J, d, "bindMatrixInverse"), g = d.skeleton)) {
                var k = g.bones;
                if (Ea.floatVertexTextures) {
                    if (void 0 === g.boneTexture) {
                        k = Math.sqrt(4 * k.length);
                        k = L.ceilPowerOfTwo(k);
                        k = Math.max(k, 4);
                        var t = new Float32Array(k * k * 4);
                        t.set(g.boneMatrices);
                        var n = new Zb(t, k, k, 1023, 1015);
                        g.boneMatrices = t;
                        g.boneTexture = n;
                        g.boneTextureSize = k;
                    }
                    m.setValue(J, "boneTexture", g.boneTexture, R);
                    m.setValue(J, "boneTextureSize", g.boneTextureSize);
                }
                else
                    m.setOptional(J, g, "boneMatrices");
            }
            if (h || e.receiveShadow !== d.receiveShadow)
                e.receiveShadow = d.receiveShadow, m.setValue(J, "receiveShadow", d.receiveShadow);
            h && (m.setValue(J, "toneMappingExposure", F.toneMappingExposure), m.setValue(J, "toneMappingWhitePoint", F.toneMappingWhitePoint), e.needsLights && (h = l, q.ambientLightColor.needsUpdate = h, q.lightProbe.needsUpdate = h, q.directionalLights.needsUpdate = h, q.pointLights.needsUpdate = h, q.spotLights.needsUpdate =
                h, q.rectAreaLights.needsUpdate = h, q.hemisphereLights.needsUpdate = h), b && c.fog && (q.fogColor.value.copy(b.color), b.isFog ? (q.fogNear.value = b.near, q.fogFar.value = b.far) : b.isFogExp2 && (q.fogDensity.value = b.density)), c.isMeshBasicMaterial ? r(q, c) : c.isMeshLambertMaterial ? (r(q, c), c.emissiveMap && (q.emissiveMap.value = c.emissiveMap)) : c.isMeshPhongMaterial ? (r(q, c), c.isMeshToonMaterial ? (p(q, c), c.gradientMap && (q.gradientMap.value = c.gradientMap)) : p(q, c)) : c.isMeshStandardMaterial ? (r(q, c), c.isMeshPhysicalMaterial ? (v(q, c), q.reflectivity.value = c.reflectivity, q.clearcoat.value = c.clearcoat, q.clearcoatRoughness.value = c.clearcoatRoughness, c.sheen && q.sheen.value.copy(c.sheen), c.clearcoatNormalMap && (q.clearcoatNormalScale.value.copy(c.clearcoatNormalScale), q.clearcoatNormalMap.value = c.clearcoatNormalMap, 1 === c.side && q.clearcoatNormalScale.value.negate()), q.transparency.value = c.transparency) : v(q, c)) : c.isMeshMatcapMaterial ? (r(q, c), c.matcap && (q.matcap.value = c.matcap), c.bumpMap && (q.bumpMap.value = c.bumpMap, q.bumpScale.value =
                c.bumpScale, 1 === c.side && (q.bumpScale.value *= -1)), c.normalMap && (q.normalMap.value = c.normalMap, q.normalScale.value.copy(c.normalScale), 1 === c.side && q.normalScale.value.negate()), c.displacementMap && (q.displacementMap.value = c.displacementMap, q.displacementScale.value = c.displacementScale, q.displacementBias.value = c.displacementBias)) : c.isMeshDepthMaterial ? (r(q, c), c.displacementMap && (q.displacementMap.value = c.displacementMap, q.displacementScale.value = c.displacementScale, q.displacementBias.value = c.displacementBias)) :
                c.isMeshDistanceMaterial ? (r(q, c), c.displacementMap && (q.displacementMap.value = c.displacementMap, q.displacementScale.value = c.displacementScale, q.displacementBias.value = c.displacementBias), q.referencePosition.value.copy(c.referencePosition), q.nearDistance.value = c.nearDistance, q.farDistance.value = c.farDistance) : c.isMeshNormalMaterial ? (r(q, c), c.bumpMap && (q.bumpMap.value = c.bumpMap, q.bumpScale.value = c.bumpScale, 1 === c.side && (q.bumpScale.value *= -1)), c.normalMap && (q.normalMap.value = c.normalMap, q.normalScale.value.copy(c.normalScale),
                    1 === c.side && q.normalScale.value.negate()), c.displacementMap && (q.displacementMap.value = c.displacementMap, q.displacementScale.value = c.displacementScale, q.displacementBias.value = c.displacementBias)) : c.isLineBasicMaterial ? (q.diffuse.value.copy(c.color), q.opacity.value = c.opacity, c.isLineDashedMaterial && (q.dashSize.value = c.dashSize, q.totalSize.value = c.dashSize + c.gapSize, q.scale.value = c.scale)) : c.isPointsMaterial ? (q.diffuse.value.copy(c.color), q.opacity.value = c.opacity, q.size.value = c.size * fa, q.scale.value =
                    .5 * Z, q.map.value = c.map, null !== c.map && (!0 === c.map.matrixAutoUpdate && c.map.updateMatrix(), q.uvTransform.value.copy(c.map.matrix))) : c.isSpriteMaterial ? (q.diffuse.value.copy(c.color), q.opacity.value = c.opacity, q.rotation.value = c.rotation, q.map.value = c.map, null !== c.map && (!0 === c.map.matrixAutoUpdate && c.map.updateMatrix(), q.uvTransform.value.copy(c.map.matrix))) : c.isShadowMaterial && (q.color.value.copy(c.color), q.opacity.value = c.opacity), void 0 !== q.ltc_1 && (q.ltc_1.value = I.LTC_1), void 0 !== q.ltc_2 && (q.ltc_2.value =
                I.LTC_2), Bb.upload(J, e.uniformsList, q, R));
            c.isShaderMaterial && !0 === c.uniformsNeedUpdate && (Bb.upload(J, e.uniformsList, q, R), c.uniformsNeedUpdate = !1);
            c.isSpriteMaterial && m.setValue(J, "center", d.center);
            0 < f.numMultiviewViews ? ta.updateObjectMatricesUniforms(d, a, m) : (m.setValue(J, "modelViewMatrix", d.modelViewMatrix), m.setValue(J, "normalMatrix", d.normalMatrix));
            m.setValue(J, "modelMatrix", d.matrixWorld);
            return f;
        }
        function r(a, b) {
            a.opacity.value = b.opacity;
            b.color && a.diffuse.value.copy(b.color);
            b.emissive && a.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity);
            b.map && (a.map.value = b.map);
            b.alphaMap && (a.alphaMap.value = b.alphaMap);
            b.specularMap && (a.specularMap.value = b.specularMap);
            b.envMap && (a.envMap.value = b.envMap, a.flipEnvMap.value = b.envMap.isCubeTexture ? -1 : 1, a.reflectivity.value = b.reflectivity, a.refractionRatio.value = b.refractionRatio, a.maxMipLevel.value = Y.get(b.envMap).__maxMipLevel);
            b.lightMap && (a.lightMap.value = b.lightMap, a.lightMapIntensity.value = b.lightMapIntensity);
            b.aoMap && (a.aoMap.value = b.aoMap, a.aoMapIntensity.value = b.aoMapIntensity);
            if (b.map)
                var c = b.map;
            else
                b.specularMap ? c = b.specularMap : b.displacementMap ? c = b.displacementMap : b.normalMap ? c = b.normalMap : b.bumpMap ? c = b.bumpMap : b.roughnessMap ? c = b.roughnessMap : b.metalnessMap ? c = b.metalnessMap : b.alphaMap ? c = b.alphaMap : b.emissiveMap && (c = b.emissiveMap);
            void 0 !== c && (c.isWebGLRenderTarget && (c = c.texture), !0 === c.matrixAutoUpdate && c.updateMatrix(), a.uvTransform.value.copy(c.matrix));
        }
        function p(a, b) {
            a.specular.value.copy(b.specular);
            a.shininess.value = Math.max(b.shininess, 1E-4);
            b.emissiveMap && (a.emissiveMap.value =
                b.emissiveMap);
            b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale, 1 === b.side && (a.bumpScale.value *= -1));
            b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale), 1 === b.side && a.normalScale.value.negate());
            b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias);
        }
        function v(a, b) {
            a.roughness.value = b.roughness;
            a.metalness.value = b.metalness;
            b.roughnessMap && (a.roughnessMap.value =
                b.roughnessMap);
            b.metalnessMap && (a.metalnessMap.value = b.metalnessMap);
            b.emissiveMap && (a.emissiveMap.value = b.emissiveMap);
            b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale, 1 === b.side && (a.bumpScale.value *= -1));
            b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale), 1 === b.side && a.normalScale.value.negate());
            b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias);
            b.envMap && (a.envMapIntensity.value = b.envMapIntensity);
        }
        a = a || {};
        var x = void 0 !== a.canvas ? a.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), z = void 0 !== a.context ? a.context : null, y = void 0 !== a.alpha ? a.alpha : !1, V = void 0 !== a.depth ? a.depth : !0, P = void 0 !== a.stencil ? a.stencil : !0, C = void 0 !== a.antialias ? a.antialias : !1, A = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0, B = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1, E = void 0 !== a.powerPreference ? a.powerPreference : "default", H = void 0 !== a.failIfMajorPerformanceCaveat ? a.failIfMajorPerformanceCaveat : !1, G = null, D = null;
        this.domElement = x;
        this.debug = { checkShaderErrors: !0 };
        this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
        this.clippingPlanes = [];
        this.localClippingEnabled = !1;
        this.gammaFactor = 2;
        this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1;
        this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1;
        this.maxMorphTargets = 8;
        this.maxMorphNormals = 4;
        var F = this, O = !1, M = null, T = 0, X = 0, N = null, ac = null, ha = -1;
        var bc = b = null;
        var S = !1;
        var Q = null, Pa = null, W = new aa, ca = new aa, da = null, K = x.width, Z = x.height, fa = 1, ia = new aa(0, 0, K, Z), ja = new aa(0, 0, K, Z), na = !1, cg = new Ed, Oa = new $i, He = !1, qa = !1, Id = new U, Fb = new n;
        try {
            y = { alpha: y, depth: V, stencil: P, antialias: C, premultipliedAlpha: A, preserveDrawingBuffer: B, powerPreference: E, failIfMajorPerformanceCaveat: H, xrCompatible: !0 };
            x.addEventListener("webglcontextlost", d, !1);
            x.addEventListener("webglcontextrestored", e, !1);
            var J = z || x.getContext("webgl", y) || x.getContext("experimental-webgl", y);
            if (null === J) {
                if (null !== x.getContext("webgl"))
                    throw Error("Error creating WebGL context with your selected attributes.");
                throw Error("Error creating WebGL context.");
            }
            void 0 === J.getShaderPrecisionFormat && (J.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 }; });
        }
        catch (Ph) {
            throw console.error("THREE.WebGLRenderer: " + Ph.message), Ph;
        }
        var ra, Ea, ba, ea, Y, R, pa, xa, sa, oa, va, ua, ma, ya, Aa, Ba, la;
        c();
        var ka = "undefined" !== typeof navigator && "xr" in navigator &&
            "supportsSession" in navigator.xr ? new Oh(F, J) : new gg(F);
        this.vr = ka;
        var ta = new kk(F, J), Da = new Jh(F, sa, Ea.maxTextureSize);
        this.shadowMap = Da;
        this.getContext = function () { return J; };
        this.getContextAttributes = function () { return J.getContextAttributes(); };
        this.forceContextLoss = function () { var a = ra.get("WEBGL_lose_context"); a && a.loseContext(); };
        this.forceContextRestore = function () { var a = ra.get("WEBGL_lose_context"); a && a.restoreContext(); };
        this.getPixelRatio = function () { return fa; };
        this.setPixelRatio = function (a) {
            void 0 !==
                a && (fa = a, this.setSize(K, Z, !1));
        };
        this.getSize = function (a) { void 0 === a && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), a = new w); return a.set(K, Z); };
        this.setSize = function (a, b, c) { ka.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (K = a, Z = b, x.width = Math.floor(a * fa), x.height = Math.floor(b * fa), !1 !== c && (x.style.width = a + "px", x.style.height = b + "px"), this.setViewport(0, 0, a, b)); };
        this.getDrawingBufferSize = function (a) {
            void 0 === a &&
                (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), a = new w);
            return a.set(K * fa, Z * fa).floor();
        };
        this.setDrawingBufferSize = function (a, b, c) { K = a; Z = b; fa = c; x.width = Math.floor(a * c); x.height = Math.floor(b * c); this.setViewport(0, 0, a, b); };
        this.getCurrentViewport = function (a) { void 0 === a && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), a = new aa); return a.copy(W); };
        this.getViewport = function (a) { return a.copy(ia); };
        this.setViewport = function (a, b, c, d) { a.isVector4 ? ia.set(a.x, a.y, a.z, a.w) : ia.set(a, b, c, d); ba.viewport(W.copy(ia).multiplyScalar(fa).floor()); };
        this.getScissor = function (a) { return a.copy(ja); };
        this.setScissor = function (a, b, c, d) { a.isVector4 ? ja.set(a.x, a.y, a.z, a.w) : ja.set(a, b, c, d); ba.scissor(ca.copy(ja).multiplyScalar(fa).floor()); };
        this.getScissorTest = function () { return na; };
        this.setScissorTest = function (a) { ba.setScissorTest(na = a); };
        this.getClearColor = function () { return ma.getClearColor(); };
        this.setClearColor = function () {
            ma.setClearColor.apply(ma, arguments);
        };
        this.getClearAlpha = function () { return ma.getClearAlpha(); };
        this.setClearAlpha = function () { ma.setClearAlpha.apply(ma, arguments); };
        this.clear = function (a, b, c) { var d = 0; if (void 0 === a || a)
            d |= 16384; if (void 0 === b || b)
            d |= 256; if (void 0 === c || c)
            d |= 1024; J.clear(d); };
        this.clearColor = function () { this.clear(!0, !1, !1); };
        this.clearDepth = function () { this.clear(!1, !0, !1); };
        this.clearStencil = function () { this.clear(!1, !1, !0); };
        this.dispose = function () {
            x.removeEventListener("webglcontextlost", d, !1);
            x.removeEventListener("webglcontextrestored", e, !1);
            va.dispose();
            ua.dispose();
            Y.dispose();
            sa.dispose();
            ka.dispose();
            za.stop();
        };
        this.renderBufferImmediate = function (a, b) {
            ba.initAttributes();
            var c = Y.get(a);
            a.hasPositions && !c.position && (c.position = J.createBuffer());
            a.hasNormals && !c.normal && (c.normal = J.createBuffer());
            a.hasUvs && !c.uv && (c.uv = J.createBuffer());
            a.hasColors && !c.color && (c.color = J.createBuffer());
            b = b.getAttributes();
            a.hasPositions && (J.bindBuffer(34962, c.position), J.bufferData(34962, a.positionArray, 35048), ba.enableAttribute(b.position),
                J.vertexAttribPointer(b.position, 3, 5126, !1, 0, 0));
            a.hasNormals && (J.bindBuffer(34962, c.normal), J.bufferData(34962, a.normalArray, 35048), ba.enableAttribute(b.normal), J.vertexAttribPointer(b.normal, 3, 5126, !1, 0, 0));
            a.hasUvs && (J.bindBuffer(34962, c.uv), J.bufferData(34962, a.uvArray, 35048), ba.enableAttribute(b.uv), J.vertexAttribPointer(b.uv, 2, 5126, !1, 0, 0));
            a.hasColors && (J.bindBuffer(34962, c.color), J.bufferData(34962, a.colorArray, 35048), ba.enableAttribute(b.color), J.vertexAttribPointer(b.color, 3, 5126, !1, 0, 0));
            ba.disableUnusedAttributes();
            J.drawArrays(4, 0, a.count);
            a.count = 0;
        };
        this.renderBufferDirect = function (a, c, d, e, f, g) {
            var h = f.isMesh && 0 > f.matrixWorld.determinant();
            ba.setMaterial(e, h);
            var l = k(a, c, e, f), m = !1;
            if (b !== d.id || bc !== l.id || S !== (!0 === e.wireframe))
                b = d.id, bc = l.id, S = !0 === e.wireframe, m = !0;
            f.morphTargetInfluences && (ya.update(f, d, e, l), m = !0);
            h = d.index;
            var q = d.attributes.position;
            c = 1;
            !0 === e.wireframe && (h = xa.getWireframeAttribute(d), c = 2);
            a = Aa;
            if (null !== h) {
                var u = pa.get(h);
                a = Ba;
                a.setIndex(u);
            }
            if (m) {
                if (!1 !== Ea.isWebGL2 ||
                    !f.isInstancedMesh && !d.isInstancedBufferGeometry || null !== ra.get("ANGLE_instanced_arrays")) {
                    ba.initAttributes();
                    m = d.attributes;
                    l = l.getAttributes();
                    var r = e.defaultAttributeValues;
                    for (w in l) {
                        var p = l[w];
                        if (0 <= p) {
                            var t = m[w];
                            if (void 0 !== t) {
                                var n = t.normalized, v = t.itemSize, x = pa.get(t);
                                if (void 0 !== x) {
                                    var y = x.buffer, z = x.type;
                                    x = x.bytesPerElement;
                                    if (t.isInterleavedBufferAttribute) {
                                        var C = t.data, V = C.stride;
                                        t = t.offset;
                                        C && C.isInstancedInterleavedBuffer ? (ba.enableAttributeAndDivisor(p, C.meshPerAttribute), void 0 ===
                                            d.maxInstancedCount && (d.maxInstancedCount = C.meshPerAttribute * C.count)) : ba.enableAttribute(p);
                                        J.bindBuffer(34962, y);
                                        J.vertexAttribPointer(p, v, z, n, V * x, t * x);
                                    }
                                    else
                                        t.isInstancedBufferAttribute ? (ba.enableAttributeAndDivisor(p, t.meshPerAttribute), void 0 === d.maxInstancedCount && (d.maxInstancedCount = t.meshPerAttribute * t.count)) : ba.enableAttribute(p), J.bindBuffer(34962, y), J.vertexAttribPointer(p, v, z, n, 0, 0);
                                }
                            }
                            else if ("instanceMatrix" === w)
                                x = pa.get(f.instanceMatrix), void 0 !== x && (y = x.buffer, z = x.type, ba.enableAttributeAndDivisor(p +
                                    0, 1), ba.enableAttributeAndDivisor(p + 1, 1), ba.enableAttributeAndDivisor(p + 2, 1), ba.enableAttributeAndDivisor(p + 3, 1), J.bindBuffer(34962, y), J.vertexAttribPointer(p + 0, 4, z, !1, 64, 0), J.vertexAttribPointer(p + 1, 4, z, !1, 64, 16), J.vertexAttribPointer(p + 2, 4, z, !1, 64, 32), J.vertexAttribPointer(p + 3, 4, z, !1, 64, 48));
                            else if (void 0 !== r && (n = r[w], void 0 !== n))
                                switch (n.length) {
                                    case 2:
                                        J.vertexAttrib2fv(p, n);
                                        break;
                                    case 3:
                                        J.vertexAttrib3fv(p, n);
                                        break;
                                    case 4:
                                        J.vertexAttrib4fv(p, n);
                                        break;
                                    default: J.vertexAttrib1fv(p, n);
                                }
                        }
                    }
                    ba.disableUnusedAttributes();
                }
                null !==
                    h && J.bindBuffer(34963, u.buffer);
            }
            u = Infinity;
            null !== h ? u = h.count : void 0 !== q && (u = q.count);
            h = d.drawRange.start * c;
            q = null !== g ? g.start * c : 0;
            var w = Math.max(h, q);
            g = Math.max(0, Math.min(u, h + d.drawRange.count * c, q + (null !== g ? g.count * c : Infinity)) - 1 - w + 1);
            if (0 !== g) {
                if (f.isMesh)
                    if (!0 === e.wireframe)
                        ba.setLineWidth(e.wireframeLinewidth * (null === N ? fa : 1)), a.setMode(1);
                    else
                        switch (f.drawMode) {
                            case 0:
                                a.setMode(4);
                                break;
                            case 1:
                                a.setMode(5);
                                break;
                            case 2: a.setMode(6);
                        }
                else
                    f.isLine ? (e = e.linewidth, void 0 === e && (e = 1), ba.setLineWidth(e *
                        (null === N ? fa : 1)), f.isLineSegments ? a.setMode(1) : f.isLineLoop ? a.setMode(2) : a.setMode(3)) : f.isPoints ? a.setMode(0) : f.isSprite && a.setMode(4);
                f.isInstancedMesh ? a.renderInstances(d, w, g, f.count) : d.isInstancedBufferGeometry ? a.renderInstances(d, w, g, d.maxInstancedCount) : a.render(w, g);
            }
        };
        this.compile = function (a, b) {
            D = ua.get(a, b);
            D.init();
            a.traverse(function (a) { a.isLight && (D.pushLight(a), a.castShadow && D.pushShadow(a)); });
            D.setupLights(b);
            a.traverse(function (b) {
                if (b.material)
                    if (Array.isArray(b.material))
                        for (var c = 0; c < b.material.length; c++)
                            u(b.material[c], a.fog, b);
                    else
                        u(b.material, a.fog, b);
            });
        };
        var Ca = null, za = new Xf;
        za.setAnimationLoop(function (a) { ka.isPresenting() || Ca && Ca(a); });
        "undefined" !== typeof window && za.setContext(window);
        this.setAnimationLoop = function (a) { Ca = a; ka.setAnimationLoop(a); za.start(); };
        this.render = function (a, c, d, e) {
            if (void 0 !== d) {
                console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
                var f = d;
            }
            if (void 0 !== e) {
                console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
                var g = e;
            }
            c && c.isCamera ? O || (bc = b = null, S = !1, ha = -1, Q = null, !0 === a.autoUpdate && a.updateMatrixWorld(), null === c.parent && c.updateMatrixWorld(), ka.enabled && (c = ka.getCamera(c)), D = ua.get(a, c), D.init(), a.onBeforeRender(F, a, c, f || N), Id.multiplyMatrices(c.projectionMatrix, c.matrixWorldInverse), cg.setFromMatrix(Id), qa = this.localClippingEnabled, He = Oa.init(this.clippingPlanes, qa, c), G = va.get(a, c), G.init(), l(a, c, 0, F.sortObjects), !0 === F.sortObjects && G.sort(), He && Oa.beginShadows(), Da.render(D.state.shadowsArray, a, c), D.setupLights(c),
                He && Oa.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== f && this.setRenderTarget(f), ka.enabled && ta.isAvailable() && ta.attachCamera(c), ma.render(G, a, c, g), d = G.opaque, e = G.transparent, a.overrideMaterial ? (f = a.overrideMaterial, d.length && m(d, a, c, f), e.length && m(e, a, c, f)) : (d.length && m(d, a, c), e.length && m(e, a, c)), a.onAfterRender(F, a, c), null !== N && (R.updateRenderTargetMipmap(N), R.updateMultisampleRenderTarget(N)), ba.buffers.depth.setTest(!0), ba.buffers.depth.setMask(!0), ba.buffers.color.setMask(!0),
                ba.setPolygonOffset(!1), ka.enabled && (ta.isAvailable() && ta.detachCamera(c), ka.submitFrame()), D = G = null) : console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        };
        this.setFramebuffer = function (a) { M !== a && J.bindFramebuffer(36160, a); M = a; };
        this.getActiveCubeFace = function () { return T; };
        this.getActiveMipmapLevel = function () { return X; };
        this.getRenderTarget = function () { return N; };
        this.setRenderTarget = function (a, b, c) {
            N = a;
            T = b;
            X = c;
            a && void 0 === Y.get(a).__webglFramebuffer && R.setupRenderTarget(a);
            var d = M, e = !1;
            a ? (d = Y.get(a).__webglFramebuffer, a.isWebGLRenderTargetCube ? (d = d[b || 0], e = !0) : d = a.isWebGLMultisampleRenderTarget ? Y.get(a).__webglMultisampledFramebuffer : d, W.copy(a.viewport), ca.copy(a.scissor), da = a.scissorTest) : (W.copy(ia).multiplyScalar(fa).floor(), ca.copy(ja).multiplyScalar(fa).floor(), da = na);
            ac !== d && (J.bindFramebuffer(36160, d), ac = d);
            ba.viewport(W);
            ba.scissor(ca);
            ba.setScissorTest(da);
            e && (a = Y.get(a.texture), J.framebufferTexture2D(36160, 36064, 34069 + (b || 0), a.__webglTexture, c || 0));
        };
        this.readRenderTargetPixels =
            function (a, b, c, d, e, f, g) {
                if (a && a.isWebGLRenderTarget) {
                    var h = Y.get(a).__webglFramebuffer;
                    a.isWebGLRenderTargetCube && void 0 !== g && (h = h[g]);
                    if (h) {
                        g = !1;
                        h !== ac && (J.bindFramebuffer(36160, h), g = !0);
                        try {
                            var l = a.texture, m = l.format, q = l.type;
                            1023 !== m && la.convert(m) !== J.getParameter(35739) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === q || la.convert(q) === J.getParameter(35738) || 1015 === q && (Ea.isWebGL2 || ra.get("OES_texture_float") ||
                                ra.get("WEBGL_color_buffer_float")) || 1016 === q && (Ea.isWebGL2 ? ra.get("EXT_color_buffer_float") : ra.get("EXT_color_buffer_half_float")) ? 36053 === J.checkFramebufferStatus(36160) ? 0 <= b && b <= a.width - d && 0 <= c && c <= a.height - e && J.readPixels(b, c, d, e, la.convert(m), la.convert(q), f) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        }
                        finally {
                            g &&
                                J.bindFramebuffer(36160, ac);
                        }
                    }
                }
                else
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            };
        this.copyFramebufferToTexture = function (a, b, c) { var d = b.image.width, e = b.image.height, f = la.convert(b.format); R.setTexture2D(b, 0); J.copyTexImage2D(3553, c || 0, f, a.x, a.y, d, e, 0); };
        this.copyTextureToTexture = function (a, b, c, d) {
            var e = b.image.width, f = b.image.height, g = la.convert(c.format), h = la.convert(c.type);
            R.setTexture2D(c, 0);
            b.isDataTexture ? J.texSubImage2D(3553, d || 0, a.x, a.y, e, f, g, h, b.image.data) : J.texSubImage2D(3553, d || 0, a.x, a.y, g, h, b.image);
        };
        "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
    function Ie(a, b) { this.name = ""; this.color = new H(a); this.density = void 0 !== b ? b : 2.5E-4; }
    function Je(a, b, c) { this.name = ""; this.color = new H(a); this.near = void 0 !== b ? b : 1; this.far = void 0 !== c ? c : 1E3; }
    function Gb(a, b) {
        this.array = a;
        this.stride = b;
        this.count = void 0 !== a ? a.length / b : 0;
        this.dynamic = !1;
        this.updateRange = { offset: 0, count: -1 };
        this.version = 0;
    }
    function Kd(a, b, c, d) { this.data = a; this.itemSize = b; this.offset = c; this.normalized = !0 === d; }
    function Hb(a) { M.call(this); this.type = "SpriteMaterial"; this.color = new H(16777215); this.map = null; this.rotation = 0; this.transparent = this.sizeAttenuation = !0; this.setValues(a); }
    function Ld(a) {
        B.call(this);
        this.type = "Sprite";
        if (void 0 === Ic) {
            Ic = new E;
            var b = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]);
            b = new Gb(b, 5);
            Ic.setIndex([0, 1, 2, 0, 2, 3]);
            Ic.addAttribute("position", new Kd(b, 3, 0, !1));
            Ic.addAttribute("uv", new Kd(b, 2, 3, !1));
        }
        this.geometry = Ic;
        this.material = void 0 !== a ? a : new Hb;
        this.center = new w(.5, .5);
    }
    function Ke(a, b, c, d, e, f) { Jc.subVectors(a, c).addScalar(.5).multiply(d); void 0 !== e ? (Md.x = f * Jc.x - e * Jc.y, Md.y = e * Jc.x + f * Jc.y) : Md.copy(Jc); a.copy(b); a.x += Md.x; a.y += Md.y; a.applyMatrix4(Qh); }
    function Nd() { B.call(this); this.type = "LOD"; Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }); this.autoUpdate = !0; }
    function Od(a, b) {
        a && a.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        ja.call(this, a, b);
        this.type = "SkinnedMesh";
        this.bindMode = "attached";
        this.bindMatrix = new U;
        this.bindMatrixInverse = new U;
    }
    function Le(a, b) { a = a || []; this.bones = a.slice(0); this.boneMatrices = new Float32Array(16 * this.bones.length); this.frame = -1; if (void 0 === b)
        this.calculateInverses();
    else if (this.bones.length === b.length)
        this.boneInverses = b.slice(0);
    else
        for (console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [], a = 0, b = this.bones.length; a < b; a++)
            this.boneInverses.push(new U); }
    function ig() {
        B.call(this);
        this.type = "Bone";
    }
    function jg(a, b, c) { ja.call(this, a, b); this.instanceMatrix = new O(new Float32Array(16 * c), 16); this.count = c; }
    function Q(a) { M.call(this); this.type = "LineBasicMaterial"; this.color = new H(16777215); this.linewidth = 1; this.linejoin = this.linecap = "round"; this.setValues(a); }
    function xa(a, b, c) {
        1 === c && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.");
        B.call(this);
        this.type = "Line";
        this.geometry = void 0 !== a ? a : new E;
        this.material = void 0 !== b ? b : new Q({ color: 16777215 *
                Math.random() });
    }
    function ca(a, b) { xa.call(this, a, b); this.type = "LineSegments"; }
    function Me(a, b) { xa.call(this, a, b); this.type = "LineLoop"; }
    function Qa(a) { M.call(this); this.type = "PointsMaterial"; this.color = new H(16777215); this.map = null; this.size = 1; this.sizeAttenuation = !0; this.morphTargets = !1; this.setValues(a); }
    function Kc(a, b) { B.call(this); this.type = "Points"; this.geometry = void 0 !== a ? a : new E; this.material = void 0 !== b ? b : new Qa({ color: 16777215 * Math.random() }); this.updateMorphTargets(); }
    function kg(a, b, c, d, e, f, g) { var h = lg.distanceSqToPoint(a); h < c && (c = new n, lg.closestPointToPoint(a, c), c.applyMatrix4(d), a = e.ray.origin.distanceTo(c), a < e.near || a > e.far || f.push({ distance: a, distanceToRay: Math.sqrt(h), point: c, index: b, face: null, object: g })); }
    function mg(a, b, c, d, e, f, g, h, l) { W.call(this, a, b, c, d, e, f, g, h, l); this.format = void 0 !== g ? g : 1022; this.minFilter = void 0 !== f ? f : 1006; this.magFilter = void 0 !== e ? e : 1006; this.generateMipmaps = !1; }
    function Lc(a, b, c, d, e, f, g, h, l, m, q, k) {
        W.call(this, null, f, g, h, l, m, d, e, q, k);
        this.image = { width: b, height: c };
        this.mipmaps = a;
        this.generateMipmaps = this.flipY = !1;
    }
    function Pd(a, b, c, d, e, f, g, h, l) { W.call(this, a, b, c, d, e, f, g, h, l); this.needsUpdate = !0; }
    function Qd(a, b, c, d, e, f, g, h, l, m) {
        m = void 0 !== m ? m : 1026;
        if (1026 !== m && 1027 !== m)
            throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === c && 1026 === m && (c = 1012);
        void 0 === c && 1027 === m && (c = 1020);
        W.call(this, null, d, e, f, g, h, m, c, l);
        this.image = { width: a, height: b };
        this.magFilter = void 0 !== g ? g : 1003;
        this.minFilter = void 0 !== h ? h : 1003;
        this.generateMipmaps =
            this.flipY = !1;
    }
    function Mc(a) {
        E.call(this);
        this.type = "WireframeGeometry";
        var b = [], c, d, e, f = [0, 0], g = {}, h = ["a", "b", "c"];
        if (a && a.isGeometry) {
            var l = a.faces;
            var m = 0;
            for (d = l.length; m < d; m++) {
                var q = l[m];
                for (c = 0; 3 > c; c++) {
                    var k = q[h[c]];
                    var t = q[h[(c + 1) % 3]];
                    f[0] = Math.min(k, t);
                    f[1] = Math.max(k, t);
                    k = f[0] + "," + f[1];
                    void 0 === g[k] && (g[k] = { index1: f[0], index2: f[1] });
                }
            }
            for (k in g)
                m = g[k], h = a.vertices[m.index1], b.push(h.x, h.y, h.z), h = a.vertices[m.index2], b.push(h.x, h.y, h.z);
        }
        else if (a && a.isBufferGeometry)
            if (h = new n, null !== a.index) {
                l =
                    a.attributes.position;
                q = a.index;
                var r = a.groups;
                0 === r.length && (r = [{ start: 0, count: q.count, materialIndex: 0 }]);
                a = 0;
                for (e = r.length; a < e; ++a)
                    for (m = r[a], c = m.start, d = m.count, m = c, d = c + d; m < d; m += 3)
                        for (c = 0; 3 > c; c++)
                            k = q.getX(m + c), t = q.getX(m + (c + 1) % 3), f[0] = Math.min(k, t), f[1] = Math.max(k, t), k = f[0] + "," + f[1], void 0 === g[k] && (g[k] = { index1: f[0], index2: f[1] });
                for (k in g)
                    m = g[k], h.fromBufferAttribute(l, m.index1), b.push(h.x, h.y, h.z), h.fromBufferAttribute(l, m.index2), b.push(h.x, h.y, h.z);
            }
            else
                for (l = a.attributes.position, m = 0, d =
                    l.count / 3; m < d; m++)
                    for (c = 0; 3 > c; c++)
                        g = 3 * m + c, h.fromBufferAttribute(l, g), b.push(h.x, h.y, h.z), g = 3 * m + (c + 1) % 3, h.fromBufferAttribute(l, g), b.push(h.x, h.y, h.z);
        this.addAttribute("position", new A(b, 3));
    }
    function Rd(a, b, c) { F.call(this); this.type = "ParametricGeometry"; this.parameters = { func: a, slices: b, stacks: c }; this.fromBufferGeometry(new Nc(a, b, c)); this.mergeVertices(); }
    function Nc(a, b, c) {
        E.call(this);
        this.type = "ParametricBufferGeometry";
        this.parameters = { func: a, slices: b, stacks: c };
        var d = [], e = [], f = [], g = [], h = new n, l = new n, m = new n, q = new n, k = new n, t, r;
        3 > a.length && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
        var p = b + 1;
        for (t = 0; t <= c; t++) {
            var v = t / c;
            for (r = 0; r <= b; r++) {
                var x = r / b;
                a(x, v, l);
                e.push(l.x, l.y, l.z);
                0 <= x - 1E-5 ? (a(x - 1E-5, v, m), q.subVectors(l, m)) : (a(x + 1E-5, v, m), q.subVectors(m, l));
                0 <= v - 1E-5 ? (a(x, v - 1E-5, m), k.subVectors(l, m)) : (a(x, v + 1E-5, m), k.subVectors(m, l));
                h.crossVectors(q, k).normalize();
                f.push(h.x, h.y, h.z);
                g.push(x, v);
            }
        }
        for (t = 0; t < c; t++)
            for (r = 0; r < b; r++)
                a = t * p + r +
                    1, h = (t + 1) * p + r + 1, l = (t + 1) * p + r, d.push(t * p + r, a, l), d.push(a, h, l);
        this.setIndex(d);
        this.addAttribute("position", new A(e, 3));
        this.addAttribute("normal", new A(f, 3));
        this.addAttribute("uv", new A(g, 2));
    }
    function Sd(a, b, c, d) { F.call(this); this.type = "PolyhedronGeometry"; this.parameters = { vertices: a, indices: b, radius: c, detail: d }; this.fromBufferGeometry(new Ca(a, b, c, d)); this.mergeVertices(); }
    function Ca(a, b, c, d) {
        function e(a) { h.push(a.x, a.y, a.z); }
        function f(b, c) { b *= 3; c.x = a[b + 0]; c.y = a[b + 1]; c.z = a[b + 2]; }
        function g(a, b, c, d) { 0 > d && 1 === a.x && (l[b] = a.x - 1); 0 === c.x && 0 === c.z && (l[b] = d / 2 / Math.PI + .5); }
        E.call(this);
        this.type = "PolyhedronBufferGeometry";
        this.parameters = { vertices: a, indices: b, radius: c, detail: d };
        c = c || 1;
        d = d || 0;
        var h = [], l = [];
        (function (a) {
            for (var c = new n, d = new n, g = new n, h = 0; h < b.length; h += 3) {
                f(b[h + 0], c);
                f(b[h + 1], d);
                f(b[h + 2], g);
                var l, m, k = c, z = d, y = g, w = Math.pow(2, a), P = [];
                for (m = 0; m <= w; m++) {
                    P[m] = [];
                    var C = k.clone().lerp(y, m / w), A = z.clone().lerp(y, m / w), B = w - m;
                    for (l = 0; l <= B; l++)
                        P[m][l] = 0 === l && m === w ? C : C.clone().lerp(A, l / B);
                }
                for (m = 0; m <
                    w; m++)
                    for (l = 0; l < 2 * (w - m) - 1; l++)
                        k = Math.floor(l / 2), 0 === l % 2 ? (e(P[m][k + 1]), e(P[m + 1][k]), e(P[m][k])) : (e(P[m][k + 1]), e(P[m + 1][k + 1]), e(P[m + 1][k]));
            }
        })(d);
        (function (a) { for (var b = new n, c = 0; c < h.length; c += 3)
            b.x = h[c + 0], b.y = h[c + 1], b.z = h[c + 2], b.normalize().multiplyScalar(a), h[c + 0] = b.x, h[c + 1] = b.y, h[c + 2] = b.z; })(c);
        (function () {
            for (var a = new n, b = 0; b < h.length; b += 3)
                a.x = h[b + 0], a.y = h[b + 1], a.z = h[b + 2], l.push(Math.atan2(a.z, -a.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5));
            a = new n;
            b = new n;
            for (var c = new n, d = new n, e = new w, f = new w, k = new w, x = 0, z = 0; x < h.length; x += 9, z += 6) {
                a.set(h[x + 0], h[x + 1], h[x + 2]);
                b.set(h[x + 3], h[x + 4], h[x + 5]);
                c.set(h[x + 6], h[x + 7], h[x + 8]);
                e.set(l[z + 0], l[z + 1]);
                f.set(l[z + 2], l[z + 3]);
                k.set(l[z + 4], l[z + 5]);
                d.copy(a).add(b).add(c).divideScalar(3);
                var y = Math.atan2(d.z, -d.x);
                g(e, z + 0, a, y);
                g(f, z + 2, b, y);
                g(k, z + 4, c, y);
            }
            for (a = 0; a < l.length; a += 6)
                b = l[a + 0], c = l[a + 2], d = l[a + 4], e = Math.min(b, c, d), .9 < Math.max(b, c, d) && .1 > e && (.2 > b && (l[a + 0] += 1), .2 > c && (l[a + 2] += 1), .2 > d && (l[a + 4] += 1));
        })();
        this.addAttribute("position", new A(h, 3));
        this.addAttribute("normal", new A(h.slice(), 3));
        this.addAttribute("uv", new A(l, 2));
        0 === d ? this.computeVertexNormals() : this.normalizeNormals();
    }
    function Td(a, b) { F.call(this); this.type = "TetrahedronGeometry"; this.parameters = { radius: a, detail: b }; this.fromBufferGeometry(new Oc(a, b)); this.mergeVertices(); }
    function Oc(a, b) { Ca.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], a, b); this.type = "TetrahedronBufferGeometry"; this.parameters = { radius: a, detail: b }; }
    function Ud(a, b) {
        F.call(this);
        this.type = "OctahedronGeometry";
        this.parameters = { radius: a, detail: b };
        this.fromBufferGeometry(new cc(a, b));
        this.mergeVertices();
    }
    function cc(a, b) { Ca.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], a, b); this.type = "OctahedronBufferGeometry"; this.parameters = { radius: a, detail: b }; }
    function Vd(a, b) { F.call(this); this.type = "IcosahedronGeometry"; this.parameters = { radius: a, detail: b }; this.fromBufferGeometry(new Pc(a, b)); this.mergeVertices(); }
    function Pc(a, b) {
        var c = (1 + Math.sqrt(5)) / 2;
        Ca.call(this, [-1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, 0, 0, -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, c, 0, -1, c, 0, 1, -c, 0, -1, -c, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], a, b);
        this.type = "IcosahedronBufferGeometry";
        this.parameters = { radius: a, detail: b };
    }
    function Wd(a, b) { F.call(this); this.type = "DodecahedronGeometry"; this.parameters = { radius: a, detail: b }; this.fromBufferGeometry(new Qc(a, b)); this.mergeVertices(); }
    function Qc(a, b) {
        var c = (1 + Math.sqrt(5)) / 2, d = 1 / c;
        Ca.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, 0, -c, 0, -d, c, 0, -d, -c, 0, d, c, 0, d], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], a, b);
        this.type = "DodecahedronBufferGeometry";
        this.parameters =
            { radius: a, detail: b };
    }
    function Xd(a, b, c, d, e, f) { F.call(this); this.type = "TubeGeometry"; this.parameters = { path: a, tubularSegments: b, radius: c, radialSegments: d, closed: e }; void 0 !== f && console.warn("THREE.TubeGeometry: taper has been removed."); a = new dc(a, b, c, d, e); this.tangents = a.tangents; this.normals = a.normals; this.binormals = a.binormals; this.fromBufferGeometry(a); this.mergeVertices(); }
    function dc(a, b, c, d, e) {
        function f(e) {
            q = a.getPointAt(e / b, q);
            var f = g.normals[e];
            e = g.binormals[e];
            for (t = 0; t <= d; t++) {
                var m = t / d * Math.PI *
                    2, k = Math.sin(m);
                m = -Math.cos(m);
                l.x = m * f.x + k * e.x;
                l.y = m * f.y + k * e.y;
                l.z = m * f.z + k * e.z;
                l.normalize();
                p.push(l.x, l.y, l.z);
                h.x = q.x + c * l.x;
                h.y = q.y + c * l.y;
                h.z = q.z + c * l.z;
                r.push(h.x, h.y, h.z);
            }
        }
        E.call(this);
        this.type = "TubeBufferGeometry";
        this.parameters = { path: a, tubularSegments: b, radius: c, radialSegments: d, closed: e };
        b = b || 64;
        c = c || 1;
        d = d || 8;
        e = e || !1;
        var g = a.computeFrenetFrames(b, e);
        this.tangents = g.tangents;
        this.normals = g.normals;
        this.binormals = g.binormals;
        var h = new n, l = new n, m = new w, q = new n, k, t, r = [], p = [], v = [], x = [];
        for (k =
            0; k < b; k++)
            f(k);
        f(!1 === e ? b : 0);
        for (k = 0; k <= b; k++)
            for (t = 0; t <= d; t++)
                m.x = k / b, m.y = t / d, v.push(m.x, m.y);
        (function () { for (t = 1; t <= b; t++)
            for (k = 1; k <= d; k++) {
                var a = (d + 1) * t + (k - 1), c = (d + 1) * t + k, e = (d + 1) * (t - 1) + k;
                x.push((d + 1) * (t - 1) + (k - 1), a, e);
                x.push(a, c, e);
            } })();
        this.setIndex(x);
        this.addAttribute("position", new A(r, 3));
        this.addAttribute("normal", new A(p, 3));
        this.addAttribute("uv", new A(v, 2));
    }
    function Yd(a, b, c, d, e, f, g) {
        F.call(this);
        this.type = "TorusKnotGeometry";
        this.parameters = { radius: a, tube: b, tubularSegments: c, radialSegments: d,
            p: e, q: f };
        void 0 !== g && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
        this.fromBufferGeometry(new Rc(a, b, c, d, e, f));
        this.mergeVertices();
    }
    function Rc(a, b, c, d, e, f) {
        function g(a, b, c, d, e) { var f = Math.sin(a); b = c / b * a; c = Math.cos(b); e.x = d * (2 + c) * .5 * Math.cos(a); e.y = d * (2 + c) * f * .5; e.z = d * Math.sin(b) * .5; }
        E.call(this);
        this.type = "TorusKnotBufferGeometry";
        this.parameters = { radius: a, tube: b, tubularSegments: c, radialSegments: d, p: e, q: f };
        a = a || 1;
        b = b || .4;
        c = Math.floor(c) ||
            64;
        d = Math.floor(d) || 8;
        e = e || 2;
        f = f || 3;
        var h = [], l = [], m = [], q = [], k, t = new n, r = new n, p = new n, v = new n, x = new n, z = new n, y = new n;
        for (k = 0; k <= c; ++k) {
            var w = k / c * e * Math.PI * 2;
            g(w, e, f, a, p);
            g(w + .01, e, f, a, v);
            z.subVectors(v, p);
            y.addVectors(v, p);
            x.crossVectors(z, y);
            y.crossVectors(x, z);
            x.normalize();
            y.normalize();
            for (w = 0; w <= d; ++w) {
                var P = w / d * Math.PI * 2, C = -b * Math.cos(P);
                P = b * Math.sin(P);
                t.x = p.x + (C * y.x + P * x.x);
                t.y = p.y + (C * y.y + P * x.y);
                t.z = p.z + (C * y.z + P * x.z);
                l.push(t.x, t.y, t.z);
                r.subVectors(t, p).normalize();
                m.push(r.x, r.y, r.z);
                q.push(k /
                    c);
                q.push(w / d);
            }
        }
        for (w = 1; w <= c; w++)
            for (k = 1; k <= d; k++)
                a = (d + 1) * w + (k - 1), b = (d + 1) * w + k, e = (d + 1) * (w - 1) + k, h.push((d + 1) * (w - 1) + (k - 1), a, e), h.push(a, b, e);
        this.setIndex(h);
        this.addAttribute("position", new A(l, 3));
        this.addAttribute("normal", new A(m, 3));
        this.addAttribute("uv", new A(q, 2));
    }
    function Zd(a, b, c, d, e) { F.call(this); this.type = "TorusGeometry"; this.parameters = { radius: a, tube: b, radialSegments: c, tubularSegments: d, arc: e }; this.fromBufferGeometry(new Sc(a, b, c, d, e)); this.mergeVertices(); }
    function Sc(a, b, c, d, e) {
        E.call(this);
        this.type = "TorusBufferGeometry";
        this.parameters = { radius: a, tube: b, radialSegments: c, tubularSegments: d, arc: e };
        a = a || 1;
        b = b || .4;
        c = Math.floor(c) || 8;
        d = Math.floor(d) || 6;
        e = e || 2 * Math.PI;
        var f = [], g = [], h = [], l = [], m = new n, q = new n, k = new n, t, r;
        for (t = 0; t <= c; t++)
            for (r = 0; r <= d; r++) {
                var p = r / d * e, v = t / c * Math.PI * 2;
                q.x = (a + b * Math.cos(v)) * Math.cos(p);
                q.y = (a + b * Math.cos(v)) * Math.sin(p);
                q.z = b * Math.sin(v);
                g.push(q.x, q.y, q.z);
                m.x = a * Math.cos(p);
                m.y = a * Math.sin(p);
                k.subVectors(q, m).normalize();
                h.push(k.x, k.y, k.z);
                l.push(r / d);
                l.push(t /
                    c);
            }
        for (t = 1; t <= c; t++)
            for (r = 1; r <= d; r++)
                a = (d + 1) * (t - 1) + r - 1, b = (d + 1) * (t - 1) + r, e = (d + 1) * t + r, f.push((d + 1) * t + r - 1, a, e), f.push(a, b, e);
        this.setIndex(f);
        this.addAttribute("position", new A(g, 3));
        this.addAttribute("normal", new A(h, 3));
        this.addAttribute("uv", new A(l, 2));
    }
    function Rh(a, b, c, d, e) { for (var f, g = 0, h = b, l = c - d; h < c; h += d)
        g += (a[l] - a[h]) * (a[h + 1] + a[l + 1]), l = h; if (e === 0 < g)
        for (e = b; e < c; e += d)
            f = Sh(e, a[e], a[e + 1], f);
    else
        for (e = c - d; e >= b; e -= d)
            f = Sh(e, a[e], a[e + 1], f); f && ec(f, f.next) && ($d(f), f = f.next); return f; }
    function ae(a, b) {
        if (!a)
            return a;
        b || (b = a);
        do {
            var c = !1;
            if (a.steiner || !ec(a, a.next) && 0 !== sa(a.prev, a, a.next))
                a = a.next;
            else {
                $d(a);
                a = b = a.prev;
                if (a === a.next)
                    break;
                c = !0;
            }
        } while (c || a !== b);
        return b;
    }
    function be(a, b, c, d, e, f, g) {
        if (a) {
            if (!g && f) {
                var h = a, l = h;
                do
                    null === l.z && (l.z = ng(l.x, l.y, d, e, f)), l.prevZ = l.prev, l = l.nextZ = l.next;
                while (l !== h);
                l.prevZ.nextZ = null;
                l.prevZ = null;
                h = l;
                var m, q, k, t, r = 1;
                do {
                    l = h;
                    var p = h = null;
                    for (q = 0; l;) {
                        q++;
                        var n = l;
                        for (m = k = 0; m < r && (k++, n = n.nextZ, n); m++)
                            ;
                        for (t = r; 0 < k || 0 < t && n;)
                            0 !== k && (0 === t || !n || l.z <= n.z) ? (m = l, l = l.nextZ, k--) : (m =
                                n, n = n.nextZ, t--), p ? p.nextZ = m : h = m, m.prevZ = p, p = m;
                        l = n;
                    }
                    p.nextZ = null;
                    r *= 2;
                } while (1 < q);
            }
            for (h = a; a.prev !== a.next;) {
                l = a.prev;
                n = a.next;
                if (f)
                    p = lk(a, d, e, f);
                else
                    a: if (p = a, q = p.prev, k = p, r = p.next, 0 <= sa(q, k, r))
                        p = !1;
                    else {
                        for (m = p.next.next; m !== p.prev;) {
                            if (Tc(q.x, q.y, k.x, k.y, r.x, r.y, m.x, m.y) && 0 <= sa(m.prev, m, m.next)) {
                                p = !1;
                                break a;
                            }
                            m = m.next;
                        }
                        p = !0;
                    }
                if (p)
                    b.push(l.i / c), b.push(a.i / c), b.push(n.i / c), $d(a), h = a = n.next;
                else if (a = n, a === h) {
                    if (!g)
                        be(ae(a), b, c, d, e, f, 1);
                    else if (1 === g) {
                        g = b;
                        h = c;
                        l = a;
                        do
                            n = l.prev, p = l.next.next, !ec(n, p) && Th(n, l, l.next, p) && ce(n, p) && ce(p, n) && (g.push(n.i / h), g.push(l.i / h), g.push(p.i / h), $d(l), $d(l.next), l = a = p), l = l.next;
                        while (l !== a);
                        a = l;
                        be(a, b, c, d, e, f, 2);
                    }
                    else if (2 === g)
                        a: {
                            g = a;
                            do {
                                for (h = g.next.next; h !== g.prev;) {
                                    if (l = g.i !== h.i) {
                                        l = g;
                                        n = h;
                                        if (p = l.next.i !== n.i && l.prev.i !== n.i) {
                                            b: {
                                                p = l;
                                                do {
                                                    if (p.i !== l.i && p.next.i !== l.i && p.i !== n.i && p.next.i !== n.i && Th(p, p.next, l, n)) {
                                                        p = !0;
                                                        break b;
                                                    }
                                                    p = p.next;
                                                } while (p !== l);
                                                p = !1;
                                            }
                                            p = !p;
                                        }
                                        if (p = p && ce(l, n) && ce(n, l)) {
                                            p = l;
                                            q = !1;
                                            k = (l.x + n.x) / 2;
                                            n = (l.y + n.y) / 2;
                                            do
                                                p.y > n !== p.next.y > n && p.next.y !== p.y && k < (p.next.x -
                                                    p.x) * (n - p.y) / (p.next.y - p.y) + p.x && (q = !q), p = p.next;
                                            while (p !== l);
                                            p = q;
                                        }
                                        l = p;
                                    }
                                    if (l) {
                                        a = Uh(g, h);
                                        g = ae(g, g.next);
                                        a = ae(a, a.next);
                                        be(g, b, c, d, e, f);
                                        be(a, b, c, d, e, f);
                                        break a;
                                    }
                                    h = h.next;
                                }
                                g = g.next;
                            } while (g !== a);
                        }
                    break;
                }
            }
        }
    }
    function lk(a, b, c, d) {
        var e = a.prev, f = a.next;
        if (0 <= sa(e, a, f))
            return !1;
        var g = e.x > a.x ? e.x > f.x ? e.x : f.x : a.x > f.x ? a.x : f.x, h = e.y > a.y ? e.y > f.y ? e.y : f.y : a.y > f.y ? a.y : f.y, l = ng(e.x < a.x ? e.x < f.x ? e.x : f.x : a.x < f.x ? a.x : f.x, e.y < a.y ? e.y < f.y ? e.y : f.y : a.y < f.y ? a.y : f.y, b, c, d);
        b = ng(g, h, b, c, d);
        c = a.prevZ;
        for (d = a.nextZ; c && c.z >= l && d && d.z <=
            b;) {
            if (c !== a.prev && c !== a.next && Tc(e.x, e.y, a.x, a.y, f.x, f.y, c.x, c.y) && 0 <= sa(c.prev, c, c.next))
                return !1;
            c = c.prevZ;
            if (d !== a.prev && d !== a.next && Tc(e.x, e.y, a.x, a.y, f.x, f.y, d.x, d.y) && 0 <= sa(d.prev, d, d.next))
                return !1;
            d = d.nextZ;
        }
        for (; c && c.z >= l;) {
            if (c !== a.prev && c !== a.next && Tc(e.x, e.y, a.x, a.y, f.x, f.y, c.x, c.y) && 0 <= sa(c.prev, c, c.next))
                return !1;
            c = c.prevZ;
        }
        for (; d && d.z <= b;) {
            if (d !== a.prev && d !== a.next && Tc(e.x, e.y, a.x, a.y, f.x, f.y, d.x, d.y) && 0 <= sa(d.prev, d, d.next))
                return !1;
            d = d.nextZ;
        }
        return !0;
    }
    function mk(a, b) { return a.x - b.x; }
    function nk(a, b) {
        var c = b, d = a.x, e = a.y, f = -Infinity;
        do {
            if (e <= c.y && e >= c.next.y && c.next.y !== c.y) {
                var g = c.x + (e - c.y) * (c.next.x - c.x) / (c.next.y - c.y);
                if (g <= d && g > f) {
                    f = g;
                    if (g === d) {
                        if (e === c.y)
                            return c;
                        if (e === c.next.y)
                            return c.next;
                    }
                    var h = c.x < c.next.x ? c : c.next;
                }
            }
            c = c.next;
        } while (c !== b);
        if (!h)
            return null;
        if (d === f)
            return h.prev;
        b = h;
        g = h.x;
        var l = h.y, m = Infinity;
        for (c = h.next; c !== b;) {
            if (d >= c.x && c.x >= g && d !== c.x && Tc(e < l ? d : f, e, g, l, e < l ? f : d, e, c.x, c.y)) {
                var q = Math.abs(e - c.y) / (d - c.x);
                (q < m || q === m && c.x > h.x) && ce(c, a) && (h = c, m = q);
            }
            c =
                c.next;
        }
        return h;
    }
    function ng(a, b, c, d, e) { a = 32767 * (a - c) * e; b = 32767 * (b - d) * e; a = (a | a << 8) & 16711935; a = (a | a << 4) & 252645135; a = (a | a << 2) & 858993459; b = (b | b << 8) & 16711935; b = (b | b << 4) & 252645135; b = (b | b << 2) & 858993459; return (a | a << 1) & 1431655765 | ((b | b << 1) & 1431655765) << 1; }
    function ok(a) { var b = a, c = a; do {
        if (b.x < c.x || b.x === c.x && b.y < c.y)
            c = b;
        b = b.next;
    } while (b !== a); return c; }
    function Tc(a, b, c, d, e, f, g, h) { return 0 <= (e - g) * (b - h) - (a - g) * (f - h) && 0 <= (a - g) * (d - h) - (c - g) * (b - h) && 0 <= (c - g) * (f - h) - (e - g) * (d - h); }
    function sa(a, b, c) {
        return (b.y - a.y) * (c.x -
            b.x) - (b.x - a.x) * (c.y - b.y);
    }
    function ec(a, b) { return a.x === b.x && a.y === b.y; }
    function Th(a, b, c, d) { return ec(a, c) && ec(b, d) || ec(a, d) && ec(c, b) ? !0 : 0 < sa(a, b, c) !== 0 < sa(a, b, d) && 0 < sa(c, d, a) !== 0 < sa(c, d, b); }
    function ce(a, b) { return 0 > sa(a.prev, a, a.next) ? 0 <= sa(a, b, a.next) && 0 <= sa(a, a.prev, b) : 0 > sa(a, b, a.prev) || 0 > sa(a, a.next, b); }
    function Uh(a, b) { var c = new og(a.i, a.x, a.y), d = new og(b.i, b.x, b.y), e = a.next, f = b.prev; a.next = b; b.prev = a; c.next = e; e.prev = c; d.next = c; c.prev = d; f.next = d; d.prev = f; return d; }
    function Sh(a, b, c, d) {
        a = new og(a, b, c);
        d ? (a.next = d.next, a.prev = d, d.next.prev = a, d.next = a) : (a.prev = a, a.next = a);
        return a;
    }
    function $d(a) { a.next.prev = a.prev; a.prev.next = a.next; a.prevZ && (a.prevZ.nextZ = a.nextZ); a.nextZ && (a.nextZ.prevZ = a.prevZ); }
    function og(a, b, c) { this.i = a; this.x = b; this.y = c; this.nextZ = this.prevZ = this.z = this.next = this.prev = null; this.steiner = !1; }
    function Vh(a) { var b = a.length; 2 < b && a[b - 1].equals(a[0]) && a.pop(); }
    function Wh(a, b) { for (var c = 0; c < b.length; c++)
        a.push(b[c].x), a.push(b[c].y); }
    function fc(a, b) {
        F.call(this);
        this.type = "ExtrudeGeometry";
        this.parameters = { shapes: a, options: b };
        this.fromBufferGeometry(new eb(a, b));
        this.mergeVertices();
    }
    function eb(a, b) {
        function c(a) {
            function c(a, b, c) { b || console.error("THREE.ExtrudeGeometry: vec does not exist"); return b.clone().multiplyScalar(c).add(a); }
            function g(a, b, c) {
                var d = a.x - b.x;
                var e = a.y - b.y;
                var f = c.x - a.x;
                var g = c.y - a.y, h = d * d + e * e;
                if (Math.abs(d * g - e * f) > Number.EPSILON) {
                    var l = Math.sqrt(h), m = Math.sqrt(f * f + g * g);
                    h = b.x - e / l;
                    b = b.y + d / l;
                    g = ((c.x - g / m - h) * g - (c.y + f / m - b) * f) / (d * g - e * f);
                    f = h + d * g - a.x;
                    d = b + e * g - a.y;
                    e = f * f +
                        d * d;
                    if (2 >= e)
                        return new w(f, d);
                    e = Math.sqrt(e / 2);
                }
                else
                    a = !1, d > Number.EPSILON ? f > Number.EPSILON && (a = !0) : d < -Number.EPSILON ? f < -Number.EPSILON && (a = !0) : Math.sign(e) === Math.sign(g) && (a = !0), a ? (f = -e, e = Math.sqrt(h)) : (f = d, d = e, e = Math.sqrt(h / 2));
                return new w(f / e, d / e);
            }
            function h(a, b) {
                for (K = a.length; 0 <= --K;) {
                    var c = K;
                    var f = K - 1;
                    0 > f && (f = a.length - 1);
                    var g, h = y + 2 * E;
                    for (g = 0; g < h; g++) {
                        var l = Y * g, m = Y * (g + 1), q = b + f + l, k = b + f + m;
                        m = b + c + m;
                        p(b + c + l);
                        p(q);
                        p(m);
                        p(q);
                        p(k);
                        p(m);
                        l = e.length / 3;
                        l = G.generateSideWallUV(d, e, l - 6, l - 3, l - 2, l - 1);
                        v(l[0]);
                        v(l[1]);
                        v(l[3]);
                        v(l[1]);
                        v(l[2]);
                        v(l[3]);
                    }
                }
            }
            function l(a, b, c) { x.push(a); x.push(b); x.push(c); }
            function k(a, b, c) { p(a); p(b); p(c); a = e.length / 3; a = G.generateTopUV(d, e, a - 3, a - 2, a - 1); v(a[0]); v(a[1]); v(a[2]); }
            function p(a) { e.push(x[3 * a]); e.push(x[3 * a + 1]); e.push(x[3 * a + 2]); }
            function v(a) { f.push(a.x); f.push(a.y); }
            var x = [], z = void 0 !== b.curveSegments ? b.curveSegments : 12, y = void 0 !== b.steps ? b.steps : 1, V = void 0 !== b.depth ? b.depth : 100, P = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0, C = void 0 !== b.bevelThickness ? b.bevelThickness : 6, A = void 0 !== b.bevelSize ? b.bevelSize : C - 2, B = void 0 !== b.bevelOffset ? b.bevelOffset : 0, E = void 0 !== b.bevelSegments ? b.bevelSegments : 3, D = b.extrudePath, G = void 0 !== b.UVGenerator ? b.UVGenerator : pk;
            void 0 !== b.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), V = b.amount);
            var F = !1;
            if (D) {
                var H = D.getSpacedPoints(y);
                F = !0;
                P = !1;
                var I = D.computeFrenetFrames(y, !1);
                var O = new n;
                var T = new n;
                var X = new n;
            }
            P || (B = A = C = E = 0);
            var M;
            z = a.extractPoints(z);
            a = z.shape;
            var N = z.holes;
            if (!pb.isClockWise(a)) {
                a =
                    a.reverse();
                var ha = 0;
                for (M = N.length; ha < M; ha++) {
                    var L = N[ha];
                    pb.isClockWise(L) && (N[ha] = L.reverse());
                }
            }
            var U = pb.triangulateShape(a, N), W = a;
            ha = 0;
            for (M = N.length; ha < M; ha++)
                L = N[ha], a = a.concat(L);
            var Q, Y = a.length, S, ca = U.length;
            z = [];
            var K = 0;
            var Z = W.length;
            var fa = Z - 1;
            for (Q = K + 1; K < Z; K++, fa++, Q++)
                fa === Z && (fa = 0), Q === Z && (Q = 0), z[K] = g(W[K], W[fa], W[Q]);
            D = [];
            var ea = z.concat();
            ha = 0;
            for (M = N.length; ha < M; ha++) {
                L = N[ha];
                var aa = [];
                K = 0;
                Z = L.length;
                fa = Z - 1;
                for (Q = K + 1; K < Z; K++, fa++, Q++)
                    fa === Z && (fa = 0), Q === Z && (Q = 0), aa[K] = g(L[K], L[fa], L[Q]);
                D.push(aa);
                ea = ea.concat(aa);
            }
            for (fa = 0; fa < E; fa++) {
                Z = fa / E;
                var da = C * Math.cos(Z * Math.PI / 2);
                Q = A * Math.sin(Z * Math.PI / 2) + B;
                K = 0;
                for (Z = W.length; K < Z; K++) {
                    var R = c(W[K], z[K], Q);
                    l(R.x, R.y, -da);
                }
                ha = 0;
                for (M = N.length; ha < M; ha++)
                    for (L = N[ha], aa = D[ha], K = 0, Z = L.length; K < Z; K++)
                        R = c(L[K], aa[K], Q), l(R.x, R.y, -da);
            }
            Q = A + B;
            for (K = 0; K < Y; K++)
                R = P ? c(a[K], ea[K], Q) : a[K], F ? (T.copy(I.normals[0]).multiplyScalar(R.x), O.copy(I.binormals[0]).multiplyScalar(R.y), X.copy(H[0]).add(T).add(O), l(X.x, X.y, X.z)) : l(R.x, R.y, 0);
            for (Z = 1; Z <= y; Z++)
                for (K =
                    0; K < Y; K++)
                    R = P ? c(a[K], ea[K], Q) : a[K], F ? (T.copy(I.normals[Z]).multiplyScalar(R.x), O.copy(I.binormals[Z]).multiplyScalar(R.y), X.copy(H[Z]).add(T).add(O), l(X.x, X.y, X.z)) : l(R.x, R.y, V / y * Z);
            for (fa = E - 1; 0 <= fa; fa--) {
                Z = fa / E;
                da = C * Math.cos(Z * Math.PI / 2);
                Q = A * Math.sin(Z * Math.PI / 2) + B;
                K = 0;
                for (Z = W.length; K < Z; K++)
                    R = c(W[K], z[K], Q), l(R.x, R.y, V + da);
                ha = 0;
                for (M = N.length; ha < M; ha++)
                    for (L = N[ha], aa = D[ha], K = 0, Z = L.length; K < Z; K++)
                        R = c(L[K], aa[K], Q), F ? l(R.x, R.y + H[y - 1].y, H[y - 1].x + da) : l(R.x, R.y, V + da);
            }
            (function () {
                var a = e.length / 3;
                if (P) {
                    var b = 0 * Y;
                    for (K = 0; K < ca; K++)
                        S = U[K], k(S[2] + b, S[1] + b, S[0] + b);
                    b = Y * (y + 2 * E);
                    for (K = 0; K < ca; K++)
                        S = U[K], k(S[0] + b, S[1] + b, S[2] + b);
                }
                else {
                    for (K = 0; K < ca; K++)
                        S = U[K], k(S[2], S[1], S[0]);
                    for (K = 0; K < ca; K++)
                        S = U[K], k(S[0] + Y * y, S[1] + Y * y, S[2] + Y * y);
                }
                d.addGroup(a, e.length / 3 - a, 0);
            })();
            (function () { var a = e.length / 3, b = 0; h(W, b); b += W.length; ha = 0; for (M = N.length; ha < M; ha++)
                L = N[ha], h(L, b), b += L.length; d.addGroup(a, e.length / 3 - a, 1); })();
        }
        E.call(this);
        this.type = "ExtrudeBufferGeometry";
        this.parameters = { shapes: a, options: b };
        a = Array.isArray(a) ? a : [a];
        for (var d = this, e = [], f = [], g = 0, h = a.length; g < h; g++)
            c(a[g]);
        this.addAttribute("position", new A(e, 3));
        this.addAttribute("uv", new A(f, 2));
        this.computeVertexNormals();
    }
    function Xh(a, b, c) { c.shapes = []; if (Array.isArray(a))
        for (var d = 0, e = a.length; d < e; d++)
            c.shapes.push(a[d].uuid);
    else
        c.shapes.push(a.uuid); void 0 !== b.extrudePath && (c.options.extrudePath = b.extrudePath.toJSON()); return c; }
    function de(a, b) { F.call(this); this.type = "TextGeometry"; this.parameters = { text: a, parameters: b }; this.fromBufferGeometry(new Uc(a, b)); this.mergeVertices(); }
    function Uc(a, b) { b = b || {}; var c = b.font; if (!c || !c.isFont)
        return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new F; a = c.generateShapes(a, b.size); b.depth = void 0 !== b.height ? b.height : 50; void 0 === b.bevelThickness && (b.bevelThickness = 10); void 0 === b.bevelSize && (b.bevelSize = 8); void 0 === b.bevelEnabled && (b.bevelEnabled = !1); eb.call(this, a, b); this.type = "TextBufferGeometry"; }
    function ee(a, b, c, d, e, f, g) {
        F.call(this);
        this.type = "SphereGeometry";
        this.parameters = { radius: a, widthSegments: b,
            heightSegments: c, phiStart: d, phiLength: e, thetaStart: f, thetaLength: g };
        this.fromBufferGeometry(new Ib(a, b, c, d, e, f, g));
        this.mergeVertices();
    }
    function Ib(a, b, c, d, e, f, g) {
        E.call(this);
        this.type = "SphereBufferGeometry";
        this.parameters = { radius: a, widthSegments: b, heightSegments: c, phiStart: d, phiLength: e, thetaStart: f, thetaLength: g };
        a = a || 1;
        b = Math.max(3, Math.floor(b) || 8);
        c = Math.max(2, Math.floor(c) || 6);
        d = void 0 !== d ? d : 0;
        e = void 0 !== e ? e : 2 * Math.PI;
        f = void 0 !== f ? f : 0;
        g = void 0 !== g ? g : Math.PI;
        var h = Math.min(f + g, Math.PI), l, m, q = 0, k = [], t = new n, r = new n, p = [], v = [], x = [], z = [];
        for (m = 0; m <= c; m++) {
            var y = [], w = m / c, P = 0;
            0 == m && 0 == f ? P = .5 / b : m == c && h == Math.PI && (P = -.5 / b);
            for (l = 0; l <= b; l++) {
                var C = l / b;
                t.x = -a * Math.cos(d + C * e) * Math.sin(f + w * g);
                t.y = a * Math.cos(f + w * g);
                t.z = a * Math.sin(d + C * e) * Math.sin(f + w * g);
                v.push(t.x, t.y, t.z);
                r.copy(t).normalize();
                x.push(r.x, r.y, r.z);
                z.push(C + P, 1 - w);
                y.push(q++);
            }
            k.push(y);
        }
        for (m = 0; m < c; m++)
            for (l = 0; l < b; l++)
                a = k[m][l + 1], d = k[m][l], e = k[m + 1][l], g = k[m + 1][l + 1], (0 !== m || 0 < f) && p.push(a, d, g), (m !== c - 1 || h < Math.PI) && p.push(d, e, g);
        this.setIndex(p);
        this.addAttribute("position", new A(v, 3));
        this.addAttribute("normal", new A(x, 3));
        this.addAttribute("uv", new A(z, 2));
    }
    function fe(a, b, c, d, e, f) { F.call(this); this.type = "RingGeometry"; this.parameters = { innerRadius: a, outerRadius: b, thetaSegments: c, phiSegments: d, thetaStart: e, thetaLength: f }; this.fromBufferGeometry(new Vc(a, b, c, d, e, f)); this.mergeVertices(); }
    function Vc(a, b, c, d, e, f) {
        E.call(this);
        this.type = "RingBufferGeometry";
        this.parameters = { innerRadius: a, outerRadius: b, thetaSegments: c, phiSegments: d, thetaStart: e,
            thetaLength: f };
        a = a || .5;
        b = b || 1;
        e = void 0 !== e ? e : 0;
        f = void 0 !== f ? f : 2 * Math.PI;
        c = void 0 !== c ? Math.max(3, c) : 8;
        d = void 0 !== d ? Math.max(1, d) : 1;
        var g = [], h = [], l = [], m = [], q = a, k = (b - a) / d, t = new n, r = new w, p, v;
        for (p = 0; p <= d; p++) {
            for (v = 0; v <= c; v++)
                a = e + v / c * f, t.x = q * Math.cos(a), t.y = q * Math.sin(a), h.push(t.x, t.y, t.z), l.push(0, 0, 1), r.x = (t.x / b + 1) / 2, r.y = (t.y / b + 1) / 2, m.push(r.x, r.y);
            q += k;
        }
        for (p = 0; p < d; p++)
            for (b = p * (c + 1), v = 0; v < c; v++)
                a = v + b, e = a + c + 1, f = a + c + 2, q = a + 1, g.push(a, e, q), g.push(e, f, q);
        this.setIndex(g);
        this.addAttribute("position", new A(h, 3));
        this.addAttribute("normal", new A(l, 3));
        this.addAttribute("uv", new A(m, 2));
    }
    function ge(a, b, c, d) { F.call(this); this.type = "LatheGeometry"; this.parameters = { points: a, segments: b, phiStart: c, phiLength: d }; this.fromBufferGeometry(new Wc(a, b, c, d)); this.mergeVertices(); }
    function Wc(a, b, c, d) {
        E.call(this);
        this.type = "LatheBufferGeometry";
        this.parameters = { points: a, segments: b, phiStart: c, phiLength: d };
        b = Math.floor(b) || 12;
        c = c || 0;
        d = d || 2 * Math.PI;
        d = L.clamp(d, 0, 2 * Math.PI);
        var e = [], f = [], g = [], h = 1 / b, l = new n, m = new w, q;
        for (q =
            0; q <= b; q++) {
            var k = c + q * h * d;
            var t = Math.sin(k), r = Math.cos(k);
            for (k = 0; k <= a.length - 1; k++)
                l.x = a[k].x * t, l.y = a[k].y, l.z = a[k].x * r, f.push(l.x, l.y, l.z), m.x = q / b, m.y = k / (a.length - 1), g.push(m.x, m.y);
        }
        for (q = 0; q < b; q++)
            for (k = 0; k < a.length - 1; k++)
                c = k + q * a.length, h = c + a.length, l = c + a.length + 1, m = c + 1, e.push(c, h, m), e.push(h, l, m);
        this.setIndex(e);
        this.addAttribute("position", new A(f, 3));
        this.addAttribute("uv", new A(g, 2));
        this.computeVertexNormals();
        if (d === 2 * Math.PI)
            for (d = this.attributes.normal.array, e = new n, f = new n, g = new n, c =
                b * a.length * 3, k = q = 0; q < a.length; q++, k += 3)
                e.x = d[k + 0], e.y = d[k + 1], e.z = d[k + 2], f.x = d[c + k + 0], f.y = d[c + k + 1], f.z = d[c + k + 2], g.addVectors(e, f).normalize(), d[k + 0] = d[c + k + 0] = g.x, d[k + 1] = d[c + k + 1] = g.y, d[k + 2] = d[c + k + 2] = g.z;
    }
    function gc(a, b) { F.call(this); this.type = "ShapeGeometry"; "object" === typeof b && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), b = b.curveSegments); this.parameters = { shapes: a, curveSegments: b }; this.fromBufferGeometry(new hc(a, b)); this.mergeVertices(); }
    function hc(a, b) {
        function c(a) {
            var c, h = e.length / 3;
            a = a.extractPoints(b);
            var m = a.shape, k = a.holes;
            !1 === pb.isClockWise(m) && (m = m.reverse());
            a = 0;
            for (c = k.length; a < c; a++) {
                var q = k[a];
                !0 === pb.isClockWise(q) && (k[a] = q.reverse());
            }
            var n = pb.triangulateShape(m, k);
            a = 0;
            for (c = k.length; a < c; a++)
                q = k[a], m = m.concat(q);
            a = 0;
            for (c = m.length; a < c; a++)
                q = m[a], e.push(q.x, q.y, 0), f.push(0, 0, 1), g.push(q.x, q.y);
            a = 0;
            for (c = n.length; a < c; a++)
                m = n[a], d.push(m[0] + h, m[1] + h, m[2] + h), l += 3;
        }
        E.call(this);
        this.type = "ShapeBufferGeometry";
        this.parameters = { shapes: a, curveSegments: b };
        b = b ||
            12;
        var d = [], e = [], f = [], g = [], h = 0, l = 0;
        if (!1 === Array.isArray(a))
            c(a);
        else
            for (var m = 0; m < a.length; m++)
                c(a[m]), this.addGroup(h, l, m), h += l, l = 0;
        this.setIndex(d);
        this.addAttribute("position", new A(e, 3));
        this.addAttribute("normal", new A(f, 3));
        this.addAttribute("uv", new A(g, 2));
    }
    function Yh(a, b) { b.shapes = []; if (Array.isArray(a))
        for (var c = 0, d = a.length; c < d; c++)
            b.shapes.push(a[c].uuid);
    else
        b.shapes.push(a.uuid); return b; }
    function Xc(a, b) {
        E.call(this);
        this.type = "EdgesGeometry";
        this.parameters = { thresholdAngle: b };
        var c = [];
        b = Math.cos(L.DEG2RAD * (void 0 !== b ? b : 1));
        var d = [0, 0], e = {}, f = ["a", "b", "c"];
        if (a.isBufferGeometry) {
            var g = new F;
            g.fromBufferGeometry(a);
        }
        else
            g = a.clone();
        g.mergeVertices();
        g.computeFaceNormals();
        a = g.vertices;
        g = g.faces;
        for (var h = 0, l = g.length; h < l; h++)
            for (var m = g[h], k = 0; 3 > k; k++) {
                var u = m[f[k]];
                var n = m[f[(k + 1) % 3]];
                d[0] = Math.min(u, n);
                d[1] = Math.max(u, n);
                u = d[0] + "," + d[1];
                void 0 === e[u] ? e[u] = { index1: d[0], index2: d[1], face1: h, face2: void 0 } : e[u].face2 = h;
            }
        for (u in e)
            if (d = e[u], void 0 === d.face2 || g[d.face1].normal.dot(g[d.face2].normal) <=
                b)
                f = a[d.index1], c.push(f.x, f.y, f.z), f = a[d.index2], c.push(f.x, f.y, f.z);
        this.addAttribute("position", new A(c, 3));
    }
    function ic(a, b, c, d, e, f, g, h) { F.call(this); this.type = "CylinderGeometry"; this.parameters = { radiusTop: a, radiusBottom: b, height: c, radialSegments: d, heightSegments: e, openEnded: f, thetaStart: g, thetaLength: h }; this.fromBufferGeometry(new qb(a, b, c, d, e, f, g, h)); this.mergeVertices(); }
    function qb(a, b, c, d, e, f, g, h) {
        function l(c) {
            var e, f = new w, l = new n, q = 0, v = !0 === c ? a : b, y = !0 === c ? 1 : -1;
            var A = p;
            for (e = 1; e <= d; e++)
                u.push(0, x * y, 0), t.push(0, y, 0), r.push(.5, .5), p++;
            var B = p;
            for (e = 0; e <= d; e++) {
                var E = e / d * h + g, D = Math.cos(E);
                E = Math.sin(E);
                l.x = v * E;
                l.y = x * y;
                l.z = v * D;
                u.push(l.x, l.y, l.z);
                t.push(0, y, 0);
                f.x = .5 * D + .5;
                f.y = .5 * E * y + .5;
                r.push(f.x, f.y);
                p++;
            }
            for (e = 0; e < d; e++)
                f = A + e, l = B + e, !0 === c ? k.push(l, l + 1, f) : k.push(l + 1, l, f), q += 3;
            m.addGroup(z, q, !0 === c ? 1 : 2);
            z += q;
        }
        E.call(this);
        this.type = "CylinderBufferGeometry";
        this.parameters = { radiusTop: a, radiusBottom: b, height: c, radialSegments: d, heightSegments: e, openEnded: f, thetaStart: g, thetaLength: h };
        var m = this;
        a = void 0 !== a ? a : 1;
        b = void 0 !== b ? b : 1;
        c = c || 1;
        d = Math.floor(d) || 8;
        e = Math.floor(e) || 1;
        f = void 0 !== f ? f : !1;
        g = void 0 !== g ? g : 0;
        h = void 0 !== h ? h : 2 * Math.PI;
        var k = [], u = [], t = [], r = [], p = 0, v = [], x = c / 2, z = 0;
        (function () {
            var f, l, q = new n, w = new n, A = 0, B = (b - a) / c;
            for (l = 0; l <= e; l++) {
                var E = [], D = l / e, G = D * (b - a) + a;
                for (f = 0; f <= d; f++) {
                    var F = f / d, H = F * h + g, I = Math.sin(H);
                    H = Math.cos(H);
                    w.x = G * I;
                    w.y = -D * c + x;
                    w.z = G * H;
                    u.push(w.x, w.y, w.z);
                    q.set(I, B, H).normalize();
                    t.push(q.x, q.y, q.z);
                    r.push(F, 1 - D);
                    E.push(p++);
                }
                v.push(E);
            }
            for (f = 0; f < d; f++)
                for (l = 0; l < e; l++)
                    q =
                        v[l + 1][f], w = v[l + 1][f + 1], B = v[l][f + 1], k.push(v[l][f], q, B), k.push(q, w, B), A += 6;
            m.addGroup(z, A, 0);
            z += A;
        })();
        !1 === f && (0 < a && l(!0), 0 < b && l(!1));
        this.setIndex(k);
        this.addAttribute("position", new A(u, 3));
        this.addAttribute("normal", new A(t, 3));
        this.addAttribute("uv", new A(r, 2));
    }
    function he(a, b, c, d, e, f, g) { ic.call(this, 0, a, b, c, d, e, f, g); this.type = "ConeGeometry"; this.parameters = { radius: a, height: b, radialSegments: c, heightSegments: d, openEnded: e, thetaStart: f, thetaLength: g }; }
    function ie(a, b, c, d, e, f, g) {
        qb.call(this, 0, a, b, c, d, e, f, g);
        this.type = "ConeBufferGeometry";
        this.parameters = { radius: a, height: b, radialSegments: c, heightSegments: d, openEnded: e, thetaStart: f, thetaLength: g };
    }
    function je(a, b, c, d) { F.call(this); this.type = "CircleGeometry"; this.parameters = { radius: a, segments: b, thetaStart: c, thetaLength: d }; this.fromBufferGeometry(new Yc(a, b, c, d)); this.mergeVertices(); }
    function Yc(a, b, c, d) {
        E.call(this);
        this.type = "CircleBufferGeometry";
        this.parameters = { radius: a, segments: b, thetaStart: c, thetaLength: d };
        a = a || 1;
        b = void 0 !== b ? Math.max(3, b) : 8;
        c = void 0 !== c ? c : 0;
        d = void 0 !== d ? d : 2 * Math.PI;
        var e = [], f = [], g = [], h = [], l, m = new n, k = new w;
        f.push(0, 0, 0);
        g.push(0, 0, 1);
        h.push(.5, .5);
        var u = 0;
        for (l = 3; u <= b; u++, l += 3) {
            var t = c + u / b * d;
            m.x = a * Math.cos(t);
            m.y = a * Math.sin(t);
            f.push(m.x, m.y, m.z);
            g.push(0, 0, 1);
            k.x = (f[l] / a + 1) / 2;
            k.y = (f[l + 1] / a + 1) / 2;
            h.push(k.x, k.y);
        }
        for (l = 1; l <= b; l++)
            e.push(l, l + 1, 0);
        this.setIndex(e);
        this.addAttribute("position", new A(f, 3));
        this.addAttribute("normal", new A(g, 3));
        this.addAttribute("uv", new A(h, 2));
    }
    function jc(a) {
        M.call(this);
        this.type =
            "ShadowMaterial";
        this.color = new H(0);
        this.transparent = !0;
        this.setValues(a);
    }
    function Zc(a) { ma.call(this, a); this.type = "RawShaderMaterial"; }
    function fb(a) {
        M.call(this);
        this.defines = { STANDARD: "" };
        this.type = "MeshStandardMaterial";
        this.color = new H(16777215);
        this.metalness = this.roughness = .5;
        this.lightMap = this.map = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new H(0);
        this.emissiveIntensity = 1;
        this.bumpMap = this.emissiveMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType =
            0;
        this.normalScale = new w(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null;
        this.envMapIntensity = 1;
        this.refractionRatio = .98;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.wireframeLinejoin = this.wireframeLinecap = "round";
        this.morphNormals = this.morphTargets = this.skinning = !1;
        this.setValues(a);
    }
    function kc(a) {
        fb.call(this);
        this.defines = { STANDARD: "", PHYSICAL: "" };
        this.type = "MeshPhysicalMaterial";
        this.reflectivity =
            .5;
        this.clearcoatRoughness = this.clearcoat = 0;
        this.sheen = null;
        this.clearcoatNormalScale = new w(1, 1);
        this.clearcoatNormalMap = null;
        this.transparency = 0;
        this.setValues(a);
    }
    function Ra(a) {
        M.call(this);
        this.type = "MeshPhongMaterial";
        this.color = new H(16777215);
        this.specular = new H(1118481);
        this.shininess = 30;
        this.lightMap = this.map = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new H(0);
        this.emissiveIntensity = 1;
        this.bumpMap = this.emissiveMap = null;
        this.bumpScale = 1;
        this.normalMap =
            null;
        this.normalMapType = 0;
        this.normalScale = new w(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.envMap = this.alphaMap = this.specularMap = null;
        this.combine = 0;
        this.reflectivity = 1;
        this.refractionRatio = .98;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.wireframeLinejoin = this.wireframeLinecap = "round";
        this.morphNormals = this.morphTargets = this.skinning = !1;
        this.setValues(a);
    }
    function lc(a) {
        Ra.call(this);
        this.defines = { TOON: "" };
        this.type = "MeshToonMaterial";
        this.gradientMap =
            null;
        this.setValues(a);
    }
    function mc(a) { M.call(this); this.type = "MeshNormalMaterial"; this.bumpMap = null; this.bumpScale = 1; this.normalMap = null; this.normalMapType = 0; this.normalScale = new w(1, 1); this.displacementMap = null; this.displacementScale = 1; this.displacementBias = 0; this.wireframe = !1; this.wireframeLinewidth = 1; this.morphNormals = this.morphTargets = this.skinning = this.fog = !1; this.setValues(a); }
    function nc(a) {
        M.call(this);
        this.type = "MeshLambertMaterial";
        this.color = new H(16777215);
        this.lightMap = this.map = null;
        this.lightMapIntensity =
            1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new H(0);
        this.emissiveIntensity = 1;
        this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null;
        this.combine = 0;
        this.reflectivity = 1;
        this.refractionRatio = .98;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.wireframeLinejoin = this.wireframeLinecap = "round";
        this.morphNormals = this.morphTargets = this.skinning = !1;
        this.setValues(a);
    }
    function oc(a) {
        M.call(this);
        this.defines = { MATCAP: "" };
        this.type = "MeshMatcapMaterial";
        this.color = new H(16777215);
        this.bumpMap =
            this.map = this.matcap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = 0;
        this.normalScale = new w(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.alphaMap = null;
        this.morphNormals = this.morphTargets = this.skinning = !1;
        this.setValues(a);
    }
    function pc(a) { Q.call(this); this.type = "LineDashedMaterial"; this.scale = 1; this.dashSize = 3; this.gapSize = 1; this.setValues(a); }
    function Ia(a, b, c, d) {
        this.parameterPositions = a;
        this._cachedIndex = 0;
        this.resultBuffer = void 0 !== d ? d : new b.constructor(c);
        this.sampleValues = b;
        this.valueSize = c;
    }
    function Ne(a, b, c, d) { Ia.call(this, a, b, c, d); this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0; }
    function ke(a, b, c, d) { Ia.call(this, a, b, c, d); }
    function Oe(a, b, c, d) { Ia.call(this, a, b, c, d); }
    function oa(a, b, c, d) {
        if (void 0 === a)
            throw Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === b || 0 === b.length)
            throw Error("THREE.KeyframeTrack: no keyframes in track named " + a);
        this.name = a;
        this.times = pa.convertArray(b, this.TimeBufferType);
        this.values =
            pa.convertArray(c, this.ValueBufferType);
        this.setInterpolation(d || this.DefaultInterpolation);
    }
    function Pe(a, b, c) { oa.call(this, a, b, c); }
    function Qe(a, b, c, d) { oa.call(this, a, b, c, d); }
    function $c(a, b, c, d) { oa.call(this, a, b, c, d); }
    function Re(a, b, c, d) { Ia.call(this, a, b, c, d); }
    function le(a, b, c, d) { oa.call(this, a, b, c, d); }
    function Se(a, b, c, d) { oa.call(this, a, b, c, d); }
    function ad(a, b, c, d) { oa.call(this, a, b, c, d); }
    function Ma(a, b, c) {
        this.name = a;
        this.tracks = c;
        this.duration = void 0 !== b ? b : -1;
        this.uuid = L.generateUUID();
        0 > this.duration &&
            this.resetDuration();
    }
    function qk(a) { switch (a.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer": return $c;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4": return ad;
        case "color": return Qe;
        case "quaternion": return le;
        case "bool":
        case "boolean": return Pe;
        case "string": return Se;
    } throw Error("THREE.KeyframeTrack: Unsupported typeName: " + a); }
    function rk(a) {
        if (void 0 === a.type)
            throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
        var b = qk(a.type);
        if (void 0 === a.times) {
            var c = [], d = [];
            pa.flattenJSON(a.keys, c, d, "value");
            a.times = c;
            a.values = d;
        }
        return void 0 !== b.parse ? b.parse(a) : new b(a.name, a.times, a.values, a.interpolation);
    }
    function pg(a, b, c) {
        var d = this, e = !1, f = 0, g = 0, h = void 0, l = [];
        this.onStart = void 0;
        this.onLoad = a;
        this.onProgress = b;
        this.onError = c;
        this.itemStart = function (a) { g++; if (!1 === e && void 0 !== d.onStart)
            d.onStart(a, f, g); e = !0; };
        this.itemEnd = function (a) { f++; if (void 0 !== d.onProgress)
            d.onProgress(a, f, g); if (f === g && (e = !1, void 0 !== d.onLoad))
            d.onLoad(); };
        this.itemError = function (a) { if (void 0 !== d.onError)
            d.onError(a); };
        this.resolveURL = function (a) { return h ? h(a) : a; };
        this.setURLModifier = function (a) { h = a; return this; };
        this.addHandler = function (a, b) { l.push(a, b); return this; };
        this.removeHandler = function (a) { a = l.indexOf(a); -1 !== a && l.splice(a, 2); return this; };
        this.getHandler = function (a) { for (var b = 0, c = l.length; b < c; b += 2) {
            var d = l[b + 1];
            if (l[b].test(a))
                return d;
        } return null; };
    }
    function S(a) {
        this.manager = void 0 !== a ? a : Zh;
        this.crossOrigin = "anonymous";
        this.resourcePath = this.path =
            "";
    }
    function Na(a) { S.call(this, a); }
    function qg(a) { S.call(this, a); }
    function rg(a) { S.call(this, a); }
    function Te(a) { S.call(this, a); }
    function bd(a) { S.call(this, a); }
    function Ue(a) { S.call(this, a); }
    function Ve(a) { S.call(this, a); }
    function D() { this.type = "Curve"; this.arcLengthDivisions = 200; }
    function Ja(a, b, c, d, e, f, g, h) { D.call(this); this.type = "EllipseCurve"; this.aX = a || 0; this.aY = b || 0; this.xRadius = c || 1; this.yRadius = d || 1; this.aStartAngle = e || 0; this.aEndAngle = f || 2 * Math.PI; this.aClockwise = g || !1; this.aRotation = h || 0; }
    function cd(a, b, c, d, e, f) { Ja.call(this, a, b, c, c, d, e, f); this.type = "ArcCurve"; }
    function sg() { var a = 0, b = 0, c = 0, d = 0; return { initCatmullRom: function (e, f, g, h, l) { e = l * (g - e); h = l * (h - f); a = f; b = e; c = -3 * f + 3 * g - 2 * e - h; d = 2 * f - 2 * g + e + h; }, initNonuniformCatmullRom: function (e, f, g, h, l, m, k) { e = ((f - e) / l - (g - e) / (l + m) + (g - f) / m) * m; h = ((g - f) / m - (h - f) / (m + k) + (h - g) / k) * m; a = f; b = e; c = -3 * f + 3 * g - 2 * e - h; d = 2 * f - 2 * g + e + h; }, calc: function (e) { var f = e * e; return a + b * e + c * f + d * f * e; } }; }
    function ya(a, b, c, d) {
        D.call(this);
        this.type = "CatmullRomCurve3";
        this.points = a || [];
        this.closed = b ||
            !1;
        this.curveType = c || "centripetal";
        this.tension = d || .5;
    }
    function $h(a, b, c, d, e) { b = .5 * (d - b); e = .5 * (e - c); var f = a * a; return (2 * c - 2 * d + b + e) * a * f + (-3 * c + 3 * d - 2 * b - e) * f + b * a + c; }
    function me(a, b, c, d) { var e = 1 - a; return e * e * b + 2 * (1 - a) * a * c + a * a * d; }
    function ne(a, b, c, d, e) { var f = 1 - a, g = 1 - a; return f * f * f * b + 3 * g * g * a * c + 3 * (1 - a) * a * a * d + a * a * a * e; }
    function Sa(a, b, c, d) { D.call(this); this.type = "CubicBezierCurve"; this.v0 = a || new w; this.v1 = b || new w; this.v2 = c || new w; this.v3 = d || new w; }
    function gb(a, b, c, d) {
        D.call(this);
        this.type = "CubicBezierCurve3";
        this.v0 = a || new n;
        this.v1 = b || new n;
        this.v2 = c || new n;
        this.v3 = d || new n;
    }
    function za(a, b) { D.call(this); this.type = "LineCurve"; this.v1 = a || new w; this.v2 = b || new w; }
    function Ta(a, b) { D.call(this); this.type = "LineCurve3"; this.v1 = a || new n; this.v2 = b || new n; }
    function Ua(a, b, c) { D.call(this); this.type = "QuadraticBezierCurve"; this.v0 = a || new w; this.v1 = b || new w; this.v2 = c || new w; }
    function hb(a, b, c) { D.call(this); this.type = "QuadraticBezierCurve3"; this.v0 = a || new n; this.v1 = b || new n; this.v2 = c || new n; }
    function Va(a) {
        D.call(this);
        this.type = "SplineCurve";
        this.points = a || [];
    }
    function rb() { D.call(this); this.type = "CurvePath"; this.curves = []; this.autoClose = !1; }
    function Wa(a) { rb.call(this); this.type = "Path"; this.currentPoint = new w; a && this.setFromPoints(a); }
    function Jb(a) { Wa.call(this, a); this.uuid = L.generateUUID(); this.type = "Shape"; this.holes = []; }
    function da(a, b) { B.call(this); this.type = "Light"; this.color = new H(a); this.intensity = void 0 !== b ? b : 1; this.receiveShadow = void 0; }
    function We(a, b, c) {
        da.call(this, a, c);
        this.type = "HemisphereLight";
        this.castShadow =
            void 0;
        this.position.copy(B.DefaultUp);
        this.updateMatrix();
        this.groundColor = new H(b);
    }
    function ib(a) { this.camera = a; this.bias = 0; this.radius = 1; this.mapSize = new w(512, 512); this.mapPass = this.map = null; this.matrix = new U; this._frustum = new Ed; this._frameExtents = new w(1, 1); this._viewportCount = 1; this._viewports = [new aa(0, 0, 1, 1)]; }
    function Xe() { ib.call(this, new na(50, 1, .5, 500)); }
    function Ye(a, b, c, d, e, f) {
        da.call(this, a, b);
        this.type = "SpotLight";
        this.position.copy(B.DefaultUp);
        this.updateMatrix();
        this.target = new B;
        Object.defineProperty(this, "power", { get: function () { return this.intensity * Math.PI; }, set: function (a) { this.intensity = a / Math.PI; } });
        this.distance = void 0 !== c ? c : 0;
        this.angle = void 0 !== d ? d : Math.PI / 3;
        this.penumbra = void 0 !== e ? e : 0;
        this.decay = void 0 !== f ? f : 1;
        this.shadow = new Xe;
    }
    function tg() {
        ib.call(this, new na(90, 1, .5, 500));
        this._frameExtents = new w(4, 2);
        this._viewportCount = 6;
        this._viewports = [new aa(2, 1, 1, 1), new aa(0, 1, 1, 1), new aa(3, 1, 1, 1), new aa(1, 1, 1, 1), new aa(3, 0, 1, 1), new aa(1, 0, 1, 1)];
        this._cubeDirections = [new n(1, 0, 0), new n(-1, 0, 0), new n(0, 0, 1), new n(0, 0, -1), new n(0, 1, 0), new n(0, -1, 0)];
        this._cubeUps = [new n(0, 1, 0), new n(0, 1, 0), new n(0, 1, 0), new n(0, 1, 0), new n(0, 0, 1), new n(0, 0, -1)];
    }
    function Ze(a, b, c, d) { da.call(this, a, b); this.type = "PointLight"; Object.defineProperty(this, "power", { get: function () { return 4 * this.intensity * Math.PI; }, set: function (a) { this.intensity = a / (4 * Math.PI); } }); this.distance = void 0 !== c ? c : 0; this.decay = void 0 !== d ? d : 1; this.shadow = new tg; }
    function oe(a, b, c, d, e, f) {
        bb.call(this);
        this.type = "OrthographicCamera";
        this.zoom = 1;
        this.view = null;
        this.left = void 0 !== a ? a : -1;
        this.right = void 0 !== b ? b : 1;
        this.top = void 0 !== c ? c : 1;
        this.bottom = void 0 !== d ? d : -1;
        this.near = void 0 !== e ? e : .1;
        this.far = void 0 !== f ? f : 2E3;
        this.updateProjectionMatrix();
    }
    function $e() { ib.call(this, new oe(-5, 5, 5, -5, .5, 500)); }
    function af(a, b) { da.call(this, a, b); this.type = "DirectionalLight"; this.position.copy(B.DefaultUp); this.updateMatrix(); this.target = new B; this.shadow = new $e; }
    function bf(a, b) { da.call(this, a, b); this.type = "AmbientLight"; this.castShadow = void 0; }
    function cf(a, b, c, d) { da.call(this, a, b); this.type = "RectAreaLight"; this.width = void 0 !== c ? c : 10; this.height = void 0 !== d ? d : 10; }
    function df(a) { S.call(this, a); this.textures = {}; }
    function ef() { E.call(this); this.type = "InstancedBufferGeometry"; this.maxInstancedCount = void 0; }
    function ff(a, b, c, d) { "number" === typeof c && (d = c, c = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")); O.call(this, a, b, c); this.meshPerAttribute = d || 1; }
    function gf(a) { S.call(this, a); }
    function hf(a) {
        S.call(this, a);
    }
    function ug(a) { "undefined" === typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."); "undefined" === typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."); S.call(this, a); this.options = void 0; }
    function vg() { this.type = "ShapePath"; this.color = new H; this.subPaths = []; this.currentPath = null; }
    function wg(a) { this.type = "Font"; this.data = a; }
    function xg(a) { S.call(this, a); }
    function jf(a) { S.call(this, a); }
    function kf() {
        this.coefficients = [];
        for (var a = 0; 9 > a; a++)
            this.coefficients.push(new n);
    }
    function Xa(a, b) { da.call(this, void 0, b); this.sh = void 0 !== a ? a : new kf; }
    function yg(a, b, c) { Xa.call(this, void 0, c); a = (new H).set(a); c = (new H).set(b); b = new n(a.r, a.g, a.b); a = new n(c.r, c.g, c.b); c = Math.sqrt(Math.PI); var d = c * Math.sqrt(.75); this.sh.coefficients[0].copy(b).add(a).multiplyScalar(c); this.sh.coefficients[1].copy(b).sub(a).multiplyScalar(d); }
    function zg(a, b) { Xa.call(this, void 0, b); a = (new H).set(a); this.sh.coefficients[0].set(a.r, a.g, a.b).multiplyScalar(2 * Math.sqrt(Math.PI)); }
    function ai() { this.type = "StereoCamera"; this.aspect = 1; this.eyeSep = .064; this.cameraL = new na; this.cameraL.layers.enable(1); this.cameraL.matrixAutoUpdate = !1; this.cameraR = new na; this.cameraR.layers.enable(2); this.cameraR.matrixAutoUpdate = !1; this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null }; }
    function Ag(a) { this.autoStart = void 0 !== a ? a : !0; this.elapsedTime = this.oldTime = this.startTime = 0; this.running = !1; }
    function Bg() {
        B.call(this);
        this.type = "AudioListener";
        this.context = Cg.getContext();
        this.gain = this.context.createGain();
        this.gain.connect(this.context.destination);
        this.filter = null;
        this.timeDelta = 0;
        this._clock = new Ag;
    }
    function dd(a) { B.call(this); this.type = "Audio"; this.listener = a; this.context = a.context; this.gain = this.context.createGain(); this.gain.connect(a.getInput()); this.autoplay = !1; this.buffer = null; this.detune = 0; this.loop = !1; this.offset = this.startTime = 0; this.duration = void 0; this.playbackRate = 1; this.isPlaying = !1; this.hasPlaybackControl = !0; this.sourceType = "empty"; this.filters = []; }
    function Dg(a) { dd.call(this, a); this.panner = this.context.createPanner(); this.panner.panningModel = "HRTF"; this.panner.connect(this.gain); }
    function Eg(a, b) { this.analyser = a.context.createAnalyser(); this.analyser.fftSize = void 0 !== b ? b : 2048; this.data = new Uint8Array(this.analyser.frequencyBinCount); a.getOutput().connect(this.analyser); }
    function Fg(a, b, c) {
        this.binding = a;
        this.valueSize = c;
        a = Float64Array;
        switch (b) {
            case "quaternion":
                b = this._slerp;
                break;
            case "string":
            case "bool":
                a = Array;
                b = this._select;
                break;
            default: b =
                this._lerp;
        }
        this.buffer = new a(4 * c);
        this._mixBufferRegion = b;
        this.referenceCount = this.useCount = this.cumulativeWeight = 0;
    }
    function bi(a, b, c) { c = c || Aa.parseTrackName(b); this._targetGroup = a; this._bindings = a.subscribe_(b, c); }
    function Aa(a, b, c) { this.path = b; this.parsedPath = c || Aa.parseTrackName(b); this.node = Aa.findNode(a, this.parsedPath.nodeName) || a; this.rootNode = a; }
    function ci() {
        this.uuid = L.generateUUID();
        this._objects = Array.prototype.slice.call(arguments);
        this.nCachedObjects_ = 0;
        var a = {};
        this._indicesByUUID = a;
        for (var b = 0, c = arguments.length; b !== c; ++b)
            a[arguments[b].uuid] = b;
        this._paths = [];
        this._parsedPaths = [];
        this._bindings = [];
        this._bindingsIndicesByPath = {};
        var d = this;
        this.stats = { objects: { get total() { return d._objects.length; }, get inUse() { return this.total - d.nCachedObjects_; } }, get bindingsPerObject() { return d._bindings.length; } };
    }
    function di(a, b, c) {
        this._mixer = a;
        this._clip = b;
        this._localRoot = c || null;
        a = b.tracks;
        b = a.length;
        c = Array(b);
        for (var d = { endingStart: 2400, endingEnd: 2400 }, e = 0; e !== b; ++e) {
            var f = a[e].createInterpolant(null);
            c[e] = f;
            f.settings = d;
        }
        this._interpolantSettings = d;
        this._interpolants = c;
        this._propertyBindings = Array(b);
        this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null;
        this.loop = 2201;
        this._loopCount = -1;
        this._startTime = null;
        this.time = 0;
        this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1;
        this.repetitions = Infinity;
        this.paused = !1;
        this.enabled = !0;
        this.clampWhenFinished = !1;
        this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0;
    }
    function Gg(a) {
        this._root = a;
        this._initMemoryManager();
        this.time = this._accuIndex = 0;
        this.timeScale = 1;
    }
    function lf(a, b) { "string" === typeof a && (console.warn("THREE.Uniform: Type parameter is no longer needed."), a = b); this.value = a; }
    function Hg(a, b, c) { Gb.call(this, a, b); this.meshPerAttribute = c || 1; }
    function ei(a, b, c, d) {
        this.ray = new Sb(a, b);
        this.near = c || 0;
        this.far = d || Infinity;
        this.camera = null;
        this.params = { Mesh: {}, Line: {}, LOD: {}, Points: { threshold: 1 }, Sprite: {} };
        Object.defineProperties(this.params, { PointCloud: { get: function () {
                    console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
                    return this.Points;
                } } });
    }
    function fi(a, b) { return a.distance - b.distance; }
    function Ig(a, b, c, d) { if (!1 !== a.visible && (a.raycast(b, c), !0 === d)) {
        a = a.children;
        d = 0;
        for (var e = a.length; d < e; d++)
            Ig(a[d], b, c, !0);
    } }
    function gi(a, b, c) { this.radius = void 0 !== a ? a : 1; this.phi = void 0 !== b ? b : 0; this.theta = void 0 !== c ? c : 0; return this; }
    function hi(a, b, c) { this.radius = void 0 !== a ? a : 1; this.theta = void 0 !== b ? b : 0; this.y = void 0 !== c ? c : 0; return this; }
    function Jg(a, b) {
        this.min = void 0 !== a ? a : new w(Infinity, Infinity);
        this.max = void 0 !== b ? b : new w(-Infinity, -Infinity);
    }
    function Kg(a, b) { this.start = void 0 !== a ? a : new n; this.end = void 0 !== b ? b : new n; }
    function pe(a) { B.call(this); this.material = a; this.render = function () { }; }
    function qe(a, b, c, d) { this.object = a; this.size = void 0 !== b ? b : 1; a = void 0 !== c ? c : 16711680; d = void 0 !== d ? d : 1; b = 0; (c = this.object.geometry) && c.isGeometry ? b = 3 * c.faces.length : c && c.isBufferGeometry && (b = c.attributes.normal.count); c = new E; b = new A(6 * b, 3); c.addAttribute("position", b); ca.call(this, c, new Q({ color: a, linewidth: d })); this.matrixAutoUpdate = !1; this.update(); }
    function ed(a, b) { B.call(this); this.light = a; this.light.updateMatrixWorld(); this.matrix = a.matrixWorld; this.matrixAutoUpdate = !1; this.color = b; a = new E; b = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]; for (var c = 0, d = 1; 32 > c; c++, d++) {
        var e = c / 32 * Math.PI * 2, f = d / 32 * Math.PI * 2;
        b.push(Math.cos(e), Math.sin(e), 1, Math.cos(f), Math.sin(f), 1);
    } a.addAttribute("position", new A(b, 3)); b = new Q({ fog: !1 }); this.cone = new ca(a, b); this.add(this.cone); this.update(); }
    function ii(a) {
        var b = [];
        a && a.isBone && b.push(a);
        for (var c = 0; c < a.children.length; c++)
            b.push.apply(b, ii(a.children[c]));
        return b;
    }
    function fd(a) {
        for (var b = ii(a), c = new E, d = [], e = [], f = new H(0, 0, 1), g = new H(0, 1, 0), h = 0; h < b.length; h++) {
            var l = b[h];
            l.parent && l.parent.isBone && (d.push(0, 0, 0), d.push(0, 0, 0), e.push(f.r, f.g, f.b), e.push(g.r, g.g, g.b));
        }
        c.addAttribute("position", new A(d, 3));
        c.addAttribute("color", new A(e, 3));
        d = new Q({ vertexColors: 2, depthTest: !1, depthWrite: !1, transparent: !0 });
        ca.call(this, c, d);
        this.root = a;
        this.bones = b;
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate =
            !1;
    }
    function gd(a, b, c) { this.light = a; this.light.updateMatrixWorld(); this.color = c; a = new Ib(b, 4, 2); b = new Ga({ wireframe: !0, fog: !1 }); ja.call(this, a, b); this.matrix = this.light.matrixWorld; this.matrixAutoUpdate = !1; this.update(); }
    function hd(a, b) {
        this.type = "RectAreaLightHelper";
        this.light = a;
        this.color = b;
        a = new E;
        a.addAttribute("position", new A([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3));
        a.computeBoundingSphere();
        b = new Q({ fog: !1 });
        xa.call(this, a, b);
        a = new E;
        a.addAttribute("position", new A([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1,
            0, -1, -1, 0, 1, -1, 0], 3));
        a.computeBoundingSphere();
        this.add(new ja(a, new Ga({ side: 1, fog: !1 })));
        this.update();
    }
    function id(a, b, c) {
        B.call(this);
        this.light = a;
        this.light.updateMatrixWorld();
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
        this.color = c;
        a = new cc(b);
        a.rotateY(.5 * Math.PI);
        this.material = new Ga({ wireframe: !0, fog: !1 });
        void 0 === this.color && (this.material.vertexColors = 2);
        b = a.getAttribute("position");
        b = new Float32Array(3 * b.count);
        a.addAttribute("color", new O(b, 3));
        this.add(new ja(a, this.material));
        this.update();
    }
    function jd(a, b) {
        this.lightProbe = a;
        this.size = b;
        a = new ma({ defines: { GAMMA_OUTPUT: "" }, uniforms: { sh: { value: this.lightProbe.sh.coefficients }, intensity: { value: this.lightProbe.intensity } }, vertexShader: "varying vec3 vNormal;\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader: "#define RECIPROCAL_PI 0.318309886\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\t// matrix is assumed to be orthogonal\n\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 linearToOutput( in vec3 a ) {\n\t#ifdef GAMMA_OUTPUT\n\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\t#else\n\t\treturn a;\n\t#endif\n}\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\t// normal is assumed to have unit length\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\t// band 0\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\t// band 1\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\t// band 2\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nuniform vec3 sh[ 9 ]; // sh coefficients\nuniform float intensity; // light probe intensity\nvarying vec3 vNormal;\nvoid main() {\n\tvec3 normal = normalize( vNormal );\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );\n\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;\n\toutgoingLight = linearToOutput( outgoingLight );\n\tgl_FragColor = vec4( outgoingLight, 1.0 );\n}" });
        b = new Ib(1, 32, 16);
        ja.call(this, b, a);
        this.onBeforeRender();
    }
    function mf(a, b, c, d) { a = a || 10; b = b || 10; c = new H(void 0 !== c ? c : 4473924); d = new H(void 0 !== d ? d : 8947848); var e = b / 2, f = a / b, g = a / 2; a = []; for (var h = [], l = 0, m = 0, k = -g; l <= b; l++, k += f) {
        a.push(-g, 0, k, g, 0, k);
        a.push(k, 0, -g, k, 0, g);
        var n = l === e ? c : d;
        n.toArray(h, m);
        m += 3;
        n.toArray(h, m);
        m += 3;
        n.toArray(h, m);
        m += 3;
        n.toArray(h, m);
        m += 3;
    } b = new E; b.addAttribute("position", new A(a, 3)); b.addAttribute("color", new A(h, 3)); c = new Q({ vertexColors: 2 }); ca.call(this, b, c); }
    function nf(a, b, c, d, e, f) {
        a = a || 10;
        b = b || 16;
        c = c || 8;
        d = d || 64;
        e = new H(void 0 !== e ? e : 4473924);
        f = new H(void 0 !== f ? f : 8947848);
        var g = [], h = [], l;
        for (l = 0; l <= b; l++) {
            var m = l / b * 2 * Math.PI;
            var k = Math.sin(m) * a;
            m = Math.cos(m) * a;
            g.push(0, 0, 0);
            g.push(k, 0, m);
            var n = l & 1 ? e : f;
            h.push(n.r, n.g, n.b);
            h.push(n.r, n.g, n.b);
        }
        for (l = 0; l <= c; l++) {
            n = l & 1 ? e : f;
            var t = a - a / c * l;
            for (b = 0; b < d; b++)
                m = b / d * 2 * Math.PI, k = Math.sin(m) * t, m = Math.cos(m) * t, g.push(k, 0, m), h.push(n.r, n.g, n.b), m = (b + 1) / d * 2 * Math.PI, k = Math.sin(m) * t, m = Math.cos(m) * t, g.push(k, 0, m), h.push(n.r, n.g, n.b);
        }
        a = new E;
        a.addAttribute("position", new A(g, 3));
        a.addAttribute("color", new A(h, 3));
        g = new Q({ vertexColors: 2 });
        ca.call(this, a, g);
    }
    function kd(a, b, c, d) { this.audio = a; this.range = b || 1; this.divisionsInnerAngle = c || 16; this.divisionsOuterAngle = d || 2; a = new E; b = new Float32Array(3 * (3 * (this.divisionsInnerAngle + 2 * this.divisionsOuterAngle) + 3)); a.addAttribute("position", new O(b, 3)); b = new Q({ color: 65280 }); c = new Q({ color: 16776960 }); xa.call(this, a, [c, b]); this.update(); }
    function re(a, b, c, d) {
        this.object = a;
        this.size = void 0 !== b ? b : 1;
        a = void 0 !== c ? c : 16776960;
        d = void 0 !== d ? d : 1;
        b = 0;
        (c = this.object.geometry) && c.isGeometry ? b = c.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
        c = new E;
        b = new A(6 * b, 3);
        c.addAttribute("position", b);
        ca.call(this, c, new Q({ color: a, linewidth: d }));
        this.matrixAutoUpdate = !1;
        this.update();
    }
    function ld(a, b, c) {
        B.call(this);
        this.light = a;
        this.light.updateMatrixWorld();
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
        this.color = c;
        void 0 ===
            b && (b = 1);
        a = new E;
        a.addAttribute("position", new A([-b, b, 0, b, b, 0, b, -b, 0, -b, -b, 0, -b, b, 0], 3));
        b = new Q({ fog: !1 });
        this.lightPlane = new xa(a, b);
        this.add(this.lightPlane);
        a = new E;
        a.addAttribute("position", new A([0, 0, 0, 0, 0, 1], 3));
        this.targetLine = new xa(a, b);
        this.add(this.targetLine);
        this.update();
    }
    function se(a) {
        function b(a, b, d) { c(a, d); c(b, d); }
        function c(a, b) { f.push(0, 0, 0); g.push(b.r, b.g, b.b); void 0 === h[a] && (h[a] = []); h[a].push(f.length / 3 - 1); }
        var d = new E, e = new Q({ color: 16777215, vertexColors: 1 }), f = [], g = [], h = {}, l = new H(16755200), m = new H(16711680), k = new H(43775), n = new H(16777215), t = new H(3355443);
        b("n1", "n2", l);
        b("n2", "n4", l);
        b("n4", "n3", l);
        b("n3", "n1", l);
        b("f1", "f2", l);
        b("f2", "f4", l);
        b("f4", "f3", l);
        b("f3", "f1", l);
        b("n1", "f1", l);
        b("n2", "f2", l);
        b("n3", "f3", l);
        b("n4", "f4", l);
        b("p", "n1", m);
        b("p", "n2", m);
        b("p", "n3", m);
        b("p", "n4", m);
        b("u1", "u2", k);
        b("u2", "u3", k);
        b("u3", "u1", k);
        b("c", "t", n);
        b("p", "c", t);
        b("cn1", "cn2", t);
        b("cn3", "cn4", t);
        b("cf1", "cf2", t);
        b("cf3", "cf4", t);
        d.addAttribute("position", new A(f, 3));
        d.addAttribute("color", new A(g, 3));
        ca.call(this, d, e);
        this.camera = a;
        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix();
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
        this.pointMap = h;
        this.update();
    }
    function qa(a, b, c, d, e, f, g) { of.set(e, f, g).unproject(d); a = b[a]; if (void 0 !== a)
        for (c = c.getAttribute("position"), b = 0, d = a.length; b < d; b++)
            c.setXYZ(a[b], of.x, of.y, of.z); }
    function sb(a, b) {
        this.object = a;
        void 0 === b && (b = 16776960);
        a = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var c = new Float32Array(24), d = new E;
        d.setIndex(new O(a, 1));
        d.addAttribute("position", new O(c, 3));
        ca.call(this, d, new Q({ color: b }));
        this.matrixAutoUpdate = !1;
        this.update();
    }
    function te(a, b) { this.type = "Box3Helper"; this.box = a; b = b || 16776960; a = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]); var c = new E; c.setIndex(new O(a, 1)); c.addAttribute("position", new A([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)); ca.call(this, c, new Q({ color: b })); this.geometry.computeBoundingSphere(); }
    function ue(a, b, c) {
        this.type =
            "PlaneHelper";
        this.plane = a;
        this.size = void 0 === b ? 1 : b;
        a = void 0 !== c ? c : 16776960;
        b = new E;
        b.addAttribute("position", new A([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3));
        b.computeBoundingSphere();
        xa.call(this, b, new Q({ color: a }));
        b = new E;
        b.addAttribute("position", new A([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3));
        b.computeBoundingSphere();
        this.add(new ja(b, new Ga({ color: a, opacity: .2, transparent: !0, depthWrite: !1 })));
    }
    function tb(a, b, c, d, e, f) {
        B.call(this);
        void 0 === a && (a = new n(0, 0, 1));
        void 0 === b && (b = new n(0, 0, 0));
        void 0 === c && (c = 1);
        void 0 === d && (d = 16776960);
        void 0 === e && (e = .2 * c);
        void 0 === f && (f = .2 * e);
        void 0 === pf && (pf = new E, pf.addAttribute("position", new A([0, 0, 0, 0, 1, 0], 3)), Lg = new qb(0, .5, 1, 5, 1), Lg.translate(0, -.5, 0));
        this.position.copy(b);
        this.line = new xa(pf, new Q({ color: d }));
        this.line.matrixAutoUpdate = !1;
        this.add(this.line);
        this.cone = new ja(Lg, new Ga({ color: d }));
        this.cone.matrixAutoUpdate = !1;
        this.add(this.cone);
        this.setDirection(a);
        this.setLength(c, e, f);
    }
    function ve(a) {
        a = a ||
            1;
        var b = [0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a];
        a = new E;
        a.addAttribute("position", new A(b, 3));
        a.addAttribute("color", new A([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
        b = new Q({ vertexColors: 2 });
        ca.call(this, a, b);
    }
    function ji(a) { console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."); ya.call(this, a); this.type = "catmullrom"; this.closed = !0; }
    function ki(a) {
        console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
        ya.call(this, a);
        this.type =
            "catmullrom";
    }
    function Mg(a) { console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."); ya.call(this, a); this.type = "catmullrom"; }
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52));
    void 0 === Number.isInteger && (Number.isInteger = function (a) { return "number" === typeof a && isFinite(a) && Math.floor(a) === a; });
    void 0 === Math.sign && (Math.sign = function (a) { return 0 > a ? -1 : 0 < a ? 1 : +a; });
    !1 === "name" in Function.prototype && Object.defineProperty(Function.prototype, "name", { get: function () { return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]; } });
    void 0 === Object.assign && (Object.assign = function (a) { if (void 0 === a || null === a)
        throw new TypeError("Cannot convert undefined or null to object"); for (var b = Object(a), c = 1; c < arguments.length; c++) {
        var d = arguments[c];
        if (void 0 !== d && null !== d)
            for (var e in d)
                Object.prototype.hasOwnProperty.call(d, e) && (b[e] = d[e]);
    } return b; });
    Object.assign(Ba.prototype, { addEventListener: function (a, b) { void 0 === this._listeners && (this._listeners = {}); var c = this._listeners; void 0 === c[a] && (c[a] = []); -1 === c[a].indexOf(b) && c[a].push(b); },
        hasEventListener: function (a, b) { if (void 0 === this._listeners)
            return !1; var c = this._listeners; return void 0 !== c[a] && -1 !== c[a].indexOf(b); }, removeEventListener: function (a, b) { void 0 !== this._listeners && (a = this._listeners[a], void 0 !== a && (b = a.indexOf(b), -1 !== b && a.splice(b, 1))); }, dispatchEvent: function (a) { if (void 0 !== this._listeners) {
            var b = this._listeners[a.type];
            if (void 0 !== b) {
                a.target = this;
                b = b.slice(0);
                for (var c = 0, d = b.length; c < d; c++)
                    b[c].call(this, a);
            }
        } } });
    for (var va = [], we = 0; 256 > we; we++)
        va[we] = (16 > we ? "0" : "") +
            we.toString(16);
    var L = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function () { var a = 4294967295 * Math.random() | 0, b = 4294967295 * Math.random() | 0, c = 4294967295 * Math.random() | 0, d = 4294967295 * Math.random() | 0; return (va[a & 255] + va[a >> 8 & 255] + va[a >> 16 & 255] + va[a >> 24 & 255] + "-" + va[b & 255] + va[b >> 8 & 255] + "-" + va[b >> 16 & 15 | 64] + va[b >> 24 & 255] + "-" + va[c & 63 | 128] + va[c >> 8 & 255] + "-" + va[c >> 16 & 255] + va[c >> 24 & 255] + va[d & 255] + va[d >> 8 & 255] + va[d >> 16 & 255] + va[d >> 24 & 255]).toUpperCase(); }, clamp: function (a, b, c) {
            return Math.max(b, Math.min(c, a));
        }, euclideanModulo: function (a, b) { return (a % b + b) % b; }, mapLinear: function (a, b, c, d, e) { return d + (a - b) * (e - d) / (c - b); }, lerp: function (a, b, c) { return (1 - c) * a + c * b; }, smoothstep: function (a, b, c) { if (a <= b)
            return 0; if (a >= c)
            return 1; a = (a - b) / (c - b); return a * a * (3 - 2 * a); }, smootherstep: function (a, b, c) { if (a <= b)
            return 0; if (a >= c)
            return 1; a = (a - b) / (c - b); return a * a * a * (a * (6 * a - 15) + 10); }, randInt: function (a, b) { return a + Math.floor(Math.random() * (b - a + 1)); }, randFloat: function (a, b) { return a + Math.random() * (b - a); }, randFloatSpread: function (a) {
            return a *
                (.5 - Math.random());
        }, degToRad: function (a) { return a * L.DEG2RAD; }, radToDeg: function (a) { return a * L.RAD2DEG; }, isPowerOfTwo: function (a) { return 0 === (a & a - 1) && 0 !== a; }, ceilPowerOfTwo: function (a) { return Math.pow(2, Math.ceil(Math.log(a) / Math.LN2)); }, floorPowerOfTwo: function (a) { return Math.pow(2, Math.floor(Math.log(a) / Math.LN2)); } };
    Object.defineProperties(w.prototype, { width: { get: function () { return this.x; }, set: function (a) { this.x = a; } }, height: { get: function () { return this.y; }, set: function (a) { this.y = a; } } });
    Object.assign(w.prototype, { isVector2: !0, set: function (a, b) { this.x = a; this.y = b; return this; }, setScalar: function (a) { this.y = this.x = a; return this; }, setX: function (a) { this.x = a; return this; }, setY: function (a) { this.y = a; return this; }, setComponent: function (a, b) { switch (a) {
            case 0:
                this.x = b;
                break;
            case 1:
                this.y = b;
                break;
            default: throw Error("index is out of range: " + a);
        } return this; }, getComponent: function (a) { switch (a) {
            case 0: return this.x;
            case 1: return this.y;
            default: throw Error("index is out of range: " + a);
        } }, clone: function () {
            return new this.constructor(this.x, this.y);
        }, copy: function (a) { this.x = a.x; this.y = a.y; return this; }, add: function (a, b) { if (void 0 !== b)
            return console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b); this.x += a.x; this.y += a.y; return this; }, addScalar: function (a) { this.x += a; this.y += a; return this; }, addVectors: function (a, b) { this.x = a.x + b.x; this.y = a.y + b.y; return this; }, addScaledVector: function (a, b) { this.x += a.x * b; this.y += a.y * b; return this; }, sub: function (a, b) {
            if (void 0 !== b)
                return console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                    this.subVectors(a, b);
            this.x -= a.x;
            this.y -= a.y;
            return this;
        }, subScalar: function (a) { this.x -= a; this.y -= a; return this; }, subVectors: function (a, b) { this.x = a.x - b.x; this.y = a.y - b.y; return this; }, multiply: function (a) { this.x *= a.x; this.y *= a.y; return this; }, multiplyScalar: function (a) { this.x *= a; this.y *= a; return this; }, divide: function (a) { this.x /= a.x; this.y /= a.y; return this; }, divideScalar: function (a) { return this.multiplyScalar(1 / a); }, applyMatrix3: function (a) {
            var b = this.x, c = this.y;
            a = a.elements;
            this.x = a[0] * b + a[3] * c + a[6];
            this.y =
                a[1] * b + a[4] * c + a[7];
            return this;
        }, min: function (a) { this.x = Math.min(this.x, a.x); this.y = Math.min(this.y, a.y); return this; }, max: function (a) { this.x = Math.max(this.x, a.x); this.y = Math.max(this.y, a.y); return this; }, clamp: function (a, b) { this.x = Math.max(a.x, Math.min(b.x, this.x)); this.y = Math.max(a.y, Math.min(b.y, this.y)); return this; }, clampScalar: function (a, b) { this.x = Math.max(a, Math.min(b, this.x)); this.y = Math.max(a, Math.min(b, this.y)); return this; }, clampLength: function (a, b) {
            var c = this.length();
            return this.divideScalar(c ||
                1).multiplyScalar(Math.max(a, Math.min(b, c)));
        }, floor: function () { this.x = Math.floor(this.x); this.y = Math.floor(this.y); return this; }, ceil: function () { this.x = Math.ceil(this.x); this.y = Math.ceil(this.y); return this; }, round: function () { this.x = Math.round(this.x); this.y = Math.round(this.y); return this; }, roundToZero: function () { this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x); this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y); return this; }, negate: function () { this.x = -this.x; this.y = -this.y; return this; }, dot: function (a) {
            return this.x *
                a.x + this.y * a.y;
        }, cross: function (a) { return this.x * a.y - this.y * a.x; }, lengthSq: function () { return this.x * this.x + this.y * this.y; }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y); }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y); }, normalize: function () { return this.divideScalar(this.length() || 1); }, angle: function () { var a = Math.atan2(this.y, this.x); 0 > a && (a += 2 * Math.PI); return a; }, distanceTo: function (a) { return Math.sqrt(this.distanceToSquared(a)); }, distanceToSquared: function (a) {
            var b = this.x - a.x;
            a = this.y - a.y;
            return b * b + a * a;
        }, manhattanDistanceTo: function (a) { return Math.abs(this.x - a.x) + Math.abs(this.y - a.y); }, setLength: function (a) { return this.normalize().multiplyScalar(a); }, lerp: function (a, b) { this.x += (a.x - this.x) * b; this.y += (a.y - this.y) * b; return this; }, lerpVectors: function (a, b, c) { return this.subVectors(b, a).multiplyScalar(c).add(a); }, equals: function (a) { return a.x === this.x && a.y === this.y; }, fromArray: function (a, b) { void 0 === b && (b = 0); this.x = a[b]; this.y = a[b + 1]; return this; }, toArray: function (a, b) { void 0 === a && (a = []); void 0 === b && (b = 0); a[b] = this.x; a[b + 1] = this.y; return a; }, fromBufferAttribute: function (a, b, c) { void 0 !== c && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."); this.x = a.getX(b); this.y = a.getY(b); return this; }, rotateAround: function (a, b) { var c = Math.cos(b); b = Math.sin(b); var d = this.x - a.x, e = this.y - a.y; this.x = d * c - e * b + a.x; this.y = d * b + e * c + a.y; return this; } });
    Object.assign(ua, { slerp: function (a, b, c, d) { return c.copy(a).slerp(b, d); }, slerpFlat: function (a, b, c, d, e, f, g) {
            var h = c[d + 0], l = c[d + 1], m = c[d + 2];
            c = c[d + 3];
            d = e[f + 0];
            var k = e[f + 1], n = e[f + 2];
            e = e[f + 3];
            if (c !== e || h !== d || l !== k || m !== n) {
                f = 1 - g;
                var t = h * d + l * k + m * n + c * e, r = 0 <= t ? 1 : -1, p = 1 - t * t;
                p > Number.EPSILON && (p = Math.sqrt(p), t = Math.atan2(p, t * r), f = Math.sin(f * t) / p, g = Math.sin(g * t) / p);
                r *= g;
                h = h * f + d * r;
                l = l * f + k * r;
                m = m * f + n * r;
                c = c * f + e * r;
                f === 1 - g && (g = 1 / Math.sqrt(h * h + l * l + m * m + c * c), h *= g, l *= g, m *= g, c *= g);
            }
            a[b] = h;
            a[b + 1] = l;
            a[b + 2] = m;
            a[b + 3] = c;
        } });
    Object.defineProperties(ua.prototype, { x: { get: function () { return this._x; }, set: function (a) { this._x = a; this._onChangeCallback(); } },
        y: { get: function () { return this._y; }, set: function (a) { this._y = a; this._onChangeCallback(); } }, z: { get: function () { return this._z; }, set: function (a) { this._z = a; this._onChangeCallback(); } }, w: { get: function () { return this._w; }, set: function (a) { this._w = a; this._onChangeCallback(); } } });
    Object.assign(ua.prototype, { isQuaternion: !0, set: function (a, b, c, d) { this._x = a; this._y = b; this._z = c; this._w = d; this._onChangeCallback(); return this; }, clone: function () { return new this.constructor(this._x, this._y, this._z, this._w); }, copy: function (a) {
            this._x =
                a.x;
            this._y = a.y;
            this._z = a.z;
            this._w = a.w;
            this._onChangeCallback();
            return this;
        }, setFromEuler: function (a, b) {
            if (!a || !a.isEuler)
                throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var c = a._x, d = a._y, e = a._z;
            a = a.order;
            var f = Math.cos, g = Math.sin, h = f(c / 2), l = f(d / 2);
            f = f(e / 2);
            c = g(c / 2);
            d = g(d / 2);
            e = g(e / 2);
            "XYZ" === a ? (this._x = c * l * f + h * d * e, this._y = h * d * f - c * l * e, this._z = h * l * e + c * d * f, this._w = h * l * f - c * d * e) : "YXZ" === a ? (this._x = c * l * f + h * d * e, this._y = h * d * f - c * l * e, this._z =
                h * l * e - c * d * f, this._w = h * l * f + c * d * e) : "ZXY" === a ? (this._x = c * l * f - h * d * e, this._y = h * d * f + c * l * e, this._z = h * l * e + c * d * f, this._w = h * l * f - c * d * e) : "ZYX" === a ? (this._x = c * l * f - h * d * e, this._y = h * d * f + c * l * e, this._z = h * l * e - c * d * f, this._w = h * l * f + c * d * e) : "YZX" === a ? (this._x = c * l * f + h * d * e, this._y = h * d * f + c * l * e, this._z = h * l * e - c * d * f, this._w = h * l * f - c * d * e) : "XZY" === a && (this._x = c * l * f - h * d * e, this._y = h * d * f - c * l * e, this._z = h * l * e + c * d * f, this._w = h * l * f + c * d * e);
            !1 !== b && this._onChangeCallback();
            return this;
        }, setFromAxisAngle: function (a, b) {
            b /= 2;
            var c = Math.sin(b);
            this._x = a.x * c;
            this._y = a.y * c;
            this._z = a.z * c;
            this._w = Math.cos(b);
            this._onChangeCallback();
            return this;
        }, setFromRotationMatrix: function (a) {
            var b = a.elements, c = b[0];
            a = b[4];
            var d = b[8], e = b[1], f = b[5], g = b[9], h = b[2], l = b[6];
            b = b[10];
            var m = c + f + b;
            0 < m ? (c = .5 / Math.sqrt(m + 1), this._w = .25 / c, this._x = (l - g) * c, this._y = (d - h) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), this._w = (l - g) / c, this._x = .25 * c, this._y = (a + e) / c, this._z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), this._w = (d - h) / c, this._x = (a + e) / c, this._y = .25 * c, this._z = (g + l) /
                c) : (c = 2 * Math.sqrt(1 + b - c - f), this._w = (e - a) / c, this._x = (d + h) / c, this._y = (g + l) / c, this._z = .25 * c);
            this._onChangeCallback();
            return this;
        }, setFromUnitVectors: function (a, b) { var c = a.dot(b) + 1; 1E-6 > c ? (c = 0, Math.abs(a.x) > Math.abs(a.z) ? (this._x = -a.y, this._y = a.x, this._z = 0) : (this._x = 0, this._y = -a.z, this._z = a.y)) : (this._x = a.y * b.z - a.z * b.y, this._y = a.z * b.x - a.x * b.z, this._z = a.x * b.y - a.y * b.x); this._w = c; return this.normalize(); }, angleTo: function (a) { return 2 * Math.acos(Math.abs(L.clamp(this.dot(a), -1, 1))); }, rotateTowards: function (a, b) { var c = this.angleTo(a); if (0 === c)
            return this; this.slerp(a, Math.min(1, b / c)); return this; }, inverse: function () { return this.conjugate(); }, conjugate: function () { this._x *= -1; this._y *= -1; this._z *= -1; this._onChangeCallback(); return this; }, dot: function (a) { return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w; }, lengthSq: function () { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w; }, length: function () { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w); }, normalize: function () {
            var a = this.length();
            0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a);
            this._onChangeCallback();
            return this;
        }, multiply: function (a, b) { return void 0 !== b ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a); }, premultiply: function (a) { return this.multiplyQuaternions(a, this); }, multiplyQuaternions: function (a, b) {
            var c = a._x, d = a._y, e = a._z;
            a = a._w;
            var f = b._x, g = b._y, h = b._z;
            b = b._w;
            this._x = c * b + a * f + d * h - e * g;
            this._y = d * b + a * g + e * f - c * h;
            this._z = e * b + a * h + c * g - d * f;
            this._w = a * b - c * f - d * g - e * h;
            this._onChangeCallback();
            return this;
        }, slerp: function (a, b) {
            if (0 === b)
                return this;
            if (1 === b)
                return this.copy(a);
            var c = this._x, d = this._y, e = this._z, f = this._w, g = f * a._w + c * a._x + d * a._y + e * a._z;
            0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, g = -g) : this.copy(a);
            if (1 <= g)
                return this._w = f, this._x = c, this._y = d, this._z = e, this;
            a = 1 - g * g;
            if (a <= Number.EPSILON)
                return g = 1 - b, this._w = g *
                    f + b * this._w, this._x = g * c + b * this._x, this._y = g * d + b * this._y, this._z = g * e + b * this._z, this.normalize(), this._onChangeCallback(), this;
            a = Math.sqrt(a);
            var h = Math.atan2(a, g);
            g = Math.sin((1 - b) * h) / a;
            b = Math.sin(b * h) / a;
            this._w = f * g + this._w * b;
            this._x = c * g + this._x * b;
            this._y = d * g + this._y * b;
            this._z = e * g + this._z * b;
            this._onChangeCallback();
            return this;
        }, equals: function (a) { return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w; }, fromArray: function (a, b) {
            void 0 === b && (b = 0);
            this._x = a[b];
            this._y = a[b + 1];
            this._z = a[b + 2];
            this._w = a[b + 3];
            this._onChangeCallback();
            return this;
        }, toArray: function (a, b) { void 0 === a && (a = []); void 0 === b && (b = 0); a[b] = this._x; a[b + 1] = this._y; a[b + 2] = this._z; a[b + 3] = this._w; return a; }, _onChange: function (a) { this._onChangeCallback = a; return this; }, _onChangeCallback: function () { } });
    var Ng = new n, li = new ua;
    Object.assign(n.prototype, { isVector3: !0, set: function (a, b, c) { this.x = a; this.y = b; this.z = c; return this; }, setScalar: function (a) { this.z = this.y = this.x = a; return this; }, setX: function (a) { this.x = a; return this; }, setY: function (a) {
            this.y =
                a;
            return this;
        }, setZ: function (a) { this.z = a; return this; }, setComponent: function (a, b) { switch (a) {
            case 0:
                this.x = b;
                break;
            case 1:
                this.y = b;
                break;
            case 2:
                this.z = b;
                break;
            default: throw Error("index is out of range: " + a);
        } return this; }, getComponent: function (a) { switch (a) {
            case 0: return this.x;
            case 1: return this.y;
            case 2: return this.z;
            default: throw Error("index is out of range: " + a);
        } }, clone: function () { return new this.constructor(this.x, this.y, this.z); }, copy: function (a) { this.x = a.x; this.y = a.y; this.z = a.z; return this; },
        add: function (a, b) { if (void 0 !== b)
            return console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b); this.x += a.x; this.y += a.y; this.z += a.z; return this; }, addScalar: function (a) { this.x += a; this.y += a; this.z += a; return this; }, addVectors: function (a, b) { this.x = a.x + b.x; this.y = a.y + b.y; this.z = a.z + b.z; return this; }, addScaledVector: function (a, b) { this.x += a.x * b; this.y += a.y * b; this.z += a.z * b; return this; }, sub: function (a, b) {
            if (void 0 !== b)
                return console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                    this.subVectors(a, b);
            this.x -= a.x;
            this.y -= a.y;
            this.z -= a.z;
            return this;
        }, subScalar: function (a) { this.x -= a; this.y -= a; this.z -= a; return this; }, subVectors: function (a, b) { this.x = a.x - b.x; this.y = a.y - b.y; this.z = a.z - b.z; return this; }, multiply: function (a, b) { if (void 0 !== b)
            return console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(a, b); this.x *= a.x; this.y *= a.y; this.z *= a.z; return this; }, multiplyScalar: function (a) {
            this.x *= a;
            this.y *= a;
            this.z *=
                a;
            return this;
        }, multiplyVectors: function (a, b) { this.x = a.x * b.x; this.y = a.y * b.y; this.z = a.z * b.z; return this; }, applyEuler: function (a) { a && a.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."); return this.applyQuaternion(li.setFromEuler(a)); }, applyAxisAngle: function (a, b) { return this.applyQuaternion(li.setFromAxisAngle(a, b)); }, applyMatrix3: function (a) {
            var b = this.x, c = this.y, d = this.z;
            a = a.elements;
            this.x = a[0] * b + a[3] * c + a[6] * d;
            this.y = a[1] * b + a[4] * c + a[7] *
                d;
            this.z = a[2] * b + a[5] * c + a[8] * d;
            return this;
        }, applyMatrix4: function (a) { var b = this.x, c = this.y, d = this.z; a = a.elements; var e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]); this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e; this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e; this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e; return this; }, applyQuaternion: function (a) { var b = this.x, c = this.y, d = this.z, e = a.x, f = a.y, g = a.z; a = a.w; var h = a * b + f * d - g * c, l = a * c + g * b - e * d, m = a * d + e * c - f * b; b = -e * b - f * c - g * d; this.x = h * a + b * -e + l * -g - m * -f; this.y = l * a + b * -f + m * -e - h * -g; this.z = m * a + b * -g + h * -f - l * -e; return this; },
        project: function (a) { return this.applyMatrix4(a.matrixWorldInverse).applyMatrix4(a.projectionMatrix); }, unproject: function (a) { return this.applyMatrix4(a.projectionMatrixInverse).applyMatrix4(a.matrixWorld); }, transformDirection: function (a) { var b = this.x, c = this.y, d = this.z; a = a.elements; this.x = a[0] * b + a[4] * c + a[8] * d; this.y = a[1] * b + a[5] * c + a[9] * d; this.z = a[2] * b + a[6] * c + a[10] * d; return this.normalize(); }, divide: function (a) { this.x /= a.x; this.y /= a.y; this.z /= a.z; return this; }, divideScalar: function (a) {
            return this.multiplyScalar(1 /
                a);
        }, min: function (a) { this.x = Math.min(this.x, a.x); this.y = Math.min(this.y, a.y); this.z = Math.min(this.z, a.z); return this; }, max: function (a) { this.x = Math.max(this.x, a.x); this.y = Math.max(this.y, a.y); this.z = Math.max(this.z, a.z); return this; }, clamp: function (a, b) { this.x = Math.max(a.x, Math.min(b.x, this.x)); this.y = Math.max(a.y, Math.min(b.y, this.y)); this.z = Math.max(a.z, Math.min(b.z, this.z)); return this; }, clampScalar: function (a, b) {
            this.x = Math.max(a, Math.min(b, this.x));
            this.y = Math.max(a, Math.min(b, this.y));
            this.z = Math.max(a, Math.min(b, this.z));
            return this;
        }, clampLength: function (a, b) { var c = this.length(); return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c))); }, floor: function () { this.x = Math.floor(this.x); this.y = Math.floor(this.y); this.z = Math.floor(this.z); return this; }, ceil: function () { this.x = Math.ceil(this.x); this.y = Math.ceil(this.y); this.z = Math.ceil(this.z); return this; }, round: function () { this.x = Math.round(this.x); this.y = Math.round(this.y); this.z = Math.round(this.z); return this; }, roundToZero: function () {
            this.x =
                0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
            this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
            return this;
        }, negate: function () { this.x = -this.x; this.y = -this.y; this.z = -this.z; return this; }, dot: function (a) { return this.x * a.x + this.y * a.y + this.z * a.z; }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z; }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z); }, manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y) +
                Math.abs(this.z);
        }, normalize: function () { return this.divideScalar(this.length() || 1); }, setLength: function (a) { return this.normalize().multiplyScalar(a); }, lerp: function (a, b) { this.x += (a.x - this.x) * b; this.y += (a.y - this.y) * b; this.z += (a.z - this.z) * b; return this; }, lerpVectors: function (a, b, c) { return this.subVectors(b, a).multiplyScalar(c).add(a); }, cross: function (a, b) {
            return void 0 !== b ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(a, b)) : this.crossVectors(this, a);
        }, crossVectors: function (a, b) { var c = a.x, d = a.y; a = a.z; var e = b.x, f = b.y; b = b.z; this.x = d * b - a * f; this.y = a * e - c * b; this.z = c * f - d * e; return this; }, projectOnVector: function (a) { var b = a.dot(this) / a.lengthSq(); return this.copy(a).multiplyScalar(b); }, projectOnPlane: function (a) { Ng.copy(this).projectOnVector(a); return this.sub(Ng); }, reflect: function (a) { return this.sub(Ng.copy(a).multiplyScalar(2 * this.dot(a))); }, angleTo: function (a) {
            var b = Math.sqrt(this.lengthSq() * a.lengthSq());
            0 === b && console.error("THREE.Vector3: angleTo() can't handle zero length vectors.");
            a = this.dot(a) / b;
            return Math.acos(L.clamp(a, -1, 1));
        }, distanceTo: function (a) { return Math.sqrt(this.distanceToSquared(a)); }, distanceToSquared: function (a) { var b = this.x - a.x, c = this.y - a.y; a = this.z - a.z; return b * b + c * c + a * a; }, manhattanDistanceTo: function (a) { return Math.abs(this.x - a.x) + Math.abs(this.y - a.y) + Math.abs(this.z - a.z); }, setFromSpherical: function (a) { return this.setFromSphericalCoords(a.radius, a.phi, a.theta); }, setFromSphericalCoords: function (a, b, c) {
            var d = Math.sin(b) * a;
            this.x = d * Math.sin(c);
            this.y = Math.cos(b) *
                a;
            this.z = d * Math.cos(c);
            return this;
        }, setFromCylindrical: function (a) { return this.setFromCylindricalCoords(a.radius, a.theta, a.y); }, setFromCylindricalCoords: function (a, b, c) { this.x = a * Math.sin(b); this.y = c; this.z = a * Math.cos(b); return this; }, setFromMatrixPosition: function (a) { a = a.elements; this.x = a[12]; this.y = a[13]; this.z = a[14]; return this; }, setFromMatrixScale: function (a) {
            var b = this.setFromMatrixColumn(a, 0).length(), c = this.setFromMatrixColumn(a, 1).length();
            a = this.setFromMatrixColumn(a, 2).length();
            this.x = b;
            this.y =
                c;
            this.z = a;
            return this;
        }, setFromMatrixColumn: function (a, b) { return this.fromArray(a.elements, 4 * b); }, equals: function (a) { return a.x === this.x && a.y === this.y && a.z === this.z; }, fromArray: function (a, b) { void 0 === b && (b = 0); this.x = a[b]; this.y = a[b + 1]; this.z = a[b + 2]; return this; }, toArray: function (a, b) { void 0 === a && (a = []); void 0 === b && (b = 0); a[b] = this.x; a[b + 1] = this.y; a[b + 2] = this.z; return a; }, fromBufferAttribute: function (a, b, c) {
            void 0 !== c && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
            this.x = a.getX(b);
            this.y = a.getY(b);
            this.z = a.getZ(b);
            return this;
        } });
    var qc = new n;
    Object.assign(Y.prototype, { isMatrix3: !0, set: function (a, b, c, d, e, f, g, h, l) { var m = this.elements; m[0] = a; m[1] = d; m[2] = g; m[3] = b; m[4] = e; m[5] = h; m[6] = c; m[7] = f; m[8] = l; return this; }, identity: function () { this.set(1, 0, 0, 0, 1, 0, 0, 0, 1); return this; }, clone: function () { return (new this.constructor).fromArray(this.elements); }, copy: function (a) {
            var b = this.elements;
            a = a.elements;
            b[0] = a[0];
            b[1] = a[1];
            b[2] = a[2];
            b[3] = a[3];
            b[4] = a[4];
            b[5] = a[5];
            b[6] = a[6];
            b[7] =
                a[7];
            b[8] = a[8];
            return this;
        }, setFromMatrix4: function (a) { a = a.elements; this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]); return this; }, applyToBufferAttribute: function (a) { for (var b = 0, c = a.count; b < c; b++)
            qc.x = a.getX(b), qc.y = a.getY(b), qc.z = a.getZ(b), qc.applyMatrix3(this), a.setXYZ(b, qc.x, qc.y, qc.z); return a; }, multiply: function (a) { return this.multiplyMatrices(this, a); }, premultiply: function (a) { return this.multiplyMatrices(a, this); }, multiplyMatrices: function (a, b) {
            var c = a.elements, d = b.elements;
            b = this.elements;
            a = c[0];
            var e = c[3], f = c[6], g = c[1], h = c[4], l = c[7], m = c[2], k = c[5];
            c = c[8];
            var n = d[0], t = d[3], r = d[6], p = d[1], v = d[4], x = d[7], z = d[2], y = d[5];
            d = d[8];
            b[0] = a * n + e * p + f * z;
            b[3] = a * t + e * v + f * y;
            b[6] = a * r + e * x + f * d;
            b[1] = g * n + h * p + l * z;
            b[4] = g * t + h * v + l * y;
            b[7] = g * r + h * x + l * d;
            b[2] = m * n + k * p + c * z;
            b[5] = m * t + k * v + c * y;
            b[8] = m * r + k * x + c * d;
            return this;
        }, multiplyScalar: function (a) { var b = this.elements; b[0] *= a; b[3] *= a; b[6] *= a; b[1] *= a; b[4] *= a; b[7] *= a; b[2] *= a; b[5] *= a; b[8] *= a; return this; }, determinant: function () {
            var a = this.elements, b = a[0], c = a[1], d = a[2], e = a[3], f = a[4], g = a[5], h = a[6], l = a[7];
            a = a[8];
            return b * f * a - b * g * l - c * e * a + c * g * h + d * e * l - d * f * h;
        }, getInverse: function (a, b) {
            a && a.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
            var c = a.elements;
            a = this.elements;
            var d = c[0], e = c[1], f = c[2], g = c[3], h = c[4], l = c[5], m = c[6], k = c[7];
            c = c[8];
            var n = c * h - l * k, t = l * m - c * g, r = k * g - h * m, p = d * n + e * t + f * r;
            if (0 === p) {
                if (!0 === b)
                    throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
                console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
                return this.identity();
            }
            b = 1 / p;
            a[0] = n * b;
            a[1] = (f * k - c * e) * b;
            a[2] = (l * e - f * h) * b;
            a[3] = t * b;
            a[4] = (c * d - f * m) * b;
            a[5] = (f * g - l * d) * b;
            a[6] = r * b;
            a[7] = (e * m - k * d) * b;
            a[8] = (h * d - e * g) * b;
            return this;
        }, transpose: function () { var a = this.elements; var b = a[1]; a[1] = a[3]; a[3] = b; b = a[2]; a[2] = a[6]; a[6] = b; b = a[5]; a[5] = a[7]; a[7] = b; return this; }, getNormalMatrix: function (a) { return this.setFromMatrix4(a).getInverse(this).transpose(); }, transposeIntoArray: function (a) {
            var b = this.elements;
            a[0] = b[0];
            a[1] = b[3];
            a[2] = b[6];
            a[3] = b[1];
            a[4] = b[4];
            a[5] = b[7];
            a[6] =
                b[2];
            a[7] = b[5];
            a[8] = b[8];
            return this;
        }, setUvTransform: function (a, b, c, d, e, f, g) { var h = Math.cos(e); e = Math.sin(e); this.set(c * h, c * e, -c * (h * f + e * g) + f + a, -d * e, d * h, -d * (-e * f + h * g) + g + b, 0, 0, 1); }, scale: function (a, b) { var c = this.elements; c[0] *= a; c[3] *= a; c[6] *= a; c[1] *= b; c[4] *= b; c[7] *= b; return this; }, rotate: function (a) { var b = Math.cos(a); a = Math.sin(a); var c = this.elements, d = c[0], e = c[3], f = c[6], g = c[1], h = c[4], l = c[7]; c[0] = b * d + a * g; c[3] = b * e + a * h; c[6] = b * f + a * l; c[1] = -a * d + b * g; c[4] = -a * e + b * h; c[7] = -a * f + b * l; return this; }, translate: function (a, b) { var c = this.elements; c[0] += a * c[2]; c[3] += a * c[5]; c[6] += a * c[8]; c[1] += b * c[2]; c[4] += b * c[5]; c[7] += b * c[8]; return this; }, equals: function (a) { var b = this.elements; a = a.elements; for (var c = 0; 9 > c; c++)
            if (b[c] !== a[c])
                return !1; return !0; }, fromArray: function (a, b) { void 0 === b && (b = 0); for (var c = 0; 9 > c; c++)
            this.elements[c] = a[c + b]; return this; }, toArray: function (a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            var c = this.elements;
            a[b] = c[0];
            a[b + 1] = c[1];
            a[b + 2] = c[2];
            a[b + 3] = c[3];
            a[b + 4] = c[4];
            a[b + 5] = c[5];
            a[b + 6] = c[6];
            a[b + 7] = c[7];
            a[b + 8] = c[8];
            return a;
        } });
    var md, Kb = { getDataURL: function (a) { if ("undefined" == typeof HTMLCanvasElement)
            return a.src; if (!(a instanceof HTMLCanvasElement)) {
            void 0 === md && (md = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"));
            md.width = a.width;
            md.height = a.height;
            var b = md.getContext("2d");
            a instanceof ImageData ? b.putImageData(a, 0, 0) : b.drawImage(a, 0, 0, a.width, a.height);
            a = md;
        } return 2048 < a.width || 2048 < a.height ? a.toDataURL("image/jpeg", .6) : a.toDataURL("image/png"); } }, Ri = 0;
    W.DEFAULT_IMAGE = void 0;
    W.DEFAULT_MAPPING =
        300;
    W.prototype = Object.assign(Object.create(Ba.prototype), { constructor: W, isTexture: !0, updateMatrix: function () { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y); }, clone: function () { return (new this.constructor).copy(this); }, copy: function (a) {
            this.name = a.name;
            this.image = a.image;
            this.mipmaps = a.mipmaps.slice(0);
            this.mapping = a.mapping;
            this.wrapS = a.wrapS;
            this.wrapT = a.wrapT;
            this.magFilter = a.magFilter;
            this.minFilter = a.minFilter;
            this.anisotropy =
                a.anisotropy;
            this.format = a.format;
            this.type = a.type;
            this.offset.copy(a.offset);
            this.repeat.copy(a.repeat);
            this.center.copy(a.center);
            this.rotation = a.rotation;
            this.matrixAutoUpdate = a.matrixAutoUpdate;
            this.matrix.copy(a.matrix);
            this.generateMipmaps = a.generateMipmaps;
            this.premultiplyAlpha = a.premultiplyAlpha;
            this.flipY = a.flipY;
            this.unpackAlignment = a.unpackAlignment;
            this.encoding = a.encoding;
            return this;
        }, toJSON: function (a) {
            var b = void 0 === a || "string" === typeof a;
            if (!b && void 0 !== a.textures[this.uuid])
                return a.textures[this.uuid];
            var c = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
            if (void 0 !== this.image) {
                var d = this.image;
                void 0 === d.uuid && (d.uuid = L.generateUUID());
                if (!b && void 0 === a.images[d.uuid]) {
                    if (Array.isArray(d)) {
                        var e = [];
                        for (var f = 0, g = d.length; f < g; f++)
                            e.push(Kb.getDataURL(d[f]));
                    }
                    else
                        e = Kb.getDataURL(d);
                    a.images[d.uuid] = { uuid: d.uuid, url: e };
                }
                c.image = d.uuid;
            }
            b || (a.textures[this.uuid] = c);
            return c;
        }, dispose: function () { this.dispatchEvent({ type: "dispose" }); }, transformUv: function (a) {
            if (300 !== this.mapping)
                return a;
            a.applyMatrix3(this.matrix);
            if (0 > a.x || 1 < a.x)
                switch (this.wrapS) {
                    case 1E3:
                        a.x -=
                            Math.floor(a.x);
                        break;
                    case 1001:
                        a.x = 0 > a.x ? 0 : 1;
                        break;
                    case 1002: a.x = 1 === Math.abs(Math.floor(a.x) % 2) ? Math.ceil(a.x) - a.x : a.x - Math.floor(a.x);
                }
            if (0 > a.y || 1 < a.y)
                switch (this.wrapT) {
                    case 1E3:
                        a.y -= Math.floor(a.y);
                        break;
                    case 1001:
                        a.y = 0 > a.y ? 0 : 1;
                        break;
                    case 1002: a.y = 1 === Math.abs(Math.floor(a.y) % 2) ? Math.ceil(a.y) - a.y : a.y - Math.floor(a.y);
                }
            this.flipY && (a.y = 1 - a.y);
            return a;
        } });
    Object.defineProperty(W.prototype, "needsUpdate", { set: function (a) { !0 === a && this.version++; } });
    Object.defineProperties(aa.prototype, { width: { get: function () { return this.z; },
            set: function (a) { this.z = a; } }, height: { get: function () { return this.w; }, set: function (a) { this.w = a; } } });
    Object.assign(aa.prototype, { isVector4: !0, set: function (a, b, c, d) { this.x = a; this.y = b; this.z = c; this.w = d; return this; }, setScalar: function (a) { this.w = this.z = this.y = this.x = a; return this; }, setX: function (a) { this.x = a; return this; }, setY: function (a) { this.y = a; return this; }, setZ: function (a) { this.z = a; return this; }, setW: function (a) { this.w = a; return this; }, setComponent: function (a, b) {
            switch (a) {
                case 0:
                    this.x = b;
                    break;
                case 1:
                    this.y = b;
                    break;
                case 2:
                    this.z = b;
                    break;
                case 3:
                    this.w = b;
                    break;
                default: throw Error("index is out of range: " + a);
            }
            return this;
        }, getComponent: function (a) { switch (a) {
            case 0: return this.x;
            case 1: return this.y;
            case 2: return this.z;
            case 3: return this.w;
            default: throw Error("index is out of range: " + a);
        } }, clone: function () { return new this.constructor(this.x, this.y, this.z, this.w); }, copy: function (a) { this.x = a.x; this.y = a.y; this.z = a.z; this.w = void 0 !== a.w ? a.w : 1; return this; }, add: function (a, b) {
            if (void 0 !== b)
                return console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                    this.addVectors(a, b);
            this.x += a.x;
            this.y += a.y;
            this.z += a.z;
            this.w += a.w;
            return this;
        }, addScalar: function (a) { this.x += a; this.y += a; this.z += a; this.w += a; return this; }, addVectors: function (a, b) { this.x = a.x + b.x; this.y = a.y + b.y; this.z = a.z + b.z; this.w = a.w + b.w; return this; }, addScaledVector: function (a, b) { this.x += a.x * b; this.y += a.y * b; this.z += a.z * b; this.w += a.w * b; return this; }, sub: function (a, b) {
            if (void 0 !== b)
                return console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
            this.x -= a.x;
            this.y -= a.y;
            this.z -= a.z;
            this.w -= a.w;
            return this;
        }, subScalar: function (a) { this.x -= a; this.y -= a; this.z -= a; this.w -= a; return this; }, subVectors: function (a, b) { this.x = a.x - b.x; this.y = a.y - b.y; this.z = a.z - b.z; this.w = a.w - b.w; return this; }, multiplyScalar: function (a) { this.x *= a; this.y *= a; this.z *= a; this.w *= a; return this; }, applyMatrix4: function (a) {
            var b = this.x, c = this.y, d = this.z, e = this.w;
            a = a.elements;
            this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e;
            this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e;
            this.z = a[2] * b + a[6] * c + a[10] * d + a[14] *
                e;
            this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e;
            return this;
        }, divideScalar: function (a) { return this.multiplyScalar(1 / a); }, setAxisAngleFromQuaternion: function (a) { this.w = 2 * Math.acos(a.w); var b = Math.sqrt(1 - a.w * a.w); 1E-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b); return this; }, setAxisAngleFromRotationMatrix: function (a) {
            a = a.elements;
            var b = a[0];
            var c = a[4];
            var d = a[8], e = a[1], f = a[5], g = a[9];
            var h = a[2];
            var l = a[6];
            var m = a[10];
            if (.01 > Math.abs(c - e) && .01 > Math.abs(d - h) && .01 > Math.abs(g - l)) {
                if (.1 > Math.abs(c +
                    e) && .1 > Math.abs(d + h) && .1 > Math.abs(g + l) && .1 > Math.abs(b + f + m - 3))
                    return this.set(1, 0, 0, 0), this;
                a = Math.PI;
                b = (b + 1) / 2;
                f = (f + 1) / 2;
                m = (m + 1) / 2;
                c = (c + e) / 4;
                d = (d + h) / 4;
                g = (g + l) / 4;
                b > f && b > m ? .01 > b ? (l = 0, c = h = .707106781) : (l = Math.sqrt(b), h = c / l, c = d / l) : f > m ? .01 > f ? (l = .707106781, h = 0, c = .707106781) : (h = Math.sqrt(f), l = c / h, c = g / h) : .01 > m ? (h = l = .707106781, c = 0) : (c = Math.sqrt(m), l = d / c, h = g / c);
                this.set(l, h, c, a);
                return this;
            }
            a = Math.sqrt((l - g) * (l - g) + (d - h) * (d - h) + (e - c) * (e - c));
            .001 > Math.abs(a) && (a = 1);
            this.x = (l - g) / a;
            this.y = (d - h) / a;
            this.z = (e - c) / a;
            this.w = Math.acos((b + f + m - 1) / 2);
            return this;
        }, min: function (a) { this.x = Math.min(this.x, a.x); this.y = Math.min(this.y, a.y); this.z = Math.min(this.z, a.z); this.w = Math.min(this.w, a.w); return this; }, max: function (a) { this.x = Math.max(this.x, a.x); this.y = Math.max(this.y, a.y); this.z = Math.max(this.z, a.z); this.w = Math.max(this.w, a.w); return this; }, clamp: function (a, b) {
            this.x = Math.max(a.x, Math.min(b.x, this.x));
            this.y = Math.max(a.y, Math.min(b.y, this.y));
            this.z = Math.max(a.z, Math.min(b.z, this.z));
            this.w = Math.max(a.w, Math.min(b.w, this.w));
            return this;
        }, clampScalar: function (a, b) { this.x = Math.max(a, Math.min(b, this.x)); this.y = Math.max(a, Math.min(b, this.y)); this.z = Math.max(a, Math.min(b, this.z)); this.w = Math.max(a, Math.min(b, this.w)); return this; }, clampLength: function (a, b) { var c = this.length(); return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c))); }, floor: function () { this.x = Math.floor(this.x); this.y = Math.floor(this.y); this.z = Math.floor(this.z); this.w = Math.floor(this.w); return this; }, ceil: function () {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);
            this.w = Math.ceil(this.w);
            return this;
        }, round: function () { this.x = Math.round(this.x); this.y = Math.round(this.y); this.z = Math.round(this.z); this.w = Math.round(this.w); return this; }, roundToZero: function () { this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x); this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y); this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z); this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w); return this; }, negate: function () {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            this.w = -this.w;
            return this;
        }, dot: function (a) { return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w; }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w; }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w); }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w); }, normalize: function () { return this.divideScalar(this.length() || 1); }, setLength: function (a) { return this.normalize().multiplyScalar(a); },
        lerp: function (a, b) { this.x += (a.x - this.x) * b; this.y += (a.y - this.y) * b; this.z += (a.z - this.z) * b; this.w += (a.w - this.w) * b; return this; }, lerpVectors: function (a, b, c) { return this.subVectors(b, a).multiplyScalar(c).add(a); }, equals: function (a) { return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w; }, fromArray: function (a, b) { void 0 === b && (b = 0); this.x = a[b]; this.y = a[b + 1]; this.z = a[b + 2]; this.w = a[b + 3]; return this; }, toArray: function (a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            a[b] = this.x;
            a[b + 1] = this.y;
            a[b + 2] = this.z;
            a[b + 3] =
                this.w;
            return a;
        }, fromBufferAttribute: function (a, b, c) { void 0 !== c && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."); this.x = a.getX(b); this.y = a.getY(b); this.z = a.getZ(b); this.w = a.getW(b); return this; } });
    la.prototype = Object.assign(Object.create(Ba.prototype), { constructor: la, isWebGLRenderTarget: !0, setSize: function (a, b) {
            if (this.width !== a || this.height !== b)
                this.width = a, this.height = b, this.texture.image.width = a, this.texture.image.height = b, this.dispose();
            this.viewport.set(0, 0, a, b);
            this.scissor.set(0, 0, a, b);
        }, clone: function () { return (new this.constructor).copy(this); }, copy: function (a) { this.width = a.width; this.height = a.height; this.viewport.copy(a.viewport); this.texture = a.texture.clone(); this.depthBuffer = a.depthBuffer; this.stencilBuffer = a.stencilBuffer; this.depthTexture = a.depthTexture; return this; }, dispose: function () { this.dispatchEvent({ type: "dispose" }); } });
    Of.prototype = Object.assign(Object.create(la.prototype), { constructor: Of, isWebGLMultisampleRenderTarget: !0, copy: function (a) {
            la.prototype.copy.call(this, a);
            this.samples = a.samples;
            return this;
        } });
    var Ka = new n, ea = new U, sk = new n(0, 0, 0), tk = new n(1, 1, 1), Lb = new n, qf = new n, ka = new n;
    Object.assign(U.prototype, { isMatrix4: !0, set: function (a, b, c, d, e, f, g, h, l, m, k, n, t, r, p, v) { var q = this.elements; q[0] = a; q[4] = b; q[8] = c; q[12] = d; q[1] = e; q[5] = f; q[9] = g; q[13] = h; q[2] = l; q[6] = m; q[10] = k; q[14] = n; q[3] = t; q[7] = r; q[11] = p; q[15] = v; return this; }, identity: function () { this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); return this; }, clone: function () { return (new U).fromArray(this.elements); }, copy: function (a) {
            var b = this.elements;
            a = a.elements;
            b[0] = a[0];
            b[1] = a[1];
            b[2] = a[2];
            b[3] = a[3];
            b[4] = a[4];
            b[5] = a[5];
            b[6] = a[6];
            b[7] = a[7];
            b[8] = a[8];
            b[9] = a[9];
            b[10] = a[10];
            b[11] = a[11];
            b[12] = a[12];
            b[13] = a[13];
            b[14] = a[14];
            b[15] = a[15];
            return this;
        }, copyPosition: function (a) { var b = this.elements; a = a.elements; b[12] = a[12]; b[13] = a[13]; b[14] = a[14]; return this; }, extractBasis: function (a, b, c) { a.setFromMatrixColumn(this, 0); b.setFromMatrixColumn(this, 1); c.setFromMatrixColumn(this, 2); return this; }, makeBasis: function (a, b, c) {
            this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1);
            return this;
        }, extractRotation: function (a) { var b = this.elements, c = a.elements, d = 1 / Ka.setFromMatrixColumn(a, 0).length(), e = 1 / Ka.setFromMatrixColumn(a, 1).length(); a = 1 / Ka.setFromMatrixColumn(a, 2).length(); b[0] = c[0] * d; b[1] = c[1] * d; b[2] = c[2] * d; b[3] = 0; b[4] = c[4] * e; b[5] = c[5] * e; b[6] = c[6] * e; b[7] = 0; b[8] = c[8] * a; b[9] = c[9] * a; b[10] = c[10] * a; b[11] = 0; b[12] = 0; b[13] = 0; b[14] = 0; b[15] = 1; return this; }, makeRotationFromEuler: function (a) {
            a && a.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var b = this.elements, c = a.x, d = a.y, e = a.z, f = Math.cos(c);
            c = Math.sin(c);
            var g = Math.cos(d);
            d = Math.sin(d);
            var h = Math.cos(e);
            e = Math.sin(e);
            if ("XYZ" === a.order) {
                a = f * h;
                var l = f * e, m = c * h, k = c * e;
                b[0] = g * h;
                b[4] = -g * e;
                b[8] = d;
                b[1] = l + m * d;
                b[5] = a - k * d;
                b[9] = -c * g;
                b[2] = k - a * d;
                b[6] = m + l * d;
                b[10] = f * g;
            }
            else
                "YXZ" === a.order ? (a = g * h, l = g * e, m = d * h, k = d * e, b[0] = a + k * c, b[4] = m * c - l, b[8] = f * d, b[1] = f * e, b[5] = f * h, b[9] = -c, b[2] = l * c - m, b[6] = k + a * c, b[10] = f * g) : "ZXY" === a.order ? (a = g * h, l = g * e, m = d * h, k = d * e, b[0] = a - k * c, b[4] = -f * e, b[8] = m + l * c, b[1] = l + m * c, b[5] = f * h, b[9] =
                    k - a * c, b[2] = -f * d, b[6] = c, b[10] = f * g) : "ZYX" === a.order ? (a = f * h, l = f * e, m = c * h, k = c * e, b[0] = g * h, b[4] = m * d - l, b[8] = a * d + k, b[1] = g * e, b[5] = k * d + a, b[9] = l * d - m, b[2] = -d, b[6] = c * g, b[10] = f * g) : "YZX" === a.order ? (a = f * g, l = f * d, m = c * g, k = c * d, b[0] = g * h, b[4] = k - a * e, b[8] = m * e + l, b[1] = e, b[5] = f * h, b[9] = -c * h, b[2] = -d * h, b[6] = l * e + m, b[10] = a - k * e) : "XZY" === a.order && (a = f * g, l = f * d, m = c * g, k = c * d, b[0] = g * h, b[4] = -e, b[8] = d * h, b[1] = a * e + k, b[5] = f * h, b[9] = l * e - m, b[2] = m * e - l, b[6] = c * h, b[10] = k * e + a);
            b[3] = 0;
            b[7] = 0;
            b[11] = 0;
            b[12] = 0;
            b[13] = 0;
            b[14] = 0;
            b[15] = 1;
            return this;
        }, makeRotationFromQuaternion: function (a) {
            return this.compose(sk, a, tk);
        }, lookAt: function (a, b, c) { var d = this.elements; ka.subVectors(a, b); 0 === ka.lengthSq() && (ka.z = 1); ka.normalize(); Lb.crossVectors(c, ka); 0 === Lb.lengthSq() && (1 === Math.abs(c.z) ? ka.x += 1E-4 : ka.z += 1E-4, ka.normalize(), Lb.crossVectors(c, ka)); Lb.normalize(); qf.crossVectors(ka, Lb); d[0] = Lb.x; d[4] = qf.x; d[8] = ka.x; d[1] = Lb.y; d[5] = qf.y; d[9] = ka.y; d[2] = Lb.z; d[6] = qf.z; d[10] = ka.z; return this; }, multiply: function (a, b) {
            return void 0 !== b ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
                this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a);
        }, premultiply: function (a) { return this.multiplyMatrices(a, this); }, multiplyMatrices: function (a, b) {
            var c = a.elements, d = b.elements;
            b = this.elements;
            a = c[0];
            var e = c[4], f = c[8], g = c[12], h = c[1], l = c[5], m = c[9], k = c[13], n = c[2], t = c[6], r = c[10], p = c[14], v = c[3], x = c[7], z = c[11];
            c = c[15];
            var y = d[0], w = d[4], A = d[8], C = d[12], B = d[1], E = d[5], D = d[9], F = d[13], G = d[2], H = d[6], I = d[10], L = d[14], M = d[3], N = d[7], O = d[11];
            d = d[15];
            b[0] = a * y + e * B + f * G + g * M;
            b[4] = a * w + e * E + f * H + g * N;
            b[8] = a * A + e * D + f * I +
                g * O;
            b[12] = a * C + e * F + f * L + g * d;
            b[1] = h * y + l * B + m * G + k * M;
            b[5] = h * w + l * E + m * H + k * N;
            b[9] = h * A + l * D + m * I + k * O;
            b[13] = h * C + l * F + m * L + k * d;
            b[2] = n * y + t * B + r * G + p * M;
            b[6] = n * w + t * E + r * H + p * N;
            b[10] = n * A + t * D + r * I + p * O;
            b[14] = n * C + t * F + r * L + p * d;
            b[3] = v * y + x * B + z * G + c * M;
            b[7] = v * w + x * E + z * H + c * N;
            b[11] = v * A + x * D + z * I + c * O;
            b[15] = v * C + x * F + z * L + c * d;
            return this;
        }, multiplyScalar: function (a) { var b = this.elements; b[0] *= a; b[4] *= a; b[8] *= a; b[12] *= a; b[1] *= a; b[5] *= a; b[9] *= a; b[13] *= a; b[2] *= a; b[6] *= a; b[10] *= a; b[14] *= a; b[3] *= a; b[7] *= a; b[11] *= a; b[15] *= a; return this; }, applyToBufferAttribute: function (a) {
            for (var b = 0, c = a.count; b < c; b++)
                Ka.x = a.getX(b), Ka.y = a.getY(b), Ka.z = a.getZ(b), Ka.applyMatrix4(this), a.setXYZ(b, Ka.x, Ka.y, Ka.z);
            return a;
        }, determinant: function () { var a = this.elements, b = a[0], c = a[4], d = a[8], e = a[12], f = a[1], g = a[5], h = a[9], l = a[13], m = a[2], k = a[6], n = a[10], t = a[14]; return a[3] * (+e * h * k - d * l * k - e * g * n + c * l * n + d * g * t - c * h * t) + a[7] * (+b * h * t - b * l * n + e * f * n - d * f * t + d * l * m - e * h * m) + a[11] * (+b * l * k - b * g * t - e * f * k + c * f * t + e * g * m - c * l * m) + a[15] * (-d * g * m - b * h * k + b * g * n + d * f * k - c * f * n + c * h * m); }, transpose: function () {
            var a = this.elements;
            var b = a[1];
            a[1] = a[4];
            a[4] = b;
            b = a[2];
            a[2] = a[8];
            a[8] = b;
            b = a[6];
            a[6] = a[9];
            a[9] = b;
            b = a[3];
            a[3] = a[12];
            a[12] = b;
            b = a[7];
            a[7] = a[13];
            a[13] = b;
            b = a[11];
            a[11] = a[14];
            a[14] = b;
            return this;
        }, setPosition: function (a, b, c) { var d = this.elements; a.isVector3 ? (d[12] = a.x, d[13] = a.y, d[14] = a.z) : (d[12] = a, d[13] = b, d[14] = c); return this; }, getInverse: function (a, b) {
            var c = this.elements, d = a.elements;
            a = d[0];
            var e = d[1], f = d[2], g = d[3], h = d[4], l = d[5], m = d[6], k = d[7], n = d[8], t = d[9], r = d[10], p = d[11], v = d[12], x = d[13], z = d[14];
            d = d[15];
            var y = t * z * k - x * r * k + x * m * p - l * z * p - t * m * d + l * r * d, w = v * r * k - n * z * k - v * m * p + h * z * p + n * m * d - h * r * d, A = n * x * k - v * t * k + v * l * p - h * x * p - n * l * d + h * t * d, C = v * t * m - n * x * m - v * l * r + h * x * r + n * l * z - h * t * z, B = a * y + e * w + f * A + g * C;
            if (0 === B) {
                if (!0 === b)
                    throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
                console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
                return this.identity();
            }
            b = 1 / B;
            c[0] = y * b;
            c[1] = (x * r * g - t * z * g - x * f * p + e * z * p + t * f * d - e * r * d) * b;
            c[2] = (l * z * g - x * m * g + x * f * k - e * z * k - l * f * d + e * m * d) * b;
            c[3] = (t * m * g - l * r * g - t * f * k + e * r * k + l * f * p - e * m * p) * b;
            c[4] = w * b;
            c[5] =
                (n * z * g - v * r * g + v * f * p - a * z * p - n * f * d + a * r * d) * b;
            c[6] = (v * m * g - h * z * g - v * f * k + a * z * k + h * f * d - a * m * d) * b;
            c[7] = (h * r * g - n * m * g + n * f * k - a * r * k - h * f * p + a * m * p) * b;
            c[8] = A * b;
            c[9] = (v * t * g - n * x * g - v * e * p + a * x * p + n * e * d - a * t * d) * b;
            c[10] = (h * x * g - v * l * g + v * e * k - a * x * k - h * e * d + a * l * d) * b;
            c[11] = (n * l * g - h * t * g - n * e * k + a * t * k + h * e * p - a * l * p) * b;
            c[12] = C * b;
            c[13] = (n * x * f - v * t * f + v * e * r - a * x * r - n * e * z + a * t * z) * b;
            c[14] = (v * l * f - h * x * f - v * e * m + a * x * m + h * e * z - a * l * z) * b;
            c[15] = (h * t * f - n * l * f + n * e * m - a * t * m - h * e * r + a * l * r) * b;
            return this;
        }, scale: function (a) {
            var b = this.elements, c = a.x, d = a.y;
            a = a.z;
            b[0] *= c;
            b[4] *= d;
            b[8] *= a;
            b[1] *= c;
            b[5] *= d;
            b[9] *= a;
            b[2] *= c;
            b[6] *= d;
            b[10] *= a;
            b[3] *= c;
            b[7] *= d;
            b[11] *= a;
            return this;
        }, getMaxScaleOnAxis: function () { var a = this.elements; return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10])); }, makeTranslation: function (a, b, c) { this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1); return this; }, makeRotationX: function (a) { var b = Math.cos(a); a = Math.sin(a); this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1); return this; }, makeRotationY: function (a) {
            var b = Math.cos(a);
            a = Math.sin(a);
            this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1);
            return this;
        }, makeRotationZ: function (a) { var b = Math.cos(a); a = Math.sin(a); this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); return this; }, makeRotationAxis: function (a, b) { var c = Math.cos(b); b = Math.sin(b); var d = 1 - c, e = a.x, f = a.y; a = a.z; var g = d * e, h = d * f; this.set(g * e + c, g * f - b * a, g * a + b * f, 0, g * f + b * a, h * f + c, h * a - b * e, 0, g * a - b * f, h * a + b * e, d * a * a + c, 0, 0, 0, 0, 1); return this; }, makeScale: function (a, b, c) { this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1); return this; }, makeShear: function (a, b, c) { this.set(1, b, c, 0, a, 1, c, 0, a, b, 1, 0, 0, 0, 0, 1); return this; }, compose: function (a, b, c) { var d = this.elements, e = b._x, f = b._y, g = b._z, h = b._w, l = e + e, m = f + f, k = g + g; b = e * l; var n = e * m; e *= k; var t = f * m; f *= k; g *= k; l *= h; m *= h; h *= k; k = c.x; var r = c.y; c = c.z; d[0] = (1 - (t + g)) * k; d[1] = (n + h) * k; d[2] = (e - m) * k; d[3] = 0; d[4] = (n - h) * r; d[5] = (1 - (b + g)) * r; d[6] = (f + l) * r; d[7] = 0; d[8] = (e + m) * c; d[9] = (f - l) * c; d[10] = (1 - (b + t)) * c; d[11] = 0; d[12] = a.x; d[13] = a.y; d[14] = a.z; d[15] = 1; return this; }, decompose: function (a, b, c) {
            var d = this.elements, e = Ka.set(d[0], d[1], d[2]).length(), f = Ka.set(d[4], d[5], d[6]).length(), g = Ka.set(d[8], d[9], d[10]).length();
            0 > this.determinant() && (e = -e);
            a.x = d[12];
            a.y = d[13];
            a.z = d[14];
            ea.copy(this);
            a = 1 / e;
            d = 1 / f;
            var h = 1 / g;
            ea.elements[0] *= a;
            ea.elements[1] *= a;
            ea.elements[2] *= a;
            ea.elements[4] *= d;
            ea.elements[5] *= d;
            ea.elements[6] *= d;
            ea.elements[8] *= h;
            ea.elements[9] *= h;
            ea.elements[10] *= h;
            b.setFromRotationMatrix(ea);
            c.x = e;
            c.y = f;
            c.z = g;
            return this;
        }, makePerspective: function (a, b, c, d, e, f) {
            void 0 === f && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var g = this.elements;
            g[0] = 2 * e / (b - a);
            g[4] = 0;
            g[8] = (b + a) / (b - a);
            g[12] = 0;
            g[1] = 0;
            g[5] = 2 * e / (c - d);
            g[9] = (c + d) / (c - d);
            g[13] = 0;
            g[2] = 0;
            g[6] = 0;
            g[10] = -(f + e) / (f - e);
            g[14] = -2 * f * e / (f - e);
            g[3] = 0;
            g[7] = 0;
            g[11] = -1;
            g[15] = 0;
            return this;
        }, makeOrthographic: function (a, b, c, d, e, f) { var g = this.elements, h = 1 / (b - a), l = 1 / (c - d), m = 1 / (f - e); g[0] = 2 * h; g[4] = 0; g[8] = 0; g[12] = -((b + a) * h); g[1] = 0; g[5] = 2 * l; g[9] = 0; g[13] = -((c + d) * l); g[2] = 0; g[6] = 0; g[10] = -2 * m; g[14] = -((f + e) * m); g[3] = 0; g[7] = 0; g[11] = 0; g[15] = 1; return this; }, equals: function (a) {
            var b = this.elements;
            a = a.elements;
            for (var c = 0; 16 > c; c++)
                if (b[c] !== a[c])
                    return !1;
            return !0;
        }, fromArray: function (a, b) { void 0 === b && (b = 0); for (var c = 0; 16 > c; c++)
            this.elements[c] = a[c + b]; return this; }, toArray: function (a, b) { void 0 === a && (a = []); void 0 === b && (b = 0); var c = this.elements; a[b] = c[0]; a[b + 1] = c[1]; a[b + 2] = c[2]; a[b + 3] = c[3]; a[b + 4] = c[4]; a[b + 5] = c[5]; a[b + 6] = c[6]; a[b + 7] = c[7]; a[b + 8] = c[8]; a[b + 9] = c[9]; a[b + 10] = c[10]; a[b + 11] = c[11]; a[b + 12] = c[12]; a[b + 13] = c[13]; a[b + 14] = c[14]; a[b + 15] = c[15]; return a; } });
    var mi = new U, ni = new ua;
    Qb.RotationOrders =
        "XYZ YZX ZXY XZY YXZ ZYX".split(" ");
    Qb.DefaultOrder = "XYZ";
    Object.defineProperties(Qb.prototype, { x: { get: function () { return this._x; }, set: function (a) { this._x = a; this._onChangeCallback(); } }, y: { get: function () { return this._y; }, set: function (a) { this._y = a; this._onChangeCallback(); } }, z: { get: function () { return this._z; }, set: function (a) { this._z = a; this._onChangeCallback(); } }, order: { get: function () { return this._order; }, set: function (a) { this._order = a; this._onChangeCallback(); } } });
    Object.assign(Qb.prototype, { isEuler: !0, set: function (a, b, c, d) { this._x = a; this._y = b; this._z = c; this._order = d || this._order; this._onChangeCallback(); return this; }, clone: function () { return new this.constructor(this._x, this._y, this._z, this._order); }, copy: function (a) { this._x = a._x; this._y = a._y; this._z = a._z; this._order = a._order; this._onChangeCallback(); return this; }, setFromRotationMatrix: function (a, b, c) {
            var d = L.clamp, e = a.elements;
            a = e[0];
            var f = e[4], g = e[8], h = e[1], l = e[5], m = e[9], k = e[2], n = e[6];
            e = e[10];
            b = b || this._order;
            "XYZ" === b ? (this._y = Math.asin(d(g, -1, 1)), .9999999 > Math.abs(g) ?
                (this._x = Math.atan2(-m, e), this._z = Math.atan2(-f, a)) : (this._x = Math.atan2(n, l), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-d(m, -1, 1)), .9999999 > Math.abs(m) ? (this._y = Math.atan2(g, e), this._z = Math.atan2(h, l)) : (this._y = Math.atan2(-k, a), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(d(n, -1, 1)), .9999999 > Math.abs(n) ? (this._y = Math.atan2(-k, e), this._z = Math.atan2(-f, l)) : (this._y = 0, this._z = Math.atan2(h, a))) : "ZYX" === b ? (this._y = Math.asin(-d(k, -1, 1)), .9999999 > Math.abs(k) ? (this._x = Math.atan2(n, e), this._z = Math.atan2(h, a)) :
                (this._x = 0, this._z = Math.atan2(-f, l))) : "YZX" === b ? (this._z = Math.asin(d(h, -1, 1)), .9999999 > Math.abs(h) ? (this._x = Math.atan2(-m, l), this._y = Math.atan2(-k, a)) : (this._x = 0, this._y = Math.atan2(g, e))) : "XZY" === b ? (this._z = Math.asin(-d(f, -1, 1)), .9999999 > Math.abs(f) ? (this._x = Math.atan2(n, l), this._y = Math.atan2(g, a)) : (this._x = Math.atan2(-m, e), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + b);
            this._order = b;
            !1 !== c && this._onChangeCallback();
            return this;
        }, setFromQuaternion: function (a, b, c) { mi.makeRotationFromQuaternion(a); return this.setFromRotationMatrix(mi, b, c); }, setFromVector3: function (a, b) { return this.set(a.x, a.y, a.z, b || this._order); }, reorder: function (a) { ni.setFromEuler(this); return this.setFromQuaternion(ni, a); }, equals: function (a) { return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order; }, fromArray: function (a) { this._x = a[0]; this._y = a[1]; this._z = a[2]; void 0 !== a[3] && (this._order = a[3]); this._onChangeCallback(); return this; }, toArray: function (a, b) {
            void 0 === a && (a =
                []);
            void 0 === b && (b = 0);
            a[b] = this._x;
            a[b + 1] = this._y;
            a[b + 2] = this._z;
            a[b + 3] = this._order;
            return a;
        }, toVector3: function (a) { return a ? a.set(this._x, this._y, this._z) : new n(this._x, this._y, this._z); }, _onChange: function (a) { this._onChangeCallback = a; return this; }, _onChangeCallback: function () { } });
    Object.assign(Pf.prototype, { set: function (a) { this.mask = 1 << a | 0; }, enable: function (a) { this.mask = this.mask | 1 << a | 0; }, enableAll: function () { this.mask = -1; }, toggle: function (a) { this.mask ^= 1 << a | 0; }, disable: function (a) {
            this.mask &= ~(1 << a |
                0);
        }, disableAll: function () { this.mask = 0; }, test: function (a) { return 0 !== (this.mask & a.mask); } });
    var Si = 0, oi = new n, nd = new ua, ub = new U, rf = new n, xe = new n, uk = new n, vk = new ua, pi = new n(1, 0, 0), qi = new n(0, 1, 0), ri = new n(0, 0, 1), wk = { type: "added" }, xk = { type: "removed" };
    B.DefaultUp = new n(0, 1, 0);
    B.DefaultMatrixAutoUpdate = !0;
    B.prototype = Object.assign(Object.create(Ba.prototype), { constructor: B, isObject3D: !0, onBeforeRender: function () { }, onAfterRender: function () { }, applyMatrix: function (a) {
            this.matrixAutoUpdate && this.updateMatrix();
            this.matrix.premultiply(a);
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        }, applyQuaternion: function (a) { this.quaternion.premultiply(a); return this; }, setRotationFromAxisAngle: function (a, b) { this.quaternion.setFromAxisAngle(a, b); }, setRotationFromEuler: function (a) { this.quaternion.setFromEuler(a, !0); }, setRotationFromMatrix: function (a) { this.quaternion.setFromRotationMatrix(a); }, setRotationFromQuaternion: function (a) { this.quaternion.copy(a); }, rotateOnAxis: function (a, b) {
            nd.setFromAxisAngle(a, b);
            this.quaternion.multiply(nd);
            return this;
        }, rotateOnWorldAxis: function (a, b) { nd.setFromAxisAngle(a, b); this.quaternion.premultiply(nd); return this; }, rotateX: function (a) { return this.rotateOnAxis(pi, a); }, rotateY: function (a) { return this.rotateOnAxis(qi, a); }, rotateZ: function (a) { return this.rotateOnAxis(ri, a); }, translateOnAxis: function (a, b) { oi.copy(a).applyQuaternion(this.quaternion); this.position.add(oi.multiplyScalar(b)); return this; }, translateX: function (a) { return this.translateOnAxis(pi, a); }, translateY: function (a) {
            return this.translateOnAxis(qi, a);
        }, translateZ: function (a) { return this.translateOnAxis(ri, a); }, localToWorld: function (a) { return a.applyMatrix4(this.matrixWorld); }, worldToLocal: function (a) { return a.applyMatrix4(ub.getInverse(this.matrixWorld)); }, lookAt: function (a, b, c) {
            a.isVector3 ? rf.copy(a) : rf.set(a, b, c);
            a = this.parent;
            this.updateWorldMatrix(!0, !1);
            xe.setFromMatrixPosition(this.matrixWorld);
            this.isCamera || this.isLight ? ub.lookAt(xe, rf, this.up) : ub.lookAt(rf, xe, this.up);
            this.quaternion.setFromRotationMatrix(ub);
            a && (ub.extractRotation(a.matrixWorld),
                nd.setFromRotationMatrix(ub), this.quaternion.premultiply(nd.inverse()));
        }, add: function (a) { if (1 < arguments.length) {
            for (var b = 0; b < arguments.length; b++)
                this.add(arguments[b]);
            return this;
        } if (a === this)
            return console.error("THREE.Object3D.add: object can't be added as a child of itself.", a), this; a && a.isObject3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, this.children.push(a), a.dispatchEvent(wk)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a); return this; }, remove: function (a) {
            if (1 <
                arguments.length) {
                for (var b = 0; b < arguments.length; b++)
                    this.remove(arguments[b]);
                return this;
            }
            b = this.children.indexOf(a);
            -1 !== b && (a.parent = null, this.children.splice(b, 1), a.dispatchEvent(xk));
            return this;
        }, attach: function (a) { this.updateWorldMatrix(!0, !1); ub.getInverse(this.matrixWorld); null !== a.parent && (a.parent.updateWorldMatrix(!0, !1), ub.multiply(a.parent.matrixWorld)); a.applyMatrix(ub); a.updateWorldMatrix(!1, !1); this.add(a); return this; }, getObjectById: function (a) {
            return this.getObjectByProperty("id", a);
        }, getObjectByName: function (a) { return this.getObjectByProperty("name", a); }, getObjectByProperty: function (a, b) { if (this[a] === b)
            return this; for (var c = 0, d = this.children.length; c < d; c++) {
            var e = this.children[c].getObjectByProperty(a, b);
            if (void 0 !== e)
                return e;
        } }, getWorldPosition: function (a) { void 0 === a && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), a = new n); this.updateMatrixWorld(!0); return a.setFromMatrixPosition(this.matrixWorld); }, getWorldQuaternion: function (a) {
            void 0 === a && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),
                a = new ua);
            this.updateMatrixWorld(!0);
            this.matrixWorld.decompose(xe, a, uk);
            return a;
        }, getWorldScale: function (a) { void 0 === a && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), a = new n); this.updateMatrixWorld(!0); this.matrixWorld.decompose(xe, vk, a); return a; }, getWorldDirection: function (a) { void 0 === a && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), a = new n); this.updateMatrixWorld(!0); var b = this.matrixWorld.elements; return a.set(b[8], b[9], b[10]).normalize(); },
        raycast: function () { }, traverse: function (a) { a(this); for (var b = this.children, c = 0, d = b.length; c < d; c++)
            b[c].traverse(a); }, traverseVisible: function (a) { if (!1 !== this.visible) {
            a(this);
            for (var b = this.children, c = 0, d = b.length; c < d; c++)
                b[c].traverseVisible(a);
        } }, traverseAncestors: function (a) { var b = this.parent; null !== b && (a(b), b.traverseAncestors(a)); }, updateMatrix: function () { this.matrix.compose(this.position, this.quaternion, this.scale); this.matrixWorldNeedsUpdate = !0; }, updateMatrixWorld: function (a) {
            this.matrixAutoUpdate &&
                this.updateMatrix();
            if (this.matrixWorldNeedsUpdate || a)
                null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;
            for (var b = this.children, c = 0, d = b.length; c < d; c++)
                b[c].updateMatrixWorld(a);
        }, updateWorldMatrix: function (a, b) {
            var c = this.parent;
            !0 === a && null !== c && c.updateWorldMatrix(!0, !1);
            this.matrixAutoUpdate && this.updateMatrix();
            null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            if (!0 === b)
                for (a = this.children, b = 0, c = a.length; b < c; b++)
                    a[b].updateWorldMatrix(!1, !0);
        }, toJSON: function (a) {
            function b(b, c) { void 0 === b[c.uuid] && (b[c.uuid] = c.toJSON(a)); return c.uuid; }
            function c(a) { var b = [], c; for (c in a) {
                var d = a[c];
                delete d.metadata;
                b.push(d);
            } return b; }
            var d = void 0 === a || "string" === typeof a, e = {};
            d && (a = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {} }, e.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
            var f = {};
            f.uuid = this.uuid;
            f.type = this.type;
            "" !==
                this.name && (f.name = this.name);
            !0 === this.castShadow && (f.castShadow = !0);
            !0 === this.receiveShadow && (f.receiveShadow = !0);
            !1 === this.visible && (f.visible = !1);
            !1 === this.frustumCulled && (f.frustumCulled = !1);
            0 !== this.renderOrder && (f.renderOrder = this.renderOrder);
            "{}" !== JSON.stringify(this.userData) && (f.userData = this.userData);
            f.layers = this.layers.mask;
            f.matrix = this.matrix.toArray();
            !1 === this.matrixAutoUpdate && (f.matrixAutoUpdate = !1);
            this.isMesh && 0 !== this.drawMode && (f.drawMode = this.drawMode);
            if (this.isMesh || this.isLine ||
                this.isPoints) {
                f.geometry = b(a.geometries, this.geometry);
                var g = this.geometry.parameters;
                if (void 0 !== g && void 0 !== g.shapes)
                    if (g = g.shapes, Array.isArray(g))
                        for (var h = 0, l = g.length; h < l; h++)
                            b(a.shapes, g[h]);
                    else
                        b(a.shapes, g);
            }
            if (void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    g = [];
                    h = 0;
                    for (l = this.material.length; h < l; h++)
                        g.push(b(a.materials, this.material[h]));
                    f.material = g;
                }
                else
                    f.material = b(a.materials, this.material);
            if (0 < this.children.length)
                for (f.children = [], h = 0; h < this.children.length; h++)
                    f.children.push(this.children[h].toJSON(a).object);
            if (d) {
                d = c(a.geometries);
                h = c(a.materials);
                l = c(a.textures);
                var m = c(a.images);
                g = c(a.shapes);
                0 < d.length && (e.geometries = d);
                0 < h.length && (e.materials = h);
                0 < l.length && (e.textures = l);
                0 < m.length && (e.images = m);
                0 < g.length && (e.shapes = g);
            }
            e.object = f;
            return e;
        }, clone: function (a) { return (new this.constructor).copy(this, a); }, copy: function (a, b) {
            void 0 === b && (b = !0);
            this.name = a.name;
            this.up.copy(a.up);
            this.position.copy(a.position);
            this.quaternion.copy(a.quaternion);
            this.scale.copy(a.scale);
            this.matrix.copy(a.matrix);
            this.matrixWorld.copy(a.matrixWorld);
            this.matrixAutoUpdate = a.matrixAutoUpdate;
            this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate;
            this.layers.mask = a.layers.mask;
            this.visible = a.visible;
            this.castShadow = a.castShadow;
            this.receiveShadow = a.receiveShadow;
            this.frustumCulled = a.frustumCulled;
            this.renderOrder = a.renderOrder;
            this.userData = JSON.parse(JSON.stringify(a.userData));
            if (!0 === b)
                for (b = 0; b < a.children.length; b++)
                    this.add(a.children[b].clone());
            return this;
        } });
    wd.prototype = Object.assign(Object.create(B.prototype), { constructor: wd, isScene: !0,
        copy: function (a, b) { B.prototype.copy.call(this, a, b); null !== a.background && (this.background = a.background.clone()); null !== a.fog && (this.fog = a.fog.clone()); null !== a.overrideMaterial && (this.overrideMaterial = a.overrideMaterial.clone()); this.autoUpdate = a.autoUpdate; this.matrixAutoUpdate = a.matrixAutoUpdate; return this; }, toJSON: function (a) { var b = B.prototype.toJSON.call(this, a); null !== this.background && (b.object.background = this.background.toJSON(a)); null !== this.fog && (b.object.fog = this.fog.toJSON()); return b; }, dispose: function () { this.dispatchEvent({ type: "dispose" }); } });
    var vb = [new n, new n, new n, new n, new n, new n, new n, new n], jb = new n, od = new n, pd = new n, qd = new n, Mb = new n, Nb = new n, rc = new n, ye = new n, sf = new n, tf = new n, Rb = new n;
    Object.assign(ab.prototype, { isBox3: !0, set: function (a, b) { this.min.copy(a); this.max.copy(b); return this; }, setFromArray: function (a) {
            for (var b = Infinity, c = Infinity, d = Infinity, e = -Infinity, f = -Infinity, g = -Infinity, h = 0, l = a.length; h < l; h += 3) {
                var m = a[h], k = a[h + 1], n = a[h + 2];
                m < b && (b = m);
                k < c && (c = k);
                n < d && (d = n);
                m > e && (e = m);
                k > f && (f = k);
                n > g && (g = n);
            }
            this.min.set(b, c, d);
            this.max.set(e, f, g);
            return this;
        }, setFromBufferAttribute: function (a) { for (var b = Infinity, c = Infinity, d = Infinity, e = -Infinity, f = -Infinity, g = -Infinity, h = 0, l = a.count; h < l; h++) {
            var m = a.getX(h), k = a.getY(h), n = a.getZ(h);
            m < b && (b = m);
            k < c && (c = k);
            n < d && (d = n);
            m > e && (e = m);
            k > f && (f = k);
            n > g && (g = n);
        } this.min.set(b, c, d); this.max.set(e, f, g); return this; }, setFromPoints: function (a) { this.makeEmpty(); for (var b = 0, c = a.length; b < c; b++)
            this.expandByPoint(a[b]); return this; }, setFromCenterAndSize: function (a, b) {
            b = jb.copy(b).multiplyScalar(.5);
            this.min.copy(a).sub(b);
            this.max.copy(a).add(b);
            return this;
        }, setFromObject: function (a) { this.makeEmpty(); return this.expandByObject(a); }, clone: function () { return (new this.constructor).copy(this); }, copy: function (a) { this.min.copy(a.min); this.max.copy(a.max); return this; }, makeEmpty: function () { this.min.x = this.min.y = this.min.z = Infinity; this.max.x = this.max.y = this.max.z = -Infinity; return this; }, isEmpty: function () { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z; }, getCenter: function (a) {
            void 0 ===
                a && (console.warn("THREE.Box3: .getCenter() target is now required"), a = new n);
            return this.isEmpty() ? a.set(0, 0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5);
        }, getSize: function (a) { void 0 === a && (console.warn("THREE.Box3: .getSize() target is now required"), a = new n); return this.isEmpty() ? a.set(0, 0, 0) : a.subVectors(this.max, this.min); }, expandByPoint: function (a) { this.min.min(a); this.max.max(a); return this; }, expandByVector: function (a) { this.min.sub(a); this.max.add(a); return this; }, expandByScalar: function (a) {
            this.min.addScalar(-a);
            this.max.addScalar(a);
            return this;
        }, expandByObject: function (a) { var b; a.updateWorldMatrix(!1, !1); var c = a.geometry; if (void 0 !== c)
            if (c.isGeometry) {
                var d = c.vertices;
                c = 0;
                for (b = d.length; c < b; c++)
                    jb.copy(d[c]), jb.applyMatrix4(a.matrixWorld), this.expandByPoint(jb);
            }
            else if (c.isBufferGeometry && (d = c.attributes.position, void 0 !== d))
                for (c = 0, b = d.count; c < b; c++)
                    jb.fromBufferAttribute(d, c).applyMatrix4(a.matrixWorld), this.expandByPoint(jb); a = a.children; c = 0; for (b = a.length; c < b; c++)
            this.expandByObject(a[c]); return this; },
        containsPoint: function (a) { return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? !1 : !0; }, containsBox: function (a) { return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z; }, getParameter: function (a, b) {
            void 0 === b && (console.warn("THREE.Box3: .getParameter() target is now required"), b = new n);
            return b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z));
        }, intersectsBox: function (a) { return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0; }, intersectsSphere: function (a) { this.clampPoint(a.center, jb); return jb.distanceToSquared(a.center) <= a.radius * a.radius; }, intersectsPlane: function (a) {
            if (0 < a.normal.x) {
                var b = a.normal.x * this.min.x;
                var c = a.normal.x * this.max.x;
            }
            else
                b = a.normal.x * this.max.x, c = a.normal.x * this.min.x;
            0 < a.normal.y ? (b += a.normal.y * this.min.y,
                c += a.normal.y * this.max.y) : (b += a.normal.y * this.max.y, c += a.normal.y * this.min.y);
            0 < a.normal.z ? (b += a.normal.z * this.min.z, c += a.normal.z * this.max.z) : (b += a.normal.z * this.max.z, c += a.normal.z * this.min.z);
            return b <= -a.constant && c >= -a.constant;
        }, intersectsTriangle: function (a) {
            if (this.isEmpty())
                return !1;
            this.getCenter(ye);
            sf.subVectors(this.max, ye);
            od.subVectors(a.a, ye);
            pd.subVectors(a.b, ye);
            qd.subVectors(a.c, ye);
            Mb.subVectors(pd, od);
            Nb.subVectors(qd, pd);
            rc.subVectors(od, qd);
            a = [0, -Mb.z, Mb.y, 0, -Nb.z, Nb.y, 0, -rc.z,
                rc.y, Mb.z, 0, -Mb.x, Nb.z, 0, -Nb.x, rc.z, 0, -rc.x, -Mb.y, Mb.x, 0, -Nb.y, Nb.x, 0, -rc.y, rc.x, 0];
            if (!Qf(a, od, pd, qd, sf))
                return !1;
            a = [1, 0, 0, 0, 1, 0, 0, 0, 1];
            if (!Qf(a, od, pd, qd, sf))
                return !1;
            tf.crossVectors(Mb, Nb);
            a = [tf.x, tf.y, tf.z];
            return Qf(a, od, pd, qd, sf);
        }, clampPoint: function (a, b) { void 0 === b && (console.warn("THREE.Box3: .clampPoint() target is now required"), b = new n); return b.copy(a).clamp(this.min, this.max); }, distanceToPoint: function (a) { return jb.copy(a).clamp(this.min, this.max).sub(a).length(); }, getBoundingSphere: function (a) {
            void 0 ===
                a && console.error("THREE.Box3: .getBoundingSphere() target is now required");
            this.getCenter(a.center);
            a.radius = .5 * this.getSize(jb).length();
            return a;
        }, intersect: function (a) { this.min.max(a.min); this.max.min(a.max); this.isEmpty() && this.makeEmpty(); return this; }, union: function (a) { this.min.min(a.min); this.max.max(a.max); return this; }, applyMatrix4: function (a) {
            if (this.isEmpty())
                return this;
            vb[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(a);
            vb[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(a);
            vb[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(a);
            vb[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(a);
            vb[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(a);
            vb[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(a);
            vb[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(a);
            vb[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(a);
            this.setFromPoints(vb);
            return this;
        }, translate: function (a) { this.min.add(a); this.max.add(a); return this; }, equals: function (a) {
            return a.min.equals(this.min) &&
                a.max.equals(this.max);
        } });
    var yk = new ab;
    Object.assign(nb.prototype, { set: function (a, b) { this.center.copy(a); this.radius = b; return this; }, setFromPoints: function (a, b) { var c = this.center; void 0 !== b ? c.copy(b) : yk.setFromPoints(a).getCenter(c); for (var d = b = 0, e = a.length; d < e; d++)
            b = Math.max(b, c.distanceToSquared(a[d])); this.radius = Math.sqrt(b); return this; }, clone: function () { return (new this.constructor).copy(this); }, copy: function (a) { this.center.copy(a.center); this.radius = a.radius; return this; }, empty: function () {
            return 0 >=
                this.radius;
        }, containsPoint: function (a) { return a.distanceToSquared(this.center) <= this.radius * this.radius; }, distanceToPoint: function (a) { return a.distanceTo(this.center) - this.radius; }, intersectsSphere: function (a) { var b = this.radius + a.radius; return a.center.distanceToSquared(this.center) <= b * b; }, intersectsBox: function (a) { return a.intersectsSphere(this); }, intersectsPlane: function (a) { return Math.abs(a.distanceToPoint(this.center)) <= this.radius; }, clampPoint: function (a, b) {
            var c = this.center.distanceToSquared(a);
            void 0 === b && (console.warn("THREE.Sphere: .clampPoint() target is now required"), b = new n);
            b.copy(a);
            c > this.radius * this.radius && (b.sub(this.center).normalize(), b.multiplyScalar(this.radius).add(this.center));
            return b;
        }, getBoundingBox: function (a) { void 0 === a && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), a = new ab); a.set(this.center, this.center); a.expandByScalar(this.radius); return a; }, applyMatrix4: function (a) { this.center.applyMatrix4(a); this.radius *= a.getMaxScaleOnAxis(); return this; },
        translate: function (a) { this.center.add(a); return this; }, equals: function (a) { return a.center.equals(this.center) && a.radius === this.radius; } });
    var wb = new n, Og = new n, uf = new n, Ob = new n, Pg = new n, vf = new n, Qg = new n;
    Object.assign(Sb.prototype, { set: function (a, b) { this.origin.copy(a); this.direction.copy(b); return this; }, clone: function () { return (new this.constructor).copy(this); }, copy: function (a) { this.origin.copy(a.origin); this.direction.copy(a.direction); return this; }, at: function (a, b) {
            void 0 === b && (console.warn("THREE.Ray: .at() target is now required"),
                b = new n);
            return b.copy(this.direction).multiplyScalar(a).add(this.origin);
        }, lookAt: function (a) { this.direction.copy(a).sub(this.origin).normalize(); return this; }, recast: function (a) { this.origin.copy(this.at(a, wb)); return this; }, closestPointToPoint: function (a, b) { void 0 === b && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), b = new n); b.subVectors(a, this.origin); a = b.dot(this.direction); return 0 > a ? b.copy(this.origin) : b.copy(this.direction).multiplyScalar(a).add(this.origin); }, distanceToPoint: function (a) { return Math.sqrt(this.distanceSqToPoint(a)); },
        distanceSqToPoint: function (a) { var b = wb.subVectors(a, this.origin).dot(this.direction); if (0 > b)
            return this.origin.distanceToSquared(a); wb.copy(this.direction).multiplyScalar(b).add(this.origin); return wb.distanceToSquared(a); }, distanceSqToSegment: function (a, b, c, d) {
            Og.copy(a).add(b).multiplyScalar(.5);
            uf.copy(b).sub(a).normalize();
            Ob.copy(this.origin).sub(Og);
            var e = .5 * a.distanceTo(b), f = -this.direction.dot(uf), g = Ob.dot(this.direction), h = -Ob.dot(uf), l = Ob.lengthSq(), m = Math.abs(1 - f * f);
            if (0 < m) {
                a = f * h - g;
                b = f *
                    g - h;
                var k = e * m;
                0 <= a ? b >= -k ? b <= k ? (e = 1 / m, a *= e, b *= e, f = a * (a + f * b + 2 * g) + b * (f * a + b + 2 * h) + l) : (b = e, a = Math.max(0, -(f * b + g)), f = -a * a + b * (b + 2 * h) + l) : (b = -e, a = Math.max(0, -(f * b + g)), f = -a * a + b * (b + 2 * h) + l) : b <= -k ? (a = Math.max(0, -(-f * e + g)), b = 0 < a ? -e : Math.min(Math.max(-e, -h), e), f = -a * a + b * (b + 2 * h) + l) : b <= k ? (a = 0, b = Math.min(Math.max(-e, -h), e), f = b * (b + 2 * h) + l) : (a = Math.max(0, -(f * e + g)), b = 0 < a ? e : Math.min(Math.max(-e, -h), e), f = -a * a + b * (b + 2 * h) + l);
            }
            else
                b = 0 < f ? -e : e, a = Math.max(0, -(f * b + g)), f = -a * a + b * (b + 2 * h) + l;
            c && c.copy(this.direction).multiplyScalar(a).add(this.origin);
            d && d.copy(uf).multiplyScalar(b).add(Og);
            return f;
        }, intersectSphere: function (a, b) { wb.subVectors(a.center, this.origin); var c = wb.dot(this.direction), d = wb.dot(wb) - c * c; a = a.radius * a.radius; if (d > a)
            return null; a = Math.sqrt(a - d); d = c - a; c += a; return 0 > d && 0 > c ? null : 0 > d ? this.at(c, b) : this.at(d, b); }, intersectsSphere: function (a) { return this.distanceSqToPoint(a.center) <= a.radius * a.radius; }, distanceToPlane: function (a) {
            var b = a.normal.dot(this.direction);
            if (0 === b)
                return 0 === a.distanceToPoint(this.origin) ? 0 : null;
            a = -(this.origin.dot(a.normal) +
                a.constant) / b;
            return 0 <= a ? a : null;
        }, intersectPlane: function (a, b) { a = this.distanceToPlane(a); return null === a ? null : this.at(a, b); }, intersectsPlane: function (a) { var b = a.distanceToPoint(this.origin); return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1; }, intersectBox: function (a, b) {
            var c = 1 / this.direction.x;
            var d = 1 / this.direction.y;
            var e = 1 / this.direction.z, f = this.origin;
            if (0 <= c) {
                var g = (a.min.x - f.x) * c;
                c *= a.max.x - f.x;
            }
            else
                g = (a.max.x - f.x) * c, c *= a.min.x - f.x;
            if (0 <= d) {
                var h = (a.min.y - f.y) * d;
                d *= a.max.y - f.y;
            }
            else
                h = (a.max.y -
                    f.y) * d, d *= a.min.y - f.y;
            if (g > d || h > c)
                return null;
            if (h > g || g !== g)
                g = h;
            if (d < c || c !== c)
                c = d;
            0 <= e ? (h = (a.min.z - f.z) * e, a = (a.max.z - f.z) * e) : (h = (a.max.z - f.z) * e, a = (a.min.z - f.z) * e);
            if (g > a || h > c)
                return null;
            if (h > g || g !== g)
                g = h;
            if (a < c || c !== c)
                c = a;
            return 0 > c ? null : this.at(0 <= g ? g : c, b);
        }, intersectsBox: function (a) { return null !== this.intersectBox(a, wb); }, intersectTriangle: function (a, b, c, d, e) {
            Pg.subVectors(b, a);
            vf.subVectors(c, a);
            Qg.crossVectors(Pg, vf);
            b = this.direction.dot(Qg);
            if (0 < b) {
                if (d)
                    return null;
                d = 1;
            }
            else if (0 > b)
                d = -1, b = -b;
            else
                return null;
            Ob.subVectors(this.origin, a);
            a = d * this.direction.dot(vf.crossVectors(Ob, vf));
            if (0 > a)
                return null;
            c = d * this.direction.dot(Pg.cross(Ob));
            if (0 > c || a + c > b)
                return null;
            a = -d * Ob.dot(Qg);
            return 0 > a ? null : this.at(a / b, e);
        }, applyMatrix4: function (a) { this.origin.applyMatrix4(a); this.direction.transformDirection(a); return this; }, equals: function (a) { return a.origin.equals(this.origin) && a.direction.equals(this.direction); } });
    var Ya = new n, xb = new n, Rg = new n, yb = new n, rd = new n, sd = new n, si = new n, Sg = new n, Tg = new n, Ug = new n;
    Object.assign(R, { getNormal: function (a, b, c, d) { void 0 === d && (console.warn("THREE.Triangle: .getNormal() target is now required"), d = new n); d.subVectors(c, b); Ya.subVectors(a, b); d.cross(Ya); a = d.lengthSq(); return 0 < a ? d.multiplyScalar(1 / Math.sqrt(a)) : d.set(0, 0, 0); }, getBarycoord: function (a, b, c, d, e) {
            Ya.subVectors(d, b);
            xb.subVectors(c, b);
            Rg.subVectors(a, b);
            a = Ya.dot(Ya);
            b = Ya.dot(xb);
            c = Ya.dot(Rg);
            var f = xb.dot(xb);
            d = xb.dot(Rg);
            var g = a * f - b * b;
            void 0 === e && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), e = new n);
            if (0 === g)
                return e.set(-2, -1, -1);
            g = 1 / g;
            f = (f * c - b * d) * g;
            a = (a * d - b * c) * g;
            return e.set(1 - f - a, a, f);
        }, containsPoint: function (a, b, c, d) { R.getBarycoord(a, b, c, d, yb); return 0 <= yb.x && 0 <= yb.y && 1 >= yb.x + yb.y; }, getUV: function (a, b, c, d, e, f, g, h) { this.getBarycoord(a, b, c, d, yb); h.set(0, 0); h.addScaledVector(e, yb.x); h.addScaledVector(f, yb.y); h.addScaledVector(g, yb.z); return h; }, isFrontFacing: function (a, b, c, d) { Ya.subVectors(c, b); xb.subVectors(a, b); return 0 > Ya.cross(xb).dot(d) ? !0 : !1; } });
    Object.assign(R.prototype, { set: function (a, b, c) { this.a.copy(a); this.b.copy(b); this.c.copy(c); return this; }, setFromPointsAndIndices: function (a, b, c, d) { this.a.copy(a[b]); this.b.copy(a[c]); this.c.copy(a[d]); return this; }, clone: function () { return (new this.constructor).copy(this); }, copy: function (a) { this.a.copy(a.a); this.b.copy(a.b); this.c.copy(a.c); return this; }, getArea: function () { Ya.subVectors(this.c, this.b); xb.subVectors(this.a, this.b); return .5 * Ya.cross(xb).length(); }, getMidpoint: function (a) {
            void 0 === a && (console.warn("THREE.Triangle: .getMidpoint() target is now required"),
                a = new n);
            return a.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }, getNormal: function (a) { return R.getNormal(this.a, this.b, this.c, a); }, getPlane: function (a) { void 0 === a && (console.warn("THREE.Triangle: .getPlane() target is now required"), a = new n); return a.setFromCoplanarPoints(this.a, this.b, this.c); }, getBarycoord: function (a, b) { return R.getBarycoord(a, this.a, this.b, this.c, b); }, getUV: function (a, b, c, d, e) { return R.getUV(a, this.a, this.b, this.c, b, c, d, e); }, containsPoint: function (a) {
            return R.containsPoint(a, this.a, this.b, this.c);
        }, isFrontFacing: function (a) { return R.isFrontFacing(this.a, this.b, this.c, a); }, intersectsBox: function (a) { return a.intersectsTriangle(this); }, closestPointToPoint: function (a, b) {
            void 0 === b && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), b = new n);
            var c = this.a, d = this.b, e = this.c;
            rd.subVectors(d, c);
            sd.subVectors(e, c);
            Sg.subVectors(a, c);
            var f = rd.dot(Sg), g = sd.dot(Sg);
            if (0 >= f && 0 >= g)
                return b.copy(c);
            Tg.subVectors(a, d);
            var h = rd.dot(Tg), l = sd.dot(Tg);
            if (0 <= h && l <=
                h)
                return b.copy(d);
            var m = f * l - h * g;
            if (0 >= m && 0 <= f && 0 >= h)
                return d = f / (f - h), b.copy(c).addScaledVector(rd, d);
            Ug.subVectors(a, e);
            a = rd.dot(Ug);
            var k = sd.dot(Ug);
            if (0 <= k && a <= k)
                return b.copy(e);
            f = a * g - f * k;
            if (0 >= f && 0 <= g && 0 >= k)
                return m = g / (g - k), b.copy(c).addScaledVector(sd, m);
            g = h * k - a * l;
            if (0 >= g && 0 <= l - h && 0 <= a - k)
                return si.subVectors(e, d), m = (l - h) / (l - h + (a - k)), b.copy(d).addScaledVector(si, m);
            e = 1 / (g + f + m);
            d = f * e;
            m *= e;
            return b.copy(c).addScaledVector(rd, d).addScaledVector(sd, m);
        }, equals: function (a) {
            return a.a.equals(this.a) &&
                a.b.equals(this.b) && a.c.equals(this.c);
        } });
    var zk = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017,
        darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504,
        green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734,
        lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734,
        palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407,
        steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, Fa = { h: 0, s: 0, l: 0 }, wf = { h: 0, s: 0, l: 0 };
    Object.assign(H.prototype, { isColor: !0, r: 1, g: 1, b: 1, set: function (a) { a && a.isColor ? this.copy(a) : "number" === typeof a ? this.setHex(a) : "string" === typeof a && this.setStyle(a); return this; }, setScalar: function (a) { this.b = this.g = this.r = a; return this; }, setHex: function (a) {
            a = Math.floor(a);
            this.r = (a >> 16 & 255) / 255;
            this.g = (a >> 8 & 255) / 255;
            this.b = (a & 255) / 255;
            return this;
        }, setRGB: function (a, b, c) { this.r = a; this.g = b; this.b = c; return this; }, setHSL: function (a, b, c) { a = L.euclideanModulo(a, 1); b = L.clamp(b, 0, 1); c = L.clamp(c, 0, 1); 0 === b ? this.r = this.g = this.b = c : (b = .5 >= c ? c * (1 + b) : c + b - c * b, c = 2 * c - b, this.r = Rf(c, b, a + 1 / 3), this.g = Rf(c, b, a), this.b = Rf(c, b, a - 1 / 3)); return this; }, setStyle: function (a) {
            function b(b) { void 0 !== b && 1 > parseFloat(b) && console.warn("THREE.Color: Alpha component of " + a + " will be ignored."); }
            var c;
            if (c =
                /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)) {
                var d = c[2];
                switch (c[1]) {
                    case "rgb":
                    case "rgba":
                        if (c = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d))
                            return this.r = Math.min(255, parseInt(c[1], 10)) / 255, this.g = Math.min(255, parseInt(c[2], 10)) / 255, this.b = Math.min(255, parseInt(c[3], 10)) / 255, b(c[5]), this;
                        if (c = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d))
                            return this.r = Math.min(100, parseInt(c[1], 10)) / 100, this.g = Math.min(100, parseInt(c[2], 10)) / 100, this.b = Math.min(100, parseInt(c[3], 10)) / 100, b(c[5]), this;
                        break;
                    case "hsl":
                    case "hsla": if (c = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) {
                        d = parseFloat(c[1]) / 360;
                        var e = parseInt(c[2], 10) / 100, f = parseInt(c[3], 10) / 100;
                        b(c[5]);
                        return this.setHSL(d, e, f);
                    }
                }
            }
            else if (c = /^#([A-Fa-f0-9]+)$/.exec(a)) {
                c = c[1];
                d = c.length;
                if (3 === d)
                    return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, this;
                if (6 === d)
                    return this.r =
                        parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this;
            }
            a && 0 < a.length && (c = zk[a], void 0 !== c ? this.setHex(c) : console.warn("THREE.Color: Unknown color " + a));
            return this;
        }, clone: function () { return new this.constructor(this.r, this.g, this.b); }, copy: function (a) { this.r = a.r; this.g = a.g; this.b = a.b; return this; }, copyGammaToLinear: function (a, b) {
            void 0 === b && (b = 2);
            this.r = Math.pow(a.r, b);
            this.g = Math.pow(a.g, b);
            this.b = Math.pow(a.b, b);
            return this;
        }, copyLinearToGamma: function (a, b) { void 0 === b && (b = 2); b = 0 < b ? 1 / b : 1; this.r = Math.pow(a.r, b); this.g = Math.pow(a.g, b); this.b = Math.pow(a.b, b); return this; }, convertGammaToLinear: function (a) { this.copyGammaToLinear(this, a); return this; }, convertLinearToGamma: function (a) { this.copyLinearToGamma(this, a); return this; }, copySRGBToLinear: function (a) { this.r = Sf(a.r); this.g = Sf(a.g); this.b = Sf(a.b); return this; }, copyLinearToSRGB: function (a) { this.r = Tf(a.r); this.g = Tf(a.g); this.b = Tf(a.b); return this; }, convertSRGBToLinear: function () {
            this.copySRGBToLinear(this);
            return this;
        }, convertLinearToSRGB: function () { this.copyLinearToSRGB(this); return this; }, getHex: function () { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0; }, getHexString: function () { return ("000000" + this.getHex().toString(16)).slice(-6); }, getHSL: function (a) {
            void 0 === a && (console.warn("THREE.Color: .getHSL() target is now required"), a = { h: 0, s: 0, l: 0 });
            var b = this.r, c = this.g, d = this.b, e = Math.max(b, c, d), f = Math.min(b, c, d), g, h = (f + e) / 2;
            if (f === e)
                f = g = 0;
            else {
                var l = e - f;
                f = .5 >= h ? l / (e + f) : l / (2 - e - f);
                switch (e) {
                    case b:
                        g = (c -
                            d) / l + (c < d ? 6 : 0);
                        break;
                    case c:
                        g = (d - b) / l + 2;
                        break;
                    case d: g = (b - c) / l + 4;
                }
                g /= 6;
            }
            a.h = g;
            a.s = f;
            a.l = h;
            return a;
        }, getStyle: function () { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"; }, offsetHSL: function (a, b, c) { this.getHSL(Fa); Fa.h += a; Fa.s += b; Fa.l += c; this.setHSL(Fa.h, Fa.s, Fa.l); return this; }, add: function (a) { this.r += a.r; this.g += a.g; this.b += a.b; return this; }, addColors: function (a, b) { this.r = a.r + b.r; this.g = a.g + b.g; this.b = a.b + b.b; return this; }, addScalar: function (a) { this.r += a; this.g += a; this.b += a; return this; },
        sub: function (a) { this.r = Math.max(0, this.r - a.r); this.g = Math.max(0, this.g - a.g); this.b = Math.max(0, this.b - a.b); return this; }, multiply: function (a) { this.r *= a.r; this.g *= a.g; this.b *= a.b; return this; }, multiplyScalar: function (a) { this.r *= a; this.g *= a; this.b *= a; return this; }, lerp: function (a, b) { this.r += (a.r - this.r) * b; this.g += (a.g - this.g) * b; this.b += (a.b - this.b) * b; return this; }, lerpHSL: function (a, b) { this.getHSL(Fa); a.getHSL(wf); a = L.lerp(Fa.h, wf.h, b); var c = L.lerp(Fa.s, wf.s, b); b = L.lerp(Fa.l, wf.l, b); this.setHSL(a, c, b); return this; },
        equals: function (a) { return a.r === this.r && a.g === this.g && a.b === this.b; }, fromArray: function (a, b) { void 0 === b && (b = 0); this.r = a[b]; this.g = a[b + 1]; this.b = a[b + 2]; return this; }, toArray: function (a, b) { void 0 === a && (a = []); void 0 === b && (b = 0); a[b] = this.r; a[b + 1] = this.g; a[b + 2] = this.b; return a; }, toJSON: function () { return this.getHex(); } });
    Object.assign(zc.prototype, { clone: function () { return (new this.constructor).copy(this); }, copy: function (a) {
            this.a = a.a;
            this.b = a.b;
            this.c = a.c;
            this.normal.copy(a.normal);
            this.color.copy(a.color);
            this.materialIndex = a.materialIndex;
            for (var b = 0, c = a.vertexNormals.length; b < c; b++)
                this.vertexNormals[b] = a.vertexNormals[b].clone();
            b = 0;
            for (c = a.vertexColors.length; b < c; b++)
                this.vertexColors[b] = a.vertexColors[b].clone();
            return this;
        } });
    var Ti = 0;
    M.prototype = Object.assign(Object.create(Ba.prototype), { constructor: M, isMaterial: !0, onBeforeCompile: function () { }, setValues: function (a) {
            if (void 0 !== a)
                for (var b in a) {
                    var c = a[b];
                    if (void 0 === c)
                        console.warn("THREE.Material: '" + b + "' parameter is undefined.");
                    else if ("shading" ===
                        b)
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === c ? !0 : !1;
                    else {
                        var d = this[b];
                        void 0 === d ? console.warn("THREE." + this.type + ": '" + b + "' is not a property of this material.") : d && d.isColor ? d.set(c) : d && d.isVector3 && c && c.isVector3 ? d.copy(c) : this[b] = c;
                    }
                }
        }, toJSON: function (a) {
            function b(a) { var b = [], c; for (c in a) {
                var d = a[c];
                delete d.metadata;
                b.push(d);
            } return b; }
            var c = void 0 === a || "string" === typeof a;
            c && (a = { textures: {}, images: {} });
            var d = { metadata: { version: 4.5,
                    type: "Material", generator: "Material.toJSON" } };
            d.uuid = this.uuid;
            d.type = this.type;
            "" !== this.name && (d.name = this.name);
            this.color && this.color.isColor && (d.color = this.color.getHex());
            void 0 !== this.roughness && (d.roughness = this.roughness);
            void 0 !== this.metalness && (d.metalness = this.metalness);
            this.sheen && this.sheen.isColor && (d.sheen = this.sheen.getHex());
            this.emissive && this.emissive.isColor && (d.emissive = this.emissive.getHex());
            this.emissiveIntensity && 1 !== this.emissiveIntensity && (d.emissiveIntensity = this.emissiveIntensity);
            this.specular && this.specular.isColor && (d.specular = this.specular.getHex());
            void 0 !== this.shininess && (d.shininess = this.shininess);
            void 0 !== this.clearcoat && (d.clearcoat = this.clearcoat);
            void 0 !== this.clearcoatRoughness && (d.clearcoatRoughness = this.clearcoatRoughness);
            this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (d.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(a).uuid, d.clearcoatNormalScale = this.clearcoatNormalScale.toArray());
            this.map && this.map.isTexture && (d.map = this.map.toJSON(a).uuid);
            this.matcap && this.matcap.isTexture && (d.matcap = this.matcap.toJSON(a).uuid);
            this.alphaMap && this.alphaMap.isTexture && (d.alphaMap = this.alphaMap.toJSON(a).uuid);
            this.lightMap && this.lightMap.isTexture && (d.lightMap = this.lightMap.toJSON(a).uuid);
            this.aoMap && this.aoMap.isTexture && (d.aoMap = this.aoMap.toJSON(a).uuid, d.aoMapIntensity = this.aoMapIntensity);
            this.bumpMap && this.bumpMap.isTexture && (d.bumpMap = this.bumpMap.toJSON(a).uuid, d.bumpScale = this.bumpScale);
            this.normalMap && this.normalMap.isTexture && (d.normalMap =
                this.normalMap.toJSON(a).uuid, d.normalMapType = this.normalMapType, d.normalScale = this.normalScale.toArray());
            this.displacementMap && this.displacementMap.isTexture && (d.displacementMap = this.displacementMap.toJSON(a).uuid, d.displacementScale = this.displacementScale, d.displacementBias = this.displacementBias);
            this.roughnessMap && this.roughnessMap.isTexture && (d.roughnessMap = this.roughnessMap.toJSON(a).uuid);
            this.metalnessMap && this.metalnessMap.isTexture && (d.metalnessMap = this.metalnessMap.toJSON(a).uuid);
            this.emissiveMap &&
                this.emissiveMap.isTexture && (d.emissiveMap = this.emissiveMap.toJSON(a).uuid);
            this.specularMap && this.specularMap.isTexture && (d.specularMap = this.specularMap.toJSON(a).uuid);
            this.envMap && this.envMap.isTexture && (d.envMap = this.envMap.toJSON(a).uuid, d.reflectivity = this.reflectivity, d.refractionRatio = this.refractionRatio, void 0 !== this.combine && (d.combine = this.combine), void 0 !== this.envMapIntensity && (d.envMapIntensity = this.envMapIntensity));
            this.gradientMap && this.gradientMap.isTexture && (d.gradientMap = this.gradientMap.toJSON(a).uuid);
            void 0 !== this.size && (d.size = this.size);
            void 0 !== this.sizeAttenuation && (d.sizeAttenuation = this.sizeAttenuation);
            1 !== this.blending && (d.blending = this.blending);
            !0 === this.flatShading && (d.flatShading = this.flatShading);
            0 !== this.side && (d.side = this.side);
            0 !== this.vertexColors && (d.vertexColors = this.vertexColors);
            1 > this.opacity && (d.opacity = this.opacity);
            !0 === this.transparent && (d.transparent = this.transparent);
            d.depthFunc = this.depthFunc;
            d.depthTest = this.depthTest;
            d.depthWrite = this.depthWrite;
            d.stencilWrite = this.stencilWrite;
            d.stencilWriteMask = this.stencilWriteMask;
            d.stencilFunc = this.stencilFunc;
            d.stencilRef = this.stencilRef;
            d.stencilFuncMask = this.stencilFuncMask;
            d.stencilFail = this.stencilFail;
            d.stencilZFail = this.stencilZFail;
            d.stencilZPass = this.stencilZPass;
            this.rotation && 0 !== this.rotation && (d.rotation = this.rotation);
            !0 === this.polygonOffset && (d.polygonOffset = !0);
            0 !== this.polygonOffsetFactor && (d.polygonOffsetFactor = this.polygonOffsetFactor);
            0 !== this.polygonOffsetUnits && (d.polygonOffsetUnits = this.polygonOffsetUnits);
            this.linewidth &&
                1 !== this.linewidth && (d.linewidth = this.linewidth);
            void 0 !== this.dashSize && (d.dashSize = this.dashSize);
            void 0 !== this.gapSize && (d.gapSize = this.gapSize);
            void 0 !== this.scale && (d.scale = this.scale);
            !0 === this.dithering && (d.dithering = !0);
            0 < this.alphaTest && (d.alphaTest = this.alphaTest);
            !0 === this.premultipliedAlpha && (d.premultipliedAlpha = this.premultipliedAlpha);
            !0 === this.wireframe && (d.wireframe = this.wireframe);
            1 < this.wireframeLinewidth && (d.wireframeLinewidth = this.wireframeLinewidth);
            "round" !== this.wireframeLinecap &&
                (d.wireframeLinecap = this.wireframeLinecap);
            "round" !== this.wireframeLinejoin && (d.wireframeLinejoin = this.wireframeLinejoin);
            !0 === this.morphTargets && (d.morphTargets = !0);
            !0 === this.morphNormals && (d.morphNormals = !0);
            !0 === this.skinning && (d.skinning = !0);
            !1 === this.visible && (d.visible = !1);
            !1 === this.toneMapped && (d.toneMapped = !1);
            "{}" !== JSON.stringify(this.userData) && (d.userData = this.userData);
            c && (c = b(a.textures), a = b(a.images), 0 < c.length && (d.textures = c), 0 < a.length && (d.images = a));
            return d;
        }, clone: function () { return (new this.constructor).copy(this); },
        copy: function (a) {
            this.name = a.name;
            this.fog = a.fog;
            this.blending = a.blending;
            this.side = a.side;
            this.flatShading = a.flatShading;
            this.vertexColors = a.vertexColors;
            this.opacity = a.opacity;
            this.transparent = a.transparent;
            this.blendSrc = a.blendSrc;
            this.blendDst = a.blendDst;
            this.blendEquation = a.blendEquation;
            this.blendSrcAlpha = a.blendSrcAlpha;
            this.blendDstAlpha = a.blendDstAlpha;
            this.blendEquationAlpha = a.blendEquationAlpha;
            this.depthFunc = a.depthFunc;
            this.depthTest = a.depthTest;
            this.depthWrite = a.depthWrite;
            this.stencilWrite =
                a.stencilWrite;
            this.stencilWriteMask = a.stencilWriteMask;
            this.stencilFunc = a.stencilFunc;
            this.stencilRef = a.stencilRef;
            this.stencilFuncMask = a.stencilFuncMask;
            this.stencilFail = a.stencilFail;
            this.stencilZFail = a.stencilZFail;
            this.stencilZPass = a.stencilZPass;
            this.colorWrite = a.colorWrite;
            this.precision = a.precision;
            this.polygonOffset = a.polygonOffset;
            this.polygonOffsetFactor = a.polygonOffsetFactor;
            this.polygonOffsetUnits = a.polygonOffsetUnits;
            this.dithering = a.dithering;
            this.alphaTest = a.alphaTest;
            this.premultipliedAlpha =
                a.premultipliedAlpha;
            this.visible = a.visible;
            this.toneMapped = a.toneMapped;
            this.userData = JSON.parse(JSON.stringify(a.userData));
            this.clipShadows = a.clipShadows;
            this.clipIntersection = a.clipIntersection;
            var b = a.clippingPlanes, c = null;
            if (null !== b) {
                var d = b.length;
                c = Array(d);
                for (var e = 0; e !== d; ++e)
                    c[e] = b[e].clone();
            }
            this.clippingPlanes = c;
            this.shadowSide = a.shadowSide;
            return this;
        }, dispose: function () { this.dispatchEvent({ type: "dispose" }); } });
    Ga.prototype = Object.create(M.prototype);
    Ga.prototype.constructor = Ga;
    Ga.prototype.isMeshBasicMaterial =
        !0;
    Ga.prototype.copy = function (a) {
        M.prototype.copy.call(this, a);
        this.color.copy(a.color);
        this.map = a.map;
        this.lightMap = a.lightMap;
        this.lightMapIntensity = a.lightMapIntensity;
        this.aoMap = a.aoMap;
        this.aoMapIntensity = a.aoMapIntensity;
        this.specularMap = a.specularMap;
        this.alphaMap = a.alphaMap;
        this.envMap = a.envMap;
        this.combine = a.combine;
        this.reflectivity = a.reflectivity;
        this.refractionRatio = a.refractionRatio;
        this.wireframe = a.wireframe;
        this.wireframeLinewidth = a.wireframeLinewidth;
        this.wireframeLinecap = a.wireframeLinecap;
        this.wireframeLinejoin = a.wireframeLinejoin;
        this.skinning = a.skinning;
        this.morphTargets = a.morphTargets;
        return this;
    };
    Object.defineProperty(O.prototype, "needsUpdate", { set: function (a) { !0 === a && this.version++; } });
    Object.assign(O.prototype, { isBufferAttribute: !0, onUploadCallback: function () { }, setDynamic: function (a) { this.dynamic = a; return this; }, copy: function (a) {
            this.name = a.name;
            this.array = new a.array.constructor(a.array);
            this.itemSize = a.itemSize;
            this.count = a.count;
            this.normalized = a.normalized;
            this.dynamic = a.dynamic;
            return this;
        }, copyAt: function (a, b, c) { a *= this.itemSize; c *= b.itemSize; for (var d = 0, e = this.itemSize; d < e; d++)
            this.array[a + d] = b.array[c + d]; return this; }, copyArray: function (a) { this.array.set(a); return this; }, copyColorsArray: function (a) { for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            void 0 === f && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", d), f = new H);
            b[c++] = f.r;
            b[c++] = f.g;
            b[c++] = f.b;
        } return this; }, copyVector2sArray: function (a) {
            for (var b = this.array, c = 0, d = 0, e = a.length; d <
                e; d++) {
                var f = a[d];
                void 0 === f && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", d), f = new w);
                b[c++] = f.x;
                b[c++] = f.y;
            }
            return this;
        }, copyVector3sArray: function (a) { for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            void 0 === f && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", d), f = new n);
            b[c++] = f.x;
            b[c++] = f.y;
            b[c++] = f.z;
        } return this; }, copyVector4sArray: function (a) {
            for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
                var f = a[d];
                void 0 === f && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", d), f = new aa);
                b[c++] = f.x;
                b[c++] = f.y;
                b[c++] = f.z;
                b[c++] = f.w;
            }
            return this;
        }, set: function (a, b) { void 0 === b && (b = 0); this.array.set(a, b); return this; }, getX: function (a) { return this.array[a * this.itemSize]; }, setX: function (a, b) { this.array[a * this.itemSize] = b; return this; }, getY: function (a) { return this.array[a * this.itemSize + 1]; }, setY: function (a, b) { this.array[a * this.itemSize + 1] = b; return this; }, getZ: function (a) { return this.array[a * this.itemSize + 2]; }, setZ: function (a, b) { this.array[a * this.itemSize + 2] = b; return this; }, getW: function (a) {
            return this.array[a *
                this.itemSize + 3];
        }, setW: function (a, b) { this.array[a * this.itemSize + 3] = b; return this; }, setXY: function (a, b, c) { a *= this.itemSize; this.array[a + 0] = b; this.array[a + 1] = c; return this; }, setXYZ: function (a, b, c, d) { a *= this.itemSize; this.array[a + 0] = b; this.array[a + 1] = c; this.array[a + 2] = d; return this; }, setXYZW: function (a, b, c, d, e) { a *= this.itemSize; this.array[a + 0] = b; this.array[a + 1] = c; this.array[a + 2] = d; this.array[a + 3] = e; return this; }, onUpload: function (a) { this.onUploadCallback = a; return this; }, clone: function () {
            return (new this.constructor(this.array, this.itemSize)).copy(this);
        }, toJSON: function () { return { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized }; } });
    xd.prototype = Object.create(O.prototype);
    xd.prototype.constructor = xd;
    yd.prototype = Object.create(O.prototype);
    yd.prototype.constructor = yd;
    zd.prototype = Object.create(O.prototype);
    zd.prototype.constructor = zd;
    Ad.prototype = Object.create(O.prototype);
    Ad.prototype.constructor = Ad;
    Tb.prototype = Object.create(O.prototype);
    Tb.prototype.constructor =
        Tb;
    Bd.prototype = Object.create(O.prototype);
    Bd.prototype.constructor = Bd;
    Ub.prototype = Object.create(O.prototype);
    Ub.prototype.constructor = Ub;
    A.prototype = Object.create(O.prototype);
    A.prototype.constructor = A;
    Cd.prototype = Object.create(O.prototype);
    Cd.prototype.constructor = Cd;
    Object.assign(jh.prototype, { computeGroups: function (a) {
            var b = [], c = void 0;
            a = a.faces;
            for (var d = 0; d < a.length; d++) {
                var e = a[d];
                if (e.materialIndex !== c) {
                    c = e.materialIndex;
                    void 0 !== f && (f.count = 3 * d - f.start, b.push(f));
                    var f = { start: 3 * d, materialIndex: c };
                }
            }
            void 0 !==
                f && (f.count = 3 * d - f.start, b.push(f));
            this.groups = b;
        }, fromGeometry: function (a) {
            var b = a.faces, c = a.vertices, d = a.faceVertexUvs, e = d[0] && 0 < d[0].length, f = d[1] && 0 < d[1].length, g = a.morphTargets, h = g.length;
            if (0 < h) {
                var l = [];
                for (var m = 0; m < h; m++)
                    l[m] = { name: g[m].name, data: [] };
                this.morphTargets.position = l;
            }
            var k = a.morphNormals, n = k.length;
            if (0 < n) {
                var t = [];
                for (m = 0; m < n; m++)
                    t[m] = { name: k[m].name, data: [] };
                this.morphTargets.normal = t;
            }
            var r = a.skinIndices, p = a.skinWeights, v = r.length === c.length, x = p.length === c.length;
            0 < c.length &&
                0 === b.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
            for (m = 0; m < b.length; m++) {
                var z = b[m];
                this.vertices.push(c[z.a], c[z.b], c[z.c]);
                var y = z.vertexNormals;
                3 === y.length ? this.normals.push(y[0], y[1], y[2]) : (y = z.normal, this.normals.push(y, y, y));
                y = z.vertexColors;
                3 === y.length ? this.colors.push(y[0], y[1], y[2]) : (y = z.color, this.colors.push(y, y, y));
                !0 === e && (y = d[0][m], void 0 !== y ? this.uvs.push(y[0], y[1], y[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", m), this.uvs.push(new w, new w, new w)));
                !0 === f && (y = d[1][m], void 0 !== y ? this.uvs2.push(y[0], y[1], y[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", m), this.uvs2.push(new w, new w, new w)));
                for (y = 0; y < h; y++) {
                    var A = g[y].vertices;
                    l[y].data.push(A[z.a], A[z.b], A[z.c]);
                }
                for (y = 0; y < n; y++)
                    A = k[y].vertexNormals[m], t[y].data.push(A.a, A.b, A.c);
                v && this.skinIndices.push(r[z.a], r[z.b], r[z.c]);
                x && this.skinWeights.push(p[z.a], p[z.b], p[z.c]);
            }
            this.computeGroups(a);
            this.verticesNeedUpdate = a.verticesNeedUpdate;
            this.normalsNeedUpdate = a.normalsNeedUpdate;
            this.colorsNeedUpdate = a.colorsNeedUpdate;
            this.uvsNeedUpdate = a.uvsNeedUpdate;
            this.groupsNeedUpdate = a.groupsNeedUpdate;
            null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
            null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
            return this;
        } });
    var Ui = 1, kb = new U, Vg = new B, xf = new n, sc = new ab, Wg = new ab, Za = new n;
    E.prototype = Object.assign(Object.create(Ba.prototype), { constructor: E, isBufferGeometry: !0, getIndex: function () { return this.index; },
        setIndex: function (a) { Array.isArray(a) ? this.index = new (65535 < kh(a) ? Ub : Tb)(a, 1) : this.index = a; }, addAttribute: function (a, b, c) { return b && b.isBufferAttribute || b && b.isInterleavedBufferAttribute ? "index" === a ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(b), this) : this.setAttribute(a, b) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(a, new O(b, c))); }, getAttribute: function (a) { return this.attributes[a]; },
        setAttribute: function (a, b) { this.attributes[a] = b; return this; }, removeAttribute: function (a) { delete this.attributes[a]; return this; }, addGroup: function (a, b, c) { this.groups.push({ start: a, count: b, materialIndex: void 0 !== c ? c : 0 }); }, clearGroups: function () { this.groups = []; }, setDrawRange: function (a, b) { this.drawRange.start = a; this.drawRange.count = b; }, applyMatrix: function (a) {
            var b = this.attributes.position;
            void 0 !== b && (a.applyToBufferAttribute(b), b.needsUpdate = !0);
            var c = this.attributes.normal;
            void 0 !== c && (b = (new Y).getNormalMatrix(a),
                b.applyToBufferAttribute(c), c.needsUpdate = !0);
            c = this.attributes.tangent;
            void 0 !== c && (b = (new Y).getNormalMatrix(a), b.applyToBufferAttribute(c), c.needsUpdate = !0);
            null !== this.boundingBox && this.computeBoundingBox();
            null !== this.boundingSphere && this.computeBoundingSphere();
            return this;
        }, rotateX: function (a) { kb.makeRotationX(a); this.applyMatrix(kb); return this; }, rotateY: function (a) { kb.makeRotationY(a); this.applyMatrix(kb); return this; }, rotateZ: function (a) { kb.makeRotationZ(a); this.applyMatrix(kb); return this; },
        translate: function (a, b, c) { kb.makeTranslation(a, b, c); this.applyMatrix(kb); return this; }, scale: function (a, b, c) { kb.makeScale(a, b, c); this.applyMatrix(kb); return this; }, lookAt: function (a) { Vg.lookAt(a); Vg.updateMatrix(); this.applyMatrix(Vg.matrix); return this; }, center: function () { this.computeBoundingBox(); this.boundingBox.getCenter(xf).negate(); this.translate(xf.x, xf.y, xf.z); return this; }, setFromObject: function (a) {
            var b = a.geometry;
            if (a.isPoints || a.isLine) {
                a = new A(3 * b.vertices.length, 3);
                var c = new A(3 * b.colors.length, 3);
                this.addAttribute("position", a.copyVector3sArray(b.vertices));
                this.addAttribute("color", c.copyColorsArray(b.colors));
                b.lineDistances && b.lineDistances.length === b.vertices.length && (a = new A(b.lineDistances.length, 1), this.addAttribute("lineDistance", a.copyArray(b.lineDistances)));
                null !== b.boundingSphere && (this.boundingSphere = b.boundingSphere.clone());
                null !== b.boundingBox && (this.boundingBox = b.boundingBox.clone());
            }
            else
                a.isMesh && b && b.isGeometry && this.fromGeometry(b);
            return this;
        }, setFromPoints: function (a) {
            for (var b = [], c = 0, d = a.length; c < d; c++) {
                var e = a[c];
                b.push(e.x, e.y, e.z || 0);
            }
            this.addAttribute("position", new A(b, 3));
            return this;
        }, updateFromObject: function (a) {
            var b = a.geometry;
            if (a.isMesh) {
                var c = b.__directGeometry;
                !0 === b.elementsNeedUpdate && (c = void 0, b.elementsNeedUpdate = !1);
                if (void 0 === c)
                    return this.fromGeometry(b);
                c.verticesNeedUpdate = b.verticesNeedUpdate;
                c.normalsNeedUpdate = b.normalsNeedUpdate;
                c.colorsNeedUpdate = b.colorsNeedUpdate;
                c.uvsNeedUpdate = b.uvsNeedUpdate;
                c.groupsNeedUpdate = b.groupsNeedUpdate;
                b.verticesNeedUpdate =
                    !1;
                b.normalsNeedUpdate = !1;
                b.colorsNeedUpdate = !1;
                b.uvsNeedUpdate = !1;
                b.groupsNeedUpdate = !1;
                b = c;
            }
            !0 === b.verticesNeedUpdate && (c = this.attributes.position, void 0 !== c && (c.copyVector3sArray(b.vertices), c.needsUpdate = !0), b.verticesNeedUpdate = !1);
            !0 === b.normalsNeedUpdate && (c = this.attributes.normal, void 0 !== c && (c.copyVector3sArray(b.normals), c.needsUpdate = !0), b.normalsNeedUpdate = !1);
            !0 === b.colorsNeedUpdate && (c = this.attributes.color, void 0 !== c && (c.copyColorsArray(b.colors), c.needsUpdate = !0), b.colorsNeedUpdate =
                !1);
            b.uvsNeedUpdate && (c = this.attributes.uv, void 0 !== c && (c.copyVector2sArray(b.uvs), c.needsUpdate = !0), b.uvsNeedUpdate = !1);
            b.lineDistancesNeedUpdate && (c = this.attributes.lineDistance, void 0 !== c && (c.copyArray(b.lineDistances), c.needsUpdate = !0), b.lineDistancesNeedUpdate = !1);
            b.groupsNeedUpdate && (b.computeGroups(a.geometry), this.groups = b.groups, b.groupsNeedUpdate = !1);
            return this;
        }, fromGeometry: function (a) { a.__directGeometry = (new jh).fromGeometry(a); return this.fromDirectGeometry(a.__directGeometry); }, fromDirectGeometry: function (a) {
            var b = new Float32Array(3 * a.vertices.length);
            this.addAttribute("position", (new O(b, 3)).copyVector3sArray(a.vertices));
            0 < a.normals.length && (b = new Float32Array(3 * a.normals.length), this.addAttribute("normal", (new O(b, 3)).copyVector3sArray(a.normals)));
            0 < a.colors.length && (b = new Float32Array(3 * a.colors.length), this.addAttribute("color", (new O(b, 3)).copyColorsArray(a.colors)));
            0 < a.uvs.length && (b = new Float32Array(2 * a.uvs.length), this.addAttribute("uv", (new O(b, 2)).copyVector2sArray(a.uvs)));
            0 < a.uvs2.length && (b =
                new Float32Array(2 * a.uvs2.length), this.addAttribute("uv2", (new O(b, 2)).copyVector2sArray(a.uvs2)));
            this.groups = a.groups;
            for (var c in a.morphTargets) {
                b = [];
                for (var d = a.morphTargets[c], e = 0, f = d.length; e < f; e++) {
                    var g = d[e], h = new A(3 * g.data.length, 3);
                    h.name = g.name;
                    b.push(h.copyVector3sArray(g.data));
                }
                this.morphAttributes[c] = b;
            }
            0 < a.skinIndices.length && (c = new A(4 * a.skinIndices.length, 4), this.addAttribute("skinIndex", c.copyVector4sArray(a.skinIndices)));
            0 < a.skinWeights.length && (c = new A(4 * a.skinWeights.length, 4), this.addAttribute("skinWeight", c.copyVector4sArray(a.skinWeights)));
            null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
            null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
            return this;
        }, computeBoundingBox: function () {
            null === this.boundingBox && (this.boundingBox = new ab);
            var a = this.attributes.position, b = this.morphAttributes.position;
            if (void 0 !== a) {
                if (this.boundingBox.setFromBufferAttribute(a), b) {
                    a = 0;
                    for (var c = b.length; a < c; a++)
                        sc.setFromBufferAttribute(b[a]), this.boundingBox.expandByPoint(sc.min),
                            this.boundingBox.expandByPoint(sc.max);
                }
            }
            else
                this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }, computeBoundingSphere: function () {
            null === this.boundingSphere && (this.boundingSphere = new nb);
            var a = this.attributes.position, b = this.morphAttributes.position;
            if (a) {
                var c = this.boundingSphere.center;
                sc.setFromBufferAttribute(a);
                if (b)
                    for (var d = 0, e = b.length; d < e; d++) {
                        var f = b[d];
                        Wg.setFromBufferAttribute(f);
                        sc.expandByPoint(Wg.min);
                        sc.expandByPoint(Wg.max);
                    }
                sc.getCenter(c);
                var g = 0;
                d = 0;
                for (e = a.count; d < e; d++)
                    Za.fromBufferAttribute(a, d), g = Math.max(g, c.distanceToSquared(Za));
                if (b)
                    for (d = 0, e = b.length; d < e; d++) {
                        f = b[d];
                        a = 0;
                        for (var h = f.count; a < h; a++)
                            Za.fromBufferAttribute(f, a), g = Math.max(g, c.distanceToSquared(Za));
                    }
                this.boundingSphere.radius = Math.sqrt(g);
                isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
            }
        }, computeFaceNormals: function () { }, computeVertexNormals: function () {
            var a = this.index, b = this.attributes;
            if (b.position) {
                var c = b.position.array;
                if (void 0 === b.normal)
                    this.addAttribute("normal", new O(new Float32Array(c.length), 3));
                else
                    for (var d = b.normal.array, e = 0, f = d.length; e < f; e++)
                        d[e] = 0;
                d = b.normal.array;
                var g = new n, h = new n, l = new n, m = new n, k = new n;
                if (a) {
                    var u = a.array;
                    e = 0;
                    for (f = a.count; e < f; e += 3) {
                        a = 3 * u[e + 0];
                        var t = 3 * u[e + 1];
                        var r = 3 * u[e + 2];
                        g.fromArray(c, a);
                        h.fromArray(c, t);
                        l.fromArray(c, r);
                        m.subVectors(l, h);
                        k.subVectors(g, h);
                        m.cross(k);
                        d[a] += m.x;
                        d[a + 1] += m.y;
                        d[a + 2] += m.z;
                        d[t] += m.x;
                        d[t + 1] += m.y;
                        d[t + 2] += m.z;
                        d[r] += m.x;
                        d[r + 1] += m.y;
                        d[r + 2] += m.z;
                    }
                }
                else
                    for (e = 0, f = c.length; e < f; e += 9)
                        g.fromArray(c, e), h.fromArray(c, e + 3), l.fromArray(c, e + 6), m.subVectors(l, h), k.subVectors(g, h), m.cross(k), d[e] = m.x, d[e + 1] = m.y, d[e + 2] = m.z, d[e + 3] = m.x, d[e + 4] = m.y, d[e + 5] = m.z, d[e + 6] = m.x, d[e + 7] = m.y, d[e + 8] = m.z;
                this.normalizeNormals();
                b.normal.needsUpdate = !0;
            }
        }, merge: function (a, b) {
            if (a && a.isBufferGeometry) {
                void 0 === b && (b = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                var c = this.attributes, d;
                for (d in c)
                    if (void 0 !== a.attributes[d]) {
                        var e = c[d].array, f = a.attributes[d], g = f.array, h = f.itemSize * b;
                        f = Math.min(g.length, e.length - h);
                        for (var l = 0; l < f; l++, h++)
                            e[h] = g[l];
                    }
                return this;
            }
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", a);
        }, normalizeNormals: function () { for (var a = this.attributes.normal, b = 0, c = a.count; b < c; b++)
            Za.x = a.getX(b), Za.y = a.getY(b), Za.z = a.getZ(b), Za.normalize(), a.setXYZ(b, Za.x, Za.y, Za.z); }, toNonIndexed: function () {
            function a(a, b) { var c = a.array; a = a.itemSize; for (var d = new c.constructor(b.length * a), e, f = 0, g = 0, h = b.length; g < h; g++) {
                e = b[g] * a;
                for (var l = 0; l < a; l++)
                    d[f++] = c[e++];
            } return new O(d, a); }
            if (null === this.index)
                return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
            var b = new E, c = this.index.array, d = this.attributes, e;
            for (e in d) {
                var f = d[e];
                f = a(f, c);
                b.addAttribute(e, f);
            }
            var g = this.morphAttributes;
            for (e in g) {
                var h = [], l = g[e];
                d = 0;
                for (var m = l.length; d < m; d++)
                    f = l[d], f = a(f, c), h.push(f);
                b.morphAttributes[e] =
                    h;
            }
            c = this.groups;
            d = 0;
            for (e = c.length; d < e; d++)
                f = c[d], b.addGroup(f.start, f.count, f.materialIndex);
            return b;
        }, toJSON: function () {
            var a = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
            a.uuid = this.uuid;
            a.type = this.type;
            "" !== this.name && (a.name = this.name);
            0 < Object.keys(this.userData).length && (a.userData = this.userData);
            if (void 0 !== this.parameters) {
                var b = this.parameters;
                for (m in b)
                    void 0 !== b[m] && (a[m] = b[m]);
                return a;
            }
            a.data = { attributes: {} };
            b = this.index;
            null !== b && (a.data.index = { type: b.array.constructor.name,
                array: Array.prototype.slice.call(b.array) });
            var c = this.attributes;
            for (m in c) {
                b = c[m];
                var d = b.toJSON();
                "" !== b.name && (d.name = b.name);
                a.data.attributes[m] = d;
            }
            c = {};
            var e = !1;
            for (m in this.morphAttributes) {
                for (var f = this.morphAttributes[m], g = [], h = 0, l = f.length; h < l; h++)
                    b = f[h], d = b.toJSON(), "" !== b.name && (d.name = b.name), g.push(d);
                0 < g.length && (c[m] = g, e = !0);
            }
            e && (a.data.morphAttributes = c);
            var m = this.groups;
            0 < m.length && (a.data.groups = JSON.parse(JSON.stringify(m)));
            m = this.boundingSphere;
            null !== m && (a.data.boundingSphere =
                { center: m.center.toArray(), radius: m.radius });
            return a;
        }, clone: function () { return (new E).copy(this); }, copy: function (a) {
            var b;
            this.index = null;
            this.attributes = {};
            this.morphAttributes = {};
            this.groups = [];
            this.boundingSphere = this.boundingBox = null;
            this.name = a.name;
            var c = a.index;
            null !== c && this.setIndex(c.clone());
            c = a.attributes;
            for (g in c)
                this.addAttribute(g, c[g].clone());
            var d = a.morphAttributes;
            for (g in d) {
                var e = [], f = d[g];
                c = 0;
                for (b = f.length; c < b; c++)
                    e.push(f[c].clone());
                this.morphAttributes[g] = e;
            }
            var g = a.groups;
            c = 0;
            for (b = g.length; c < b; c++)
                d = g[c], this.addGroup(d.start, d.count, d.materialIndex);
            g = a.boundingBox;
            null !== g && (this.boundingBox = g.clone());
            g = a.boundingSphere;
            null !== g && (this.boundingSphere = g.clone());
            this.drawRange.start = a.drawRange.start;
            this.drawRange.count = a.drawRange.count;
            this.userData = a.userData;
            return this;
        }, dispose: function () { this.dispatchEvent({ type: "dispose" }); } });
    var ti = new U, tc = new Sb, Xg = new nb, Vb = new n, Wb = new n, Xb = new n, mh = new n, nh = new n, oh = new n, Uf = new n, Vf = new n, Wf = new n, Ac = new w, Bc = new w, Cc = new w, Dd = new n, Ee = new n;
    ja.prototype = Object.assign(Object.create(B.prototype), { constructor: ja, isMesh: !0, setDrawMode: function (a) { this.drawMode = a; }, copy: function (a) { B.prototype.copy.call(this, a); this.drawMode = a.drawMode; void 0 !== a.morphTargetInfluences && (this.morphTargetInfluences = a.morphTargetInfluences.slice()); void 0 !== a.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, a.morphTargetDictionary)); return this; }, updateMorphTargets: function () {
            var a = this.geometry;
            if (a.isBufferGeometry) {
                a =
                    a.morphAttributes;
                var b = Object.keys(a);
                if (0 < b.length) {
                    var c = a[b[0]];
                    if (void 0 !== c)
                        for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, a = 0, b = c.length; a < b; a++) {
                            var d = c[a].name || String(a);
                            this.morphTargetInfluences.push(0);
                            this.morphTargetDictionary[d] = a;
                        }
                }
            }
            else
                a = a.morphTargets, void 0 !== a && 0 < a.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }, raycast: function (a, b) {
            var c = this.geometry, d = this.material, e = this.matrixWorld;
            if (void 0 !== d && (null === c.boundingSphere && c.computeBoundingSphere(), Xg.copy(c.boundingSphere), Xg.applyMatrix4(e), !1 !== a.ray.intersectsSphere(Xg) && (ti.getInverse(e), tc.copy(a.ray).applyMatrix4(ti), null === c.boundingBox || !1 !== tc.intersectsBox(c.boundingBox))))
                if (c.isBufferGeometry) {
                    var f = c.index;
                    e = c.attributes.position;
                    var g = c.morphAttributes.position, h = c.attributes.uv, l = c.attributes.uv2, m = c.groups, k = c.drawRange, n, t;
                    if (null !== f)
                        if (Array.isArray(d)) {
                            var r = 0;
                            for (n = m.length; r < n; r++) {
                                var p = m[r];
                                var v = d[p.materialIndex];
                                var x = Math.max(p.start, k.start);
                                for (t = c = Math.min(p.start + p.count, k.start + k.count); x < t; x += 3) {
                                    c = f.getX(x);
                                    var z = f.getX(x + 1);
                                    var y = f.getX(x + 2);
                                    if (c = Fe(this, v, a, tc, e, g, h, l, c, z, y))
                                        c.faceIndex = Math.floor(x / 3), c.face.materialIndex = p.materialIndex, b.push(c);
                                }
                            }
                        }
                        else
                            for (x = Math.max(0, k.start), c = Math.min(f.count, k.start + k.count), r = x, n = c; r < n; r += 3) {
                                if (c = f.getX(r), z = f.getX(r + 1), y = f.getX(r + 2), c = Fe(this, d, a, tc, e, g, h, l, c, z, y))
                                    c.faceIndex = Math.floor(r / 3), b.push(c);
                            }
                    else if (void 0 !== e)
                        if (Array.isArray(d))
                            for (r = 0, n = m.length; r <
                                n; r++)
                                for (p = m[r], v = d[p.materialIndex], x = Math.max(p.start, k.start), t = c = Math.min(p.start + p.count, k.start + k.count); x < t; x += 3) {
                                    if (c = x, z = x + 1, y = x + 2, c = Fe(this, v, a, tc, e, g, h, l, c, z, y))
                                        c.faceIndex = Math.floor(x / 3), c.face.materialIndex = p.materialIndex, b.push(c);
                                }
                        else
                            for (x = Math.max(0, k.start), c = Math.min(e.count, k.start + k.count), r = x, n = c; r < n; r += 3)
                                if (c = r, z = r + 1, y = r + 2, c = Fe(this, d, a, tc, e, g, h, l, c, z, y))
                                    c.faceIndex = Math.floor(r / 3), b.push(c);
                }
                else if (c.isGeometry)
                    for (e = Array.isArray(d), g = c.vertices, h = c.faces, c = c.faceVertexUvs[0],
                        0 < c.length && (f = c), r = 0, n = h.length; r < n; r++)
                        if (p = h[r], c = e ? d[p.materialIndex] : d, void 0 !== c && (l = g[p.a], m = g[p.b], k = g[p.c], c = lh(this, c, a, tc, l, m, k, Dd)))
                            f && f[r] && (v = f[r], Ac.copy(v[0]), Bc.copy(v[1]), Cc.copy(v[2]), c.uv = R.getUV(Dd, l, m, k, Ac, Bc, Cc, new w)), c.face = p, c.faceIndex = r, b.push(c);
        }, clone: function () { return (new this.constructor(this.geometry, this.material)).copy(this); } });
    var Vi = 0, lb = new U, Yg = new B, yf = new n;
    F.prototype = Object.assign(Object.create(Ba.prototype), { constructor: F, isGeometry: !0, applyMatrix: function (a) {
            for (var b = (new Y).getNormalMatrix(a), c = 0, d = this.vertices.length; c < d; c++)
                this.vertices[c].applyMatrix4(a);
            c = 0;
            for (d = this.faces.length; c < d; c++) {
                a = this.faces[c];
                a.normal.applyMatrix3(b).normalize();
                for (var e = 0, f = a.vertexNormals.length; e < f; e++)
                    a.vertexNormals[e].applyMatrix3(b).normalize();
            }
            null !== this.boundingBox && this.computeBoundingBox();
            null !== this.boundingSphere && this.computeBoundingSphere();
            this.normalsNeedUpdate = this.verticesNeedUpdate = !0;
            return this;
        }, rotateX: function (a) {
            lb.makeRotationX(a);
            this.applyMatrix(lb);
            return this;
        }, rotateY: function (a) { lb.makeRotationY(a); this.applyMatrix(lb); return this; }, rotateZ: function (a) { lb.makeRotationZ(a); this.applyMatrix(lb); return this; }, translate: function (a, b, c) { lb.makeTranslation(a, b, c); this.applyMatrix(lb); return this; }, scale: function (a, b, c) { lb.makeScale(a, b, c); this.applyMatrix(lb); return this; }, lookAt: function (a) { Yg.lookAt(a); Yg.updateMatrix(); this.applyMatrix(Yg.matrix); return this; }, fromBufferGeometry: function (a) {
            function b(a, b, d, e) {
                var f = void 0 === h ? [] : [c.colors[a].clone(),
                    c.colors[b].clone(), c.colors[d].clone()], k = void 0 === g ? [] : [(new n).fromArray(g, 3 * a), (new n).fromArray(g, 3 * b), (new n).fromArray(g, 3 * d)];
                e = new zc(a, b, d, k, f, e);
                c.faces.push(e);
                void 0 !== l && c.faceVertexUvs[0].push([(new w).fromArray(l, 2 * a), (new w).fromArray(l, 2 * b), (new w).fromArray(l, 2 * d)]);
                void 0 !== m && c.faceVertexUvs[1].push([(new w).fromArray(m, 2 * a), (new w).fromArray(m, 2 * b), (new w).fromArray(m, 2 * d)]);
            }
            var c = this, d = null !== a.index ? a.index.array : void 0, e = a.attributes;
            if (void 0 === e.position)
                return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),
                    this;
            var f = e.position.array, g = void 0 !== e.normal ? e.normal.array : void 0, h = void 0 !== e.color ? e.color.array : void 0, l = void 0 !== e.uv ? e.uv.array : void 0, m = void 0 !== e.uv2 ? e.uv2.array : void 0;
            void 0 !== m && (this.faceVertexUvs[1] = []);
            for (e = 0; e < f.length; e += 3)
                c.vertices.push((new n).fromArray(f, e)), void 0 !== h && c.colors.push((new H).fromArray(h, e));
            var k = a.groups;
            if (0 < k.length)
                for (e = 0; e < k.length; e++) {
                    f = k[e];
                    var u = f.start, t = u;
                    for (u += f.count; t < u; t += 3)
                        void 0 !== d ? b(d[t], d[t + 1], d[t + 2], f.materialIndex) : b(t, t + 1, t + 2, f.materialIndex);
                }
            else if (void 0 !==
                d)
                for (e = 0; e < d.length; e += 3)
                    b(d[e], d[e + 1], d[e + 2]);
            else
                for (e = 0; e < f.length / 3; e += 3)
                    b(e, e + 1, e + 2);
            this.computeFaceNormals();
            null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
            null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
            return this;
        }, center: function () { this.computeBoundingBox(); this.boundingBox.getCenter(yf).negate(); this.translate(yf.x, yf.y, yf.z); return this; }, normalize: function () {
            this.computeBoundingSphere();
            var a = this.boundingSphere.center, b = this.boundingSphere.radius;
            b = 0 === b ? 1 : 1 / b;
            var c = new U;
            c.set(b, 0, 0, -b * a.x, 0, b, 0, -b * a.y, 0, 0, b, -b * a.z, 0, 0, 0, 1);
            this.applyMatrix(c);
            return this;
        }, computeFaceNormals: function () { for (var a = new n, b = new n, c = 0, d = this.faces.length; c < d; c++) {
            var e = this.faces[c], f = this.vertices[e.a], g = this.vertices[e.b];
            a.subVectors(this.vertices[e.c], g);
            b.subVectors(f, g);
            a.cross(b);
            a.normalize();
            e.normal.copy(a);
        } }, computeVertexNormals: function (a) {
            void 0 === a && (a = !0);
            var b;
            var c = Array(this.vertices.length);
            var d = 0;
            for (b = this.vertices.length; d < b; d++)
                c[d] = new n;
            if (a) {
                var e = new n, f = new n;
                a = 0;
                for (d = this.faces.length; a < d; a++) {
                    b = this.faces[a];
                    var g = this.vertices[b.a];
                    var h = this.vertices[b.b];
                    var l = this.vertices[b.c];
                    e.subVectors(l, h);
                    f.subVectors(g, h);
                    e.cross(f);
                    c[b.a].add(e);
                    c[b.b].add(e);
                    c[b.c].add(e);
                }
            }
            else
                for (this.computeFaceNormals(), a = 0, d = this.faces.length; a < d; a++)
                    b = this.faces[a], c[b.a].add(b.normal), c[b.b].add(b.normal), c[b.c].add(b.normal);
            d = 0;
            for (b = this.vertices.length; d < b; d++)
                c[d].normalize();
            a = 0;
            for (d = this.faces.length; a < d; a++)
                b = this.faces[a], g = b.vertexNormals,
                    3 === g.length ? (g[0].copy(c[b.a]), g[1].copy(c[b.b]), g[2].copy(c[b.c])) : (g[0] = c[b.a].clone(), g[1] = c[b.b].clone(), g[2] = c[b.c].clone());
            0 < this.faces.length && (this.normalsNeedUpdate = !0);
        }, computeFlatVertexNormals: function () {
            var a;
            this.computeFaceNormals();
            var b = 0;
            for (a = this.faces.length; b < a; b++) {
                var c = this.faces[b];
                var d = c.vertexNormals;
                3 === d.length ? (d[0].copy(c.normal), d[1].copy(c.normal), d[2].copy(c.normal)) : (d[0] = c.normal.clone(), d[1] = c.normal.clone(), d[2] = c.normal.clone());
            }
            0 < this.faces.length && (this.normalsNeedUpdate =
                !0);
        }, computeMorphNormals: function () {
            var a, b;
            var c = 0;
            for (b = this.faces.length; c < b; c++) {
                var d = this.faces[c];
                d.__originalFaceNormal ? d.__originalFaceNormal.copy(d.normal) : d.__originalFaceNormal = d.normal.clone();
                d.__originalVertexNormals || (d.__originalVertexNormals = []);
                var e = 0;
                for (a = d.vertexNormals.length; e < a; e++)
                    d.__originalVertexNormals[e] ? d.__originalVertexNormals[e].copy(d.vertexNormals[e]) : d.__originalVertexNormals[e] = d.vertexNormals[e].clone();
            }
            var f = new F;
            f.faces = this.faces;
            e = 0;
            for (a = this.morphTargets.length; e <
                a; e++) {
                if (!this.morphNormals[e]) {
                    this.morphNormals[e] = {};
                    this.morphNormals[e].faceNormals = [];
                    this.morphNormals[e].vertexNormals = [];
                    d = this.morphNormals[e].faceNormals;
                    var g = this.morphNormals[e].vertexNormals;
                    c = 0;
                    for (b = this.faces.length; c < b; c++) {
                        var h = new n;
                        var l = { a: new n, b: new n, c: new n };
                        d.push(h);
                        g.push(l);
                    }
                }
                g = this.morphNormals[e];
                f.vertices = this.morphTargets[e].vertices;
                f.computeFaceNormals();
                f.computeVertexNormals();
                c = 0;
                for (b = this.faces.length; c < b; c++)
                    d = this.faces[c], h = g.faceNormals[c], l = g.vertexNormals[c],
                        h.copy(d.normal), l.a.copy(d.vertexNormals[0]), l.b.copy(d.vertexNormals[1]), l.c.copy(d.vertexNormals[2]);
            }
            c = 0;
            for (b = this.faces.length; c < b; c++)
                d = this.faces[c], d.normal = d.__originalFaceNormal, d.vertexNormals = d.__originalVertexNormals;
        }, computeBoundingBox: function () { null === this.boundingBox && (this.boundingBox = new ab); this.boundingBox.setFromPoints(this.vertices); }, computeBoundingSphere: function () { null === this.boundingSphere && (this.boundingSphere = new nb); this.boundingSphere.setFromPoints(this.vertices); }, merge: function (a, b, c) {
            if (a && a.isGeometry) {
                var d, e = this.vertices.length, f = this.vertices, g = a.vertices, h = this.faces, l = a.faces, m = this.colors, k = a.colors;
                void 0 === c && (c = 0);
                void 0 !== b && (d = (new Y).getNormalMatrix(b));
                for (var n = 0, t = g.length; n < t; n++) {
                    var r = g[n].clone();
                    void 0 !== b && r.applyMatrix4(b);
                    f.push(r);
                }
                n = 0;
                for (t = k.length; n < t; n++)
                    m.push(k[n].clone());
                n = 0;
                for (t = l.length; n < t; n++) {
                    g = l[n];
                    var p = g.vertexNormals;
                    k = g.vertexColors;
                    m = new zc(g.a + e, g.b + e, g.c + e);
                    m.normal.copy(g.normal);
                    void 0 !== d && m.normal.applyMatrix3(d).normalize();
                    b = 0;
                    for (f = p.length; b < f; b++)
                        r = p[b].clone(), void 0 !== d && r.applyMatrix3(d).normalize(), m.vertexNormals.push(r);
                    m.color.copy(g.color);
                    b = 0;
                    for (f = k.length; b < f; b++)
                        r = k[b], m.vertexColors.push(r.clone());
                    m.materialIndex = g.materialIndex + c;
                    h.push(m);
                }
                n = 0;
                for (t = a.faceVertexUvs.length; n < t; n++)
                    for (c = a.faceVertexUvs[n], void 0 === this.faceVertexUvs[n] && (this.faceVertexUvs[n] = []), b = 0, f = c.length; b < f; b++) {
                        d = c[b];
                        e = [];
                        h = 0;
                        for (l = d.length; h < l; h++)
                            e.push(d[h].clone());
                        this.faceVertexUvs[n].push(e);
                    }
            }
            else
                console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a);
        }, mergeMesh: function (a) { a && a.isMesh ? (a.matrixAutoUpdate && a.updateMatrix(), this.merge(a.geometry, a.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a); }, mergeVertices: function () {
            var a = {}, b = [], c = [], d = Math.pow(10, 4), e;
            var f = 0;
            for (e = this.vertices.length; f < e; f++) {
                var g = this.vertices[f];
                g = Math.round(g.x * d) + "_" + Math.round(g.y * d) + "_" + Math.round(g.z * d);
                void 0 === a[g] ? (a[g] = f, b.push(this.vertices[f]), c[f] = b.length - 1) : c[f] = c[a[g]];
            }
            a = [];
            f = 0;
            for (e = this.faces.length; f < e; f++)
                for (d =
                    this.faces[f], d.a = c[d.a], d.b = c[d.b], d.c = c[d.c], d = [d.a, d.b, d.c], g = 0; 3 > g; g++)
                    if (d[g] === d[(g + 1) % 3]) {
                        a.push(f);
                        break;
                    }
            for (f = a.length - 1; 0 <= f; f--)
                for (d = a[f], this.faces.splice(d, 1), c = 0, e = this.faceVertexUvs.length; c < e; c++)
                    this.faceVertexUvs[c].splice(d, 1);
            f = this.vertices.length - b.length;
            this.vertices = b;
            return f;
        }, setFromPoints: function (a) { this.vertices = []; for (var b = 0, c = a.length; b < c; b++) {
            var d = a[b];
            this.vertices.push(new n(d.x, d.y, d.z || 0));
        } return this; }, sortFacesByMaterialIndex: function () {
            for (var a = this.faces, b = a.length, c = 0; c < b; c++)
                a[c]._id = c;
            a.sort(function (a, b) { return a.materialIndex - b.materialIndex; });
            var d = this.faceVertexUvs[0], e = this.faceVertexUvs[1], f, g;
            d && d.length === b && (f = []);
            e && e.length === b && (g = []);
            for (c = 0; c < b; c++) {
                var h = a[c]._id;
                f && f.push(d[h]);
                g && g.push(e[h]);
            }
            f && (this.faceVertexUvs[0] = f);
            g && (this.faceVertexUvs[1] = g);
        }, toJSON: function () {
            function a(a, b, c) { return c ? a | 1 << b : a & ~(1 << b); }
            function b(a) {
                var b = a.x.toString() + a.y.toString() + a.z.toString();
                if (void 0 !== k[b])
                    return k[b];
                k[b] = l.length / 3;
                l.push(a.x, a.y, a.z);
                return k[b];
            }
            function c(a) { var b = a.r.toString() + a.g.toString() + a.b.toString(); if (void 0 !== u[b])
                return u[b]; u[b] = n.length; n.push(a.getHex()); return u[b]; }
            function d(a) { var b = a.x.toString() + a.y.toString(); if (void 0 !== r[b])
                return r[b]; r[b] = t.length / 2; t.push(a.x, a.y); return r[b]; }
            var e = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } };
            e.uuid = this.uuid;
            e.type = this.type;
            "" !== this.name && (e.name = this.name);
            if (void 0 !== this.parameters) {
                var f = this.parameters, g;
                for (g in f)
                    void 0 !== f[g] &&
                        (e[g] = f[g]);
                return e;
            }
            f = [];
            for (g = 0; g < this.vertices.length; g++) {
                var h = this.vertices[g];
                f.push(h.x, h.y, h.z);
            }
            h = [];
            var l = [], k = {}, n = [], u = {}, t = [], r = {};
            for (g = 0; g < this.faces.length; g++) {
                var p = this.faces[g], v = void 0 !== this.faceVertexUvs[0][g], x = 0 < p.normal.length(), z = 0 < p.vertexNormals.length, y = 1 !== p.color.r || 1 !== p.color.g || 1 !== p.color.b, w = 0 < p.vertexColors.length, A = 0;
                A = a(A, 0, 0);
                A = a(A, 1, !0);
                A = a(A, 2, !1);
                A = a(A, 3, v);
                A = a(A, 4, x);
                A = a(A, 5, z);
                A = a(A, 6, y);
                A = a(A, 7, w);
                h.push(A);
                h.push(p.a, p.b, p.c);
                h.push(p.materialIndex);
                v && (v = this.faceVertexUvs[0][g], h.push(d(v[0]), d(v[1]), d(v[2])));
                x && h.push(b(p.normal));
                z && (x = p.vertexNormals, h.push(b(x[0]), b(x[1]), b(x[2])));
                y && h.push(c(p.color));
                w && (p = p.vertexColors, h.push(c(p[0]), c(p[1]), c(p[2])));
            }
            e.data = {};
            e.data.vertices = f;
            e.data.normals = l;
            0 < n.length && (e.data.colors = n);
            0 < t.length && (e.data.uvs = [t]);
            e.data.faces = h;
            return e;
        }, clone: function () { return (new F).copy(this); }, copy: function (a) {
            var b, c, d;
            this.vertices = [];
            this.colors = [];
            this.faces = [];
            this.faceVertexUvs = [[]];
            this.morphTargets =
                [];
            this.morphNormals = [];
            this.skinWeights = [];
            this.skinIndices = [];
            this.lineDistances = [];
            this.boundingSphere = this.boundingBox = null;
            this.name = a.name;
            var e = a.vertices;
            var f = 0;
            for (b = e.length; f < b; f++)
                this.vertices.push(e[f].clone());
            e = a.colors;
            f = 0;
            for (b = e.length; f < b; f++)
                this.colors.push(e[f].clone());
            e = a.faces;
            f = 0;
            for (b = e.length; f < b; f++)
                this.faces.push(e[f].clone());
            f = 0;
            for (b = a.faceVertexUvs.length; f < b; f++) {
                var g = a.faceVertexUvs[f];
                void 0 === this.faceVertexUvs[f] && (this.faceVertexUvs[f] = []);
                e = 0;
                for (c = g.length; e <
                    c; e++) {
                    var h = g[e], l = [];
                    var k = 0;
                    for (d = h.length; k < d; k++)
                        l.push(h[k].clone());
                    this.faceVertexUvs[f].push(l);
                }
            }
            k = a.morphTargets;
            f = 0;
            for (b = k.length; f < b; f++) {
                d = {};
                d.name = k[f].name;
                if (void 0 !== k[f].vertices)
                    for (d.vertices = [], e = 0, c = k[f].vertices.length; e < c; e++)
                        d.vertices.push(k[f].vertices[e].clone());
                if (void 0 !== k[f].normals)
                    for (d.normals = [], e = 0, c = k[f].normals.length; e < c; e++)
                        d.normals.push(k[f].normals[e].clone());
                this.morphTargets.push(d);
            }
            k = a.morphNormals;
            f = 0;
            for (b = k.length; f < b; f++) {
                d = {};
                if (void 0 !== k[f].vertexNormals)
                    for (d.vertexNormals =
                        [], e = 0, c = k[f].vertexNormals.length; e < c; e++)
                        g = k[f].vertexNormals[e], h = {}, h.a = g.a.clone(), h.b = g.b.clone(), h.c = g.c.clone(), d.vertexNormals.push(h);
                if (void 0 !== k[f].faceNormals)
                    for (d.faceNormals = [], e = 0, c = k[f].faceNormals.length; e < c; e++)
                        d.faceNormals.push(k[f].faceNormals[e].clone());
                this.morphNormals.push(d);
            }
            e = a.skinWeights;
            f = 0;
            for (b = e.length; f < b; f++)
                this.skinWeights.push(e[f].clone());
            e = a.skinIndices;
            f = 0;
            for (b = e.length; f < b; f++)
                this.skinIndices.push(e[f].clone());
            e = a.lineDistances;
            f = 0;
            for (b = e.length; f <
                b; f++)
                this.lineDistances.push(e[f]);
            f = a.boundingBox;
            null !== f && (this.boundingBox = f.clone());
            f = a.boundingSphere;
            null !== f && (this.boundingSphere = f.clone());
            this.elementsNeedUpdate = a.elementsNeedUpdate;
            this.verticesNeedUpdate = a.verticesNeedUpdate;
            this.uvsNeedUpdate = a.uvsNeedUpdate;
            this.normalsNeedUpdate = a.normalsNeedUpdate;
            this.colorsNeedUpdate = a.colorsNeedUpdate;
            this.lineDistancesNeedUpdate = a.lineDistancesNeedUpdate;
            this.groupsNeedUpdate = a.groupsNeedUpdate;
            return this;
        }, dispose: function () { this.dispatchEvent({ type: "dispose" }); } });
    var Zg = function (a) { function b(b, d, e, f, g, h) { a.call(this); this.type = "BoxGeometry"; this.parameters = { width: b, height: d, depth: e, widthSegments: f, heightSegments: g, depthSegments: h }; this.fromBufferGeometry(new Gd(b, d, e, f, g, h)); this.mergeVertices(); } a && (b.__proto__ = a); b.prototype = Object.create(a && a.prototype); return b.prototype.constructor = b; }(F), Gd = function (a) {
        function b(b, d, e, f, g, h) {
            function c(a, b, c, d, e, f, g, h, l, m, w) {
                var x = f / l, z = g / m, y = f / 2, A = g / 2, C = h / 2;
                g = l + 1;
                var B = m + 1, E = f = 0, D, F, G = new n;
                for (F = 0; F < B; F++) {
                    var H = F *
                        z - A;
                    for (D = 0; D < g; D++)
                        G[a] = (D * x - y) * d, G[b] = H * e, G[c] = C, u.push(G.x, G.y, G.z), G[a] = 0, G[b] = 0, G[c] = 0 < h ? 1 : -1, t.push(G.x, G.y, G.z), r.push(D / l), r.push(1 - F / m), f += 1;
                }
                for (F = 0; F < m; F++)
                    for (D = 0; D < l; D++)
                        a = p + D + g * (F + 1), b = p + (D + 1) + g * (F + 1), c = p + (D + 1) + g * F, q.push(p + D + g * F, a, c), q.push(a, b, c), E += 6;
                k.addGroup(v, E, w);
                v += E;
                p += f;
            }
            a.call(this);
            this.type = "BoxBufferGeometry";
            this.parameters = { width: b, height: d, depth: e, widthSegments: f, heightSegments: g, depthSegments: h };
            var k = this;
            b = b || 1;
            d = d || 1;
            e = e || 1;
            f = Math.floor(f) || 1;
            g = Math.floor(g) || 1;
            h =
                Math.floor(h) || 1;
            var q = [], u = [], t = [], r = [], p = 0, v = 0;
            c("z", "y", "x", -1, -1, e, d, b, h, g, 0);
            c("z", "y", "x", 1, -1, e, d, -b, h, g, 1);
            c("x", "z", "y", 1, 1, b, e, d, f, h, 2);
            c("x", "z", "y", 1, -1, b, e, -d, f, h, 3);
            c("x", "y", "z", 1, -1, b, d, e, f, g, 4);
            c("x", "y", "z", -1, -1, b, d, -e, f, g, 5);
            this.setIndex(q);
            this.addAttribute("position", new A(u, 3));
            this.addAttribute("normal", new A(t, 3));
            this.addAttribute("uv", new A(r, 2));
        }
        a && (b.__proto__ = a);
        b.prototype = Object.create(a && a.prototype);
        return b.prototype.constructor = b;
    }(E), Ak = { clone: Yb, merge: Da };
    ma.prototype =
        Object.create(M.prototype);
    ma.prototype.constructor = ma;
    ma.prototype.isShaderMaterial = !0;
    ma.prototype.copy = function (a) {
        M.prototype.copy.call(this, a);
        this.fragmentShader = a.fragmentShader;
        this.vertexShader = a.vertexShader;
        this.uniforms = Yb(a.uniforms);
        this.defines = Object.assign({}, a.defines);
        this.wireframe = a.wireframe;
        this.wireframeLinewidth = a.wireframeLinewidth;
        this.lights = a.lights;
        this.clipping = a.clipping;
        this.skinning = a.skinning;
        this.morphTargets = a.morphTargets;
        this.morphNormals = a.morphNormals;
        this.extensions =
            a.extensions;
        return this;
    };
    ma.prototype.toJSON = function (a) {
        var b = M.prototype.toJSON.call(this, a);
        b.uniforms = {};
        for (var c in this.uniforms) {
            var d = this.uniforms[c].value;
            b.uniforms[c] = d && d.isTexture ? { type: "t", value: d.toJSON(a).uuid } : d && d.isColor ? { type: "c", value: d.getHex() } : d && d.isVector2 ? { type: "v2", value: d.toArray() } : d && d.isVector3 ? { type: "v3", value: d.toArray() } : d && d.isVector4 ? { type: "v4", value: d.toArray() } : d && d.isMatrix3 ? { type: "m3", value: d.toArray() } : d && d.isMatrix4 ? { type: "m4", value: d.toArray() } : { value: d };
        }
        0 <
            Object.keys(this.defines).length && (b.defines = this.defines);
        b.vertexShader = this.vertexShader;
        b.fragmentShader = this.fragmentShader;
        a = {};
        for (var e in this.extensions)
            !0 === this.extensions[e] && (a[e] = !0);
        0 < Object.keys(a).length && (b.extensions = a);
        return b;
    };
    bb.prototype = Object.assign(Object.create(B.prototype), { constructor: bb, isCamera: !0, copy: function (a, b) {
            B.prototype.copy.call(this, a, b);
            this.matrixWorldInverse.copy(a.matrixWorldInverse);
            this.projectionMatrix.copy(a.projectionMatrix);
            this.projectionMatrixInverse.copy(a.projectionMatrixInverse);
            return this;
        }, getWorldDirection: function (a) { void 0 === a && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), a = new n); this.updateMatrixWorld(!0); var b = this.matrixWorld.elements; return a.set(-b[8], -b[9], -b[10]).normalize(); }, updateMatrixWorld: function (a) { B.prototype.updateMatrixWorld.call(this, a); this.matrixWorldInverse.getInverse(this.matrixWorld); }, clone: function () { return (new this.constructor).copy(this); } });
    na.prototype = Object.assign(Object.create(bb.prototype), { constructor: na,
        isPerspectiveCamera: !0, copy: function (a, b) { bb.prototype.copy.call(this, a, b); this.fov = a.fov; this.zoom = a.zoom; this.near = a.near; this.far = a.far; this.focus = a.focus; this.aspect = a.aspect; this.view = null === a.view ? null : Object.assign({}, a.view); this.filmGauge = a.filmGauge; this.filmOffset = a.filmOffset; return this; }, setFocalLength: function (a) { a = .5 * this.getFilmHeight() / a; this.fov = 2 * L.RAD2DEG * Math.atan(a); this.updateProjectionMatrix(); }, getFocalLength: function () {
            var a = Math.tan(.5 * L.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() /
                a;
        }, getEffectiveFOV: function () { return 2 * L.RAD2DEG * Math.atan(Math.tan(.5 * L.DEG2RAD * this.fov) / this.zoom); }, getFilmWidth: function () { return this.filmGauge * Math.min(this.aspect, 1); }, getFilmHeight: function () { return this.filmGauge / Math.max(this.aspect, 1); }, setViewOffset: function (a, b, c, d, e, f) {
            this.aspect = a / b;
            null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 });
            this.view.enabled = !0;
            this.view.fullWidth = a;
            this.view.fullHeight = b;
            this.view.offsetX = c;
            this.view.offsetY =
                d;
            this.view.width = e;
            this.view.height = f;
            this.updateProjectionMatrix();
        }, clearViewOffset: function () { null !== this.view && (this.view.enabled = !1); this.updateProjectionMatrix(); }, updateProjectionMatrix: function () {
            var a = this.near, b = a * Math.tan(.5 * L.DEG2RAD * this.fov) / this.zoom, c = 2 * b, d = this.aspect * c, e = -.5 * d, f = this.view;
            if (null !== this.view && this.view.enabled) {
                var g = f.fullWidth, h = f.fullHeight;
                e += f.offsetX * d / g;
                b -= f.offsetY * c / h;
                d *= f.width / g;
                c *= f.height / h;
            }
            f = this.filmOffset;
            0 !== f && (e += a * f / this.getFilmWidth());
            this.projectionMatrix.makePerspective(e, e + d, b, b - c, a, this.far);
            this.projectionMatrixInverse.getInverse(this.projectionMatrix);
        }, toJSON: function (a) { a = B.prototype.toJSON.call(this, a); a.object.fov = this.fov; a.object.zoom = this.zoom; a.object.near = this.near; a.object.far = this.far; a.object.focus = this.focus; a.object.aspect = this.aspect; null !== this.view && (a.object.view = Object.assign({}, this.view)); a.object.filmGauge = this.filmGauge; a.object.filmOffset = this.filmOffset; return a; } });
    Dc.prototype = Object.create(B.prototype);
    Dc.prototype.constructor = Dc;
    Ab.prototype =
        Object.create(la.prototype);
    Ab.prototype.constructor = Ab;
    Ab.prototype.isWebGLRenderTargetCube = !0;
    Ab.prototype.fromEquirectangularTexture = function (a, b) {
        this.texture.type = b.type;
        this.texture.format = b.format;
        this.texture.encoding = b.encoding;
        var c = new wd, d = new ma({ type: "CubemapFromEquirect", uniforms: Yb({ tEquirect: { value: null } }), vertexShader: "varying vec3 vWorldDirection;\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            fragmentShader: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}", side: 1, blending: 0 });
        d.uniforms.tEquirect.value = b;
        b = new ja(new Gd(5, 5, 5), d);
        c.add(b);
        d = new Dc(1, 10, 1);
        d.renderTarget = this;
        d.renderTarget.texture.name = "CubeCameraTexture";
        d.update(a, c);
        b.geometry.dispose();
        b.material.dispose();
        return this;
    };
    Zb.prototype = Object.create(W.prototype);
    Zb.prototype.constructor = Zb;
    Zb.prototype.isDataTexture = !0;
    var $g = new n, Bk = new n, Ck = new Y;
    Object.assign(cb.prototype, { isPlane: !0, set: function (a, b) { this.normal.copy(a); this.constant = b; return this; }, setComponents: function (a, b, c, d) { this.normal.set(a, b, c); this.constant = d; return this; }, setFromNormalAndCoplanarPoint: function (a, b) { this.normal.copy(a); this.constant = -b.dot(this.normal); return this; }, setFromCoplanarPoints: function (a, b, c) { b = $g.subVectors(c, b).cross(Bk.subVectors(a, b)).normalize(); this.setFromNormalAndCoplanarPoint(b, a); return this; }, clone: function () { return (new this.constructor).copy(this); }, copy: function (a) { this.normal.copy(a.normal); this.constant = a.constant; return this; }, normalize: function () { var a = 1 / this.normal.length(); this.normal.multiplyScalar(a); this.constant *= a; return this; }, negate: function () {
            this.constant *=
                -1;
            this.normal.negate();
            return this;
        }, distanceToPoint: function (a) { return this.normal.dot(a) + this.constant; }, distanceToSphere: function (a) { return this.distanceToPoint(a.center) - a.radius; }, projectPoint: function (a, b) { void 0 === b && (console.warn("THREE.Plane: .projectPoint() target is now required"), b = new n); return b.copy(this.normal).multiplyScalar(-this.distanceToPoint(a)).add(a); }, intersectLine: function (a, b) {
            void 0 === b && (console.warn("THREE.Plane: .intersectLine() target is now required"), b = new n);
            var c = a.delta($g), d = this.normal.dot(c);
            if (0 === d) {
                if (0 === this.distanceToPoint(a.start))
                    return b.copy(a.start);
            }
            else if (d = -(a.start.dot(this.normal) + this.constant) / d, !(0 > d || 1 < d))
                return b.copy(c).multiplyScalar(d).add(a.start);
        }, intersectsLine: function (a) { var b = this.distanceToPoint(a.start); a = this.distanceToPoint(a.end); return 0 > b && 0 < a || 0 > a && 0 < b; }, intersectsBox: function (a) { return a.intersectsPlane(this); }, intersectsSphere: function (a) { return a.intersectsPlane(this); }, coplanarPoint: function (a) {
            void 0 === a && (console.warn("THREE.Plane: .coplanarPoint() target is now required"),
                a = new n);
            return a.copy(this.normal).multiplyScalar(-this.constant);
        }, applyMatrix4: function (a, b) { b = b || Ck.getNormalMatrix(a); a = this.coplanarPoint($g).applyMatrix4(a); b = this.normal.applyMatrix3(b).normalize(); this.constant = -a.dot(b); return this; }, translate: function (a) { this.constant -= a.dot(this.normal); return this; }, equals: function (a) { return a.normal.equals(this.normal) && a.constant === this.constant; } });
    var td = new nb, zf = new n;
    Object.assign(Ed.prototype, { set: function (a, b, c, d, e, f) {
            var g = this.planes;
            g[0].copy(a);
            g[1].copy(b);
            g[2].copy(c);
            g[3].copy(d);
            g[4].copy(e);
            g[5].copy(f);
            return this;
        }, clone: function () { return (new this.constructor).copy(this); }, copy: function (a) { for (var b = this.planes, c = 0; 6 > c; c++)
            b[c].copy(a.planes[c]); return this; }, setFromMatrix: function (a) {
            var b = this.planes, c = a.elements;
            a = c[0];
            var d = c[1], e = c[2], f = c[3], g = c[4], h = c[5], l = c[6], k = c[7], n = c[8], u = c[9], t = c[10], r = c[11], p = c[12], v = c[13], x = c[14];
            c = c[15];
            b[0].setComponents(f - a, k - g, r - n, c - p).normalize();
            b[1].setComponents(f + a, k + g, r + n, c + p).normalize();
            b[2].setComponents(f +
                d, k + h, r + u, c + v).normalize();
            b[3].setComponents(f - d, k - h, r - u, c - v).normalize();
            b[4].setComponents(f - e, k - l, r - t, c - x).normalize();
            b[5].setComponents(f + e, k + l, r + t, c + x).normalize();
            return this;
        }, intersectsObject: function (a) { var b = a.geometry; null === b.boundingSphere && b.computeBoundingSphere(); td.copy(b.boundingSphere).applyMatrix4(a.matrixWorld); return this.intersectsSphere(td); }, intersectsSprite: function (a) { td.center.set(0, 0, 0); td.radius = .7071067811865476; td.applyMatrix4(a.matrixWorld); return this.intersectsSphere(td); },
        intersectsSphere: function (a) { var b = this.planes, c = a.center; a = -a.radius; for (var d = 0; 6 > d; d++)
            if (b[d].distanceToPoint(c) < a)
                return !1; return !0; }, intersectsBox: function (a) { for (var b = this.planes, c = 0; 6 > c; c++) {
            var d = b[c];
            zf.x = 0 < d.normal.x ? a.max.x : a.min.x;
            zf.y = 0 < d.normal.y ? a.max.y : a.min.y;
            zf.z = 0 < d.normal.z ? a.max.z : a.min.z;
            if (0 > d.distanceToPoint(zf))
                return !1;
        } return !0; }, containsPoint: function (a) { for (var b = this.planes, c = 0; 6 > c; c++)
            if (0 > b[c].distanceToPoint(a))
                return !1; return !0; } });
    var N = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
        color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif", common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
        defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\ttransformedNormal = mat3( instanceMatrix ) * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
        envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
        envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
        lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = saturate( clearcoat );\tmaterial.clearcoatRoughness = clamp( clearcoatRoughness, 0.04, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( pointLight.shadow, directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( spotLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( directionalLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 1.0 ? log2( vFragDepth ) * logDepthBufFC * 0.5 : gl_FragCoord.z;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
        map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif", map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
        normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
        normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\t#ifdef USE_TANGENT\n\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, normalScale, normalMap );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 normalScale, in sampler2D normalMap ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy *= normalScale;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tbool frontFacing = dot( cross( S, T ), N ) > 0.0;\n\t\t\tmapN.xy *= ( float( frontFacing ) * 2.0 - 1.0 );\n\t\t#else\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
        clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = clearcoatNormalScale * mapN.xy;\n\t\tclearcoatNormal = normalize( vTBN * mapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatNormalScale, clearcoatNormalMap );\n\t#endif\n#endif",
        clearcoat_normalmap_pars_fragment: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 encodeHalfRGBA ( vec2 v ) {\n\tvec4 encoded = vec4( 0.0 );\n\tconst vec2 offset = vec2( 1.0 / 255.0, 0.0 );\n\tencoded.xy = vec2( v.x, fract( v.x * 255.0 ) );\n\tencoded.xy = encoded.xy - ( encoded.yy * offset );\n\tencoded.zw = vec2( v.y, fract( v.y * 255.0 ) );\n\tencoded.zw = encoded.zw - ( encoded.ww * offset );\n\treturn encoded;\n}\nvec2 decodeHalfRGBA( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn decodeHalfRGBA( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = ( floor( uv * size - 0.5 ) + 0.5 ) * texelSize;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= all( bvec2( directionalLight.shadow, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= all( bvec2( spotLight.shadow, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= all( bvec2( pointLight.shadow, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
        uv_pars_fragment: "#ifdef USE_UV\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
        normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}", shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}" }, I = { common: { diffuse: { value: new H(15658734) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new Y }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null },
            normalScale: { value: new w(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 2.5E-4 }, fogNear: { value: 1 }, fogFar: { value: 2E3 }, fogColor: { value: new H(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {}, shadow: {}, shadowBias: {},
                    shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } },
            pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } } }, points: { diffuse: { value: new H(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, uvTransform: { value: new Y } }, sprite: { diffuse: { value: new H(15658734) }, opacity: { value: 1 }, center: { value: new w(.5, .5) }, rotation: { value: 0 }, map: { value: null }, uvTransform: { value: new Y } } }, db = { basic: { uniforms: Da([I.common, I.specularmap, I.envmap, I.aomap, I.lightmap, I.fog]), vertexShader: N.meshbasic_vert, fragmentShader: N.meshbasic_frag }, lambert: { uniforms: Da([I.common, I.specularmap, I.envmap, I.aomap, I.lightmap, I.emissivemap, I.fog, I.lights, { emissive: { value: new H(0) } }]), vertexShader: N.meshlambert_vert, fragmentShader: N.meshlambert_frag }, phong: { uniforms: Da([I.common, I.specularmap, I.envmap, I.aomap, I.lightmap, I.emissivemap, I.bumpmap, I.normalmap, I.displacementmap, I.gradientmap, I.fog, I.lights, { emissive: { value: new H(0) },
                    specular: { value: new H(1118481) }, shininess: { value: 30 } }]), vertexShader: N.meshphong_vert, fragmentShader: N.meshphong_frag }, standard: { uniforms: Da([I.common, I.envmap, I.aomap, I.lightmap, I.emissivemap, I.bumpmap, I.normalmap, I.displacementmap, I.roughnessmap, I.metalnessmap, I.fog, I.lights, { emissive: { value: new H(0) }, roughness: { value: .5 }, metalness: { value: .5 }, envMapIntensity: { value: 1 } }]), vertexShader: N.meshphysical_vert, fragmentShader: N.meshphysical_frag }, matcap: { uniforms: Da([I.common, I.bumpmap, I.normalmap, I.displacementmap,
                I.fog, { matcap: { value: null } }]), vertexShader: N.meshmatcap_vert, fragmentShader: N.meshmatcap_frag }, points: { uniforms: Da([I.points, I.fog]), vertexShader: N.points_vert, fragmentShader: N.points_frag }, dashed: { uniforms: Da([I.common, I.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: N.linedashed_vert, fragmentShader: N.linedashed_frag }, depth: { uniforms: Da([I.common, I.displacementmap]), vertexShader: N.depth_vert, fragmentShader: N.depth_frag }, normal: { uniforms: Da([I.common, I.bumpmap, I.normalmap,
                I.displacementmap, { opacity: { value: 1 } }]), vertexShader: N.normal_