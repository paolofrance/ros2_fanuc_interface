return dragDialog;
}
var prevDialogPos = { x: 0, y: 0 };	// Previous Dialog position.
var crntDialogPos = { x: 0, y: 0 };	// Current Dialog position.
// Mouse down on Dialog header.
function downDialogBox(evt) {
  var tempClient = getEventClient(evt);
  prevDialogPos.x = tempClient.x;
  prevDialogPos.y = tempClient.y;
  dragDialog = true;
}
// Mouse up on Dialog header.
function upDialogBox(evt) {
  dragDialog = false;
}
// Mouse move on Dialog header.
function moveDialogBox(evt) {
  var tempClient = getEventClient(evt);
  crntDialogPos.x = tempClient.x;
  crntDialogPos.y = tempClient.y;
  var diffX = crntDialogPos.x - prevDialogPos.x;
  var diffY = crntDialogPos.y - prevDialogPos.y;
  prevDialogPos.x = crntDialogPos.x;
  prevDialogPos.y = crntDialogPos.y;
  var crntT = evt.target.parentElement.offsetTop;
  var crntL = evt.target.parentElement.offsetLeft;
  var crntH = evt.target.parentElement.offsetHeight;
  var crntW = evt.target.parentElement.offsetWidth;
  var dlgTarget = (isScrModeEditorTab()) ? '#layoutarea' : '#pceditor';
  var maxT = $(dlgTarget).height();
  var maxL = $(dlgTarget).width();
  var scrlLeft = $(window).scrollLeft();
  var scrlTop = $(window).scrollTop();

  // adjust top edge
  crntT += diffY;
  if (crntT < 0) {
    crntT = 0;
  } else if ((crntT + crntH) > (maxT + scrlTop)) {
    crntT = ((maxT + scrlTop) - crntH);
  }
  // adjust left edge
  crntL += diffX;
  if (isScrModeEditorTab()) {    // when Tablet mode.
    // Left edge is dialog width - 60px, Right edge is maxL - 60px.
    if (crntL < (0 - (crntW - 60))) {
      crntL = (0 - (crntW - 60));
    } else if (crntL > (maxL - 60)) {
      crntL = maxL - 60;
    }
  } else {
    // Left edge is 0, Right edge is dialog width.
    if (crntL < 0) {
      crntL = 0;
    } else if ((crntL + crntW) > maxL) {
      crntL = (maxL - crntW);
    }
  }
  var dlgIdStr = '#' + evt.target.parentElement.id;
  $(dlgIdStr).css({ "left": crntL + "px", "top": crntT + "px" });
}
// Close Dialog
function closeDialog(dlgId) {
  $(dlgId).hide();
  $(dlgId).remove();
  removeOverlayScreen('dialog');
}

// Close Button
function closeButton(btnId) {
  $(btnId).hide();
  $(btnId).remove();
}

/* === Dialog setting === */
var defineDialog = {};
var defineButtonDlg = {};
$(function () {

  // Dialog process definition.
  defineDialog = {
    // Open dialog.
    open: function (btnId, dlgId, textResId, field) {
      var scrlLeft = $(window).scrollLeft();
      var scrlTop = $(window).scrollTop();
      configDialog(dlgId, textResId);
      if(dlgId == "#appleditordlg"){
        cleateApplEditor("appl");

      }
      if (btnId != null) {	// specified button id,
        $(btnId).blur();	// focus off
      }
      putOverlayScreen('dialog', 'forpopup');
      centeringDialogWindow(dlgId, scrlLeft, scrlTop);
      $(dlgId).fadeIn("middle");
      var textBox = $(dlgId).find('#prgname');
      if (textBox.length != 0) {
        $('#prgname').val("").focus();
      } else if (dlgId === "#edtalertdlg") { 
        document.activeElement.blur();
      }
      else {
        $('.btnok').focus();
      }
      $('.modaldlg').on('keydown', function (event) {
        if (event.which == KEYCODE_ENTER) {
          if (dlgId == '#selprogdlg') {
            var pgName = $('#progrow' + prevprogelem + '-2').text();
            if (pgName.length == 0) {
              return;
            }
          } else if(dlgId == '#appleditordlg'){
            return;
          }
          $('.btnok').click();
          return false;
        } else if (event.which == KEYCODE_ESC) {
          if ($('.btncancel').length > 0) {
            $('.btncancel').click();
          } else {
            $('.btnok').click();
          }
          return false;
        }
      });
      // Dialog button process
      // OK button / Yes button
      $('.btnok').off('click');
      $('.btnok').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        if (event.target.offsetParent == null) {
          return false;	// Discard the event of the button itself.
        }
        var dlgId = '#' + event.target.offsetParent.id;
        var saveParam = {}; // transfer parameter to callback func.
        var func = $(this).attr('call');  // Callback function called by the OK method.
        if ((dlgId == '#getprogdlg') ||		// Dialog is input program name
          (dlgId == '#getsvasprogdlg') ||	//           save as program
          (dlgId == '#getrenameprogdlg')) {	//       rename program
          // programTermination(dlgId);	// If the program is being executed, abort it.
          tooltipOff('prgform');
          var $prgname = $('#prgname');
          if ($prgname.val().length > 0) {	// input name (not empty)
            // Check program name just in case...
            if (checkProgName($prgname.val())) {
              var pgname = $prgname.val().toUpperCase();
              $prgname.val(pgname);
              closeDialog(dlgId);
              //generatenewprogram(pgname);
              if (dlgId == '#getprogdlg') {
                executeProgramMethod(func, pgname);
              } else if (dlgId == '#getsvasprogdlg') {
                saveParam['aftersave'] = AFTERPROC_SAVEASPG;
                saveParam['progname'] = pgname;
                executeProgramMethod(func, saveParam);
              } else if (dlgId == '#getrenameprogdlg') {
                saveParam['aftersave'] = AFTERPROC_RENAMEPG;
                saveParam['progname'] = pgname;
                executeProgramMethod(func, saveParam);
              }
              if ($('.fornoprog').length > 0 && !progLoadError) {
                npOverlayCleanUp();
                removeOverlayScreen('exec');
              }
            } else {	// Illegal program name error.
              tooltipOn('prgform', 'ilgName');
              $('.btnok').blur();
              $prgname.select().focus();
            }
          } else {	// no program name error...
            tooltipOn('prgform', 'emptyName');
            $('.btnok').blur();
            $prgname.focus();
          }
        } else if (dlgId == '#selchangedlg') {	// Select change program list
          closeDialog(dlgId);
          // Call the OK method.
          //var pgName = $('#programname').val();
          saveParam['aftersave'] = AFTERPROC_SELPROG;
          //saveParam['selprog'] = pgName;
          executeProgramMethod(func, saveParam);
        } else if (dlgId == '#progattrselchangedlg') {	// Select change program list
          closeDialog(dlgId);
          // Call the OK method.
          //var pgName = $('#programname').val();
          saveParam['aftersave'] = btnId;
          //saveParam['selprog'] = pgName;
          executeProgramMethod(func, saveParam);
        } else if (dlgId == '#selprogdlg') {	// Select program list
          var pgName = $('#progrow' + prevprogelem + '-2').text();
          isDispMoveToMoniDlg(pgName, undispDlg);
          closeDialog(dlgId);  

          function undispDlg(taskNUm, mainPrg) {
            top.irprogapi.setPauseConfDlgFlag(getCurrentProgram());
            pgName = mainPrg;
            loadFile(addProgramExtension(mainPrg), chkLoadFile);
          }
          function chkLoadFile(status) {
            if (status == IO_SUCCESS) {
              // programTermination(dlgId);	// If the program is being executed, abort it.
              $('#programname').val(pgName);
              // Call the OK method.
              selectProgamList(pgName);
            } else {
              defineDialog.open(null, '#failedSelerrdlg', 'dlgMsgSelectError');
            }
          }
        } else if (dlgId == '#confsvrundlg') {	// Save and Run program
          closeDialog(dlgId);
          // Call the OK method.
          saveParam['aftersave'] = AFTERPROC_RUNPROG;
          executeProgramMethod(func, saveParam);
        } else if (dlgId == '#confdeletedlg') {	// Delete position.
          closeDialog(dlgId);
          // Call the OK method.
          executeProgramMethod(func, "");
        } else if (dlgId == '#mltpastedlg') { //  Improper multi lines paste
          $('.btnok').blur();
          closeDialog(dlgId);
          executeProgramMethod(func, saveParam);
        } else if (dlgId == '#attralertdlg') {	// Alarm has occured.
          closeDialog(dlgId);
          // Call the OK method.
          executeProgramMethod(func, "");
        } else if (dlgId == '#confsaveprgdlg') {	// Save the program before edit the attr.
          closeDialog(dlgId);
          // Call the OK method.
          saveParam['aftersave'] = AFTERPROC_EDITATTR;
          executeProgramMethod(func, saveParam);
        } else if (dlgId == '#confsaveatterdlg') {	// save attribute
          closeDialog(dlgId);
          // Call the OK method.
          saveParam['aftersave'] = btnId;
          executeProgramMethod(func, saveParam);
        } else if (dlgId == '#progattrsavedlg') {	// save program
          closeDialog(dlgId);
          // Call the OK method.
          saveParam['aftersave'] = btnId;
          executeProgramMethod(func, saveParam);
        } else if (dlgId == '#applsaveerrdlg') {	// save program
          closeDialog(dlgId);
          // Call the OK method.
          removeOverlayScreen('applsaveerrdlg');
        } else if (dlgId == '#editattrdlg') {	// attr dialog
          var btnEvent = event;
          clickEditAttrDlgOkBtn(btnEvent);
        } else if (dlgId == '#pltcmdsaveerr') {
          closeDialog(dlgId);
          removeOverlayScreen('applsaveerrdlg');
        } else if (dlgId == '#appleditordlg'){ // save application data
          var changeText = applEditor.getValue();
          executeProgramMethod(func, changeText);
        } else {	// may be 'confalertdlg' or 'confnoticedlg'
          debug(DBGDUMP, 'Dialog OK : id=' + dlgId);
          closeDialog(dlgId);
          // Call the OK method.
          saveParam['aftersave'] = ((dlgId == '#confsavedlg') || (dlgId == '#confovwrdlg')) ?
            AFTERPROC_NONE : AFTERPROC_NEWOPEN;
          saveParam['newopen'] = (dlgId == '#confmodifieddlg') ? true : false;
          saveParam['textResId'] = textResId;
          $('.btnok').blur();
          executeProgramMethod(func, saveParam);
          if (isScrModeProgAttr()) {
            revertCurrentProg();
          }
        }
        return false;
      });
      // Cancel button
      $('.btncancel').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        if (event.target.offsetParent == null) {
          return false;
        }
        var dlgId = event.target.offsetParent.id;
        if(dlgId == 'editattrdlg') {
          var btnEvent = event;
          clickEditAttrDlgCancelBtn(btnEvent);
          return false;
        }

        tooltipOff('prgform');
        closeDialog('#' + dlgId);
        if (isScrModePcEditor() || isScrModeEditorTab()) {
          var editor = getPcEditor();
          var csrLine = editor.getCursor().line;
          var csrChar = editor.getCursor().ch;
          if (!isTablet) {
            var scrlLeft = $(window).scrollLeft();
            var scrlTop = $(window).scrollTop();
            editor.focus();
            // Return the scroll position to its before position.
            window.scrollTo(scrlLeft, scrlTop);
          }
          editor.setCursor({ line: csrLine, ch: csrChar });
          // Program editting flag resume...
          if ((dlgId == 'getprogdlg') ||
            (dlgId == 'selprogdlg') ||
            (dlgId == 'cautionprogdlg')) {	// Select program list
            resumePrgPosModify();
          }
        }
        // Call the Cancel method.
        var func = $(this).attr('call');    // Callback function called by the Cancel method.
        executeProgramMethod(func, "");
        return false;
      });
      // Title cancel button
      $('#dlgTtlCancel').off('click');
      $('#dlgTtlCancel').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        var dlgId = '#' + event.target.offsetParent.offsetParent.id;
        if (dlgId == '#posregconferr') { // [01/15/2019] position registor config error dialog close
          closeDialog(dlgId);
          paintMaskingCell();
        } else if ($('.btncancel').length > 0) {
          $('.btncancel').click();
        } else if ($('.btnng').length > 0) {	// [8/26/2018] Leakage of support
          $('.btnng').click();
        } else{
        $('.btnok').click();
        }
        return false;
      });
      // No button
      $('.btnng').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        var dlgId = event.target.offsetParent.id;
        if ((dlgId == 'selchangedlg') ||
          (dlgId == 'confmodifieddlg')) {
          setProgramModified(false);	// Reset editting flag
          setPositionModified(false);
        }
        tooltipOff('prgform');
        closeDialog('#' + dlgId);
        // Call the NG method.
        var saveParam = {};
        var func = $(this).attr('call');  // Callback function called by the NG method.
        if (dlgId == 'getprogdlg') { 	// Dialog is input program name
          executeProgramMethod(func, "");
        } else if (dlgId == 'confmodifieddlg') {	// Save NO... Confirm discard.
          var pgName = $('#programname').val();
          saveParam['aftersave'] = AFTERPROC_NEWOPEN;
          saveParam['selprog'] = pgName;
          saveParam['dialogid'] = 'confmodifieddlg';
          executeProgramMethod(func, saveParam);
        } else if (dlgId == 'selchangedlg') {	// Select change program list
          var pgName = $('#programname').val();
          saveParam['aftersave'] = AFTERPROC_SELPROG;
          saveParam['selprog'] = pgName;
          saveParam['dialogid'] = 'selchangedlg';
          executeProgramMethod(func, saveParam);
        } else if (dlgId == 'progattrselchangedlg') {	// Select change program list
          var pgName = getSelectProgram();
          saveParam['aftersave'] = btnId;
          saveParam['selprog'] = pgName;
          executeProgramMethod(func, saveParam);
        } else {
          if ((func != undefined) && (func.length > 0)) {
            executeProgramMethod(func, "");
          }
        }
        return false;
      });
      var prevprogelem = '0';
      $('.proglistelem').on('click', function (event) {
        var id = event.target.id;
        var idnum = parseInt(id.substr(7));
        if (prevprogelem != '0') {
          $('#progrow' + prevprogelem + '-1').css({ 'background': '#e1e7ec', 'color': '#000000' });
          $('#progrow' + prevprogelem + '-2').css({ 'background': '#e1e7ec', 'color': '#000000' });
          $('#progrow' + prevprogelem + '-3').css({ 'background': '#e1e7ec', 'color': '#000000' });
        }
        prevprogelem = idnum;
				/*
				var leftW =  $('#progrow' + idnum + '-1').prop('scrollWidth');
				var rightW = $('#progrow' + idnum + '-2').prop('scrollWidth');
				$('#progrow' + idnum).width(leftW + rightW);
				$('#progrow' + idnum + '-1').css({width: leftW});
				$('#progrow' + idnum + '-2').css({width: rightW});
				*/
        $('#progrow' + idnum + '-1').css({ 'background': '#0e6eb8', 'color': '#ffffff' });
        $('#progrow' + idnum + '-2').css({ 'background': '#0e6eb8', 'color': '#ffffff' });
        $('#progrow' + idnum + '-3').css({ 'background': '#0e6eb8', 'color': '#ffffff' });
        // When list is selected, enable OK button.
        $('#btnprgnameok').prop('disabled', false);
        $('#btnprgnameok').removeClass('okyesdis');
        $('#btnprgnameok').addClass('okyes');
      });
    }
  };

  // Button process definition.
  defineButtonDlg = {
    // Open Button.
    open: function (btnId) {
      configButton(btnId);
      $(btnId).fadeIn("middle");
    },

    // Close Button.
    close: function (btnId) {
      closeButton(btnId);
    }
  };

	/**
	* Define of require dialog process.
	**/

  /* Select program. */
  function selectProgamList(pgName) {
    var param = {};
    param['selprog'] = pgName;
    selectProgram(param);
    // 20181221 FSI clear overlay(for no program)
    if ($('.fornoprog').length > 0) {
      if(!progLoadError) {
        npOverlayCleanUp();
        removeOverlayScreen('exec');
      }
    }
    if ((isScrModePcEditor()) && (isMyIFrameIdPrim())) {
      protOverlaySetting();
      if (!isNotEditableWin()) {
        protOverlayManager(false);
      }
    }
  }

  /* Run button click */
  $('#playrun').on('click', function (event) {
    // Check whether TP is valid
    if (!isEnableOn()) {
      defineDialog.open('#posctrlmov', '#confalertdlg', 'dlgMsgEnableOff');	// Confirm TP disable
      return;
    }
    if (isAlarmOn()) {
      defineDialog.open('#playrun', '#confalertdlg', 'dlgMsgAlarmOn');	// Confirm alarm on
      return;
    }
    if ((isProgramModified()) || (isPositionModified()) ||
      // [4/10/2018] Add : When there is an editing program, it is judged that editing is in progress.
      (isExistEditProgramFile(getTempProgName(getCurrentProgram())))) {
      defineDialog.open('#playrun', '#confsvrundlg', '');	// Confirm save before run prog
      return;
    }
    // On request, to reload the program before execution.
    //runProgram();
    // [STEP8] If the program is paused, do not reload the program.
    var reflectprog = JSON.parse(JSON.stringify(statusProgramInfoTrans.getCurrentProgramSI()));
    if (reflectprog.stat == WATCHEXEC_PAUSED) {
      runProgram(); // Program execution. (prgwin)
      return;
    }
    if (holdingTransmitInfo == null) {
      holdingTransmitInfo = new TransProgramInfo();
    }
    holdingTransmitInfo.afterProc = AFTERPROC_RUNPROG;
    holdingTransmitInfo.modifyTime = false;
    reloadProgramFile(getProdProgName(getCurrentProgram()), reloadPrgCallback);	// fileio
  });

});

function checkProgName(val) {
  // Check program name just in case...
  var valid = (/^[A-Z_]([0-9A-Z_])*$/i).test(val);
  if(getCurrentLanguage() == 'jp') {
    valid = (/^[A-Zｦ-ﾟ_]([0-9A-Zｦ-ﾟ_])*$/i).test(val);
  }
  return valid;
}

/*
 * for Attr dialog button event.
 */
function checkByte(inputCom, byteNumber) {
  if (inputCom.val().sjisBytes() > byteNumber) {
    return false;
  } else {
    return true;
  }
}
function clickEditAttrDlgOkBtn(event) {
  tooltipOff("divapplLineSch");
  tooltipOff("divapplLineBound");
  tooltipOff('attrIptCmnt');
  tooltipOff('attrIptStack');
  var attrComment = $('#attrcomment');
  pgAttrComment = attrComment.val();
  if (attrComment.val().length > 0) {	// input comment (not empty)
    var valid = checkByte(attrComment, COMMENTMAX);
    if (!valid) { // Illegal program comment error.
      tooltipOn('attrIptCmnt', 'tipByteOver');
      $('#btneditattrok').blur();
      attrComment.select().focus();
      return false;
    }
  }
  var dlgId = event.target.offsetParent.id;
  var attrStackSize = $('#attrstacksize');
  pgAttrStackSize = Number(attrStackSize.val());
  var valid = true;
  if (attrStackSize.val().length == 0) {	// input stacksize (not empty)
    valid = false;
  } else {
    if ((pgAttrStackSize < STACKSIZEMIN) || (pgAttrStackSize > STACKSIZEMAX)) {	// Illegal program comment error.
      valid = false;
    }
  }
  if (!valid) {
    tooltipOn('attrIptStack', 'tipNumvalOver');
    $('#btneditattrok').blur();
    attrStackSize.select().focus();
    return false;
  }

  var currentSelect = $('#attrsubtype').text();

  switch (currentSelect) {
    case resources['attrSubNone']:
      pgSubType = top.MM_SUB_UNDEF_C;
      break;
    case resources['attrSubMacro']:
      pgSubType = top.MM_SUB_MACRO_C;
      break;
    case resources['attrSubCond']:
      pgSubType = top.MM_SUB_COND_C;
      break;
  }

  if (!ProgramApplManager.isLoadLineTrack() || (pgProtect == PROTECTON)) {
    $('#' + dlgId).hide();
    $('#' + dlgId).remove();
    removeOverlayScreen('editattr');
  } else {
    var editAppl = {};
    // LINE_TRACK_SCHEDULE_NUMBER
    editAppl[resources["lineschedule"]] = $('#applLineSch').val();
    var applSch = $('#applLineSch');
    if ((editAppl[resources["lineschedule"]] < 0) || (editAppl[resources["lineschedule"]] > 8)) {
      tooltipOn('divapplLineSch', 'tipScheduleOvar');
      $('#btneditattrok').blur();
      applSch.select().focus();
      return false;
    }
    if ((!isScrModeProgAttr()) && (editAppl[resources["lineschedule"]] != ProgramApplManager.getLineTrackingConfig("lineschedule"))) {
      clearDisplayRepPos(); // poswin
    }
    // LINE_TRACK_BOUNDARY_NUMBER
    editAppl[resources["lineboundary"]] = $('#applLineBound').val();
    var applBoun = $('#applLineBound');
    if ((editAppl[resources["lineboundary"]] < 0) || (editAppl[resources["lineboundary"]] > 10)) {
      tooltipOn('divapplLineBound', 'tipBoundryOvar');
      $('#btneditattrok').blur();
      applBoun.select().focus();
      return false;
    }
    var endCheck = "FALSE";
    if ($('#applLineEnd').prop('checked')) {
      endCheck = "TRUE";
    }
    editAppl[resources["lineend"]] = endCheck;
    ProgramApplManager.initEditApplData(); // fileio
    ProgramApplManager.setEditApplData(editAppl);  // fileio
  }
  if ((pgProtect == PROTECTON) && (isScrModePcEditor()) && (isMyIFrameIdPrim())) { // program protect editting in editor 
    protOverlayManager(true);
  } else if ((pgProtect == PROTECTOFF) && (isScrModePcEditor())) {
    if (!checkEditInvalid(true)) {
      protOverlayManager(false);
    }
  }
  saveattribute();
}

function clickEditAttrDlgCancelBtn(event) {
  var dlgId = event.target.offsetParent.id;
  //tooltipOff('prgform');
  $('#' + dlgId).hide();
  $('#' + dlgId).remove();
  removeOverlayScreen('editattr');
  if (!isScrModeProgAttr()) {
    var editor = getPcEditor();
    var csrLine = editor.getCursor().line;
    var csrChar = editor.getCursor().ch;
    var scrlLeft = $(window).scrollLeft();
    var scrlTop = $(window).scrollTop();
    editor.focus();
    // Return the scroll position to its before position.
    window.scrollTo(scrlLeft, scrlTop);
    editor.setCursor({ line: csrLine, ch: csrChar });
  }
}
/*
 * If the program is being executed, abort it.
 */
function programTermination(dlgId) {
  if ((dlgId == '#getprogdlg') ||		// Before create program (input program name),
    (dlgId == '#selprogdlg')) {	// open program.
    debug(DBGINFO, 'Program to abort. Same as [Stop] button click.');
    if (isMyIFrameIdPrim()) {
      var progNameList = [];
      for (var i = 0; i < programFileList.length; i++) {
        progNameList[i] = programFileList[i].name;
      }
      if (progNameList.indexOf(getCurrentProgram()) == -1) {
        stopProgram();	// prgwin (initialize each data)
        abortProgram(getCurrentProgram(), progTermCallback);	// io
      } else if (getCurrentProgram() !== "") {
        stopProgram();	// prgwin (initialize each data)
        var progMain = ProgramInfoManager.getMainProgInfo();
        if (progMain != undefined) {
          abortProgram(progMain.getProgName(), progTermCallback);	// io 
        } else {
          abortProgram(getCurrentProgram(), progTermCallback);	// io 
        }
        
      }
    }
  }
}
function progTermCallback(status) {
  debug((status === IO_SUCCESS) ? DBGINFO : DBGERROR, 'Program aborted. status[' + status + ']');
  // operation is especially none.
}

// Centering Dialog window
function centeringDialogWindow(dlgId, scrlLeft, scrlTop) {
  // Get content width/height
  var winX = $(window).innerWidth();
  var winY = $(window).innerHeight();
  var dlgHRatio;

  // Palletizing dialog
  if (isScrModeEditorTab() && isiPad && (dlgId == '#pltmainfrmdlg' || dlgId == '#pltsubfrmdlg')) {
    dlgHRatio = 2;
  } else if (dlgId == '#appleditordlg'){
    dlgHRatio = 1;
  } else {
    dlgHRatio = 1.25;
  }

  if (!dlgId.startsWith('#')) {
    dlgId = '#' + dlgId;
  }

  var dlgW = $(dlgId).outerWidth();
  var dlgH = $(dlgId).outerHeight();
  var winScrlX = document.body.scrollWidth;
  var winScrlY = document.body.scrollHeight;
  var posLeft = ((winX - dlgW) / 2) + scrlLeft;
  var posTop = (winY - (dlgH * dlgHRatio)) / 2;

  // Prevent keyboard from overlapping dialog for iPad.
  var ipadAdjustGroup = {
    '#editattrdlg': true
  };
  // Prevent keyboard from overlapping dialog for android.
  var androidAdjustGroup = {
    '#getprogdlg': true,
    '#getsvasprogdlg': true,
    '#getrenameprogdlg': true
  };
  var keybordHeight = 216;

  if (isiPad && ipadAdjustGroup[dlgId]) {
    // vertical screen
    if (winY > winX) {
      posTop = ((winX - keybordHeight) - dlgW) / 2;
    }
  } else if (isAndroid && androidAdjustGroup[dlgId]) {
    posTop = (((winY - keybordHeight) - (dlgH * 1.25)) / 2) + scrlTop;
  } else {
    //iOS can not get scroll amount. So, put it in the center.
    if (!isiPad) {
      // Adjust for Tablet or multi screen.
      if (winX < dlgW) {	// There is no space to center the dialog.
        if ((winScrlX - scrlLeft) > dlgW) {
          posLeft = scrlLeft;
        } else {
          posLeft = winScrlX - dlgW;
        }
      }
      if (winY < ((dlgH * 1.25) + scrlTop)) { // It corresponds to the case that scroll
        if ((winScrlY - scrlTop) > dlgH) {
          posTop = scrlTop;
        } else {
          posTop = winScrlY - dlgH;
        }
      }
    }
  }
  // Unify the positions of pltmainfrmdlg and pltsubfrmdlg.
  if ((isiPad) && (dlgId == '#pltmainfrmdlg' || dlgId == '#pltsubfrmdlg')) { // for iOS horizontal screen display
    posTop /= 2;
  }

  // If posTop is (-X px), the top of the dialog is hidden.
  if (posTop < 0) {
    posTop = 0;
  } else if(isScrModeProgAttr()) {
    if (winY > winX) {
      posTop = 300;
    } else {
      posTop = 100;
    }
  }

  $(dlgId).css({ "left": posLeft + "px", "top": posTop + "px" });

  //iOS can not set scroll amount.
  if (!isiPad) {
    window.scrollTo(scrlLeft, scrlTop);
  }
};

function moveButtonProc(btnId, btnConf) {
  var btnDef = null;
  var defId = -1;
  for (var i = 0; i < buttonDefinitionTable.length; i++) {
    btnDef = buttonDefinitionTable[i];
    var idStr = '#' + btnDef.id;
    if (idStr === btnId) { // target button?
      defId = i;
      break;
    }
  }
  switch (defId) {
    case 0:
      $('#programarea').css({
        'position': 'relative'
      });
      $('#programarea').append(btnConf);
      break;
    default:
      break;
  }
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
/*
 edit attribute value ON
 */
var PROTECTOFF = 1;
var PROTECTON = 2;
var PAUSEON = 7;
var MASK_IGNRPAUS = 0x7;
var ATTRTAB_PRTCTON = 6;
var COMMENTMAX = 16;
var STACKSIZEMIN = 300;
var STACKSIZEMAX = 4000;

/* === Dialog configure === */
function configEditAttr(dlgId, status) {
  var progInfo = ProgramInfoManager.getCurrentProgInfo();
  var currentAttr = progInfo.getEditAttrValue();
  // set initial value
  if (status == false) {
    pgAttrComment = currentAttr.COMMENT;
    pgAttrStackSize = currentAttr.STACK_SIZE;
    pgSubType = currentAttr.SUBTYPE;
    pgPause = currentAttr.PAUSE;
    pgProtect = currentAttr.PROTECT;
    pgMotionGroup = currentAttr.MTNGRP;
  }
  // Make dialog
  var dlgIdStr = dlgId.substr(1);
  var dlgConf = $('<div>',
    { id: dlgIdStr, 'class': 'modaldlg' });
  var modalH = '460px';
  if (isScrModeProgAttr()) {
    modalH = '560px';
  }
  dlgConf.css({ 'width': modalH });
  var dlgTtl = $('<div>',
    { id: dlgIdStr + 'Ttl', 'class': 'dlgtitlebar' });
  var ttlArea = $('<label>', { 'class': 'dlgTtlText' });
  ttlArea.html(resources['toolBtnAttribute']);
  dlgTtl.append(ttlArea);
  dlgConf.append(dlgTtl);
  var dlgMsg = $('<p>');
  var attrTblFlm = $('<div>', { 'class': 'dlgtblflm' });
  var attrTable = $('<table>', { rules: 'none', 'class': 'dlgattrtable' });
  //Editattribute Comment
  var attrTr = $('<tr>');
  var attrTd = $('<td>', { 'class': 'dlgattrtitle' });
  attrTd.html(resources['dlgAttrComment']);
  attrTr.append(attrTd);
  attrTd = $('<td>');
  var inputForm = $('<div>', { 'id': 'attrIptCmnt' });
  var attrInput = $('<input>', { 'type': 'text', 'id': 'attrcomment', 'class': 'dlgiptcommbox', 'maxlength': 16, 'tabindex': 1 });
  attrInput.val(currentAttr.COMMENT);
  if (currentAttr.PROTECT == PROTECTON) {
    attrInput.prop('disabled', true);
  }
  inputForm.append(attrInput);
  attrTd.append(inputForm);
  attrTr.append(attrTd);
  attrTable.append(attrTr);
  //Editattribute Stacksize
  attrTr = $('<tr>');
  attrTd = $('<td>', { 'class': 'dlgattrtitle' });
  attrTd.html(resources['dlgAttrStack']);
  attrTr.append(attrTd);
  attrTd = $('<td>');
  inputForm = $('<div>', { 'id': 'attrIptStack' });
  attrInput = $('<input>', { 'type': 'text', 'id': 'attrstacksize', 'class': 'dlgstksize', 'tabindex': 2 });
  var currentStack = currentAttr.STACK_SIZE == 0 ? 500 : currentAttr.STACK_SIZE;
  attrInput.val(currentStack);
  if (currentAttr.PROTECT == PROTECTON) {
    attrInput.prop('disabled', true);
  }
  inputForm.append(attrInput);
  attrTd.append(inputForm);
  attrTr.append(attrTd);
  attrTable.append(attrTr);
  //Editattribute Subtype
  attrTr = $('<tr>');
  attrTd = $('<td>', { 'class': 'dlgattrtitle' });
  attrTd.html(resources['dlgAttrSubtype']);
  attrTr.append(attrTd);
  attrTd = $('<td>');

  var slctTextObj = {};
  slctTextObj[top.MM_SUB_UNDEF_C] = resources['attrSubNone'];
  slctTextObj[top.MM_SUB_MACRO_C] = resources['attrSubMacro'];
  slctTextObj[top.MM_SUB_COND_C] = resources['attrSubCond'];

  var attrSelect = $('<div>', { 'id': 'attrsubtype', 'class': 'dlgslctbox', 'tabindex': 3 });
  var attrSelBtn = $('<div>', { 'id': 'dlgselbtn', 'class': 'dlgselbtn' });
  var selIconLink = 'select_icon.png';
  if(isScrModeProgAttr()) {
    selIconLink = 'select_icon_large.png';
  }
  var attrSelIcn = $('<img>', { 'id': 'dlgselimg', 'class': 'dlgselimg', 'src': 'images/' + selIconLink });

  if (currentAttr.PROTECT == PROTECTON) {
    attrSelect.addClass('attrdisable');
    attrSelIcn.attr('src', 'images/select_icon_disable.png');
  }

  attrSelect.text(slctTextObj[currentAttr.SUBTYPE]);
  attrSelBtn.append(attrSelIcn);
  attrSelect.append(attrSelBtn);

  attrTd.append(attrSelect);
  attrTr.append(attrTd);
  attrTable.append(attrTr);
  //Editattribute Motion group
  attrTr = $('<tr>');
  attrTd = $('<td>', { 'class': 'dlgattrtitle' });
  attrTd.html(resources['dlgAttrMtnGrp']);
  if (getCurrentLanguage() == LANG_JP) {
    attrTd.css({ 'letter-spacing': '-0.15em' });
  }
  attrTr.append(attrTd);
  attrTd = $('<td>');
  maxGroupCount = getGroupCount();	// Limit on the number of groups.
  if (!isScrModeProgAttr()) {
    posRecordCount = getValidRowCount();	// poswin:
  }
  var grpChecked = false;
  var grpMasked = false;
  var grpChkCnt = getGroupCheckCount();
  for (var i = 0; i < maxGroupCount; i++) {
    // Checkboxes force a line break every four.
    // Start of line.
    if (i % 4 == 0) { // Examples : 1st & 5th
      var attrDiv = $('<div class="dlgChBox" style="height: 34px">');
    }
    var attrGrp = $('<input>', {
      'type': 'checkbox', 'id': 'attrGrp' + (i + 1), 'name': 'attrmtngrp',
      'class': 'chkboxbk', 'value': 'grp' + (i + 1)
    });
    if ((pgMotionGroup & (1 << i)) != 0) {
      attrGrp.attr({ 'checked': 'checked' });
      grpChecked = true;
    }
    var attrLbl = $('<label>', { 'for': 'attrGrp' + (i + 1), 'id': 'lblGrp' + (i + 1), 'class': 'chkboxlg' });
    attrLbl.html('' + (i + 1));
    if ((currentAttr.PROTECT == PROTECTON) || 	// Protection on -> Disable  or
      ((progInfo.isExistProgPosition()) || (posRecordCount > 0)) || // Position data is exist and checked group -> Disable or
      (currentAttr.SUBTYPE == top.MM_SUB_COND_C)) { // Subtype is Condition -> Disable
      attrGrp.prop('disabled', true);
      attrLbl.prop('disabled', true);
      attrLbl.css({ 'opacity': '0.5' });
      grpMasked = true;
    }
    $(attrLbl).css('top','8px');
    attrDiv.append(attrGrp);
    attrDiv.append(attrLbl);
    // End of line.
    if ((i % 4 == 3) || (i == maxGroupCount - 1)) { // Examples : 4th & number of checkboxes
      attrTd.append(attrDiv);
    }
  }
  attrTr.append(attrTd);
  attrTable.append(attrTr);
  //Editattribute Pause
  attrTr = $('<tr>');
  attrTd = $('<td>', { 'class': 'dlgattrtitle' });
  attrTd.html(resources['dlgAttrPause']);
  attrTr.append(attrTd);
  attrTd = $('<td>');
  var attrPouseOn = 'dlgpousebtnoff attrleftbtn';
  var attrPouseOff = 'dlgpousebtnon attrrightbtn';
  if ((currentAttr.PAUSE & MASK_IGNRPAUS) == PAUSEON) {
    attrPouseOn = 'dlgpousebtnon attrleftbtn';
    attrPouseOff = 'dlgpousebtnoff attrrightbtn';
  }
  var attrButton = $('<button>');
  attrButton.attr({ 'type': 'button', 'id': 'attrpauseon', 'class': attrPouseOn, 'tabindex': 4 });
  attrButton.html(resources['attrBtnOn']);
  if (currentAttr.PROTECT == PROTECTON) {
    attrButton.prop('disabled', true);
    attrButton.addClass('attrdisable');
  }
  attrTd.append(attrButton);
  attrButton = $('<button>');
  attrButton.attr({ 'type': 'button', 'id': 'attrpauseoff', 'class': attrPouseOff, 'tabindex': 5 });
  attrButton.html(resources['attrBtnOff']);
  if (currentAttr.PROTECT == PROTECTON) {
    attrButton.prop('disabled', true);
    attrButton.addClass('attrdisable');
  }
  attrTd.append(attrButton);
  attrTr.append(attrTd);
  attrTable.append(attrTr);
  //Editattribute Protect
  attrTr = $('<tr>');
  attrTd = $('<td>', { 'class': 'dlgattrtitle' });
  attrTd.html(resources['dlgAttrProtect']);
  attrTr.append(attrTd);
  attrTd = $('<td>');
  var attrProtectOn = 'dlgprotectbtnoff attrleftbtn';
  var attrProtectOff = 'dlgprotectbtnon attrrightbtn';
  if (currentAttr.PROTECT == PROTECTON) {
    attrProtectOn = 'dlgprotectbtnon attrleftbtn';
    attrProtectOff = 'dlgprotectbtnoff attrrightbtn';
  }
  attrButton = $('<button>');
  attrButton.attr({ 'type': 'button', 'id': 'attrprotecton', 'class': attrProtectOn, 'tabindex': 6 });
  attrButton.html(resources['attrBtnOn']);
  attrTd.append(attrButton);
  attrButton = $('<button>');
  attrButton.attr({ 'type': 'button', 'id': 'attrprotectoff', 'class': attrProtectOff, 'tabindex': 7 });
  attrButton.html(resources['attrBtnOff']);
  attrTd.append(attrButton);
  attrTr.append(attrTd);
  attrTable.append(attrTr);
  attrTblFlm.append(attrTable);

  //==============
  //Line Tracking
  console.log("create attribute appl flg :", ProgramApplManager.isLoadLineTrack());
  if (ProgramApplManager.isLoadLineTrack()) {
    // SCHEDULE_NUMBER
    var applTable = $('<table>', { rules: 'none', 'class': 'dlgappltable' });

    var attrTr = $('<tr>');
    var attrTd = $('<td>', { 'class': 'dlgappltitle', "align": "left" });
    attrTd.html(convertHanZenkaku(resources["applTitle"]));
    attrTd.css({ "font-weight": "bold" });
    attrTr.append(attrTd);
    applTable.append(attrTr);

    var attrTr = $('<tr>');
    var attrTd = $('<td>', { 'class': 'dlgappltitle', "align": "left" });
    attrTd.html("LINE_TRACK");
    attrTr.append(attrTd);
    applTable.append(attrTr);

    var attrTr = $('<tr>');
    var attrTd = $('<td>', { 'class': 'dlgappltitle', "align": "left" });
    attrTd.html(convertHanZenkaku(resources["lineschedule"]));
    attrTr.append(attrTd);
    attrTd = $('<td>');
    var inputForm = $('<div>', { 'id': 'divapplLineSch' });
    var attrInput = $('<input>', { 'type': 'text', 'id': 'applLineSch', 'class': 'dlgiptcommbox', 'maxlength': 1, 'tabindex': 1 });
    attrInput.val(ProgramApplManager.getLineTrackingConfig("lineschedule"));
    inputForm.append(attrInput);
    attrTd.append(inputForm);
    attrTr.append(attrTd);
    applTable.append(attrTr);

    // BOUNDARY_NUMBER
    var attrTr = $('<tr>');
    var attrTd = $('<td>', { 'class': 'dlgappltitle' });
    attrTd.html(convertHanZenkaku(resources["lineboundary"]));
    attrTr.append(attrTd);
    attrTd = $('<td>');
    var inputForm = $('<div>', { 'id': 'divapplLineBound' });
    var attrInput = $('<input>', { 'type': 'text', 'id': 'applLineBound', 'class': 'dlgiptcommbox', 'maxlength': 2, 'tabindex': 1 });
    attrInput.val(ProgramApplManager.getLineTrackingConfig("lineboundary"));
    inputForm.append(attrInput);
    attrTd.append(inputForm);
    attrTr.append(attrTd);
    applTable.append(attrTr);

    // CONTINUE_TRACK_AT_PROG_END
    var attrTr = $('<tr>');
    var attrTd = $('<td>', { 'class': 'dlgappltitle' });
    attrTd.html(convertHanZenkaku(resources["lineend"]));
    attrTr.append(attrTd);
    attrTd = $('<td>');
    var inputForm = $('<div>', { 'id': 'divapplLineEnd' });

    var attrGrp = $('<input>', {
      'type': 'checkbox', 'id': 'applLineEnd', 'name': 'LineEnd',
      'class': 'chkboxbk', 'value': 'LineEnd1'
    });
    if (ProgramApplManager.getLineTrackingConfig("lineend") == "TRUE") {
      attrGrp.attr({ 'checked': 'checked' });
    }
    var attrLbl = $('<label>', { 'for': 'applLineEnd', 'id': 'LineEnd1', 'class': 'chkboxlg' });
    attrLbl.html('');
    attrTd.append(attrGrp);
    attrTd.append(attrLbl);

    attrTr.append(attrTd);
    applTable.append(attrTr);
  }

  //all append
  attrTblFlm.append(applTable);
  dlgConf.append(attrTblFlm);

  var dlgBtn = $('<div align="center" style="clear: both;">');
  //OK
  var btnClass = "dlgbutton okyes btnok";
  var btnObj = $('<button>',
    { type: 'button', id: 'btneditattrok', 'class': btnClass, value: resources['dlgBtnOk'], 'tabindex': 8 });
  btnObj.html(resources['dlgBtnOk']);
  dlgBtn.append(btnObj);
  //cancell
  var btnClass = "dlgbutton nocancel btncancel";
  var btnObj = $('<button>',
    { type: 'button', id: 'btneditattrcancel', 'class': btnClass, value: resources['dlgBtncancel'], 'tabindex': 9 });
  btnObj.html(resources['dlgBtnCancel']);
  dlgBtn.append(btnObj);

  dlgConf.append(dlgBtn);
  var attrFrm = $('<form>', { 'id': 'dlgattrform' });
  attrFrm.append(dlgConf);
  $('body').append(attrFrm);
}
// Get Group Mask Check count.
function getGroupCheckCount() {
  var grpChkCnt = 0;
  for (var grpNum = 0; grpNum < maxGroupCount; grpNum++) {
    if (((pgMotionGroup >> grpNum) & 0x1) == 1) {	// check on
      grpChkCnt++;
    }
  }
  return grpChkCnt;
}

// Definition of usage variables.
var maxGroupCount = 0;
var posRecordCount = 0;
var editAttrDlg = {};
var pgAttrComment = "";
var pgAttrStackSize = 0;
var pgSubType = 0;
var pgPause = 0;
var pgProtect = PROTECTOFF;
var pgMotionGroup = 0;
var attrBtnOnColor = '#0E6EB8';  // button on color
var attrBtnOffColor = isScrModeProgAttr() ? '#696969' : '#67727E';  // butuon off color
var stackInputFlag = false; // input data in stack size area

function saveattribute() {
  var correctProgName = getCurrentProgram();
  var crntAttr = {};
  crntAttr.COMMENT = dispAttrDlgFlag ? pgAttrComment : "";
  crntAttr.STACK_SIZE = dispAttrDlgFlag ? pgAttrStackSize : 0;
  crntAttr.SUBTYPE = dispAttrDlgFlag ? pgSubType : 0;
  crntAttr.PAUSE = dispAttrDlgFlag ? pgPause : 0;
  crntAttr.PROTECT = dispAttrDlgFlag ? pgProtect : PROTECTOFF;
  crntAttr.MTNGRP = dispAttrDlgFlag ? pgMotionGroup : 0;
  dispAttrDlgFlag = true;
  saveProgramAttribute(correctProgName, crntAttr, stackInputFlag, afterSetAttribute);
}
function afterSetAttribute(progname) {
  if (!isScrModeProgAttr()) {
    var editor = getPcEditor();
    var csrLine = editor.getCursor().line;
    var csrChar = editor.getCursor().ch;
    editor.focus();
    editor.setCursor({ line: csrLine, ch: csrChar });
    makeDisplayRepPos(w2ui[getSelPosTblName()].records, getSelPosTblKind()); // poswin
    if (isProgramNameTemporary(progname)) {
      var saveParam = {};
      saveParam['aftersave'] = '';
      saveProgram(saveParam);
    }
  }
  if (isScrModeProgAttr()) {
    jmpEditPage();
    return;
  }
}
function saveAttributeErr() {
  debug(DBGINFO, 'save attribute Error');
  editAttrDlg.open('#fileeditattr', '#editattrdlg', true);		// Get program attribute
}
$(function () {
  // file attribute reg exp checker
  // Dialog process definition.
  editAttrDlg = {
    // Open dialog.
    open: function (btnId, dlgId, status) {
      var scrlLeft = $(window).scrollLeft();
      var scrlTop = $(window).scrollTop();
      configEditAttr(dlgId, status);
      stackInputFlag = false;
      if (btnId != null) {	// specified button id,
        $(btnId).blur();	// focus off
      }
      putOverlayScreen('editattr', 'forpopup');
      centeringDialogWindow(dlgId, scrlLeft, scrlTop);	// dialog.js
      $(dlgId).fadeIn("middle");
      var textBox = $(dlgId).find('#prgeditattr');
      if (textBox.length != 0) {
        $('#prgeditattr').val("").focus();
      } else {
        $('.btnok').focus();
      }
      $('.modaldlg').on('keydown', function (event) {
        if (event.which == KEYCODE_ENTER) {
          var targetId = event.target.id;
          if (targetId == 'attrcomment') {
            $('#attrstacksize').trigger('focus');
          } else if (targetId == 'attrstacksize') {
            $('#attrsubtype').trigger('focus');
          } else if (targetId == 'attrsubtype') {
            $('#attrsubtype').trigger('click');
          } else {
            $('.btnok').click();
          }
          return false;
        } else if (event.which == KEYCODE_TAB) {
          var elem = $('#dlgattrform')[0];
          var tabLeng = elem.length;
          var nxttabidx = event.target.tabIndex;
          nxttabidx = (event.shiftKey) ? nxttabidx - 1 : nxttabidx + 1;
          if (pgProtect == PROTECTON) {	// Protect on
            if (nxttabidx > tabLeng) {
              nxttabidx = ATTRTAB_PRTCTON;
            } else if (nxttabidx < ATTRTAB_PRTCTON) {
              nxttabidx = tabLeng;
            }
          } else {
            if (nxttabidx > tabLeng) {
              nxttabidx = 1;
            } else if (nxttabidx <= 0) {
              nxttabidx = tabLeng;
            }
          }
          elem[nxttabidx - 1].focus();
          return false;
        } else if (event.which == KEYCODE_ESC) {
          $('.btncancel').click();
          return false;
        }
      });
      // Dialog button process
      // OK button / Yes button
      $('#btneditattrok').on('click', function (event) {
        if (event.target.offsetParent == null) {
          return false;	// Discard the event of the button itself.
        }
        var btnEvent = event;
        clickEditAttrDlgOkBtn(btnEvent);
        return false;
      });
      // Cancel button
      $('#btneditattrcancel').on('click', function (event) {
        if (event.target.offsetParent == null) {
          return false;
        }
        var btnEvent = event;
        clickEditAttrDlgCancelBtn(btnEvent);
        return false;
      });
      $('#attrstacksize').on('input', function (event) {
        stackInputFlag = true;
        tooltipOff('attrIptStack');
        var inputNum = $('#attrstacksize').val();
        inputNum = inputNum.replace(/[^0-9]+/i, '');	// number only
        $('#attrstacksize').val(inputNum);
      });
      $('#attrcomment').on('input', function (event) {
        tooltipOff('attrIptCmnt');
      });
      $('input[name="attrmtngrp"]').on('change', function (evt) {
        pgMotionGroup = 0;
        $('input[name="attrmtngrp"]:checked').each(function (i) {
          var chkValStr = $(this).val();
          var chkValue = parseInt(chkValStr.substr('grp'.length));
          pgMotionGroup |= 1 << (chkValue - 1);
        });
        // if position data is exist and check group is last 1... to disable
        var grpNum = 1;
        var grpCheck = pgMotionGroup;
        var grpChkCnt = getGroupCheckCount();
        var progInfo = ProgramInfoManager.getCurrentProgInfo();
        for (var grpNum = 0; grpNum < maxGroupCount; grpNum++) {
          var checkStat = false;
          var checkOpcty = '1.0';
          if (((grpCheck >> grpNum) & 0x1) == 1) {	// check on
            if (progInfo.isExistProgPosition()) {	// Position data is exist.
              checkStat = true;
              checkOpcty = '0.5';
            }
          }
          $('#attrGrp' + (grpNum + 1)).prop('disabled', checkStat);
          $('#lblGrp' + (grpNum + 1)).prop('disabled', checkStat);
          $('#lblGrp' + (grpNum + 1)).css({ 'opacity': checkOpcty });
        }
				/*
				if (pgMotionGroup > 0) {	// Either group is checked.
					$('#attrpauseon').prop('disabled', true);
					$('#attrpauseon').addClass('attrdisable');
					$('#attrpauseoff').prop('disabled', true);
					$('#attrpauseoff').addClass('attrdisable');
				} else {*/
        $('#attrpauseon').prop('disabled', false);
        $('#attrpauseon').removeClass('attrdisable');
        $('#attrpauseoff').prop('disabled', false);
        $('#attrpauseoff').removeClass('attrdisable');
        //}
      });
      $('#attrsubtype').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        var slcMenu = $('#slcmenulist');
        var slcBtn = $('#dlgselbtn');
        var currentSelect;

        if ($(event.currentTarget).hasClass('attrdisable')) {
          event.stopPropagation();
          return false;
        }

        if (slcMenu.length) {
          var target = $(event.target);

          if (target.hasClass('slcmenu')) {
            currentSelect = target.text();
            $('#attrsubtype').text(currentSelect);
            $('#attrsubtype').append(slcBtn);
          }
          setCheckStat(currentSelect);
          if(!isScrModeProgAttr()) $('#dlgselimg').attr('src', 'images/select_icon.png');
          slcMenu.remove();
        } else {
          if(!isScrModeProgAttr()) $('#dlgselimg').attr('src', 'images/select_icon_open.png');
          var slctTextObj = {
            none: resources['attrSubNone'],
            macro: resources['attrSubMacro'],
            
          };
          var progdata = ProgramInfoManager.getSpecifiedProgInfo(getTempProgName(getCurrentProgram()));
          var progInfo = ProgramInfoManager.getCurrentProgInfo();
          if ((progdata.getMnemonicLineCount() > 0) || // Program line is exist -> Disable(Condition) or
            (posRecordCount > 0) || (progInfo.isExistProgPosition())) { // Position data is exist -> Disable(Condition)
          } else {
            slctTextObj['resouce'] = resources['attrSubCond'];
          }
          slcMenu = $('<div>', { 'id': 'slcmenulist', 'class': 'slcmenulist' });
          for (var key in slctTextObj) {
            var value = slctTextObj[key];
            var slcitem = $('<div>', { 'id': 'selcmenu' + key, 'class': 'slcmenu' });
            slcitem.html(value);
            currentSelect = $('#attrsubtype').text();
            if (value == currentSelect) {
              slcitem.css('background-color', '#0e6eb8');
              slcitem.css('color', '#ffffff');
            }
            if (key == 'none') {
              slcitem.addClass('selcmenutop');
            }
            if (key == 'resouce') {
              slcitem.addClass('selcmenuend');
            }
            slcMenu.append(slcitem);
          }
          $('#attrsubtype').append(slcMenu);
        }
        event.stopPropagation();
        return false;
      });
      $('#attrpauseon').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        // When list is selected, enable OK button.
        $('#attrpauseon').css({ 'background-color': attrBtnOnColor });
        $('#attrpauseoff').css({ 'background-color': attrBtnOffColor });
        pgPause = PAUSEON;
      });
      $('#attrpauseoff').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        // When list is selected, enable OK button.
        $('#attrpauseoff').css({ 'background-color': attrBtnOnColor });
        $('#attrpauseon').css({ 'background-color': attrBtnOffColor });
        pgPause = 0;
      });
      $('#attrprotecton').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        // When list is selected, enable OK button.
        $('#attrprotecton').css({ 'background-color': attrBtnOnColor });
        $('#attrprotectoff').css({ 'background-color': attrBtnOffColor });
        $('#attrpauseon').prop('disabled', true);
        $('#attrpauseon').addClass('attrdisable');
        $('#attrpauseoff').prop('disabled', true);
        $('#attrpauseoff').addClass('attrdisable');
        $('#attrcomment').prop('disabled', true);
        $('#attrstacksize').prop('disabled', true);
        $('#attrsubtype').addClass('attrdisable');
        if(!isScrModeProgAttr()) $('#dlgselimg').attr('src', 'images/select_icon_disable.png');
        $('#attrGrp1').prop('disabled', true);
        $('#lblGrp1').prop('disabled', true);
        $('#lblGrp1').css({ 'opacity': '0.5' });
        $('#applLineEnd').prop('disabled', true);
        $('#LineEnd1').prop('disabled', true);
        $('#LineEnd1').css({ 'opacity': '0.5' });
        pgProtect = PROTECTON;
      });
      $('#attrprotectoff').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        // When list is selected, enable OK button.
        $('#attrprotectoff').css({ 'background-color': attrBtnOnColor });
        $('#attrprotecton').css({ 'background-color': attrBtnOffColor });
        $('#attrpauseon').prop('disabled', false);
        $('#attrpauseon').removeClass('attrdisable');
        $('#attrpauseoff').prop('disabled', false);
        $('#attrpauseoff').removeClass('attrdisable');
        $('#attrcomment').prop('disabled', false);
        $('#attrstacksize').prop('disabled', false);
        $('#attrsubtype').removeClass('attrdisable');
        if(!isScrModeProgAttr()) $('#dlgselimg').attr('src', 'images/select_icon.png');
        var progInfo = ProgramInfoManager.getCurrentProgInfo();
        if ((!progInfo.isExistProgPosition()) && (posRecordCount == 0) &&
          ($('#attrsubtype').text() != resources['attrSubCond'])) {
          $('.chkboxbk').prop('disabled', false);
          $('.chkboxlg').prop('disabled', false);
          $('.chkboxlg').css({ 'opacity': '1.0' });
        }
        $('#applLineEnd').prop('disabled', false); // Checkbox for Line track is enable,
        $('#LineEnd1').prop('disabled', false); // when Position data is exist.
        $('#LineEnd1').css({ 'opacity': '1.0' });
        pgProtect = PROTECTOFF;
      });
    }
  };
});

// This process is called by the line tracking instruction.
function convertHanZenkaku(str) {
  replaceFm = new Array(
    'ｳﾞ', 'ｶﾞ', 'ｷﾞ', 'ｸﾞ', 'ｹﾞ', 'ｺﾞ'
    , 'ｻﾞ', 'ｼﾞ', 'ｽﾞ', 'ｾﾞ', 'ｿﾞ'
    , 'ﾀﾞ', 'ﾁﾞ', 'ﾂﾞ', 'ﾃﾞ', 'ﾄﾞ'
    , 'ﾊﾞ', 'ﾋﾞ', 'ﾌﾞ', 'ﾍﾞ', 'ﾎﾞ'
    , 'ﾊﾟ', 'ﾋﾟ', 'ﾌﾟ', 'ﾍﾟ', 'ﾎﾟ'
  );
  replaceTo = new Array(
    'ヴ', 'ガ', 'ギ', 'グ', 'ゲ', 'ゴ'
    , 'ザ', 'ジ', 'ズ', 'ゼ', 'ゾ'
    , 'ダ', 'ヂ', 'ヅ', 'デ', 'ド'
    , 'バ', 'ビ', 'ブ', 'ベ', 'ボ'
    , 'パ', 'ピ', 'プ', 'ペ', 'ポ'
  );
  for (var key in replaceFm) {
    str = str.replace(new RegExp(replaceFm[key], 'g'), replaceTo[key]);
  }
  replaceFm = new Array(
    'ｱ', 'ｲ', 'ｳ', 'ｴ', 'ｵ'
    , 'ｶ', 'ｷ', 'ｸ', 'ｹ', 'ｺ'
    , 'ｻ', 'ｼ', 'ｽ', 'ｾ', 'ｿ'
    , 'ﾀ', 'ﾁ', 'ﾂ', 'ﾃ', 'ﾄ'
    , 'ﾅ', 'ﾆ', 'ﾇ', 'ﾈ', 'ﾉ'
    , 'ﾊ', 'ﾋ', 'ﾌ', 'ﾍ', 'ﾎ'
    , 'ﾏ', 'ﾐ', 'ﾑ', 'ﾒ', 'ﾓ'
    , 'ﾔ', 'ﾕ', 'ﾖ'
    , 'ﾗ', 'ﾘ', 'ﾙ', 'ﾚ', 'ﾛ'
    , 'ﾜ', 'ｦ', 'ﾝ'
    , 'ｧ', 'ｨ', 'ｩ', 'ｪ', 'ｫ'
    , 'ｬ', 'ｭ', 'ｮ', 'ｯ'
    , '､', '｡', 'ｰ', '｢', '｣', 'ﾞ', 'ﾟ'
  );
  replaceTo = new Array(
    'ア', 'イ', 'ウ', 'エ', 'オ'
    , 'カ', 'キ', 'ク', 'ケ', 'コ'
    , 'サ', 'シ', 'ス', 'セ', 'ソ'
    , 'タ', 'チ', 'ツ', 'テ', 'ト'
    , 'ナ', 'ニ', 'ヌ', 'ネ', 'ノ'
    , 'ハ', 'ヒ', 'フ', 'ヘ', 'ホ'
    , 'マ', 'ミ', 'ム', 'メ', 'モ'
    , 'ヤ', 'ユ', 'ヨ'
    , 'ラ', 'リ', 'ル', 'レ', 'ロ'
    , 'ワ', 'ヲ', 'ン'
    , 'ァ', 'ィ', 'ゥ', 'ェ', 'ォ'
    , 'ャ', 'ュ', 'ョ', 'ッ'
    , '、', '。', 'ー', '「', '」', '”', ''
  );
  for (var key in replaceFm) {
    str = str.replace(new RegExp(replaceFm[key], 'g'), replaceTo[key]);
  }
  return str;
}

function setCheckStat(currentSelect) {
  var progInfo = ProgramInfoManager.getCurrentProgInfo();
  var checkStat = false;
  var checkOpcty = '1.0';

  if (currentSelect == resources['attrSubCond']) {
    checkStat = true;
    checkOpcty = '0.5';
    pgMotionGroup = 0;
  } else {
    if ((progInfo.isExistProgPosition()) || (posRecordCount > 0)) {
      checkStat = true; // Position data is exist -> Disable
      checkOpcty = '0.5';
    }
  }
  for (var grpNum = 0; grpNum < maxGroupCount; grpNum++) {
    $('#attrGrp' + (grpNum + 1)).prop('disabled', checkStat);
    $('#lblGrp' + (grpNum + 1)).prop('disabled', checkStat);
    $('#lblGrp' + (grpNum + 1)).css({ 'opacity': checkOpcty });

    if (currentSelect == resources['attrSubCond']) {
      var checkbox = document.getElementById('attrGrp' + (grpNum + 1));
      checkbox.checked = false; // Subtype is Condition -> Checked clear
    }
  }
}                                                                                                                                                                                                                         /**********************************************************************
 * Robot Program Editor
 * File I/O
 * Created: 2017/06/16 FSI
 * Modified:2017/08/21 Responding to interface module.
 *          2019/04/03 for STEP8
 *                     Fix for code with quality problems.
 *          2019/05/07 Separate File info and Program info (prginfo.js).
 */

// Use Encoding.js
// Converts character encoding.
// Copyright (c) 2013-2017 polygon planet <polygon.planet.aqua@gmail.com>
// licensed under the MIT license.
// https://github.com/polygonplanet/encoding.js

/* === Tag group define === */
var TAGPROG = 0;
var TAGATTR = 1;
var TAGAPPL = 2;
var TAGMN = 3;
var TAGPOS = 4;
var TAGEND = 5;
var tagNameList = [
  { name: 'PROG', group: TAGPROG },
  { name: 'ATTR', group: TAGATTR },
  { name: 'APPL', group: TAGAPPL },
  { name: 'MN', group: TAGMN },
  { name: 'POS', group: TAGPOS },
  { name: 'END', group: TAGEND }
];

var applNameList = [
  { name: "AUTO_SINGULARITY_HEADER;", group: "singularity" },
  { name: "LINE_TRACK;", group: "track" },
  { name: "ﾊﾟﾚﾀｲｼﾞﾝｸﾞ[", group: "pallet" },
  { name: "Palletizing[", group: "pallet" },
  { name: "PLTZ_MODE_HEADER;", group: "pltzMode" }
];

/* === Position data status === */
var POSCAPTION = 0;
var POSGROUP = 1;
var POSCOORDINATE = 2;
var POSPOSITION = 3;

/*
 * Check tag name
 * return -1=Not match, 0> Tag group
 */
function checkTagName(name) {
  for (var i = 0; i < tagNameList.length; i++) {
    if (name == tagNameList[i].name) {
      return tagNameList[i].group;
    }
  }
  debug(DBGERROR, 'Illegal tag name(' + name + ')');
  return -1; // Illegal tag name
}
// Check APPL name
function checkApplName(name) {
  for (var i = 0; i < applNameList.length; i++) {
    if (name.indexOf(applNameList[i].name) >= 0) {
      return applNameList[i].group;
    }
  }
  // debug(DBGERROR, 'Illegal tag name(' + name + ')');
  return -1; // Illegal tag name
}

// Get language en or jp
function getFileIOLang() {
  var lang = getCurrentLanguage();
  if (lang != CRNTLANG_JP) {
    lang = CRNTLANG_EG;
  }
  return lang;
}

/* APPL data object */
var ProgramApplManager = (function () {
  /* APPL program data object */
  var progApplData = [];
  function l_initApplData() {
    progApplData.length = 0;
  }
  function l_getProgApplData() {
    return progApplData;
  }
  function l_putProgApplData(applPair) {
    progApplData.push(applPair);
  }
  // Default LineTracking APPL set to progApplData object.
  function l_setDefaultAppl() {
    var attrList = defaultLineTrackAppl[getFileIOLang()];
    for (var key in attrList) {
      var val = attrList[key];
      var attrPair = {};
      attrPair.key = key;
      attrPair.val = val;
      progApplData.push(attrPair);
    }
  }
  /* APPL edit data object */
  var editApplData = {};
  function l_initEditApplData() {
    editApplData = {};
  }
  function l_getEditApplData() {
    return editApplData;
  }
  function l_setEditApplData(editAppl) {
    editApplData = $.extend({}, editAppl);
  }

  /* APPL edit local registers object */
  var editApplLocalRegisters = {};
  function l_initEditApplLocalRegisters() {
    l_setEditApplLocalRegisters(["0","0","0"]);
  }
  function l_getEditApplLocalRegisters() {
    return editApplLocalRegisters;
  }
  function l_setEditApplLocalRegisters(localRegsVal, localRegType) {
    var oldLocalRegs = l_getEditApplLocalRegisters();
    var newLocalRegs = {};
    newLocalRegs["LOCAL_REGISTER"] = oldLocalRegs["LOCAL_REGISTER"];
    newLocalRegs["LOCAL_POS_REGISTER"] = oldLocalRegs["LOCAL_POS_REGISTER"];
    newLocalRegs["LOCAL_STR_REGISTER"] = oldLocalRegs["LOCAL_STR_REGISTER"];
    if (localRegType != null) {
      newLocalRegs[localRegType] = localRegsVal;
    } else if (localRegsVal.length == 3) {
      newLocalRegs["LOCAL_REGISTER"] = localRegsVal[0];
      newLocalRegs["LOCAL_POS_REGISTER"] = localRegsVal[1];
      newLocalRegs["LOCAL_STR_REGISTER"]  = localRegsVal[2];
    }
    editApplLocalRegisters = $.extend({}, newLocalRegs);
  }

  /* APPL edit data object */
  var editApplSingularity = {};
  function l_initEditApplSingularity(isEmpty) {
    if (isEmpty) {
      editApplSingularity = {};
    } else {
      var editSingularity = {};
      editSingularity["ENABLE_SINGULARITY_AVOIDANCE"] = 'FALSE;';
      l_setEditApplSingularity(editSingularity);
    }
  }
  function l_getEditApplSingularity() {
    return editApplSingularity;
  }
  function l_setEditApplSingularity(editAppl) {
    editApplSingularity = $.extend({}, editAppl);
  }

  /* APPL edit PALLETIZING MODE object */
  var editApplPltzMode = {};
  function l_initEditApplPltzMode(isEmpty) {
    if (isEmpty) {
      editApplPltzMode = {};
    } else {
      editApplPltzMode = {
        PLTZ_MODE_ENABLE: 'FALSE',
        J4TURN: J4TURN_ZERORAD,
        ORIENT: ORIENT_DOWNWARDS
      };
      l_setEditApplPltzMode(editApplPltzMode);
    }
  }
  function l_getEditApplPltzMode() {
    return editApplPltzMode;
  }
  function l_setEditApplPltzMode(editAppl) {
    editApplPltzMode = $.extend(editApplPltzMode, editAppl);
  }

  /* Line tracking data */
  var defaultLineTrackAppl = {  // Default data table
    'jp': {
      'ﾗｲﾝﾄﾗｯｷﾝｸﾞｽｹｼﾞｭｰﾙﾊﾞﾝｺﾞｳ': '0',
      'ﾗｲﾝﾄﾗｯｷﾝｸﾞｷｮｳｶｲﾊﾞﾝｺﾞｳ': '0',
      'ｼｭｳﾘｮｳｺﾞﾉﾄﾗｯｷﾝｸﾞｿﾞｯｺｳ': 'TRUE'
    },
    'eg': {
      'LINE_TRACK_SCHEDULE_NUMBER': '0',
      'LINE_TRACK_BOUNDARY_NUMBER': '0',
      'CONTINUE_TRACK_AT_PROG_END': 'TRUE'
    }
  };
  var lineTrackList = { // LineTracking data
    'jp': {
      'ﾗｲﾝﾄﾗｯｷﾝｸﾞｽｹｼﾞｭｰﾙﾊﾞﾝｺﾞｳ': 'lineschedule',
      'ﾗｲﾝﾄﾗｯｷﾝｸﾞｷｮｳｶｲﾊﾞﾝｺﾞｳ': 'lineboundary',
      "ｼｭｳﾘｮｳｺﾞﾉﾄﾗｯｷﾝｸﾞｿﾞｯｺｳ": "lineend"
    },
    'eg': {
      'LINE_TRACK_SCHEDULE_NUMBER': 'lineschedule',
      'LINE_TRACK_BOUNDARY_NUMBER': 'lineboundary',
      "CONTINUE_TRACK_AT_PROG_END": "lineend"
    }
  };
  function l_getLineTrackList(lang) {
    return lineTrackList[lang];
  }

  // palletizing section string
  var palletizingSection = {
    "ｼｮｷﾃﾞｰﾀ:": "config",
    "CONFIG:": "config",
    "ﾂﾐﾃﾝ:": "bottom",
    "BOTTOM:": "bottom",
    "ｹｲﾛﾊﾟﾀｰﾝ:": "route",
    "ROUTE:": "route",
    "ｹｲﾛｼﾞｮｳｹﾝ:": "pattern",
    "PATTERN:": "pattern"
  };
  function l_getPalletizingSection(key) {
    return palletizingSection[key];
  }

  var palletizingItem = {
    "TYPE": "type",
    "INCR": "incr",
    "PAL REG": "pal_reg",
    "ORDER": "order",
    "ROWS": "rows",
    "COLUMNS": "columns",
    "LAYERS": "layers",
    "AUXILIARY POS": "aux_pos",
    "APPR": "appr",
    "RTRT": "rtrt",
    "PATTERN": "pattern",
    "ｼｭﾙｲ": "type",
    "ｿﾞｳｶ": "incr",
    "ﾊﾟﾚｯﾄ ﾚｼﾞｽﾀ": "pal_reg",
    "ｼﾞｭﾝｼﾞｮ": "order",
    "ｷﾞｮｳ": "rows",
    "ﾚﾂ": "columns",
    "ﾀﾞﾝ": "layers",
    "ﾎｼﾞｮﾃﾝ": "aux_pos",
    "ｾｯｷﾝﾃﾝ": "appr",
    "ﾆｹﾞﾃﾝ": "rtrt",
    "ﾊﾟﾀｰﾝ": "pattern"
  };
  function l_getPalletizingItem(key) {
    return palletizingItem[key];
  }

  var lineTrackingConfig = {};
  var lineTrackCfgList = {};
  function l_initTrackingConfig() {
    lineTrackingConfig = {};
    lineTrackCfgList = {};
  }
  function l_getLineTrackingConfig(key) {
    return lineTrackingConfig[key];
  }
  function l_putLineTrackingConfig(key, value) {
    lineTrackingConfig[key] = value;
    l_putLineTrackConfList(getCurrentProgram());
  }
  function l_updateLineTrackingConfig() {
    var keyList = l_getLineTrackList(getFileIOLang());
    for (var key in editApplData) {
      l_putLineTrackingConfig(keyList[key], editApplData[key]);
    }
  }
  function l_setLineTrack() {
    var trackList = l_getLineTrackList(getFileIOLang()); // fileio
    var applData = l_getProgApplData(); // fileio
    for (var i = 0; i < applData.length; i++) {
      var param = trackList[applData[i].key];
      if (param) {
        lineTrackingConfig[param] = (applData[i].val.indexOf(";") > 0) ? applData[i].val.substring(0, applData[i].val.length - 1) : applData[i].val;
        resources[param] = applData[i].key;
      }
    }
    for (var key in lineTrackingConfig) {
      editApplData[resources[key]] = lineTrackingConfig[key];
    }
  }
  function l_getLineTrackConfList(progname, key) {
    return lineTrackCfgList[progname][key];
  }
  function l_putLineTrackConfList(progname) {
    lineTrackCfgList[progname] = JSON.parse(JSON.stringify(lineTrackingConfig));
  }

  /*
  * Loading APPL data.
  */
  var applList = {
    "{\"cmdId\":\"GRPTRACK\"}": "Line",
    "{\"cmdId\":\"GRPPALLET\"}": "Pallet",
    "{\"cmdId\":\"GRPVISION\"}": "Vision"
  };

  var LOAD_LINE_TRACK = false;
  var LOAD_PALLETIZING = false;
  var LOAD_VISION = false;
  var LOAD_VIA = false;
  function l_isLoadLineTrack() {
    return LOAD_LINE_TRACK;
  }
  function l_isLoadPalletizing() {
    return LOAD_PALLETIZING;
  }
  function l_isLoadVision() {
    return LOAD_VISION;
  }
  function l_isLoadVIA() {
    return LOAD_VIA;
  }

  function l_setLoadAppl() {
    // Get command list
    var treetype = 'instruct_tree';
    $.getJSON('/softpart/xmljson?file=/frh/irprog/pcedtdef_cmdlist.xml&id=' + treetype + '&connect_id=' + top.g_connect_id, function (commandTree) {
      for (var i = 0; i < commandTree.length; i++) {
        if (applList[commandTree[i].data.addParam]) {
          switch (applList[commandTree[i].data.addParam]) {
            case "Line":
              LOAD_LINE_TRACK = true;
              if (progApplData.length == 0) {
                l_setDefaultAppl();
                l_setLineTrack();
              }
              break;
            case "Pallet":
              LOAD_PALLETIZING = true;
              break;
            case "Vision":
              LOAD_VISION = true;
              break;
          }
        }
        if (commandTree[i].children.length >= 0 && !LOAD_VIA) {
          for (var j = 0; j < commandTree[i].children.length; j++){
            if (commandTree[i].children[j].data.addParam === "{\"cmdId\":\"GRPVIA\"}") {
              LOAD_VIA = true;
            }
          }
        }
      }
    }).fail(function (xhr, textStatus, errorThrown) {
      debug(DBGFATAL, 'Get data failed.(' + textStatus + ':' + errorThrown.message + ')');
    });
  }

  return {
    initApplData: l_initApplData,
    setDefaultAppl: l_setDefaultAppl,
    getProgApplData: l_getProgApplData,
    putProgApplData: l_putProgApplData,
    initEditApplData: l_initEditApplData,
    getEditApplData: l_getEditApplData,
    setEditApplData: l_setEditApplData,
    initEditApplSingularity: l_initEditApplSingularity,
    getEditApplSingularity: l_getEditApplSingularity,
    setEditApplSingularity: l_setEditApplSingularity,
    initEditApplLocalRegisters: l_initEditApplLocalRegisters,
    getEditApplLocalRegisters: l_getEditApplLocalRegisters,
    setEditApplLocalRegisters: l_setEditApplLocalRegisters,
    initTrackingConfig: l_initTrackingConfig,
    getLineTrackList: l_getLineTrackList,
    getLineTrackingConfig: l_getLineTrackingConfig,
    putLineTrackingConfig: l_putLineTrackingConfig,
    updateLineTrackingConfig: l_updateLineTrackingConfig,
    setLineTrack: l_setLineTrack,
    isLoadLineTrack: l_isLoadLineTrack,
    isLoadPalletizing: l_isLoadPalletizing,
    isLoadVision: l_isLoadVision,
    isLoadVIA: l_isLoadVIA,
    getPalletizingSection: l_getPalletizingSection,
    getPalletizingItem: l_getPalletizingItem,
    setLoadAppl: l_setLoadAppl,
    getLineTrackConfList: l_getLineTrackConfList,
    putLineTrackConfList: l_putLineTrackConfList,
    initEditApplPltzMode: l_initEditApplPltzMode,
    getEditApplPltzMode: l_getEditApplPltzMode,
    setEditApplPltzMode: l_setEditApplPltzMode
  };
})();

// group position data convert to record data.
function convertGroupPosition(posRawData) {
  posKeys = posRawData.poskey;
  var newrec = {};
  newrec.UF = posRawData.ufVal;
  newrec.UT = posRawData.utVal;
  newrec.Config = posRawData.configStr;
  for (posarr in posKeys) {
    posKey = posKeys[posarr];
    var key = posKey.key;
    newrec[key] = posKey.val;
  }
  return newrec;
}

/**
 * File loading status
 */
var loadingProgramFile = false;
function isFileLoading() {
  return loadingProgramFile;
}
function setFileLoading(mode) {
  loadingProgramFile = mode;
}

/*
 * Callback of Program File Read. (loadFile)
 */
function readPrgCallback(status, programName, programText, lineCount) {
  programName = omitExtension(programName);
  // If status is error, read the production file.
  if (status != IO_SUCCESS) {
    getProgramText(programName, GETPROG_PROD, readPrgCallback);
    return;
  }
  //dispOffWaiting();
  // Convert program text lines
  initConvertLines();
  convertLSData(programText, lineCount, setConvertLines); // common api.
  var callbackArg = { programName: programName };
  waitCnvTextComplete(readPrgCnvCallback, callbackArg);
}
function readPrgCnvCallback(callbackArg) {
  var programName = callbackArg.programName;
  // Analyze and Parse program file.
  var saveProgInfoIndex = 0;
  var progInfo = parseProgramFile(getProdProgName(programName), getConvertLines()); // api.
  if (!isScrModeProgAttr()) { // except for ProgramList/Attribute screen.
    // NOTE: You will come here when loading the recently edited program (TP_DEFPROG)
    //        after startup and when opening the program.
    //       If the subprogram is in execution (pause) state,
    //        it has already read the information of the subprogram.
    //       Therefore, if the program information has already been read,
    //        it will respond as follows.
    //       If the main program is at the top, leave the list as it is.
    //       If the main program is not at the top, insert the information
    //        of the main program at the top.
    // Note that initialization of program information management
    // is performed immediately after startup and at the time of program to open.

    // Get ProgInfo List from manager.
    var progInfoList = ProgramInfoManager.getProgInfoList();
    if (progInfoList.length > 0) {  // Already read program.
      if (programName == getCurrentProgram()) { // read main now.
        var progIndex = 0
        for (; progIndex < progInfoList.length; progIndex++) {
          if (progInfoList[progIndex].getProgName() == programName) {
            // Main program information already exists in the list.
            break;
          }
        }
        if (progIndex >= progInfoList.length) { // Not found main info.
          saveProgInfoIndex = ProgramInfoManager.getCurrentInfoIndex() + 1;
        }
      }
    }
  }

  // *** Opened an editing program.
  // --> Set the status during editing.
  if (isProgramNameTemporary(programName)) {
    addEditProgramFile(programName);
    if (isMyIFrameIdPrim()) {
      setProgramModified(true); // set modified flag only prim screen.
    }
  }
  // This block is an additional process for program attribute.
  if (isScrModeProgAttr()) {
    // When load, program not selected and select a program in the list, the flag will not be set.
    if (progAttr_LoadFlg || (getCurrentProgram() == '') || selProgFlag) {
      dispOnWaiting();
      ProgramInfoManager.overwriteProgInfo(progInfo);  // Set program info
      getFileAttribute(programName, EDITATTRMODE_SELATTR, afterGetFileAttribute); // api
    } else { // first load
      getFileAttribute(programName, EDITATTRMODE_ATTR, afterGetFileAttribute); // api
      ProgramInfoManager.setProgInfo(progInfo);  // Set program info
    }
    //change save button state
    chgSaveBtnCallback(null, programName);
    return;
  }
  // --------------------------

  ProgramInfoManager.prependProgInfo(progInfo); // Set program info to top.
  if (saveProgInfoIndex > 0) {  // Prepend main progInfo, shift index.
    ProgramInfoManager.setCurrentInfoIndex(saveProgInfoIndex);  // progInfo index set to sub prog index.
  }
  getFileAttribute(programName, EDITATTRMODE_OPEN, afterGetFileAttribute); // api
  //drawProgramData(programName, changeProgCallback);	// (Call after get attribute)
}

// Callback of after get file attribute.
function afterGetFileAttribute(progName, attrMode, fileAttr) {
  reflectSetAttribute(progName, fileAttr);	// see below
  var transInfo = {};
  transInfo.progName = progName;
  transInfo.attrMode = attrMode;
  getNumberOfGroups(afterGetNumberOfGroups, transInfo);	// api (see below)
  // program protect editting in editor
  if (isScrModePcEditor() && isMyIFrameIdPrim()) {
    protOverlayManager(fileAttr.PROTECT == PROTECTON);
  }
}
// Callback of after get group number(count)
function afterGetNumberOfGroups(transInfo) {
  getCurrentGroup(afterGetCurrentGroup, transInfo);	// api (see below)
}
// Callback of after get current group number(No.)
function afterGetCurrentGroup(transInfo) {
  if (transInfo.attrMode == EDITATTRMODE_OPEN) { // Mode of get attr is program OPEN.
    getModifyTime(transInfo.progName, getModifyTimeCallback);	// api
  } else {
    // This block is an additional process for visual programming.
    if (isScrModeProgAttr()) {
      if (transInfo.attrMode == EDITATTRMODE_ATTR) {
        getProgramText(getCurrentProgram(), GETPROG_TEMP, chgSaveBtnCallback);
        drawProgramList();	// Entities exist in visual
        drawAttribute();	// Entities exist in visual
        progAttr_LoadFlg = true;
      } else if (transInfo.attrMode == EDITATTRMODE_SAVEAS) {
        getProgramText(transInfo.progName, GETPROG_TEMP, chgSaveBtnCallback);
        drawProgramList();	// Entities exist in visual
        drawAttribute();	// Entities exist in visual
        progAttr_LoadFlg = true;
      } else if (transInfo.attrMode == EDITATTRMODE_SELATTR) {
        drawAttribute();	// Entities exist in visual
      } else if (transInfo.attrMode == EDITATTRMODE_NEW) {
        editAttrDlg.open(null, '#editattrdlg', false); // Get program attribute
      }
    }
  }
}
// Editable attribute set to current program information.
function reflectSetAttribute(progName, crntAttr) {
  var progInfo = ProgramInfoManager.getSpecifiedProgInfo(progName);
  progInfo.putEditAttrValue('COMMENT', crntAttr.COMMENT); // fileio
  progInfo.putEditAttrValue('STACK_SIZE', crntAttr.STACK_SIZE);
  progInfo.putEditAttrValue('MTNGRP', crntAttr.MTNGRP);
  progInfo.putEditAttrValue('PAUSE', crntAttr.PAUSE);
  progInfo.putEditAttrValue('PROTECT', crntAttr.PROTECT);
  progInfo.putEditAttrValue('SUBTYPE', crntAttr.SUBTYPE);
}

/**
 * Reload Program File data when save or remove temp file.
 */
function reloadPrgCallback(status, programName, programText, lineCount) {
  //dispOffWaiting();
  if (status != IO_SUCCESS) {
    debug(DBGERROR, 'reloadPrgCallback failure. status=' + status);
  }
  // Convert program text lines
  initConvertLines();
  convertLSData(programText, lineCount, setConvertLines); // common api.
  var callbackArg = { programName: programName, };
  waitCnvTextComplete(reloadPrgCnvCallback, callbackArg);
}
function reloadPrgCnvCallback(callbackArg) {
  var programName = omitExtension(callbackArg.programName);
  var saveCrntAttr = ProgramInfoManager.getSpecifiedProgInfo(programName).getEditAttrValue(); // Transport Edit Attribute.
  var progInfo = parseProgramFile(getProdProgName(programName), getConvertLines()); // api
  progInfo.setEditAttrValue(saveCrntAttr);
  ProgramInfoManager.updateProgInfo(programName, progInfo); // Update program info
  if (holdingTransmitInfo == null) { // Debug code
    debug(DBGERROR, "reload callback : illegal trans info: program=" + programName);
  }
  var afterProc = (holdingTransmitInfo == null) ? AFTERPROC_NONE : holdingTransmitInfo.afterProc;
  debug(DBGDUMP, 'reloadPrgCallback: afterProc[' + afterProc + ']');
  if (afterProc == AFTERPROC_RUNPROG) { // Run execute program
    drawProgramData(programName, setExecProgCallback); // See below.
  } else if ((afterProc == AFTERPROC_SELPROG) || // Select(Open) program
    (afterProc == AFTERPROC_NEWOPEN) || // Create program
    (afterProc == AFTERPROC_EDITATTR)) { // Edit attribute
    drawProgramData(programName, preProcSaveCallback); // See below.
  } else if ((afterProc == AFTERPROC_NEWPROG)) {
    if (isMyIFrameIdPrim()) {
      var cbArg = {};
      chgProg(programName, preProcSaveCallback, cbArg); // No need wait chgProg reflect.
    } else {
      preProcSaveCallback(0, programName);
    }
  } else if ((afterProc == AFTERPROC_OPENPROG)) {
    deleteAfterOpenPrg(); // pceditor_prgwin
  } else if (afterProc == AFTERPROC_PLTPASTE) {
    drawProgramData(programName, reloadPltModifyCallback); // See below and api.
    holdingTransmitInfo.afterProc = '';
  } else if (afterProc == 'detailstab') {
    var cbArg = {};
    chgProg(programName, preProcSaveCallback, cbArg); // No need wait chgProg reflect.
  } else {
    var modifyCallback = (afterProc == AFTERPROC_RENAMEPG) ? renameModifyCallback : getModifyTimeCallback; // api
    getModifyTime(programName, modifyCallback); // api
    //drawProgramData(programName, changeProgCallback);	// (Call after get modify info)
  }
  //holdingTransmitInfo = null;	Initialize after each process
}

// Callback of Exec program after reload file.
function setExecProgCallback(status, programName) {
  debug((status != IO_SUCCESS) ? DBGERROR : DBGDUMP, 'setExecProgCallback chgProg status=[' + status + ']. (' + programName + ')');
  if (status != IO_SUCCESS) {
    // Error Dialog?  --> May be no need.
  }
  var execValid = !holdingTransmitInfo.modifyTime; // if the edited file is discarded, will not be executed.
  holdingTransmitInfo = null; // reset trans info.
  if (execValid) {
    runProgram(); // Program execution. (prgwin)
  }
}
// Callback of Save and Reload program when Caution dialog.
function preProcSaveCallback(status, programName) {
  debug((status != IO_SUCCESS) ? DBGERROR : DBGDUMP, 'preProcSaveCallback chgProg status=[' + status + ']. (' + programName + ')');
  if (status != IO_SUCCESS) {
    // Error Dialog?  --> May be no need.
  }
  setCurrentProgram(programName);
  // Each process after save.
  var afterProc = holdingTransmitInfo.afterProc;
  if (afterProc == AFTERPROC_SELPROG) {
    openOpenDialog(); // Get program list and open [Open]Dialog.
  } else if (afterProc == AFTERPROC_NEWOPEN) {
    defineDialog.open('#filenew', '#getprogdlg', ''); // Get program name
  } else if (afterProc == AFTERPROC_EDITATTR) {
    editAttrDlg.open('#fileeditattr', '#editattrdlg', false); // Get program attribute
  } else if ((afterProc == AFTERPROC_NEWPROG)) {
    defineDialog.open('#filenew', '#getprogdlg', ''); // Get program name
  } else if (afterProc = 'detailstab') {
    modifiAster = false;
    prgbuttonSelectProc();
  }
  holdingTransmitInfo = null;
}
// Process after get create time (production program) when save program.
function changeProgCallback(status, programName) {
  debug((status != IO_SUCCESS) ? DBGERROR : DBGDUMP, 'changeProgCallback chgProg status=[' + status + ']. (' + programName + ')');
  if (status != IO_SUCCESS) {
    // Error Dialog?  --> May be no need.
  }
	/* ====================== [8/3/2018]
	 * If it is running at load time, mask screen processing.
	 * This process is based on a request from the US that
	 * "Do not stop the operation even if you switch to
	 * another menu during execution".
	 * ====================== */
  if (isScrModePcEditor()) {
    if (getWatchExecValue() == 1) { // RUN LED is ON
      debug(DBGINFO, 'changeProgCallback: [RUN] LED is ON.');
      if (!isExecuteProgram()) {  // if no exec program,
        setProgramExec(true);     // program to exec.
      }
      var myFrameId = getMyIFrameId();
      initEditorAreaInfo(myFrameId); // prgwin
      // Refresh current program info
      statusProgramInfoTrans.refreshCrntProgramInfo();
      setTimeout(function () {
        var reflectprog = JSON.parse(JSON.stringify(statusProgramInfoTrans.getCurrentProgramSI()));
        reflectExecLine(reflectprog);  // main (for highlight)
      }, 100);
      if (checkEditInvalid(false)) {
        protOverlaySetting();
      }
      putOverlayScreen('exec', 'forexec'); // Operations such as editing are disabled.
    }
    holdingTransmitInfo = null; // initialize
    debug(DBGINFO, 'Complete editor window initialize.');
    initStatusProgramInfo();  // main
  } else {
    holdingTransmitInfo = null; // initialize
  }
}

// Callback to get joint axes count. (call from poswin)
function getJointAxesCallback() {
  // Initialization of JOG window by number of axes. (move from main)
  isFirstInitJogWin = true;
  initJogDialWin(); // jogwin
  retryInitCount = 0;
  watchInitJog();
}
var completeJogInit = false;  // set true by jogwin
var retryInitCount = 0;
// Watch of complete Jog max frame num init. Retry 50 ms.
function watchInitJog() {
  var wdTimer_JogInit = null;
  if ((!completeJogInit) && (retryInitCount < 200)) {
    wdTimer_JogInit = setTimeout(function () {
      retryInitCount++;
      debug(DBGDUMP, 'watchInitJog: ' + retryInitCount + 'time(s)');
      watchInitJog();
    }, 50);
  } else {
    clearTimeout(wdTimer_JogInit);
    wdTimer_JogInit = null;
    retryInitCount = 0;
    // Continue initialyze
    getUFUTValue(1); // common api
    watchGetUfUtVal();
  }
}
// Watch get uf/uf value. Retry until complete.
function watchGetUfUtVal() {
  var wdTimer_ufutVal = null;
  if (!isGetUfUtValue()) { // Acquired UF/UT values? (common api)
    debug(DBGDUMP, 'watchGetUfUtVal: ' + retryInitCount + 'time(s)');
    wdTimer_ufutVal = setTimeout(function () {
      retryInitCount++;
      watchGetUfUtVal();
    }, 100);
  } else {
    clearTimeout(wdTimer_ufutVal);
    wdTimer_ufutVal = null;
    retryInitCount = 0;
    if (!(isScrModeProgAttr())) {
      buildProgramList(); // prgwin
    }
  }
}

// Draw edit text data and position data
function drawProgramData(programName, callback) {
  setFileLoading(true); // true for cursorActivity in progwin
  programName = getProdProgName(programName);
  var progInfo = ProgramInfoManager.getSpecifiedProgInfo(programName);
  if (!isScrModeProgAttr()) {
    drawProgramText(progInfo.getProgMnemonicStr());
    top.irprogapi.dispPauseCautionPopup(window);
  }
  if (isExistEditProgramFile(getTempProgName(programName))) {
    setProgramModified(true);
  }
  if (isScrModePcEditor()) {
    drawPositionData(progInfo.getProgPositionArray());
  }
  if (isMyIFrameIdPrim()) {
    var cbArg = {};
    top.rpcmc_getVar(top.SYSNAME_C, '$TP_DEFPROG', tpDefProgCB);
    function tpDefProgCB(prog, varName, typeCode, valStr) {
      if (valStr != programName) {
        chgProg(programName, callback, cbArg); // No need wait chgProg reflect.
      } else {
        callback(IO_SUCCESS, programName);
      }
    }
  } else {
    callback(0, programName);
  }
  setFileLoading(false);
}
/**
 * Read specified program file.
 * generate program data object.
 * (IN) programName Program file name.
 * return: result code 0=success, not 0=error
 */
function readProgramFile(programName) {
  // Text data receive. (1st read(try) is temp file)
  dispOnWaiting();
  getProgramText(programName, GETPROG_TEMP, readPrgCallback); // robotapi
}

// Callback of Loaded Sub Program.
function loadSubPrgCallback(status, programName, programText, lineCount, progStat) {
  programName = omitExtension(programName);
  debug((status != IO_SUCCESS) ? DBGERROR : DBGDUMP, 'loadSubPrgCallback(' + programName + '): status[' + status + ']');
  // If status is error, display error dialog?
  if (status != IO_SUCCESS) {
    // Open error dialog
    return;
  }
  //dispOffWaiting();
  // Convert program text lines
  initConvertLines();
  convertLSData(programText, lineCount, setConvertLines); // common api.
  var callbackArg = { programName: programName, progStat: progStat };
  waitCnvTextComplete(loadSubPrgCnvCallback, callbackArg);
}
function loadSubPrgCnvCallback(callbackArg) {
  var programName = getProdProgName(callbackArg.programName);
  var progInfo = parseProgramFile(programName, getConvertLines()); // api
  // Draw sub program text to edit window.
  updateEditorScreen(callbackArg.progStat, progInfo, true); // prgwin
}
// Read (Load) Sub program file.
function loadSubProgram(programName, reflectprog) {
  var progStat = JSON.parse(JSON.stringify(reflectprog)); // deep copy
  // Text data receive. (load only production file)
  dispOnWaiting();
  var progFile = addProgramExtension(programName);
  loadFile(progFile, loadSubPrgCallback, progStat); // io
}

/**
 * Reload program file.
 *   : production file : before execution, after save main and 2nd/3rd screen.
 *   : temporary file  : after paste success/error.
 * (IN) programName : Product program name.
 */
function reloadProgramFile(programName, callback) {
  dispOnWaiting();
  programName = addProgramExtension(programName);
  loadFile(programName, callback); // io
}

/*
 * Analyze and Build Program File Data
 */
/* Get one line of text up to CR/LF. */
function getLine(text, index) {
  var lineInfo = {};
  var st = index;
  var termLf = false; // terminate at LF
  for (; ((text[index] != CODECR) && (text[index] != CODELF)) && (text.length > index); index++) {
    ; // until cr/lf
  }
  lineInfo.text = text.substring(st, index);
  // If skip line breaks, empty lines are also skipped,
  // so judge one character at a time.
  //for ( ; ((text[index] == CODECR) || (text[index] == CODELF)) &&
  //		 (text.length > index); index++) {
  //	;	// until not cr/lf
  //}
  if ((text[index] == CODECR) && (text.length > index)) {
    index++;
  }
  if ((text[index] == CODELF) && (text.length > index)) {
    index++;
    termLf = true;
  }
  lineInfo.next = index;
  lineInfo.ewnl = ((index == text.length) && (termLf)) ? true : false; // The last character ends with a new line.
  return lineInfo;
}
/* Create an array for each line. */
function makeEachLineArray(fileText) {
  var programLines = [];
  for (var i = 0; i < fileText.length;) {
    // Get 1 line data
    var lineInfo = getLine(fileText, i);
    programLines[programLines.length] = lineInfo.text;
    i = lineInfo.next;
    if ((i == fileText.length) && (lineInfo.ewnl)) {
      programLines[programLines.length] = ''; // Last line data. (empty row)
    }
  }
  return programLines;
}
/*
 * Parse program text data.
 * (IN) : Program name
 * (IN) : File line array
 * return : Program information object
 */
function parseProgramFile(progName, fileLines) {
  var tagGroup = 0;
  var posStatus = POSCAPTION;
  var mnArray = [];
  var posArray = [];
  // Make Program Info object
  var programInfoObj = new ProgramFileInfo();
  // Initialyze data
  programInfoObj.init(progName);
  ProgramApplManager.initApplData();
  ProgramApplManager.initEditApplData();

  var applGroup = -1;
  var palet_num = palet_bottom_num = palet_route_num = bottomDataNum = 0;
  var palet_catego = ";";
  var palletsection = "";
  var modObj = {};
  var catego = "";
  var routePatNum = "1";
  initGPlt();

  // Iterate for line count of file.
  for (var i = 0; i < fileLines.length; i++) {
    // Get 1 line data
    var line = fileLines[i];
    // Start at slash?
    if (line.startsWith('/')) { // Header.
      var tags = line.split(' '); // Program name is exist after tag name
      var tag = tags[0].substr(1).trim(); // Cut out tag name
      // tag name check
      tagGroup = checkTagName(tag);
      continue;
    }
    // Body data.
    switch (tagGroup) {
      case TAGATTR: // Attributes
        var attr = line.split('='); // extract attr-key and attr-val.
        var attrPair = {};
        attrPair.key = attr[0].trim();
        attrPair.val = attr[1].trim();
        programInfoObj.putAttribute(attrPair);
        
        // set local registers
        if (attrPair.key.indexOf(localRegsText[getFileIOLang()]) >= 0) {
          var localRegArr = ((attrPair.val).replace(";", "")).split(',');
          ProgramApplManager.setEditApplLocalRegisters(localRegArr);  // fileio
        }
        break;

      case TAGAPPL: // Application data
        if (/^[\w|ｦ-ﾟ]+/.test(line)) { // check APPL kind
          applGroup = checkApplName(line);
        }
        switch (applGroup) {
          case "singularity": // Singularity Avoidance
            if (line.indexOf(":") > 1) {
              var appl = line.split(':');
              var editSingularity = {};
              editSingularity[appl[0].trim()] = appl[1].trim();
              ProgramApplManager.setEditApplSingularity(editSingularity);  // fileio
            }
            break;
          case "track": // Line Tracking
            if (line.indexOf(":") > 1) {
              var appl = line.split(':');
              var applPair = {};
              applPair.key = appl[0].trim();
              applPair.val = appl[1].trim();
              ProgramApplManager.putProgApplData(applPair);
            }
            break;
          case "pltzMode": // PALLETIZING MODE
            if (line.indexOf(":") > 1) {
              var appl = line.split(':');
              var applPair = {};
              applPair[appl[0].trim()] = appl[1].trim().replace(";", "");
              ProgramApplManager.setEditApplPltzMode(applPair);
            }
            break;
          case "pallet": // Palletizing
            if (line.match(/[ﾊﾟﾚﾀｲｼﾞﾝｸﾞ|Palletizing]\[\d+\];/)) {
              palet_num = line.replace(/[^0-9]/g, "");
            } else if (/^\t[\w|ｦ-ﾟ]+:/.test(line)) {
              palletsection = ProgramApplManager.getPalletizingSection(line.trim());
            } else {
              switch (palletsection) {
                case "config":
                  if (line.indexOf("=") >= 0) {
                    var appl = line.split('=');
                    var itemName = ProgramApplManager.getPalletizingItem(appl[0].trim());
                    var val = appl[1].replace(/;$/, "").trim();
                    if (/^\d+$/g.test(val)) {
                      val = Number(val);
                    } else if (/^\[.+\]$/.test(val)) {
                      val = val.replace(/[\[|\]]/g, "");
                      val = val.split(",");
                      var new_val = [];
                      for (var val_cnt = 0; val_cnt < val.length; val_cnt++) {
                        if (isNaN(Number(val[val_cnt]))) {
                          var conv = serchPltResource(resources, val[val_cnt].trim());
                          if (conv != null) val[val_cnt] = conv;
                          new_val[val_cnt] = val[val_cnt].trim();
                        } else {
                          new_val[val_cnt] = Number(val[val_cnt]);
                        }
                      }
                      val = new_val;
                    }
                    var convert = serchPltResource(resources, val);
                    if (convert != null) val = convert;
                    modObj.config[itemName] = val;
                  } else {
                    var sprit = line.split(/[\s|-]/);
                    // First, extract categories and numbers
                    for (index in sprit) {
                      if (/\w+_\d+/.test(sprit[index])) {
                        catego = sprit[index].match(/\w+_\d+/);
                      }
                    }
                    palet_num = catego[0].replace(/[^0-9]/g, "");
                    var temp_catego = catego[0].replace(/[^A-Z]/g, "");
                    if (palet_catego !== temp_catego) {
                      routePatNum = "1";
                      palet_route_num = 0;
                      palet_catego = temp_catego;
                    }

                    // create default object
                    modObj = getInitPltObj(palet_catego, palet_num);
                    // Next, extruct comment
                    var comment = line.match(/".*"/);
                    if (comment) {
                      modObj.config.name = comment[0].replace(/"/g, "");
                    } else {
                      modObj.config.name = "";
                    }
                    palet_bottom_num = 0;
                    palet_route_num = 0;
                  }
                  modObj = updatePltObj(modObj);
                  break;
                case "bottom":
                  var bottomObj = modObj.bottom[palet_bottom_num];
                  // analizePalletPosition(line, bottomObj);
                  // posNumber
                  if (/\[\d,\d,\d\]/.test(line)) {
                    var posNum = line.replace("{", "").trim();
                    bottomObj.posNumber = posNum;
                    bottomObj.posData[0] = getVoidPosDataModel();
                  } else if (/GP\d+:/.test(line)) { // GP Number
                    bottomObj.posData[0].groupNumber = line.replace(/[^0-9]/g, "");
                  } else if (/UF.+UT.+/.test(line)) { // UF UT Config
                    // Analyze UF, UT, CONFIG...
                    var crds = line.split(','); // Split for each comma
                    for (index in crds) {
                      var crd = crds[index].split(':'); // Split by colon
                      var crdKey = crd[0].trim();
                      if (crdKey == 'UF') {
                        var ufVal = parseInt(crd[1].trim());
                        if (isNaN(ufVal)) {
                          ufVal = '';
                        }
                        bottomObj.posData[0].ufVal = ufVal;
                      } else if (crdKey == 'UT') {
                        var utVal = parseInt(crd[1].trim());
                        if (isNaN(utVal)) {
                          utVal = '';
                        }
                        bottomObj.posData[0].utVal = utVal;
                      } else if (crdKey.length > 0) { // if any string is exist, set as ('CONFIG').
                        var confPos = line.lastIndexOf(':');
                        var confStr = line.substr(confPos + 1);
                        var confSta = confStr.indexOf("'");
                        var confEnd = confStr.lastIndexOf("'");
                        confStr = confStr.substring(confSta + 1, confEnd);
                        bottomObj.posData[0].configStr = confStr;
                        break; // Do not analyze any more...
                      }
                    }
                  } else if (/\t\t};/.test(line)) {
                    palet_bottom_num++;
                  } else { // x,y,z,w,p,r
                    var posElem = line.split(','); // Split for each comma
                    for (index in posElem) {
                      var elem = posElem[index]; // 1 item
                      if (elem.length == 0) {
                        continue;
                      }
                      var keys = elem.split('='); // Split by equal
                      var keyPair = {};
                      var keyStr = keys[0].trim()
                      keyPair.key = keyStr;
                      keyPair.val = parseFloat(keys[1]);
                      if (isNaN(keyPair.val)) {
                        keyPair.val = '';
                      }
                      var posobj = bottomObj.posData[0].poskey;
                      if (keyPair.key in posobj) {
                        posobj[keyPair.key] = keyPair.val;
                      }
                    }
                  }
                  break;
                case "pattern":
                  var temp = line.split("=");
                  var num = temp[0].replace(/[^0-9]/g, "");
                  var val = temp[1].replace(/[\[|\]|;]/g, "").split(",");
                  var patternArry = modObj.pattern[Number(num) - 1];
                  for (var patNum = 0; patNum < 3; patNum++) {
                    patternArry[patNum] = val[patNum].trim();
                  }
                  break;
                case "route":
                  if (/\[\d+\]/.test(line)) {
                    var route_num = line.replace(/[^0-9]/g, "").trim();
                    if (routePatNum !== route_num) {
                      routePatNum = route_num;
                      palet_route_num = 0;
                    }
                  }
                  var routeObj = modObj.route.pattern;
                  if (!(/\t\t};/.test(line))) {
                    var routePosObj = routeObj[routePatNum][palet_route_num];
                  }

                  // analizePalletPosition(line, routeObj);
                  // posNumber
                  if (/\[...\]/.test(line)) {
                    var posNum = line.replace("{", "").trim();
                    routePosObj.posNumber = posNum;
                    routePosObj.posData[0] = getVoidPosDataModel();
                  } else if (/GP\d+:/.test(line)) { // GP Number
                    routePosObj.posData[0].groupNumber = line.replace(/[^0-9]/g, "");
                  } else if (/UF.+UT.+/.test(line)) { // UF UT Config
                    // Analyze UF, UT, CONFIG...
                    var crds = line.split(','); // Split for each comma
                    for (index in crds) {
                      var crd = crds[index].split(':'); // Split by colon
                      var crdKey = crd[0].trim();
                      if (crdKey == 'UF') {
                        var ufVal = parseInt(crd[1].trim());
                        if (isNaN(ufVal)) {
                          ufVal = '';
                        }
                        routePosObj.posData[0].ufVal = ufVal;
                      } else if (crdKey == 'UT') {
                        var utVal = parseInt(crd[1].trim());
                        if (isNaN(utVal)) {
                          utVal = '';
                        }
                        routePosObj.posData[0].utVal = utVal;
                      } else if (crdKey.length > 0) { // if any string is exist, set as ('CONFIG').
                        var confPos = line.lastIndexOf(':');
                        var confStr = line.substr(confPos + 1);
                        var confSta = confStr.indexOf("'");
                        var confEnd = confStr.lastIndexOf("'");
                        confStr = confStr.substring(confSta + 1, confEnd);
                        routePosObj.posData[0].configStr = confStr;
                        break; // Do not analyze any more...
                      }
                    }
                  } else if (/\t\t\s\s\s};/.test(line)) {
                    palet_route_num++;
                  } else if (/\t\t};/.test(line)) {
                    // no action
                  } else { // x,y,z,w,p,r
                    var posElem = line.split(','); // Split for each comma
                    for (index in posElem) {
                      var elem = posElem[index]; // 1 item
                      if (elem.length == 0) {
                        continue;
                      }
                      var keys = elem.split('='); // Split by equal
                      var keyPair = {};
                      var keyStr = keys[0].trim()
                      keyPair.key = keyStr;
                      keyPair.val = parseFloat(keys[1]);
                      if (isNaN(keyPair.val)) {
                        keyPair.val = '';
                      }
                      var posobj = routePosObj.posData[0].poskey;

                      if (keyPair.key in posobj) {
                        posobj[keyPair.key] = keyPair.val;
                      }
                    }
                  }
                  break;
                default:
                  // especially none.
                  break;
              }
            }
            break;
        }
        break;

      case TAGMN: // Line is mnemonic
        var colonPos = line.indexOf(':'); // Skip go colon
        var mnText = line.substr(colonPos + 1);
        var setIndex = mnArray.length;
        var lineNum = parseInt(line.trim());
        var mnSave = '';

        // If there is no line number, concatenate it to the previous line.
        if (isNaN(lineNum)) {
          setIndex--;
          mnText = mnArray[setIndex].trim() + ' ' + mnText.trim();
        }
        mnText = (mnText[mnText.length - 1] == ';') ? mnText.substr(0, mnText.length - 1) : mnText;
        mnSave = exceptEndEmp(mnText);
        mnArray[setIndex] = mnSave;
        break;
      case TAGPOS: // Line is Position data
        var result = analizePosition(line, posStatus, posArray);
        if (result < 0) {
          debug(DBGERROR, 'Illegal position data(' + line + ')');
        }
        posStatus = result;
        break;
      default:
        // especially none.
        break;
    }
  }
  // Save program information data.
  programInfoObj.setProgMnemonicArray(mnArray);
  programInfoObj.setProgPositionArray(posArray);
  programInfoObj.initEditAttrValue();
  // Initialyze APPL data.
  ProgramApplManager.setLineTrack();
  ProgramApplManager.putLineTrackConfList(progName);
  ProgramApplManager.setLoadAppl();
  return programInfoObj;
}

/*
 * Analyze Position data string
 * (IN) line : Line text
 * (IN) status : Analyze target status
 * (IN/OUT) posArray : Position data object array
 */
function analizePosition(line, status, posArray) {
  // When the position data is '***', there is a bug just before the expansion axis.
  // (The comma at the end of the line is missing.)
  // Normally it is analysis of group, but analysis of extend axis is necessary.
  if ((status == POSGROUP) && (line.indexOf('GP') < 0)) {
    if (line.indexOf(';') < 0) { // No terminate position data.
      status = POSPOSITION;
    }
  }
  // Get target position array index.
  // Add element when parsing caption, and update recent elements otherwise.
  var targetIndex = (status == POSCAPTION) ? posArray.length : posArray.length - 1;
  switch (status) {
    case POSCAPTION: // Position number
      // pickup number of [n]
      var sqBraLf = line.indexOf('[');
      var sqBraRi = line.indexOf(']', sqBraLf);
      if ((sqBraLf == -1) || (sqBraRi == -1)) {
        return -1;  // Illegal format
      }
      var numStr = line.substring(sqBraLf + 1, sqBraRi);
      var cmntStr = '';
      var cmntPos = numStr.indexOf(':');
      if (cmntPos >= 0) { // comment is exist
        cmntStr = numStr.substr(cmntPos + 1).slice(1, -1); // Remove quotes around it
        numStr = numStr.substring(0, cmntPos);
      }
      var posNum = parseInt(numStr);
      var posData = {};
      posData.posNumber = posNum;
      posData.Comment = cmntStr;
      posArray[targetIndex] = posData;  // Add position element
      status = POSGROUP;
      break;
    case POSGROUP: // Group number
      // pickup number of GPn:
      var grpPos = line.indexOf('GP');
      var grpEnd = line.indexOf(':', grpPos);
      if ((grpPos == -1) || (grpEnd == -1)) {
        return POSCAPTION; // May be close position [};]. Back to position top.
      }
      var grpStr = line.substring(grpPos + 'GP'.length, grpEnd);
      var grpNum = parseInt(grpStr);
      var grpData = {};
      grpData = {
        'groupNumber': grpNum
      };
      var posDatas = posArray[targetIndex].posData;
      if (posDatas == undefined) { // 1st group
        posDatas = [];
      }
      var posGrpIndex = posDatas.length;
      posDatas[posGrpIndex] = grpData;
      posArray[targetIndex].posData = posDatas;
      status = POSCOORDINATE;
      break;
    case POSCOORDINATE: // Coordinate data
      var posDatas = posArray[targetIndex].posData;
      var posIndex = posDatas.length - 1;
      // Analyze UF, UT, CONFIG...
      var crds = line.split(','); // Split for each comma
      for (index in crds) {
        var crd = crds[index].split(':'); // Split by colon
        var crdKey = crd[0].trim();
        if (crdKey == 'UF') {
          var ufVal = parseInt(crd[1].trim());
          if (isNaN(ufVal)) {
            ufVal = '';
          }
          posArray[targetIndex].posData[posIndex].ufVal = ufVal;
        } else if (crdKey == 'UT') {
          var utVal = parseInt(crd[1].trim());
          if (isNaN(utVal)) {
            utVal = '';
          }
          posArray[targetIndex].posData[posIndex].utVal = utVal;
        } else if (crdKey.length > 0) { // if any string is exist, set as ('CONFIG').
          var confPos = line.lastIndexOf(':');
          var confStr = line.substr(confPos + 1);
          var confSta = confStr.indexOf("'");
          var confEnd = confStr.lastIndexOf("'");
          confStr = confStr.substring(confSta + 1, confEnd);
          posArray[targetIndex].posData[posIndex].configStr = confStr;
          break; // Do not analyze any more...
        }
      }
      status = POSPOSITION;
      break;
    case POSPOSITION: // Position raw data
      var posDatas = posArray[targetIndex].posData;
      var posIndex = posDatas.length - 1;
      var posElem = line.split(','); // Split for each comma
      for (index in posElem) {
        var elem = posElem[index]; // 1 item
        if (elem.length == 0) {
          continue;
        }
        var keys = elem.split('='); // Split by equal
        var keyPair = {};
        var keyStr = keys[0].trim()
        if (keyStr.startsWith('E')) {
          var realKey = 'EXT' + (keyStr.substr(1));
          keyStr = realKey;
        }
        keyPair.key = keyStr;
        keyPair.val = parseFloat(keys[1]);
        if (isNaN(keyPair.val)) {
          keyPair.val = '';
        }
        var poskeys = posArray[targetIndex].posData[posIndex].poskey;
        if (poskeys == undefined) {
          poskeys = [];
        }
        var pkindex = poskeys.length;
        poskeys[pkindex] = keyPair;
        posArray[targetIndex].posData[posIndex].poskey = poskeys;
      }
      if (line.charAt(line.length - 1) != ',') { // line mode continue...
        status = POSGROUP;
      }
      break;
    default:
      // especially none
      break;
  }
  return status;
}

// Analyze Palletizing Position data string now making...
function analizePalletPosition(line, targetObj) {
  // posNumber
  if (/\[\d,\d,\d\]/.test(line)) {
    var posNum = line.replace("{", "").trim();
    targetObj.posNumber = posNum;
    targetObj.posData[0] = getVoidPosDataModel();
  } else if (/GP\d+:/.test(line)) { // GP Number
    targetObj.posData[0].groupNumber = line.replace(/[^0-9]/g, "");
  } else if (/UF.+UT.+CONFIG/.test(line)) { // UF UT Config
    // Analyze UF, UT, CONFIG...
    var crds = line.split(','); // Split for each comma
    for (index in crds) {
      var crd = crds[index].split(':'); // Split by colon
      var crdKey = crd[0].trim();
      if (crdKey == 'UF') {
        var ufVal = parseInt(crd[1].trim());
        if (isNaN(ufVal)) {
          ufVal = '';
        }
        targetObj.posData[0].ufVal = ufVal;
      } else if (crdKey == 'UT') {
        var utVal = parseInt(crd[1].trim());
        if (isNaN(utVal)) {
          utVal = '';
        }
        targetObj.posData[0].utVal = utVal;
      } else if (crdKey.length > 0) { // if any string is exist, set as ('CONFIG').
        var confPos = line.lastIndexOf(':');
        var confStr = line.substr(confPos + 1);
        var confSta = confStr.indexOf("'");
        var confEnd = confStr.lastIndexOf("'");
        confStr = confStr.substring(confSta + 1, confEnd);
        targetObj.posData[0].configStr = confStr;
        break; // Do not analyze any more...
      }
    }
  } else if (/\t\t};/.test(line)) {
    palet_posdata_num++;
  } else { // x,y,z,w,p,r
    var posElem = line.split(','); // Split for each comma
    for (index in posElem) {
      var elem = posElem[index]; // 1 item
      if (elem.length == 0) {
        continue;
      }
      var keys = elem.split('='); // Split by equal
      var keyPair = {};
      var keyStr = keys[0].trim()
      keyPair.key = keyStr;
      keyPair.val = parseFloat(keys[1]);
      if (isNaN(keyPair.val)) {
        keyPair.val = '';
      }
      var posobj = targetObj.posData[0].poskey;
      if (keyPair.key in posobj) {
        posobj[keyPair.key] = keyPair.val;
      }
    }
  }
}

/*
 * Float value to String (x.xxx)
 */
function convertFtoA(fVal) {
  if (fVal === '') {
    return ' ****.******';
  }
  // 'toFixed' is only Number, so convert if it is a string.
  if (typeof fVal === 'string') {
    fVal = parseFloat(fVal);
  }
  var fStr = " " + fVal.toFixed(6); // Rounded to 6 decimal places
  return fStr;
}

/**
 * Compose Program data and Position data to program text
 **/
// Mnemonic data make from program text.
// This function is used for editing when writing the LS file.
function makeMnemonic(prgText) {
  var mnLines = [];
  for (var ch = 0; ch < prgText.length;) {
    var mnText = '';
    var lineInfo = getLine(prgText, ch);
    var line = lineInfo.text;
    ch = lineInfo.next;
    mnText += line;
    prevLineClose = (line.charAt(line.length - 1) == ';') ? true : false;
    mnLines[mnLines.length] = mnText;
  }
  return mnLines;
}

// Position data make from position records.
/**
 * Direct strings are specified according to file specifications.
 * When the specification of the file changes,
 *  it is necessary to add or modify it according to the specification.
 * If change significantly, create a string definition table.
 **/
// Make position text array
function makePosition(progInfo, posRec) {
  var posLines = [];
  var grpCount;
  if (progInfo.getProgPositionArray().length > 0) {
    if (progInfo.getProgPositionElement(0).posData != undefined) {
      grpCount = progInfo.getProgPositionElement(0).posData.length; // get Group count reference as 1st rec.
    }
  } else {
    grpCount = 1; // new program default group.
  }
  for (var posIdx = 0; posIdx <= (posRec.length - 1); posIdx++) { // -1 is Blank line...
    if (isExistPositionData(posRec[posIdx])) {  // poswin
      if (posRec[posIdx].error == 1) {
        continue;	// If there is an error in the record, it skip the configuration.
      }
      posLines[posLines.length] = constructPositionText(posRec[posIdx], progInfo.getProgPositionElement(posIdx), grpCount);
    }
  }
  return posLines;
}

// Compose program file.
function composeProgramFile() {
  // Process the number of lines of the program.
  var programName = getCurrentProgram();
  debug(DBGDUMP, 'composeProgram: currentProgram=' + programName);
  var progInfo = ProgramInfoManager.getSpecifiedProgInfo(programName);
  var programText = getAllProgramText(); // pickup from editor
  var mnTextArray = makeEachLineArray(programText); // each row (string) to array
  progInfo.setEditMnemonicArray(mnTextArray);
  // Process the record of position data.
  var currentAttr = progInfo.getEditAttrValue();
  var posTextArray = (currentAttr.MTNGRP != 0) ? updatePositionText(progInfo) : []; // each position to array
  progInfo.setEditPositionArray(posTextArray);
  // File transport...
  // The program divides instructions and positions and saves them.
  // The save all at once process is not supported now.

  if (isModifiedText() || isProgramModified()) {
    saveEditLine();
    saveEditLineTimer = setTimeout(function () {
      waitSaveEditLine(programName);
    }, 100); // Keep a interval
  } else {
    putProgramPosition(programName); // api
  }
}

// Make position text array of current position table
function updatePositionText(progInfo) {
  var posRecords = getAllPosition();  // poswin
  var updPosition = makePosition(progInfo, posRecords);
  return updPosition;
}

// Buildup program file data.
// for Future. (Currently, it may not be called from anywhere.)
function buildupProgramFile(programName) {
  var fileText = '';
  fileText = '/' + tagNameList[TAGPROG].name + '  ' + programName + CODECRLF;
  // Attribute write back
  fileText += '/' + tagNameList[TAGATTR].name + CODECRLF;
  var progInfo = ProgramInfoManager.getSpecifiedProgInfo(programName);
  var attrList = progInfo.getAttribute();   // Get File attribute list
  for (var index in attrList) {
    var attrItem = attrList[index]; // get 1 item
    var updateVal = attrItem.val;
    var mdfyTarget = progInfo.getUpdateAttribute(attrItem.key); // get update target attr.
    if (mdfyTarget != null) { // target entry key is modify target?
      switch (mdfyTarget) {
        case 'modified': // modify modified date time
          var formatStr = progInfo.getDefaultAttrDate(getFileIOLang());
          var nowDate = new Date();
          updateVal = progInfo.formatDateStr(nowDate, formatStr);
          break;
        case 'linecount': // modify line count
          updateVal = progInfo.getMnemonicLineCount();
          break;
        default:
          // especially none
          break;
      }
    }
    fileText += attrItem.key;
    fileText += '\t= ' + updateVal + CODECRLF;
  }
  // Application
  fileText += '/' + tagNameList[TAGAPPL].name + CODECRLF;
  // Implement each appl data to text here......
  // Mnemonic set
  fileText += '/' + tagNameList[TAGMN].name + CODECRLF;
  var mnemonicLine = progInfo.getEditMnemonicArray();
  for (var index in mnemonicLine) {
    fileText += mnemonicLine[index];
  }
  // Position set
  fileText += '/' + tagNameList[TAGPOS].name + CODECRLF;
  var positionText = progInfo.getEditPositionArray();
  for (var index in positionText) {
    fileText += positionText[index];
  }
  // End mark set
  fileText += '/' + tagNameList[TAGEND].name + CODECRLF;
  return fileText;
}

// Construct Extend Axis Position data.
function constructExtendAxis(recWork, grp) {
  var extText = '';
  var extAxes = getExtendAxesCount(grp);
  if (extAxes > 0) {
    extText += ',' + CODECRLF;
    for (var ext = 1; ext <= extAxes; ext++) {
      if (ext > 1) {
        extText += ',';
      }
      extText += CODETAB + 'E' + ext + '= ' + convertFtoA(recWork['EXT' + ext]) + ' ' + getJointUnitStr(grp, ext + 5);
    }
  }
  return extText;
}
/**
 * Construct position text.
 * ex) P[n]{ GP:n UF : n, UT : n, CONFIG:'xxxxx', ... };
 * (IN) rec : Target position record
 * (IN) orgPos : Original position data
 * (IN) grpCount : Group count
 * Return : Positoin text
 */
function constructPositionText(rec, orgPos, grpCount) {
  var recWork = $.extend({}, rec); // Copy record data.
  // Gen. pos header
  var posText = '';
  posText += 'P[' + recWork.rowno;
  if (recWork.Comment != '') {
    posText += ':"' + recWork.Comment + '"';
  }
  posText += ']{' + CODECRLF;
  // Gen. group block
  for (var grp = 1; grp <= grpCount; grp++) {
    // group header
    posText += '   GP' + grp + ':' + CODECRLF;
    // next group data overwrite to work area
    if (grp > 1) {
      recWork = convertGroupPosition(orgPos.posData[grp - 1]);
    }
    if (recWork.frame == COORDINATECART) {
      posText += CODETAB + 'UF : ' + recWork.UF + ', ';
      posText += 'UT : ' + recWork.UT + ', ';
    } else {
      // If the UF / UT value has already been set, it use the set value.
      // Otherwise, the default value is used.
      posText += CODETAB + 'UF : ' + ((recWork.UF !== '') ? recWork.UF : getUfUtSystemValue(grp).UF) + ', ';
      posText += 'UT : ' + ((recWork.UT !== '') ? recWork.UT : getUfUtSystemValue(grp).UT) + ', ';
    }
    // Either rec.X or rec.J1 may be used for judgment.
    if ((recWork.Config != undefined) && (recWork.Config != '')) {
      posText += CODETAB + CODETAB + 'CONFIG:\'' + recWork.Config + '\',';
    }
    posText += CODECRLF;
    // position data
    if (recWork.frame == COORDINATECART) {  // Cartesian
      posText += CODETAB + 'X = ' + convertFtoA(recWork.X) + '  mm,';
      posText += CODETAB + 'Y = ' + convertFtoA(recWork.Y) + '  mm,';
      posText += CODETAB + 'Z = ' + convertFtoA(recWork.Z) + '  mm,' + CODECRLF;
      posText += CODETAB + 'W = ' + convertFtoA(recWork.W) + ' deg,';
      posText += CODETAB + 'P = ' + convertFtoA(recWork.P) + ' deg,';
      posText += CODETAB + 'R = ' + convertFtoA(recWork.R) + ' deg';
    } else {  // Joint
      if (recWork.J1 !== '') {
        posText += CODETAB + 'J1= ' + convertFtoA(recWork.J1) + ' ' + getJointUnitStr(grp, 0); //' deg';
      }
      if (recWork.J2 !== '') {
        posText += ',' + CODETAB + 'J2= ' + convertFtoA(recWork.J2) + ' ' + getJointUnitStr(grp, 1);
      }
      if (recWork.J3 !== '') {
        posText += ',' + CODETAB + 'J3= ' + convertFtoA(recWork.J3) + ' ' + getJointUnitStr(grp, 2);
      }
      if (recWork.J4 !== '') {
        posText += ',' + CODECRLF + CODETAB + 'J4= ' + convertFtoA(recWork.J4) + ' ' + getJointUnitStr(grp, 3);
      }
      if (recWork.J5 !== '') {
        posText += ',' + CODETAB + 'J5= ' + convertFtoA(recWork.J5) + ' ' + getJointUnitStr(grp, 4);
      }
      if (recWork.J6 !== '') {
        posText += ',' + CODETAB + 'J6= ' + convertFtoA(recWork.J6) + ' ' + getJointUnitStr(grp, 5);
      }
    }
    // extend axis
    posText += constructExtendAxis(recWork, grp);
    posText += CODECRLF;
  }
  posText += '};' + CODECRLF;
  return posText;
}

// Save file error has occured.
function saveFileError(saveParam) {
  // Call from error alert dialog.
  // process is especially none.
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                /**
 * Controller I/O interface module.
 * Created : 8/7/2017   Base code created by FA...
 * Modified: 2/28/2018  Separate common processing into common_io.
 *           Omit details
 *
 * Remarks : In order to analyze the code easily and naturally,
 *           we unified the description as follows.
 *           = In the if statement, the variable is placed
 *             on the left side and the values such as constant
 *             is placed on the right side.
 *           = The style of control statement conforms to java's convention.
 */

var IO_COMFAILURE = 0xffffff;

/**
 * Create new program.
 * (IN) prog_name : Program name to create.
 * (IN) callback : A callback function to receive the result of create.
 *          arg1 : status 0=Success, !0=Error.
 *          arg2 : Program name.
 */
function createPrg(prog_name, callback) {
	$.getJSON("/COMET/rpc?func=MMCREMN&prog_name=" + encodeASCII(prog_name), function (json) {
		if (json.FANUC.RPC != undefined) {
			json.FANUC.RPC[0].status = json.FANUC.RPC[0].status.toLowerCase();
			if (callback != undefined) {
				callback(json.FANUC.RPC[0].status, prog_name);
			}
		} else {
			top.rpcmc_rprintf("[rpcmc] unexpected reply " + JSON.stringify(json));
		}
	}).fail(function (xhr, textStatus, errorThrown) {
		debug(DBGFATAL, 'Communication failed.(' + textStatus + ')');
		callback(IO_COMFAILURE, prog_name);
	});
}

/**
 * Delete program.
 * (IN) prog_name : Program name to delete.
 * (IN) callback : A callback function to receive the result of delete.
 *          arg1 : status 0=Success, !0=Error.
 *          arg2 : Program name.
 */
function deletePrg(prog_name, callback) {
	$.getJSON("/COMET/rpc?func=MMDELPRG&prog_name=" + encodeASCII(prog_name), function (json) {
		if (json.FANUC.RPC != undefined) {
			json.FANUC.RPC[0].status = json.FANUC.RPC[0].status.toLowerCase();
			if (callback != undefined) {
				callback(json.FANUC.RPC[0].status, prog_name);
			}
		} else {
			top.rpcmc_rprintf("[rpcmc] unexpected reply " + JSON.stringify(json));
		}
	});
}

/**
 * Rename program.
 * (IN) src_name : Source program name. Rename from...
 * (IN) chg_name : Destination program name. Rename to...
 * (IN) callback : A callback function to receive the result of rename.
 *          arg1 : status 0=Success, !0=Error.
 *          arg2 : Program name after rename.
 * (IN) cbArg : Callback argument object. [5/14/2019] Add
 */
function renamePrg(src_name, chg_name, callback, cbArg) {
  $.getJSON("/COMET/rpc?func=MMRENPRG&src_name=" + encodeASCII(src_name) + "&chg_name=" + encodeASCII(chg_name), function (json) {
    if (json.FANUC.RPC != undefined) {
      json.FANUC.RPC[0].status = json.FANUC.RPC[0].status.toLowerCase();
      if (callback != undefined) {
        callback(json.FANUC.RPC[0].status, chg_name, cbArg); // modify: src_name to chg_name, add: cbArg
      }
    } else {
      top.rpcmc_rprintf("[rpcmc] unexpected reply " + JSON.stringify(json));
    }
  });
}

/**
 * Add or replace line data to program
 * (IN) prog_name : target program file name.
 * (IN) in_buf : data of line.
 * (IN) line_num : line number.
 * (IN) opt_sw : Write mode.
 *      0=Overwrite, 1=Insert to specified line, 2=Insert after specified line
 * (IN) callback : A callback function to receive the result of edit prog.
 *          arg1 : status 0=Success, !0=Error.
 *          arg2 : Program name after rename.
 * (IN) cbArg : Callback argument object. [3/14/2019] Add
 */
var errorInfo = ''; // Plan to change it later
function editPrg(prog_name, in_buf, line_num, opt_sw, callback, cbArg) {
	$.getJSON("/COMET/rpc?func=SCEDIT&prog_name=" + encodeASCII(prog_name) +
		"&in_buf=" + in_buf + "&lin_num=" + line_num + "&opt_sw=" + opt_sw, function (json) {
		if (json.FANUC.RPC != undefined) {
			json.FANUC.RPC[0].status = json.FANUC.RPC[0].status.toLowerCase();
			if (json.FANUC.RPC[0].status != IO_SUCCESS) {
				if (json.FANUC.RPC[0].status == IOSTAT_ASBN_002) {
					errorInfo = "Invalid encoding of line on line " + json.FANUC.RPC[0].row + ", column " + json.FANUC.RPC[0].col;
					debug(DBGERROR, 'editPrg: Status error :' + errorInfo);
				}
			}
			if (callback != undefined) {
				callback(json.FANUC.RPC[0].status, prog_name, cbArg);
			}
		} else {
			top.rpcmc_rprintf("[rpcmc] unexpected reply " + JSON.stringify(json));
		}
	});
}

/**
 * get program attribute
 * (IN) prog_name : Program name
 * (IN) attr : Attribute type
 *             MM_OWNER_C = Set owner, MM_COMMENT_C = Set comment ...
 * (IN) callback : A callback function to receive status.
 *          arg1 : Status
 *          arg2 : Program name
 *          arg3 : Attribute type
 *          arg4 : Attrubute value
 */
function getAttr(prog_name, attr, callback) {
	$.getJSON("/COMET/rpc?func=MMGETATR&prog_name=" + encodeASCII(prog_name) + "&attr=" + attr, function (json) {
		if (json.FANUC.RPC != undefined) {
			json.FANUC.RPC[0].status = json.FANUC.RPC[0].status.toLowerCase();
			if (callback != undefined) {
				callback(json.FANUC.RPC[0].status, prog_name, attr, json.FANUC.RPC[0].buf);
			}
		} else {
			top.rpcmc_rprintf("[rpcmc] unexpected reply " + JSON.stringify(json));
		}
	});
}

/**
 * set program attribute
 * (IN) prog_name : Program name
 * (IN) attr : Attribute type
 *             MM_OWNER_C = Set owner, MM_COMMENT_C = Set comment ...
 * (IN) value : Attribute value.
 * (IN) callback : A callback function to receive status.
 *          arg1 : Status
 *          arg2 : Program name
 */
function setAttr(prog_name, attr, value, callback) {
	$.getJSON("/COMET/rpc?func=MMSETATR&prog_name=" + encodeASCII(prog_name) + "&attr=" + attr + "&in_buf=" + value, function (json) {
		if (json.FANUC.RPC != undefined) {
			json.FANUC.RPC[0].status = json.FANUC.RPC[0].status.toLowerCase();
			if (callback != undefined) {
				callback(json.FANUC.RPC[0].status, prog_name);
			}
		} else {
			top.rpcmc_rprintf("[rpcmc] unexpected reply " + JSON.stringify(json));
		}
	});
}

/**
 * Add or replace position data to program
 * (IN) prog_name : Program name
 * (IN) in_buf : ASCII format position data.
 *      ex) var pos = 'P[1:"Pick Standby"]' +
 *                    '{GP1:UF:0,UT:1,CONFIG:\'N%20U%20T ,0,0,0\',' +
 *                    'X=1807.000 mm,Y=0.000 mm,Z=1300.000 mm,' +
 *                    'W=180.000 deg,P=-90.000 deg,R=0.000 deg};';
 * (IN) callback  : A callback function to set position.
 *                  arg1: status
 *                  arg2: program name
 */
function editPos(prog_name, in_buf, callback) {
	$.getJSON("/COMET/rpc?func=SCSETPOS&prog_name=" + encodeASCII(prog_name) + "&in_buf=" + in_buf, function (json) {
		if (json.FANUC.RPC != undefined) {
			json.FANUC.RPC[0].status = json.FANUC.RPC[0].status.toLowerCase();
			if (json.FANUC.RPC[0].status != IO_SUCCESS) {
				if (json.FANUC.RPC[0].status == IOSTAT_ASBN_002) {
					errorInfo = "Invalid encoding of line on line " + json.FANUC.RPC[0].row + ", column " + json.FANUC.RPC[0].col;
					debug(DBGERROR, 'editPos: Status error :' + errorInfo);
				}
			}
			if (callback != undefined) {
				callback(json.FANUC.RPC[0].status, prog_name);
			}
		} else {
			top.rpcmc_rprintf("[rpcmc] unexpected reply " + JSON.stringify(json));
		}
	});
}

/**
 * Delete program line.
 * (IN) prog_name : Target program name.
 * (IN) line_num : Target delete line number.
 * (IN) num : Delete line count.
 * (IN) callback : A callback function to receive the program list.
 *          arg1 : Status code.
 *          arg2 : Program name.
 *          arg3 : Delete line number.
 * (IN) cbArg : Callback argument object. [3/14/2019] Add
 */
function delLine(prog_name, line_num, num, callback, cbArg) {
	$.getJSON("/COMET/rpc?func=SCDELETE&prog_name=" + encodeASCII(prog_name) + "&lin_num=" + line_num + "&num=" + num, function (json) {
		if (json.FANUC.RPC != undefined) {
			json.FANUC.RPC[0].status = json.FANUC.RPC[0].status.toLowerCase();
			if (callback != undefined) {
				callback(json.FANUC.RPC[0].status, prog_name, line_num, json.FANUC.RPC[0].del_num, cbArg);
			}
		} else {
			top.rpcmc_rprintf("[rpcmc] unexpected reply " + JSON.stringify(json));
		}
	});
}

/**
 * Get program (name) list.
 * (IN) datatype : Types of acquired data
 *                 TV_PRG_ALL = Program name,
 *                 TV_PRGCMT_ALL = Program name and comment ...
 * (IN) prg_typ : Program type
 *                MM_MNEPRG_C = TP program,
 *                MM_KRLPRG_C = KAREL program,
 *                MM_RECENT = Recent program,
 *                MM_NCVAR_C = All programs with comment ...
 * (IN) sub_typ : Program sub type
 *                MM_SUB_UNDEF_C = Unspecified
 *                MM_SUB_MACRO_C = Macro
 *                MM_SUB_COND_C = Condition
 *                MM_SUB_COLLECT_C = Collection ...
 * (IN) callback : A callback function to receive the program list.
 *          arg2 : Program name list. (Array of String)
 *          arg3 : Program count. (list length)
 */
function lstProg(datatype, prg_typ, sub_typ, callback) {
	$.getJSON("/COMET/rpc?func=TXLSTPRG_FC&datatype=" + datatype + "&prg_typ=" + prg_typ + "&sub_typ=" + sub_typ, function (json) {
		if (json.FANUC.RPC != undefined) {
			json.FANUC.RPC[0].status = json.FANUC.RPC[0].status.toLowerCase();
			if (json.FANUC.RPC[0].status != IO_SUCCESS) {
				handle_error(json.FANUC.RPC[0].status);
			}
			if (callback != undefined) {
				var programs = json.FANUC.RPC[0].programs;
				var n_programs = programs.length;
				callback(datatype, programs, n_programs);
			}
		} else {
			top.rpcmc_rprintf("[rpcmc] unexpected reply " + JSON.stringify(json));
		}
	}).fail(function (xhr, textStatus, errorThrown) {
    lstProgErr();
    top.rpcmc_rprintf(IO_COMFAILURE, [], 0);
	});
}
function lstProgErr() {
  if(isScrModeProgAttr()) {
    var btnObj = {
      btnData :{ btn1 : top.irpDlgBtnOC.btn1 },
    };
    top.openCmpConfirm(webPage, window, 'alreadydelerrdlg', resources['dlgMsgPrgLoadError'], btnObj, true);
  } else {
    defineDialog.open(null, '#failedloaderrdlg', 'dlgMsgPrgLoadError');
    setCurrentProgram("");
    changeProgStat({prog: '', line: 0, stat: -1, shellLine: 0, initSetLineFlag: false});
    progLoadError = true;
  }
}

function setLine(prog_name, line_num, callback) {
	$.getJSON("/COMET/rpc?func=TXSETLIN&prog_name=" + encodeASCII(prog_name) + "&line_num=" + line_num, function (json) {
		if (json.FANUC.RPC != undefined) {
			json.FANUC.RPC[0].status = json.FANUC.RPC[0].status.toLowerCase();
			if (json.FANUC.RPC[0].status != IO_SUCCESS) {
				handle_error(json.FANUC.RPC[0].status);
			}
			if (callback != undefined) {	// add call callback
				callback(json.FANUC.RPC[0].status, prog_name);
			}
		}
	});
}


/**
 * Start Program.
 * (IN) prog_name : Program name.
 * (IN) callback : A callback function to receive the program list.
 *          arg1 : Status code.
 *          arg2 : Program name.
 */
function execProgram(prog_name, callback) {
	$.getJSON("/COMET/rpc?func=TXCHGPRG&prog_name=" + encodeASCII(prog_name), function (json) {
		if (json.FANUC.RPC != undefined) {
			json.FANUC.RPC[0].status = json.FANUC.RPC[0].status.toLowerCase();
			if (json.FANUC.RPC[0].status != IO_SUCCESS) {
				top.rpcmc_rprintf("TXCHGPRG error status:" + json.FANUC.RPC[0].status);
			}
			if ((!isProgramStepMode()) && (isEnableOn())) {	// refer prgwin and toolbar
				if (top.dlg_shift_open != undefined) {
					top.dlg_shift_open("Program is Running");
				} else {
					console.log('Fatal: *** dlg_shift_open is undefined. ***');
				}
			}
      shiftFWD();
			if (callback != undefined) {	// add call callback
				callback(json.FANUC.RPC[0].status, prog_name);
			}
		}
	});
}

/**
 * Start Program(SHIFT+FOWARD)
 */
function shiftFWD() {
  top.sendKey("R-shift", 1);
  top.sendKey("FWD", 1);
  top.sendKey("FWD", 0);
}

/**
 * Pause Program.
 * Annotation : Delay processing is necessary to make temporary stop work.
 */
function pauseProgram() {
	top.sendKey("Hold", 1);
	setTimeout(function () { // add timeout
		top.sendKey("Hold", 0);
		setTimeout(function () { // add timeout
			top.sendKey("R-shift", 0);
			top.sendKey("L-shift", 0);
		}, 100);
	}, 500);
}

/**
 * Stop Program.
 * (IN) prog_name : Program name.
 * (IN) callback : A callback function to stop excute .
 *          arg1 : Status code.
 *          arg2 : Program name.
 */
function abortProgram(prog_name, callback) {
	if (!top.g_jitpky2) { // [Add] by FAC
		// This is not the iPendant connection
		return;
	}
	$.getJSON("/COMET/rpc?func=PGABORT&task_name=" + encodeASCII(prog_name), function (json) {
		if (json.FANUC.RPC != undefined) {
			json.FANUC.RPC[0].status = json.FANUC.RPC[0].status.toLowerCase();
			if (json.FANUC.RPC[0].status != IO_SUCCESS) {
				top.rpcmc_rprintf("stopProgram error status");
				handle_error(json.FANUC.RPC[0].status);
			}
			top.sendKey("R-shift", 0);
			if (callback != undefined) {
				callback(json.FANUC.RPC[0].status, prog_name);  // omit line_num
			}
		} else {
			top.rpcmc_rprintf("[rpcmc] unexpected reply " + JSON.stringify(json));
		}
	});
}

/**
 * Copy Program
 * (IN) src_name : Source program name
 * (IN) chg_name : Destination program name
 * (IN) callback : A callback function to copy program.
 *          arg1 : Status code.
 *          arg2 : Source program name.
 *          arg3 : Destination program name.
 */
function copyPrg(src_name, chg_name, callback) {
	$.getJSON("/COMET/rpc?func=MNCPYPRG&src_name=" + encodeASCII(src_name) + "&chg_name=" + encodeASCII(chg_name), function (json) {
		if (json.FANUC.RPC != undefined) {
			json.FANUC.RPC[0].status = json.FANUC.RPC[0].status.toLowerCase();
			if (callback != undefined) {
				callback(json.FANUC.RPC[0].status, src_name, chg_name);
			}
		} else {
			rpcmc_rprintf("[rpcmc] unexpected reply " + JSON.stringify(json));
		}
	});
}

/**
 * Delete position data
 * (IN) prog_name : Target program name
 * (IN) pos_num : Delete position number
 * (IN) callback : A callback function to delete position.
 *          arg1 : Status code.
 *          arg2 : Target program name.
 *          arg3 : Delete position number.
 */
function delPos(prog_name, pos_num, callback) {
	$.getJSON("/COMET/rpc?func=MMDELPOS&prog_name=" + encodeASCII(prog_name) + "&pos_num=" + pos_num, function (json) {
		if (json.FANUC.RPC != undefined) {
			json.FANUC.RPC[0].status = json.FANUC.RPC[0].status.toLowerCase();
			if (callback != undefined) {
				callback(json.FANUC.RPC[0].status, prog_name, pos_num);
			}
		} else {
			rpcmc_rprintf("[rpcmc] unexpected reply " + JSON.stringify(json));
		}
	});
}

/**
 * Change Program
 * (IN) prog_name : Target program name
 * (IN) callback  : A callback function to change program.
 *          arg1 : Status code.
 *          arg2 : Target program name.
 * (IN) cbArg : Callback argument object. [3/14/2019] Add
 */
function chgProg(prog_name, callback, cbArg) {
	$.getJSON("/COMET/rpc?func=TXCHGPRG&prog_name=" + encodeASCII(prog_name), function (json) {
		if (json.FANUC.RPC != undefined) {
			json.FANUC.RPC[0].status = json.FANUC.RPC[0].status.toLowerCase();
			if (callback != undefined) {
				callback(json.FANUC.RPC[0].status, prog_name, cbArg);
			}
		} else {
			rpcmc_rprintf("[rpcmc] unexpected reply " + JSON.stringify(json));
		}
	});
}

/**
 * Get Program Type.
 * (IN) prog_name: Program name.
 * (IN) callback : A callback function to get program type
 *                 arg1: status
 *                 arg2: program type
 *                 arg3: sub type
 */
function getPrgType(prog_name, callback) {
	$.getJSON("/COMET/rpc?func=MMGETTYP&prog_name=" + encodeASCII(prog_name), function (json) {
		if (json.FANUC.RPC != undefined) {
			json.FANUC.RPC[0].status = json.FANUC.RPC[0].status.toLowerCase();
			if (callback != undefined) {
				var prg_typ = json.FANUC.RPC[0].prg_typ;
				var sub_typ = json.FANUC.RPC[0].sub_typ;
				callback(json.FANUC.RPC[0].status, prg_typ, sub_typ);
			}
		} else {
			rpcmc_rprintf("[rpcmc] unexpected reply " + JSON.stringify(json));
		}
	});
}

/**
 * Change Program Type.
 * (IN) prog_name: Program name.
 * (IN) sub_type  : Program sub type.
 * (IN) callback : A callback function to set program type
 *                 arg1: status
 * 				   arg2: program name
 */
function chgPrgType(prog_name, sub_type, callback) {
	$.getJSON("/COMET/rpc?func=MMCHGTYP&prog_name=" + encodeASCII(prog_name) + "&sub_type=" + sub_type, function (json) {
		if (json.FANUC.RPC != undefined) {
			json.FANUC.RPC[0].status = json.FANUC.RPC[0].status.toLowerCase();
			if (callback != undefined) {
				callback(json.FANUC.RPC[0].status, prog_name);
			}
		} else {
			rpcmc_rprintf("[rpcmc] unexpected reply " + JSON.stringify(json));
		}
	});
}


function recPos(prog_name,
    pos_idx,
    pos_rep, // (in)  position format representation (KXYZWPR)
    pos_type, // (in)  position record or display type (TXML_TP_REC_TYPE)
    grp_num, // (in)  group number (1, 2, ...)
    callback, // (in)  callback function when data received
    callbackarg) { // (in)  callback argument
	$.getJSON("/COMET/rpc?func=RECPOS&prog_name=" + encodeASCII(prog_name) + "&pos_idx=" + pos_idx + "&pos_rep=" + pos_rep +
        "&pos_type=" + pos_type + "&grp_num=" + grp_num,
        function (json) {
			if (json.FANUC.RPC != undefined) {
				json.FANUC.RPC[0].status = json.FANUC.RPC[0].status.toLowerCase();
				if (callback != undefined) {
					callback(json.FANUC.RPC[0].status, prog_name, json.FANUC.RPC[0].value, callbackarg);
				}
			} else {
				top.rpcmc_rprintf("[rpcmc] unexpected reply " + JSON.stringify(json));
			}
		});
}                                                                                                                                                                                                                                                                                                                                                                                                                                                          /**********************************************************************
 * PC Editor script
 * for JOG Window.
 * Created: 2017/06/26 FSI
 *
 */

// JOG Frame list value definition
var frameMaxNumList = [0, 5, 0, 9, 10, 0];
var frameNumValList = [0, 1, 0, 1, 1, 0];
var frameCurrentNum = 0;
var MAX_FRAMENUM = 5;
var ZINDEX_IPTNUM = 9999;	// Change .iptframenum z-index to...
var ZINDEX_FRMNUM = 9980;


// Get JOG Frame number
function getJogFrameNumber(kind) {
	return ((kind >= 0) && (kind < frameNumValList.length)) ? frameNumValList[kind] : null;
}

// Update JOG Frame number
function updateJogFrameNumber(index, value, refresh) {
	frameNumValList[index] = value;
	if (refresh) {	// frame number refresh?
		if (getSelFrameIndex() == index) {	// match selected frame kind
			$('#iptframenum').val(value);	// set frame value
		}
	}
}

/**
 * Acquisition of client position in pointing device.
 * @param evt event object
 * @return Client position. (.clientX, .clientY)
 */
function getJogWinClient(evt) {
	var tempEvent = { pageX: 0, pageY: 0, clientX: 0, clientY: 0 };
	if (evt.type.indexOf("touch") == 0) {
		// For iPad Emu
		tempEvent.pageX = evt.touches[0].pageX;
		tempEvent.pageY = evt.touches[0].pageY;
		// Used with elementFromPoint
		tempEvent.clientX = evt.touches[0].clientX;
		tempEvent.clientY = evt.touches[0].clientY;
	} else if (evt.type.indexOf("mouse") == 0) {
		tempEvent.clientX = evt.clientX;
		tempEvent.clientY = evt.clientY;
	}
	return tempEvent;
}

/*
* Initialize Jog window.
*/
var isFirstInitJogWin = false;
var jointBtnIdList = ['j1', 'j2', 'j3', 'j4', 'j5', 'j6'];
var jointExtBtnId = ['e1', 'e2', 'e3'];
var jointRowPost = 'row';
function initJogDialWin() {
	if (isFirstInitJogWin) {	// First time only do the initialization process.
		debug(DBGINFO, 'Initialize Jog Window Joint button.');
		var crntGrpNum = getCurrentGroupNum();
		isFirstInitJogWin = false;
		if (!isTablet) {	// If PC, change stick size etc...
			initPCStickButton();
		}
		var extAxes = getExtendAxesCount(crntGrpNum);
		if (extAxes == 0) {	// additional axes is none...
			$('#jogextaxes').hide();
			$('#jogjntaxes').css({ 'border': '0', 'left': '75px' });	// w:135px; left:180px;
		}
		// Calculate the rate according to the number of buttons
		var robotAxes = getJointRobotAxes(crntGrpNum);
		var btnTopRate = Math.floor(96 / robotAxes);	// start at top 4%.
		$(jointBtnIdList).each(function (i) {
			if (i >= robotAxes) {
				var btnIdStr = '#' + jointBtnIdList[i] + jointRowPost;
				$(btnIdStr).hide();
			} else {
				var btnTop = ((btnTopRate * i) + 4);
				$('.jogj' + (i + 1) + 'row').css({ 'top': btnTop + '%' });
			}
		});
		$(jointExtBtnId).each(function (i) {
			if (i >= extAxes) {
				var btnIdStr = '#' + jointExtBtnId[i] + jointRowPost;
				$(btnIdStr).hide();
			}
		});
		getCartFrameNumber(FRMVAL_USER, crntGrpNum, getCurrentFrameNumbers);	// api
		setJogButtonStat();
	}
}
/*
* Resize Jog dial image window.
* Change the style of the coordinate system information according to the expansion and contraction of the window size.
*/
function resizeJogDial() {
	// Keep it for the future
}

/*
 * Callback function of get current frame kind.
 */
function getFrameKindCallback(progName, varName, typeCode, frameKindStr) {
	var kindIndex = (frameKindStr.length > 0) ? parseInt(frameKindStr) : FRMVAL_WORLD;
	if ((kindIndex == FRMVAL_JOINT) ||
		(kindIndex == FRMVAL_JOG)) {		// [9/18/2018] Emergency response: Remove Jog option...
		kindIndex = FRMVAL_WORLD;
	}
	selFrmVal = frameValueList[kindIndex];
	if ((selFrmVal == undefined) ||
		((selFrmVal != undefined) &&
			((kindIndex < 0) || (kindIndex >= frameValueList.length)))) {  // if selFrmVal is undefined
		kindIndex = FRMVAL_WORLD;
		selFrmVal = frameValueList[kindIndex];
	}
	setSelFrameListVal(selFrmVal);
	if (!isScrModePcEditor()) {	// Other than editor.
		$('#selframelist').html(resources['lbl' + selFrmVal] + ' <div id="selframebtn" class="selframebtn">' +
			'<img id="selbtnimg" class="selbtnimg" src="images/select_icon.png">' +
			'</div>');
	} else {
		$('#selframelist').html(resources['lbl' + selFrmVal] + ct_jogselframe);	// layout.js
	}
	frameCurrentNum = frameNumValList[kindIndex];
	if (isiPad) {
		$('#iptframenum').attr({ 'value': frameCurrentNum });
	} else {
		$('#iptframenum').val(frameCurrentNum);	// set frame value
	}
	if (kindIndex == FRMVAL_WORLD) {
		setFrameNumberInput(true);	// Toggle text box to disable.
	}
	debug(DBGDUMP, 'getFrameKindCallback:' + frameCurrentNum);
	changeFrameCart();
	getCartFrameMaxNumber(FRMVAL_USER, getFrameMaxNumCallback);
}
/*
 * Get number of specified frame.
 * Save global area.
 */
function getCurrentFrameNumbers(progName, varName, typeCode, frameNumStr, frmIndex) {
	debug(DBGDUMP, 'getCurrentFrameNumbers:[' + frmIndex + ']=' + frameNumStr);
	var crntGrpNum = getCurrentGroupNum();
	var frameNumber = parseInt(frameNumStr);
	switch (frmIndex) {
		case FRMVAL_USER:
			updateJogFrameNumber(FRMVAL_USER, frameNumber, false);
			getCartFrameNumber(FRMVAL_TOOL, crntGrpNum, getCurrentFrameNumbers);	// api
			return;
		case FRMVAL_TOOL:
			updateJogFrameNumber(FRMVAL_TOOL, frameNumber, false);
			getCartFrameNumber(FRMVAL_JOG, crntGrpNum, getCurrentFrameNumbers);	// api
			return;
		case FRMVAL_JOG:
			updateJogFrameNumber(FRMVAL_JOG, frameNumber, false);
	}
	getCartFrameKind(crntGrpNum, getFrameKindCallback);	// api
}
/**
 * Get max number(count) of specified frame.
 * Save global area.
 */
function getFrameMaxNumCallback(progName, varName, typeCode, framMaxStr, frmIndex) {
	debug(DBGDUMP, 'getFrameMaxNumCallback:[' + frmIndex + ']=' + framMaxStr);
	var frameMax = parseInt(framMaxStr);
	switch (frmIndex) {
		case FRMVAL_USER:
			frameMaxNumList[FRMVAL_USER] = frameMax;
			getCartFrameMaxNumber(FRMVAL_TOOL, getFrameMaxNumCallback);
			return;
		case FRMVAL_TOOL:
			frameMaxNumList[FRMVAL_TOOL] = frameMax;
	}
	debug(DBGDUMP, 'getFrameMaxNumCallback: completeJogInit!');
	completeJogInit = true;	// fileio
}
// Send frame type cartesian to controller.
function changeFrameCart() {
	var selIndex = getSelFrameIndex();
	sendJogTypeCart(getCurrentGroupNum(), selIndex);	// api
}
// Send frame type joint to controller.
function changeFrameJoint() {
	sendJogTypeJoint(getCurrentGroupNum());	// api
}
// Send set frame kind and number.
function callSetFrame(frameNum) {
	// Call I/F
	var selIndex = getSelFrameIndex();
	debug(DBGINFO, "Call I/F > Change Frame:" + selIndex + "[" + frameNum + "]");
	var crntGrpNum = getCurrentGroupNum();
	setFrameCoordinate(crntGrpNum, selIndex, frameNum);	// api
	updateUfUtValue(crntGrpNum, selIndex, frameNum);	// poswin
}
// Set the coordinate number input area to valid / invalid according to the coordinate system.
function setFrameNumberInput(disable) {
	$('#iptframenum').prop('disabled', disable);
	$('#hdrframenum').prop('disabled', disable);
	if (disable) {
		$('#iptframenum').addClass('framenumdisable');
		$('#hdrframenum').addClass('framenumdisable');
		frameNumTooltip('off', '', 0, 0);
	} else {
		$('#iptframenum').removeClass('framenumdisable');
		$('#hdrframenum').removeClass('framenumdisable');
	}
}
// Tooltip on/off function. ---> No use, but Keep it for the future.
function frameNumTooltip(onoff, message, minVal, maxVal) {
	var tipId = (isScrModePcEditor()) ? 'iptframehead' : 'iptframeheadTab';
	switch (onoff) {
		case 'on':
			$('#jogctrlarea').css('z-index', ZINDEX_IPTNUM);
			putOverlayScreen('framenum', 'forpopup');
			var placeHolderList = [];
			if (message == 'maxFrameNum') {
				var placeHolderMinNum = {};
				placeHolderMinNum.phStr = '$min$';
				placeHolderMinNum.repStr = minVal;
				placeHolderList[0] = placeHolderMinNum;
				var placeHolderMaxNum = {};
				placeHolderMaxNum.phStr = '$max$';
				placeHolderMaxNum.repStr = maxVal;
				placeHolderList[1] = placeHolderMaxNum;
			} else {
				placeHolderList = null;
			}
			tooltipDisp(tipId, message, placeHolderList);
			$('#iptframenum').css('z-index', ZINDEX_IPTNUM);
			$('#iptframenum').select().focus();
			break;
		case 'off':
			tooltipOff(tipId);
			$('#jogctrlarea').css({ 'z-index': '' });
			removeOverlayScreen('framenum');
			$('#iptframenum').css('z-index', ZINDEX_FRMNUM);
			break;
		default:
	}
}

// Depending on the TP button and the state of the alarm, change the appearance of the JOG button.
function setJogButtonStat() {
	enableJogButton = (isEnableOn() && !isAlarmOn()) ? true : false;	// Check alarm status
	if (enableJogButton) {
		$('.jogstickbtn').css({ 'background-color': '#67727E', 'cursor': 'pointer' });
	} else {
		if (isJogStickOn()) {	// If the JOG key is in operation, turn it OFF.
			sendJogStickKey(jogSendStat.key, 'off');
			resetJogStick(targetStickId);
		}
		$('.jogstickbtn').css({ 'background-color': '#c7ced7', 'cursor': '' });
	}
}

var jogSendStat = { key: '', id: '', grp: 1 };
var JOGSENDSTAT_SET = 1;
var JOGSENDSTAT_CLR = 0;
/*
* JOG Panel event process.
*/
var openSelFrameList = false;
function isOpenSelFrameList() {
	return openSelFrameList;
}
function setOpenSelFrameList(stat) {
	openSelFrameList = stat;
}
var selFrameValue = '';
function getSelFrameListVal() {
	return selFrameValue;
}
function setSelFrameListVal(frameVal) {
	selFrameValue = frameVal;
}
function getSelFrameIndex() {
	return $.inArray(getSelFrameListVal(), frameValueList);
}

// Supported when passive of event is true.
var outerFrameBox = {};
function createOuterFrameEvent() {
  var outerId = document.getElementById('outerframe');
  var jogstickbtnClass = document.getElementsByClassName('jogstickbtn');
  outerId.addEventListener('touchmove', ctrlTMForOuterFrame, { passive: false });
  outerId.addEventListener('touchleave', ctrlTLForOuterFrame, { passive: false });
  for (var i = 0; i < jogstickbtnClass.length; i++) {
    jogstickbtnClass[i].addEventListener('touchstart', ctrlTSForOuterFrame, { passive: false });
  }
  outerId.addEventListener('touchend', ctrlTEForOuterFrame, { passive: false });
}
function ctrlTMForOuterFrame(evt) {
  if (isJogStickOn()) {
    var curClient = getJogWinClient(evt);
    canselTextSelection();
    var curElem = document.elementFromPoint(curClient.clientX, curClient.clientY);
    tabletDebug('dump', 'X=[' + curClient.clientX + ']/Y=[' + curClient.clientY + ']/curId=(' + curElem.id + ')/targetId=(' + evt.target.id + ')');
    if ((curClient.pageX < outerFrameBox.left) || (curClient.pageX > outerFrameBox.right) ||
      (curClient.pageY < outerFrameBox.top) || (curClient.pageY > outerFrameBox.bottom)) {
      // If touch move position out of JOG panel area.
      sendJogStickKey(jogSendStat.key, 'off');
      resetJogStick(evt.target.id);
      evt.preventDefault();
      evt.stopPropagation();
      return false;
    }
    evt.preventDefault();
    moveJogStick(evt);
    evt.stopPropagation();
    return false;
  }
}
function ctrlTLForOuterFrame(evt) {
  if (isJogStickOn()) {
    canselTextSelection();
    sendJogStickKey(jogSendStat.key, 'off');
    resetJogStick(targetStickId);
    evt.preventDefault();
    evt.stopPropagation();
    return false;
  }
}
function ctrlTSForOuterFrame(evt) {
  startJogStick(evt);	// Just only pressed a button (stick).
  var tempOffset = $('#outerframe').offset();
  outerFrameBox.top = tempOffset.top;
  outerFrameBox.left = tempOffset.left;
  outerFrameBox.bottom = tempOffset.top + $('#outerframe').height();
  outerFrameBox.right = tempOffset.left + $('#outerframe').width();
  evt.preventDefault();
  evt.stopPropagation();
  return false;
}
function ctrlTEForOuterFrame(evt) {
  if (isJogStickOn()) {
    sendJogStickKey(jogSendStat.key, 'off');
    resetJogStick(targetStickId);
    evt.preventDefault();
    evt.stopPropagation();
  }
  canselTextSelection();
}

$(function () {
	// Click on select list
	$('#layoutarea').on('click touchstart', '#selframelist', function (evt) {
		//frameNumTooltip('off', '', 0, 0);
		if (openSelFrameList) {
			selectFrameListProc(evt);
			$('#selframebtn').css({ 'background-color': '' });
			closeSelFrameList();
		} else {
			// if error message is popup, ignore select list click.
			if ($('#tooltipbody').length != 0) {
				$('#iptframenum').select().focus();
				return;
			}

			$('#selframeddn').removeClass('ddnbtninactive');
			$('#selframeddn').addClass('ddnbtnactive');
			// Make Frame-list HTML.
			$('#selframelist').css({ 'border': '1px solid #6fc7d5' });
			$('#selbtnimg').attr('src', 'images/select_icon_open.png');
			var $frmoptbox = $('<div>', { 'id': 'selframeopt', 'class': 'selframebox' });
			var extAxes = getExtendAxesCount(getCurrentGroupNum());
			for (var frmidx = 0; frmidx < (frameValueList.length - 1); frmidx++) {
				if (frameValueList[frmidx] == 'FrameJog') {	// [9/18/2018] Emergency response:
					continue;	// Remove Jog coordinate system from option
				}
				var $frmoptitem = $('<div>', { 'id': frameValueList[frmidx], 'class': 'selframeopt' });
				$frmoptitem.html(resources['lbl' + frameValueList[frmidx]]);
				if (frameValueList[frmidx] == getSelFrameListVal()) {
					$frmoptitem.css({ 'background-color': '#0E6EB8', 'color': '#ffffff' });
				}
				if (isTablet) {
					$frmoptitem.css({ 'min-height': '36px', 'min-width': '120px', 'font-size': '16px' });
				}
				if (frmidx == 0) { 	// start of item
					$frmoptitem.addClass('selframeopttop');
				}
				if (extAxes == 0) {
					$frmoptitem.addClass('selframeoptend');
				}
				$frmoptbox.append($frmoptitem);
			}
			if (extAxes > 0) {
				var $frmoptitem = $('<div>', { 'id': frameValueList[FRMVAL_EXTEND], 'class': 'selframeopt' });
				$frmoptitem.html(resources['lbl' + frameValueList[FRMVAL_EXTEND]]);
				if (frameValueList[FRMVAL_EXTEND] == getSelFrameListVal()) {
					$frmoptitem.css({ 'background-color': '#0E6EB8', 'color': '#ffffff' });
				}
				if (isTablet) {
					$frmoptitem.css({ 'min-height': '36px', 'min-width': '120px', 'font-size': '16px' });
				}
				$frmoptitem.addClass('selframeoptend');
				$frmoptbox.append($frmoptitem);
			}
			$('#selframelist').append($frmoptbox);
			setOpenSelFrameList(true);
		}
		if (!isTablet) {
			$('#selframelist').focus();
		} else {
			$('#iptframenum').blur();
		}
		evt.preventDefault();
		evt.stopPropagation();
		return false;
	});

	// Procedure for frame list selection.
	function selectFrameListProc(evt) {
		var selFrmVal = evt.target.id;
		var selIndex = $.inArray(selFrmVal, frameValueList);
		if (selIndex < 0) {
			return;
		}
		setSelFrameListVal(selFrmVal);
		var disable = true;
		frameCurrentNum = frameNumValList[selIndex];
		tabletDebug('dump', 'frameCurrentNum=[' + frameCurrentNum + ']');
		if (isiPad) {
			$('#iptframenum').attr({ 'value': '' });
			setTimeout(function (evt) {
				$('#iptframenum').attr({ 'value': frameCurrentNum });
			}, 0);
		}
		$('#iptframenum').val(frameCurrentNum);	// Set frame nunmber
		if ((selIndex != FRMVAL_WORLD) &&
			(selIndex != FRMVAL_JOINT) &&
			(selIndex != FRMVAL_EXTEND)) {
			disable = false;
		} else {
			if (isTablet) {
				$('#iptframenum').blur();
				$('#layoutarea').focus();
			}
		}
		// refrect to frame name box
		if (!isScrModePcEditor()) {	// Other than editor.
			$('#selframelist').html(resources['lbl' + selFrmVal] + ' <div id="selframebtn" class="selframebtn">' +
				'<img id="selbtnimg" class="selbtnimg" src="images/select_icon.png">' +
				'</div>');
		} else {
			$('#selframelist').html(resources['lbl' + selFrmVal] + ct_jogselframe);	// layout.js
		}
		setFrameNumberInput(disable);
		if (!disable) {
			// focus set to number.
			$('#selframelist').blur();
			if (!isTablet) {
				$('#iptframenum').focus();
			}
		}
		var crntGrpNum = getCurrentGroupNum();
		if (selIndex == FRMVAL_JOINT) {
			$('#jogcarttbl').hide();
			$('#horzjntbtn').show();
			$('#horzjnt2btn').show();
			$('#horzextbtn').hide();
			$('#jogjointtbl').show();
			sendJogTypeJoint(crntGrpNum);	// api
		} else if (selIndex == FRMVAL_EXTEND) {
			$('#jogcarttbl').hide();
			$('#horzjntbtn').hide();
			$('#horzjnt2btn').hide();
			$('#horzextbtn').show();
			$('#jogjointtbl').show();
			sendJogTypeJoint(crntGrpNum);	// api
		} else {
			$('#jogjointtbl').hide();
			$('#jogcarttbl').show();
			sendJogTypeCart(crntGrpNum, selIndex);
		}
	}

	$('#layoutarea').on('touchstart', '#iptframenum', function (evt) {
		$('#iptframenum').focus();
	});

	$('#layoutarea').on('input', '#iptframenum', function (evt) {
		var frameNum = $('#iptframenum').val();
		if (frameNum.length > MAX_FRAMENUM) {
			frameNum = frameNum.substr(0, MAX_FRAMENUM);
		}
		frameNum = frameNum.replace(/[^0-9]+/i, '');
		var selIndex = getSelFrameIndex();
		if ((selIndex != FRMVAL_WORLD) &&
			(selIndex != FRMVAL_JOINT) &&
			(selIndex != FRMVAL_EXTEND)) {
			if (frameNum.length > 0) {
				if ((selIndex != FRMVAL_USER) && (frameNum < 1)) {	// [10/17/2018] Modify: "User" enables 0
					frameNum = 1;	// == Do not specify '0' when selecting except for world.
					// No need adjust process.
					//} else if (frameNum > frameMaxNumList[selIndex]) {
					//	// If it exceeds the maximum value, adjust it to the maximum value.
					//	frameNum = frameMaxNumList[selIndex];
				}
			}
		}
		$('#iptframenum').val(frameNum);
	});
	function checkNumberInputKey(evt) {
		var keySkip = false;
		if (((evt.which >= 96) && (evt.which <= 105)) ||	// 0 to 9 Ten-key
			((evt.which >= 48) && (evt.which <= 57))) {		// 0 to 9 Main-key
			if (evt.shiftKey == undefined) {
				keySkip = true;
			} else {
				if (evt.shiftKey) {	// with shift key = not num...
					keySkip = true;
				}
			}
		} else {
			keySkip = true;
		}
		return keySkip;
	}
	$('#layoutarea').on('keydown', '#iptframenum', function (evt) {
		frameNumTooltip('off', '', 0, 0);
		if (isiPad) $('#iptframenum').focus();
		var keySkip = false;
		debug(DBGDUMP, 'Keydown:keyCode=[' + evt.which + ']/key=[' + evt.key + ']/shift=[' + evt.shiftKey + ']');
		tabletDebug('dump', 'Keydown_:keyCode=[' + evt.which + ']/key=[' + evt.key + ']/shift=[' + evt.shiftKey + ']');
		switch (evt.which) {
			case KEYCODE_ENTER:
				$('#iptframenum').trigger('blur');
				break;
			case KEYCODE_BS:
			case KEYCODE_DEL:
			case KEYCODE_ESC:
			case KEYCODE_LFARW:	// Arrow Left
			case KEYCODE_RTARW:	// Arrow Right
				break;
			default:
				keySkip = checkNumberInputKey(evt);
				break;
		}
		if (keySkip) {
			evt.which = null;
			evt.preventDefault();
			evt.stopPropagation();
			return false;
		}
	});
	$('#layoutarea').on('keypress', '#iptframenum', function (evt) {
		debug(DBGDUMP, 'keypress:keyCode=[' + evt.which + ']/key=[' + evt.key + ']/shift=[' + evt.shiftKey + ']');
		if (isiPad) {
			tabletDebug('dump', 'Keypress:keyCode=[' + evt.which + ']/key=[' + evt.key + ']/shift=[' + evt.shiftKey + ']');
			var keySkip = checkNumberInputKey(evt);
			if (keySkip) {
				evt.which = null;
				evt.preventDefault();
				evt.stopPropagation();
				return false;
			}
		}
	});
	$('#layoutarea').on('blur', '#iptframenum', function (evt) {
		var selIndex = getSelFrameIndex();
		if ((selIndex != FRMVAL_WORLD) &&	// No check when selected World/Joint/Extend.
			(selIndex != FRMVAL_JOINT) &&
			(selIndex != FRMVAL_EXTEND)) {
			var iptFrame = $('#iptframenum').val();
			//if (iptFrame.length == 0) {	// No need adjust process.
			//	iptFrame = '1';
			//	$('#iptframenum').val(iptFrame);
			//}
			if (iptFrame.length > 0) {	// Check revived. * Frame number input value is not checked. *
				var convFrmVal = parseInt(iptFrame, 10);
				// Revived max check process.
				var checkFrmVal = (selIndex == FRMVAL_USER) ? 0 : 1;
				if ((convFrmVal < checkFrmVal) || (convFrmVal > frameMaxNumList[selIndex])) {
					frameNumTooltip('on', 'maxFrameNum', checkFrmVal, frameMaxNumList[selIndex]);
				} else {
					frameCurrentNum = convFrmVal;
					updateJogFrameNumber(selIndex, convFrmVal, false);
					callSetFrame(iptFrame);
				}
			} else {	// if empty ... set current setting value.
				frameNumTooltip('on', 'emptyFrameNum', 0, 0);
			}
		}
	});

	$(document).on('mousemove', "#outerframe", function (evt) {
		if (isJogStickOn()) {
			var curClient = getJogWinClient(evt);
			canselTextSelection();
			var curElem = document.elementFromPoint(curClient.clientX, curClient.clientY);
			tabletDebug('dump', 'X=[' + curClient.clientX + ']/Y=[' + curClient.clientY + ']/curId=(' + curElem.id + ')/targetId=(' + evt.target.id + ')');
			moveJogStick(evt);
			evt.preventDefault();
			evt.stopPropagation();
			return false;
		}
	});

	$(document).on('mouseleave', '#outerframe', function (evt) {
		if (isJogStickOn()) {
			canselTextSelection();
			sendJogStickKey(jogSendStat.key, 'off');
			resetJogStick(targetStickId);
			evt.preventDefault();
			evt.stopPropagation();
			return false;
		}
	});

	$(document).on('mousedown', '.jogstickbtn', function (evt) {
		startJogStick(evt);	// Just only pressed a button (stick).
		var tempOffset = $('#outerframe').offset();
		outerFrameBox.top = tempOffset.top;
		outerFrameBox.left = tempOffset.left;
		outerFrameBox.bottom = tempOffset.top + $('#outerframe').height();
		outerFrameBox.right = tempOffset.left + $('#outerframe').width();
		evt.preventDefault();
		evt.stopPropagation();
		return false;
	});

	$(document).on('mouseup', "#outerframe", function (evt) {
		if (isJogStickOn()) {
			sendJogStickKey(jogSendStat.key, 'off');
			resetJogStick(targetStickId);
			evt.preventDefault();
			evt.stopPropagation();
		}
		canselTextSelection();
	});

});

//
//	using jog key
//

// JOG key opration
var enableJogButton = false;
var jogStickState = false;
function closeSelFrameList() {
	$('#selframeopt').remove();
	setOpenSelFrameList(false);
	$('#selframeddn').removeClass('ddnbtnactive');
	$('#selframeddn').addClass('ddnbtninactive');
	$('#selframelist').css({ 'border': '1px solid #97a1ae' });
	$('#selbtnimg').attr('src', 'images/select_icon.png');
}
function isJogStickOn() {
	return jogStickState;
}
function setJogStickCond(cond) {
	jogStickState = cond;
}

/* == Stick (Knob/Button) Position data table == */
var KNOBSIZEFORPC = 41;	// px
var KNOBPOSTOPPC = 32;	// px
var KNOBPOSLEFTPC = 32;	// px
var KNOBNEUTRALPC = 10;	// px
var KNOBSIZEFORTAB = 51;	// px
var KNOBPOSTOPTAB = 27;	// px
var KNOBPOSLEFTTAB = 27;	// px
var KNOBNEUTRALTAB = 8;	// px
var KNOBSLIDERWID = 5;	// px
var KNOBSLIDERSIZE = 105;	// px
var knobDiameter = KNOBSIZEFORTAB;
var knobDefPosT = KNOBPOSTOPTAB;
var knobDefPosL = KNOBPOSLEFTTAB;
var knobAdjustPos = 0;	// Adjust the upper / left position in the slider area.
var knobNeutral = KNOBNEUTRALTAB;
//  Stick (Knob/Button) Origin position initialyze
var stickPCOrg = { l: knobDefPosL, t: knobDefPosT };
var stickPZOrg = { l: 0, t: knobDefPosT };
var stickACOrg = { l: knobDefPosL, t: knobDefPosT };
var stickAZOrg = { l: 0, t: knobDefPosT };
var stickJntOrg = { l: knobDefPosL, t: 0 };
var stickDirection = '';	// Stick direction (Right/Left/Up/Down)
var targetStickId = '';
var prevCursorPos = { x: 0, y: 0 };
var crntCursorPos = { x: 0, y: 0 };
var neutralZone = { t: 0, l: 0, b: 0, r: 0 };

// Initialize Stick button position/size etc... for PC
function initPCStickButton() {
	knobDiameter = KNOBSIZEFORPC;
	knobDefPosT = KNOBPOSTOPPC;
	knobDefPosL = KNOBPOSLEFTPC;
	knobAdjustPos = 5;	// Area's short side is 51px. knob size is 41px. Adjust 5px.
	knobNeutral = KNOBNEUTRALPC;
	var tempKnobSize = KNOBSIZEFORPC + 'px';
	$('#stick_pc').css({
		'top': KNOBPOSTOPPC + 'px', 'left': KNOBPOSLEFTPC + 'px',
		'width': tempKnobSize, 'height': tempKnobSize
	});
	$('#stick_pz').css({
		'top': KNOBPOSTOPPC + 'px', 'left': knobAdjustPos + 'px',
		'width': tempKnobSize, 'height': tempKnobSize
	});
	$('#stick_ac').css({
		'top': KNOBPOSTOPPC + 'px', 'left': KNOBPOSLEFTPC + 'px',
		'width': tempKnobSize, 'height': tempKnobSize
	});
	$('#stick_az').css({
		'top': KNOBPOSTOPPC + 'px', 'left': knobAdjustPos + 'px',
		'width': tempKnobSize, 'height': tempKnobSize
	});
	$('.jogstickjnt').css({
		'top': knobAdjustPos + 'px', 'left': KNOBPOSLEFTPC + 'px',
		'width': tempKnobSize, 'height': tempKnobSize
	});
	stickPCOrg = { l: knobDefPosL, t: knobDefPosT };
	stickPZOrg = { l: knobAdjustPos, t: knobDefPosT };
	stickACOrg = { l: knobDefPosL, t: knobDefPosT };
	stickAZOrg = { l: knobAdjustPos, t: knobDefPosT };
	stickJntOrg = { l: knobDefPosL, t: knobAdjustPos };
}

// Reset stick position.
function resetJogStick(targetId) {
	setJogStickCond(false);
	if ((targetId == 'stick_pc') || (targetId == 'crossboxup')) {
		stickPCOrg.l = knobDefPosL;
		stickPCOrg.t = knobDefPosT;
		stickDirection = '';
		$('#stick_pc').css({ 'top': stickPCOrg.t + 'px', 'left': stickPCOrg.l + 'px', 'background-color': STICKSENDOFF });
	} else if (targetId == 'stick_pz') {
		stickPZOrg.l = knobAdjustPos;
		stickPZOrg.t = knobDefPosT;
		stickDirection = '';
		$('#' + targetId).css({ 'top': stickPZOrg.t + 'px', 'left': stickPZOrg.l + 'px', 'background-color': STICKSENDOFF });
	} else if ((targetId == 'stick_ac') || (targetId == 'crossboxdn')) {
		stickACOrg.l = knobDefPosL;
		stickACOrg.t = knobDefPosT;
		stickDirection = '';
		$('#stick_ac').css({ 'top': stickACOrg.t + 'px', 'left': stickACOrg.l + 'px', 'background-color': STICKSENDOFF });
	} else if (targetId == 'stick_az') {
		stickAZOrg.l = knobAdjustPos;
		stickAZOrg.t = knobDefPosT;
		stickDirection = '';
		$('#' + targetId).css({ 'top': stickAZOrg.t + 'px', 'left': stickAZOrg.l + 'px', 'background-color': STICKSENDOFF });
	} else if (targetId.startsWith('stick_j')) {	// Joint stick
		stickJntOrg.l = knobDefPosL;
		stickJntOrg.t = knobAdjustPos;
		stickDirection = '';
		$('#' + targetId).css({ 'top': stickJntOrg.t + 'px', 'left': stickJntOrg.l + 'px', 'background-color': STICKSENDOFF });
	}
	targetStickId = '';
	if (isAndroid) {
		$('#pceditor').css({ 'position': '', 'top': '', 'left': '' });
		setAndroidScrollOff();
	}
}
var retryAndroidScroll = 0;  // 'Retry loop count' for setting of Android scroll on/off.
var RETRYANDROIDMSEC = 50;
var RETRYANDROIDMAX = 10;
function setAndroidScrollOn() {
	var wdTimer_cssOn = null;
	var posStyle = $('#pceditor').css('position');
	if ((posStyle != 'fixed') && (retryAndroidScroll < RETRYANDROIDMAX)) {
		wdTimer_cssOn = setTimeout(function () {
			$('#pceditor').css({ 'position': 'fixed', 'top': 0 - editorTop, 'left': 0 - editorLeft });
			setAndroidScrollOn();
			retryAndroidScroll++;
		}, RETRYANDROIDMSEC);
	} else {
		clearTimeout(wdTimer_cssOn);
		wdTimer_cssOn = null;
		canselTextSelection();
		retryAndroidScroll = 0;
	}
}
function setAndroidScrollOff() {
	var wdTimer_cssOff = null;
	var posStyle = $('#pceditor').css('position');
	if ((posStyle != '') && (posStyle != 'static') && (retryAndroidScroll < RETRYANDROIDMAX)) {
		wdTimer_cssOff = setTimeout(function () {
			$('#pceditor').css({ 'position': '', 'top': '', 'left': '' });
			setAndroidScrollOff();
			retryAndroidScroll++;
		}, RETRYANDROIDMSEC);
	} else {
		clearTimeout(wdTimer_cssOff);
		wdTimer_cssOff = null;
		$(window).scrollTop(editorTop);
		$(window).scrollLeft(editorLeft);
		retryAndroidScroll = 0;
		setScrollTop();
	}
}
function setScrollTop() {
	var wdTimer_scrollTop = null;
	if (($(window).scrollTop() != editorTop)) {
		wdTimer_scrollTop = setTimeout(function () {
			$(window).scrollTop(editorTop);
			$(window).scrollLeft(editorLeft);
			setScrollTop();
		}, 100);
	} else {
		clearTimeout(wdTimer_scrollTop);
		wdTimer_scrollTop = null;
	}
}
// Cancel text selection.
function canselTextSelection() {
	// When the operation of the JOG slider is started,
	// if the text is selected, the selection to be canceled.
	var seltext = document.getSelection();
	if (seltext.toString().length > 0) {
		seltext.removeAllRanges();
	}
}
// Get target stick neutral zone (top/bottom/left/right).
function getStickNeutralZone(targetStickId) {
	var crntStickPos = $('#' + targetStickId).offset();
	var stickNeutral = {};
	stickNeutral.t = crntStickPos.top;
	stickNeutral.b = crntStickPos.top + knobDiameter;
	stickNeutral.l = crntStickPos.left;
	stickNeutral.r = crntStickPos.left + knobDiameter;
	if (isTablet) {
		// Adjust tablet. Neutral zone is too wide.
		// Reduce the size of the neutral zone to nearly two-thirds of the button.
		var adjustZone = (((knobDiameter * 3) - KNOBSLIDERSIZE) / 2) / 3;
		stickNeutral.t += adjustZone;
		stickNeutral.b -= adjustZone;
		stickNeutral.l += adjustZone;
		stickNeutral.r -= adjustZone;
	}
	var crntScrollPos = {};
	crntScrollPos.left = $(window).scrollLeft();
	crntScrollPos.top = $(window).scrollTop();
	if (crntScrollPos.top > 0) {	// Adjust scroll pos.
		stickNeutral.t -= crntScrollPos.top;
		stickNeutral.b -= crntScrollPos.top;
	}
	if (crntScrollPos.left > 0) {	// Adjust scroll pos.
		stickNeutral.l -= crntScrollPos.left;
		stickNeutral.r -= crntScrollPos.left;
	}
	debug(DBGDUMP, 'Get neutral zone:\nPos l[' + stickNeutral.l + ']r[' + stickNeutral.r +
		']t[' + stickNeutral.t + ']b[' + stickNeutral.b + ']/scrL(' +
		crntScrollPos.left + ')scrT(' + crntScrollPos.top + ')');
	return stickNeutral;
}
/*
 * Processing of the JOG button that starts with clicking or tapping.
 */
var editorTop = 0;
var editorLeft = 0;
function startJogStick(evt) {
	if ((enableJogButton) && (!isJogStickOn())) {	// Enable and Not already ON.
		setJogStickCond(true);
		targetStickId = evt.target.id;
		prevCursorPos.x = getJogWinClient(evt).clientX;
		prevCursorPos.y = getJogWinClient(evt).clientY;
		neutralZone = getStickNeutralZone(targetStickId);
		debug(DBGDUMP, 'Cursor Position:\nCursor x[' + prevCursorPos.x + ']y[' + prevCursorPos.y + ']');
		if (isAndroid) {
			editorTop = $(window).scrollTop();
			editorLeft = $(window).scrollLeft();
			$('#pceditor').css({ 'position': 'fixed', 'top': 0 - editorTop, 'left': 0 - editorLeft });
			setAndroidScrollOn();
		}
	}
	canselTextSelection();
}
// Get direction of cross type JOG button.
function getCrossStickDirection(direct, diffX, diffY) {
	if (direct.length == 0) {
		if ((diffX < 0) && (Math.abs(diffX) > Math.abs(diffY))) {
			direct = 'L';
		} else if ((diffX > 0) && (diffX > Math.abs(diffY))) {
			direct = 'R';
		} else if ((diffY < 0) && (Math.abs(diffY) > Math.abs(diffX))) {
			direct = 'U';
		} else if ((diffY > 0) && (diffY > Math.abs(diffX))) {
			direct = 'D';
		} else {
			direct = '';
		}
	}
	debug(DBGDUMP, "Direction cross => [" + direct + "]");
	return direct;
}
// Get direction of vertical type JOG button.
function getVertStickDirection(direct, diffX, diffY) {
	if (direct.length == 0) {
		if ((diffY < 0) && (Math.abs(diffY) > Math.abs(diffX))) {
			direct = 'U';
		} else if ((diffY > 0) && (diffY > Math.abs(diffX))) {
			direct = 'D';
		} else {
			direct = '';
		}
	}
	debug(DBGDUMP, "Direction vert => [" + direct + "]");
	return direct;
}
// Get direction of horizontal type JOG button.
function getHorzStickDirection(direct, diffX, diffY) {
	if (direct.length == 0) {
		if ((diffX < 0) && (Math.abs(diffX) > Math.abs(diffY))) {
			direct = 'L';
		} else if ((diffX > 0) && (diffX > Math.abs(diffY))) {
			direct = 'R';
		} else {
			direct = '';
		}
	}
	debug(DBGDUMP, "Direction horz => [" + direct + "]");
	return direct;
}

/*
 * Process of moving the jog stick.
 */
var stickIdBase = 'stick_xx';	// Base part of JOG stick ID
var STICKSENDON = '#0E6EB8';
var STICKSENDOFF = '#67727E';
var confKeyIdStickDir = {	// A table to convert to key ID depending on stick and direction.
	'stick_pcL': 'xdn', 'stick_pcR': 'xup', 'stick_pcU': 'yri', 'stick_pcD': 'ylf',
	'stick_acL': 'wlf', 'stick_acR': 'wri', 'stick_acU': 'pup', 'stick_acD': 'pdn',
	'stick_pzU': 'zup', 'stick_pzD': 'zdn', 'stick_azU': 'rup', 'stick_azD': 'rdn'
};
function makeJogMoveSendInfo(direction, fixSidePos, sendOnPos, sendOffPos) {
	var jogInfo = {};
	jogInfo.direct = direction;
	switch (direction) {
		case 'L':	// Left
			jogInfo.moveT = fixSidePos;
			if (crntCursorPos.x < neutralZone.l) {
				jogInfo.moveL = sendOnPos;
				jogInfo.onoff = 'on';
			} else {
				jogInfo.direct = '';
				jogInfo.moveL = sendOffPos;
				jogInfo.onoff = 'off';
			}
			break;
		case 'R':	// Right
			jogInfo.moveT = fixSidePos;
			if (crntCursorPos.x > neutralZone.r) {
				jogInfo.moveL = sendOnPos;
				jogInfo.onoff = 'on';
			} else {
				jogInfo.direct = '';
				jogInfo.moveL = sendOffPos;
				jogInfo.onoff = 'off';
			}
			break;
		case 'U':	// Up
			jogInfo.moveL = fixSidePos;
			if (crntCursorPos.y < neutralZone.t) {
				jogInfo.moveT = sendOnPos;
				jogInfo.onoff = 'on';
			} else {
				jogInfo.direct = '';
				jogInfo.moveT = sendOffPos;
				jogInfo.onoff = 'off';
			}
			break;
		case 'D':	// Down
			jogInfo.moveL = fixSidePos;
			if (crntCursorPos.y > neutralZone.b) {
				jogInfo.moveT = sendOnPos;
				jogInfo.onoff = 'on';
			} else {
				jogInfo.direct = '';
				jogInfo.moveT = sendOffPos;
				jogInfo.onoff = 'off';
			}
			break;
	}
	return jogInfo;
}
function moveJogStick(evt) {
	crntCursorPos.x = getJogWinClient(evt).clientX;
	crntCursorPos.y = getJogWinClient(evt).clientY;
	var diffX = crntCursorPos.x - prevCursorPos.x;
	var diffY = crntCursorPos.y - prevCursorPos.y;
	prevCursorPos.x = crntCursorPos.x;
	prevCursorPos.y = crntCursorPos.y;
	var fixKnobPosTop = knobDefPosT;
	var fixKnobPosLeft = knobDefPosL;
	var maxKnobPosTop = knobDefPosT * 2;
	var maxKnobPosLeft = knobDefPosL * 2;
	var sendKeyId = '';
	var sendJogInfo = {};
	var stickcolor = '';
	var stickId = targetStickId.substr(0, stickIdBase.length);
	switch (stickId) {
		case 'stick_pc':
		case 'stick_ac':
			stickDirection = getCrossStickDirection(stickDirection, diffX, diffY);
			if (stickDirection.length == 0) {
				return;
			}
			var fixSidePos = ((stickDirection == 'L') || (stickDirection == 'R')) ? fixKnobPosTop : fixKnobPosLeft;
			var sendOnPos = (stickDirection == 'R') ? maxKnobPosLeft : (stickDirection == 'D') ? maxKnobPosTop : 0;
			var sendOffPos = ((stickDirection == 'L') || (stickDirection == 'R')) ? fixKnobPosLeft : fixKnobPosTop;
			sendJogInfo = makeJogMoveSendInfo(stickDirection, fixSidePos, sendOnPos, sendOffPos);
			stickcolor = (sendJogInfo.onoff == 'on') ? STICKSENDON : STICKSENDOFF;
			sendKeyId = confKeyIdStickDir[stickId + stickDirection];
			stickDirection = sendJogInfo.direct;
			break;
		case 'stick_pz':
		case 'stick_az':
			stickDirection = getVertStickDirection(stickDirection, diffX, diffY);
			if (stickDirection.length == 0) {
				return;
			}
			var sendOnPos = (stickDirection == 'U') ? 0 : maxKnobPosTop;
			sendJogInfo = makeJogMoveSendInfo(stickDirection, knobAdjustPos, sendOnPos, fixKnobPosTop);
			stickcolor = (sendJogInfo.onoff == 'on') ? STICKSENDON : STICKSENDOFF;
			sendKeyId = confKeyIdStickDir[stickId + stickDirection];
			stickDirection = sendJogInfo.direct;
			break;
		case 'stick_jj':
		case 'stick_je':
			stickDirection = getHorzStickDirection(stickDirection, diffX, diffY);
			if (stickDirection.length == 0) {
				return;
			}
			var sendOnPos = (stickDirection == 'L') ? 0 : (stickDirection == 'R') ? maxKnobPosLeft : 0;
			sendJogInfo = makeJogMoveSendInfo(stickDirection, knobAdjustPos, sendOnPos, fixKnobPosLeft);
			stickcolor = (sendJogInfo.onoff == 'on') ? STICKSENDON : STICKSENDOFF;
			var jogNum = targetStickId.substr('stick_j'.length).toLowerCase();
			sendKeyId = (stickDirection == 'L') ? jogNum + 'm' : (stickDirection == 'R') ? jogNum + 'p' : '';
			stickDirection = sendJogInfo.direct;
			break;
		default:
			return;
	}
	sendJogStickKey(sendKeyId, sendJogInfo.onoff);
	$('#' + targetStickId).css({ 'top': sendJogInfo.moveT + 'px', 'left': sendJogInfo.moveL + 'px' });
	$('#' + targetStickId).css({ 'background-color': stickcolor });
}

/*
 * Send JOG key according to JOG stick ID and ON / OFF.
 */
var sendingJogKey = false;
function sendJogStickKey(keyId, onoff) {
	jogSendStat = getJogKey(keyId);
	debug(DBGDUMP, 'send Jog stick key:[' + keyId + '] id:(' + jogSendStat.id + ') grp:[' + jogSendStat.grp + '] onoff:' + onoff + ' stick=[' + isJogStickOn() + ']');
	if (onoff == 'on') {
		if (sendingJogKey) {	// Already on.
			debug(DBGDUMP, 'Already On.');
			return;
		}
		debug(DBGDUMP, 'Send JOG key On.');
		setSubGroup(keyId, jogSendStat.grp);  // set sub group for extention Axes.
		sendJogKey(jogSendStat.id, JOGSENDSTAT_SET);
		sendingJogKey = true;
	} else {
		if (!isJogStickOn()) {	// Already off.
			debug(DBGDUMP, 'Already Off.');
			sendingJogKey = false;
			return;
		}
		if (jogSendStat.id !== '') {	// if key sending.
			debug(DBGDUMP, 'Send JOG key Off.');
			sendJogKey(jogSendStat.id, JOGSENDSTAT_CLR);
			sendingJogKey = false;
		}
		jogSendStat = { key: '', id: '', grp: 1 };	// initialize.
	}
}
// Conversion table of JOG button and 'send key'.
var jogBtnKeyConv = {
	'xup': '+J1', 'xdn': '-J1', 'ylf': '-J2', 'yri': '+J2', 'zup': '+J3', 'zdn': '-J3',
	'pup': '+J5', 'pdn': '-J5', 'wlf': '-J4', 'wri': '+J4', 'rup': '+J6', 'rdn': '-J6',
	'j1p': '+J1', 'j1m': '-J1', 'j2m': '-J2', 'j2p': '+J2', 'j3p': '+J3', 'j3m': '-J3',
	'j4p': '+J4', 'j4m': '-J4', 'j5m': '-J5', 'j5p': '+J5', 'j6p': '+J6', 'j6m': '-J6',
	'e1p': '+J1', 'e1m': '-J1', 'e2p': '+J2', 'e2m': '-J2', 'e3p': '+J3', 'e3m': '-J3'
};
// 'Send key' table for judgment on cartesian / joint.
var jogCartesianId = ['xup', 'xdn', 'ylf', 'yri', 'zup', 'zdn', 'pup', 'pdn', 'wlf', 'wri', 'rup', 'rdn'];

// Get JOG key information.
function getJogKey(id) {
	var grp = getCurrentGroupNum();
	var sendJogObj = { key: '', id: '', grp: 1 };
	if (id.length > 0) {	// valid id
		sendJogObj.key = id;
		sendJogObj.id = jogBtnKeyConv[id];
		sendJogObj.grp = grp;
	}
	return sendJogObj;
}
// Sending jog key
function sendJogKey(key, status) {
	if (status == 1) {	// Process of command.
		sendShiftKey(1);
		top.sendKey(key, 1);
	} else {
		top.sendKey(key, 0);
		sendShiftKey(0);
	}
}
// Callback function for STOP button.
function playStopCallback(status) {
	if (status !== IO_SUCCESS) {
		setJogStickCond(false);	// no need?
	}
}
// Set sub group for extend button.
function setSubGroup(id, grp) {
	var extAxesList = ['e1p', 'e1m', 'e2p', 'e2m', 'e3p', 'e3m'];
	var extAxesId = $.inArray(id, extAxesList);
	if (extAxesId >= 0) {	// Process of command.
		top.rpcmc_setVar(top.SYSNAME_C, '$JCR_GRP[' + grp + '].$JOG_SUBGRP', JOGJOINT_EXT);
	} else {
		top.rpcmc_setVar(top.SYSNAME_C, '$JCR_GRP[' + grp + '].$JOG_SUBGRP', JOGJOINT_RBT);
	}
}                                                                                                                                                                                                                                                                     /**********************************************************************
 * Robot Program Editor script
 * language script
 * Created: 2017/04/24 FSI
 *
 */

var resources = [];
function initResource(callback) {
  var lang = getCurrentLanguage();
  if (lang == LANG_GR || lang == LANG_FR) lang = LANG_EG;
  $.getJSON('lang/' + lang + '.jsn')
    .done(function (data, status, xhr) {
      debug(DBGINFO, 'Read language resource file.(' + lang + '):status[' + status + ']');
      resources = data;
      initToolbarResource();
      initEachWindowResource();
      initCommandList();
      callback();
      debug(DBGINFO, 'Finish language resource.');
    })
    .fail(function (xhr, textStatus, errorThrown) {
      if (lang != LANG_EG) {
        currentLang = LANG_EG;
        initResource(callback);
        debug(DBGFATAL, 'Get Lang data failed.('+ textStatus + ')');
        console.log("change Language :" + lang + " > " + currentLang);
      }
    });
}

/* === Resource matching table (for fixed contents) === */
/* (Generate contents resource are defined in each place.) */
var resourceToolbarTable = [
	// Toolbar button resource.
	{'id': 'filemenu',   'append': 'after', 'resId': 'toolTabProgram'},
	{'id': 'createprog', 'append': 'after', 'resId': 'toolBtnNewProg'},
	{'id': 'saveprog',   'append': 'after', 'resId': 'toolBtnSaveProg'},
	{'id': 'playrun',    'append': 'after', 'resId': 'toolBtnPlayRun'},
	{'id': 'playpause',  'append': 'after', 'resId': 'toolBtnPlayPause'},
	{'id': 'playstop',   'append': 'after', 'resId': 'toolBtnPlayStop'},
	{'id': 'playstep',   'append': 'after', 'resId': 'toolBtnPlayStep'},
	{'id': 'playcont',   'append': 'after', 'resId': 'toolBtnPlayCont'},
	// each button
	{'id': 'ovrridbtn',   'append': 'after', 'resId': 'overrideBtn'},
	{'id': 'resetbutton', 'append': 'after', 'resId': 'resetButton'},
	{'id': 'othermenu',   'append': 'after', 'resId': 'otherMenu'},
	// file menu
	{'id': 'filenewtext',  'append': 'after', 'resId': 'toolBtnNewProg'},
	{'id': 'filesavetext', 'append': 'after', 'resId': 'toolBtnSaveProg'},
	// Dummy
	{'id': 'dummy', 'append': 'no', 'resId': 'dummy'}
];
var resourceEachWindowTable = [
	// JOG button resource.
	{'id': 'jogctrlcrt', 'append': 'no', 'resId': 'posTableCrt'},
	{'id': 'jogctrljnt', 'append': 'no', 'resId': 'posTableJnt'},
	// JOG window resource.
	{'id': 'hdrframelabel', 'append': 'no', 'resId': 'hdrFrameLbl'},
	{'id': 'lblframeuser', 'append': 'no', 'resId': 'lblFrameUser'},
	{'id': 'lblframetool', 'append': 'no', 'resId': 'lblFrameTool'},
	{'id': 'lblframewrld', 'append': 'no', 'resId': 'lblFrameWorld'},
	{'id': 'lblframejog', 'append': 'no', 'resId': 'lblFrameJog'},
	{'id': 'lblframejoint', 'append': 'no', 'resId': 'lblFrameJoint'},
	{'id': 'hdrframenum', 'append': 'no', 'resId': 'hdrFrameNum'},
	// Position table control resource.
	{'id': 'posctrledit', 'append': 'before', 'resId': 'posTableEdt'},
	{'id': 'posctrldel', 'append': 'no', 'resId': 'posTableDel'},
	{'id': 'posctrlmov', 'append': 'before', 'resId': 'posTableMov'},
	{'id': 'posctrltup', 'append': 'no', 'resId': 'posTableTup'},
	{'id': 'posctrlcpy', 'append': 'no', 'resId': 'posTableCpy'},
	{'id': 'posctrlpst', 'append': 'no', 'resId': 'posTablePst'},
	{'id': 'posctrljnt', 'append': 'no', 'resId': 'posTableJnt'},
	{'id': 'posctrlcrt', 'append': 'no', 'resId': 'posTableCrt'},
	// Dummy
	{'id': 'dummy', 'append': 'no', 'resId': 'dummy'}
];
var resourceAfterLayoutTable = [
	// Position register paging resource.
    { 'id': 'page_slash', 'append': 'no', 'resId': 'PageSlash' },
    { 'id': 'page_unit', 'append': 'no', 'resId': 'Page' },
    { 'id': 'page_item_unit', 'append': 'before', 'resId': 'NumUnit' },
    { 'id': 'page_item_max_unit', 'append': 'no', 'resId': 'NumUnit' }
];

// Toolbar Language Resource Initialize.
function initToolbarResource() {
	debug(DBGDUMP, 'Init toolbar resource.');
	for (var i = 0; i < resourceToolbarTable.length; i++) {
		var rmt = resourceToolbarTable[i];
		var idStr = '#' + rmt.id;
		var resourceText = resources[rmt.resId];
		if (rmt.append == 'before') {	// Message append to already existed text.
			resourceText = resourceText + $(idStr).html();	//	append text
		} else if (rmt.append == 'after') {
			resourceText = $(idStr).html() + resourceText;	//	append text
		}
		$(idStr).html(resourceText);
	}
	debug(DBGDUMP, 'Finish toobar resource.');
}

// Language Resource Initialize. (except toolbar)
function initEachWindowResource() {
	debug(DBGDUMP, 'Init window resource.');
	for (var i = 0; i < resourceEachWindowTable.length; i++) {
		var rmt = resourceEachWindowTable[i];
		var idStr = '#' + rmt.id;
		var resourceText = resources[rmt.resId];
		if (rmt.append == 'before') {	// Message append to already existed text.
			resourceText = resourceText + $(idStr).html();	//	append text
		} else if (rmt.append == 'after') {
			resourceText = $(idStr).html() + resourceText;	//	append text
		}
		$(idStr).html(resourceText);
	}
	debug(DBGDUMP, 'Finish windows resource.');
}

// Language Resource Initialize. (After layout)
function initResourceAfterLayout() {
	debug(DBGDUMP, 'Init after layout resource.');
	for (var i = 0; i < resourceAfterLayoutTable.length; i++) {
		var rmt = resourceAfterLayoutTable[i];
		var idStr = '#' + rmt.id;
		var resourceText = resources[rmt.resId];
		if (rmt.append == 'before') {	// Message append to already existed text.
			resourceText = resourceText + $(idStr).html();	//	append text
		} else if (rmt.append == 'after') {
			resourceText = $(idStr).html() + resourceText;	//	append text
		}
		$(idStr).html(resourceText);
	}
	debug(DBGDUMP, 'Finish after layout resource.');
}
                                                                                                                                                                                                                                                                                                                                                                                 BU T . J S      P C E D I  T O R _ L A   Y O PCEDI~10JS    MjXX  MjX[D  B. J S      P C E D I  T O R _ M A   I N PCEDI~11JS    MjXX  MjX~Ԇ  BT O . J S      P C E D I  T O R _ M O   V E PCEDI~12JS    MjXX  MjX2  BP . J S    f  P C E D I  fT O R _ P O   P U PCEDI~13JS    MjXX  MjXQ]  BI N . J S      P C E D I  T O R _ P O   S W PCEDI~14JS    MjXX  MjX BI N . J S  &    /**********************************************************************
 * Robot Program Editor script
 * Layout generator
 * Created: 2017/06/08 FSI
 *
 */

/*
  Robot Program Editor initialyze layout.
*/
var isInitialised = false;	// 1st initialize : false=unfinished / true=finished
// JOG Frame list value definition
var frameValueList = ['FrameJoint', 'FrameJog', 'FrameWorld', 'FrameTool', 'FrameUser', 'FrameExtend'];

// HTML code definition.
// = Program & List Area.
var ct_prglist =
'	<div id="programlistarea" class="programlistarea">' +
//'	<select name="programlist" id="programlist" class="prglistsel"></select>' +
'	<input type="text" name="programname" id="programname" class="prglistsel" readonly="readonly" disabled="disabled">' +
'	</div>' +
'	<div id="execlinearea" class="execlinearea"></div>' +
'	<div id="programarea" class="programarea">' +
'	<textarea name="programtext" id="programtext" cols="256" class="programtext"></textarea>' +
'	</div>';
// = Command List Area.
var ct_cmdlist =
'	<div id="cmdwinarea" class="cmdwinarea">' +
'	<div id="closelistbtn" class="closelistbtn"><img src="images/btn_listclose.png"></div>' +
'	<div id="jstree_div" class="cmdlistwin"></div>' +
'	</div>';
// = Horizontal Bar.
var ct_horzbar =
'	<div id="resizeposmarkh" class="resizeposmarkh resizebarh">' +
'		<span id="resizemarkh" class="ui-icon ui-icon-grip-solid-horizontal resizemark"></span>' +
'		<button id="resizebtnhup"  class="resizebtnh">' +
'		<img id="posjogmax" src="images/icon_layout_up.png" class="resizemaxwinh" align="middle" title="posjogmax"/>' +
'		</button>' +
'		<button id="resizebtnhdn"  class="resizebtnh">' +
'		<img id="prgcmdmax" src="images/icon_layout_dn.png" class="resizeminwinh" align="middle" title="prgcmdmax" />' +
'		</button>' +
'	</div>';
// = Position Data Area.
var ct_selposkind =
'<div id="selpostblddn" class="selpostblddn ddnbtninactive">' +
'<img id="selpostblimg" src="images/pulldown.png" class="dropdownbtnimg" />' +
'</div>';
var ct_poswin =
'	<div id="posdatawin" class="posdatawin">' +
'		<div id="posctrl" class="posctrlarea">' +
'		<div id="posctrlbtn" class="posctrlbtnarea">' +
'			<div id="selpostbllist" class="selpostbllist first selpostblstyle">' + ct_selposkind +
'			</div>' +
'		<button id="posctrltup" class="posctrlbtn posctrlproc posctrlinact" disabled="disabled"></button>' +
'		<button id="posctrlmov" class="posctrlbtn posctrlmov posctrlinact" disabled="disabled">' +
'			<div id="movetobtnddn" class="ddnbtne ui-icon ui-icon-triangledn-white"></div>' +
'		</button>' +
'		<button id="posctrledit" class="posctrlbtn posctrledit posctrlinact" disabled="disabled">' +
'			<div id="editbtnddn" class="ddnbtne ui-icon ui-icon-triangledn-white"></div>' +
'		</button>' +
'		</div>' +
'		<div id="vctctrlbtn" class="coordctrlbtnarea">' +
'			<button id="posctrljnt" class="coordctrlbtn first"></button>' +
'			<button id="posctrlcrt" class="coordctrlbtn coordctrlon"></button>' +
'		</div>' +
'		</div>' +
'		<div id="posdata" class="postblarea"></div>' +
'		<div id="posregarea" class="posregarea" style="display: none;">' +
'			<div id="posregpage" class="pagearea"></div>' +
'			<div id="posregstbl" class="postblarea"></div>' +
'		</div>' +
'	</div>';
// = Vertical Bar.
var ct_vertbar =
'	<div id="resizeposmarkv" class="resizeposmarkv resizebarv">' +
'		<button id="resizebtnvri"  class="resizebtnv">' +
'		<img id="posareamax" src="images/icon_layout_ri.png" class="resizemaxwinv" align="middle" title="posareamax" />' +
'		</button>' +
'		<button id="resizebtnvlt"  class="resizebtnv">' +
'		<img id="jogareamax" src="images/icon_layout_lt.png" class="resizeminwinv" align="middle" title="jogareamax" />' +
'		</button>' +
'		<span id="resizemarkv" class="ui-icon ui-icon-grip-solid-vertical resizemarkvert"></span>' +
'	</div>';
// = JOG Key Area.
var ct_jogselframe =
'<div id="selframeddn" class="selframeddn ddnbtninactive"><img id="selframeimg" src="images/pulldown.png" class="dropdownbtnimg" /></div>';
var ct_jogwin =
'	<div id="jogwindow" class="jogwindow" >' +
'	  <div id="jogbtnarea" class="jogbtnarea saveselmenu" style="" >' +
'	    <div id="outerframe" class="outerframe">' +
'	      <div id="jogctrlarea" class="jogctrlarea">' +
'		    <div id="innerframekind" class="innerframekind">' +
'		      <fieldset class="frmcartfield">' +
'		      <div id="frameelement" class="frameelement">' +
'		        <div style="position: absolute; left: 5px;">' +
'		          <div id="hdrframelabel" class="hdrfrmlbl"></div>' +
'		          <div id="slctframehead" class="slctfrmhd slctfrmlf">' +
'		            <div id="selframelist" class="selframelist">' + ct_jogselframe +
'		            </div>' +
'		          </div>' +
'		        </div>' +
'		        <div style="position: absolute; left: 162px;">' +
'		          <div id="hdrframenum" class="hdrfrmlbl"></div>' +
'		          <div id="iptframehead" class="slctfrmhd slctfrmri">' +
'		            <input type="tel" id="iptframenum" class="iptfrmnum" />' +
'		          </div>' +
'		        </div>' +
'		      </div>' +
'		      </fieldset>' +
'		    </div>' +
'	      </div>' +
'		  <div id="jogcarttbl" class="jogbtncarttbl">' +
'		    <div id="crsbtnuptxt" class="crsbtntxtup"></div>' +
'		    <div id="crossbtnup" class="crossbtnup">' +
'		      <div id="crossboxup" class="crossboxup">' +
'		        <div id="ccbar_pv" class="crsbarhorzup"></div>' +
'		        <div id="ccbar_ph" class="crsbarvertup"></div>' +
'		        <span id="txtposyp" class="txtposyp"><img src="images/jogcart_y_p.png" ondragstart="return false;"></span>' +
'		        <span id="txtposym" class="txtposym"><img src="images/jogcart_y_m.png" ondragstart="return false;"></span>' +
'		        <span id="txtposxp" class="txtposxp"><img src="images/jogcart_x_p.png" ondragstart="return false;"></span>' +
'		        <span id="txtposxm" class="txtposxm"><img src="images/jogcart_x_m.png" ondragstart="return false;"></span>' +
'		        <div id="stick_pc" class="jogstickbtn jogstickpos"></div>' +
'		      </div>' +
'		    </div>' +
'		    <div id="vertbtnup" class="vertbtnup">' +
'		      <div id="vertlineup" class="vertlineup">' +
'		        <div id="vlbar_pz" class="linebarvup"></div>' +
'		        <div id="vlcrs_pz" class="linecrsvup"></div>' +
'		        <span id="txtpospzp" class="txtposzp"><img src="images/jogcart_z_p.png" ondragstart="return false;"></span>' +
'		        <span id="txtpospzm" class="txtposzm"><img src="images/jogcart_z_m.png" ondragstart="return false;"></span>' +
'		        <div id="stick_pz" class="jogstickbtn jogstickzup"></div>' +
'		      </div>' +
'		    </div>' +
'		    <div id="crsbtndntxt" class="crsbtntxtdn"></div>' +
'		    <div id="crossbtndn" class="crossbtndn">' +
'		      <div id="crossboxdn" class="crossboxdn">' +
'		        <div id="ccbar_av" class="crsbarhorzdn"></div>' +
'		        <div id="ccbar_ah" class="crsbarvertdn"></div>' +
'		        <span id="txtattyp" class="txtattyp"><img src="images/jogcart_y_r.png" ondragstart="return false;"></span>' +
'		        <span id="txtattym" class="txtattym"><img src="images/jogcart_y_l.png" ondragstart="return false;"></span>' +
'		        <span id="txtattxp" class="txtattxp"><img src="images/jogcart_x_r.png" ondragstart="return false;"></span>' +
'		        <span id="txtattxm" class="txtattxm"><img src="images/jogcart_x_l.png" ondragstart="return false;"></span>' +
'		        <div id="stick_ac" class="jogstickbtn jogstickatt"></div>' +
'		      </div>' +
'		    </div>' +
'		    <div id="vertbtndn" class="vertbtndn">' +
'		      <div id="vertlinedn" class="vertlinedn">' +
'		        <div id="vlbar_az" class="linebervdn"></div>' +
'		        <div id="vlcrs_pz" class="linecrsvdn"></div>' +
'		        <span id="txtposazp" class="txtattzp"><img src="images/jogcart_z_r.png" ondragstart="return false;"></span>' +
'		        <span id="txtposazm" class="txtattzm"><img src="images/jogcart_z_l.png" ondragstart="return false;"></span>' +
'		        <div id="stick_az" class="jogstickbtn jogstickzdn"></div>' +
'		      </div>' +
'		    </div>' +
'		  </div>' +
'		  <div id="jogjointtbl" class="jogbtnjointtbl" style="display: none;">' +
'		    <div id="horzjntbtn" class="horzjntbtn horzjnt1st">' +
'		      <div id="j1row" class="jointrow j1row">' +
'		        <div id="cbar_j1h" class="jnthorzbar"></div>' +
'		        <div id="cbar_j1v" class="jntvertbar"></div>' +
'		        <span id="txtj1p" class="jntlbltxtp">+J1</span>' +
'		        <span id="txtj1m" class="jntlbltxtm">-J1</span>' +
'		        <div id="stick_jj1" class="jogstickbtn jogstickjnt"></div>' +
'		      </div>' +
'		      <div id="j2row" class="jointrow j2row"">' +
'		        <div id="cbar_j2h" class="jnthorzbar"></div>' +
'		        <div id="cbar_j2v" class="jntvertbar"></div>' +
'		        <span id="txtj2p" class="jntlbltxtp">+J2</span>' +
'		        <span id="txtj2m" class="jntlbltxtm">-J2</span>' +
'		        <div id="stick_jj2" class="jogstickbtn jogstickjnt"></div>' +
'		      </div>' +
'		      <div id="j3row" class="jointrow j3row">' +
'		        <div id="cbar_j3h" class="jnthorzbar"></div>' +
'		        <div id="cbar_j3v" class="jntvertbar"></div>' +
'		        <span id="txtj3p" class="jntlbltxtp">+J3</span>' +
'		        <span id="txtj3m" class="jntlbltxtm">-J3</span>' +
'		        <div id="stick_jj3" class="jogstickbtn jogstickjnt"></div>' +
'		      </div>' +
'		    </div>' +
'		    <div id="horzjnt2btn" class="horzjntbtn horzjnt2nd">' +
'		      <div id="j4row" class="jointrow j4row">' +
'		        <div id="cbar_j4h" class="jnthorzbar"></div>' +
'		        <div id="cbar_j4v" class="jntvertbar"></div>' +
'		        <span id="txtj4p" class="jntlbltxtp">+J4</span>' +
'		        <span id="txtj4m" class="jntlbltxtm">-J4</span>' +
'		        <div id="stick_jj4" class="jogstickbtn jogstickjnt"></div>' +
'		      </div>' +
'		      <div id="j5row" class="jointrow j5row">' +
'		        <div id="cbar_j5h" class="jnthorzbar"></div>' +
'		        <div id="cbar_j5v" class="jntvertbar"></div>' +
'		        <span id="txtj5p" class="jntlbltxtp">+J5</span>' +
'		        <span id="txtj5m" class="jntlbltxtm">-J5</span>' +
'		        <div id="stick_jj5" class="jogstickbtn jogstickjnt"></div>' +
'		      </div>' +
'		      <div id="j6row" class="jointrow j6row">' +
'		        <div id="cbar_j6h" class="jnthorzbar"></div>' +
'		        <div id="cbar_j6v" class="jntvertbar"></div>' +
'		        <span id="txtj6p" class="jntlbltxtp">+J6</span>' +
'		        <span id="txtj6m" class="jntlbltxtm">-J6</span>' +
'		        <div id="stick_jj6" class="jogstickbtn jogstickjnt"></div>' +
'		      </div>' +
'		    </div>' +
'		    <div id="horzextbtn" class="horzextbtn" style="display: none;">' +
'		      <div id="e1row" class="jointrow j1row">' +
'		        <div id="cbar_e1h" class="jnthorzbar"></div>' +
'		        <div id="cbar_e1v" class="jntvertbar"></div>' +
'		        <span id="txte1p" class="jntlbltxtp">+E1</span>' +
'		        <span id="txte1m" class="jntlbltxtm">-E1</span>' +
'		        <div id="stick_je1" class="jogstickbtn jogstickjnt"></div>' +
'		      </div>' +
'		      <div id="e2row" class="jointrow j2row">' +
'		        <div id="cbar_e2h" class="jnthorzbar"></div>' +
'		        <div id="cbar_e2v" class="jntvertbar"></div>' +
'		        <span id="txte2p" class="jntlbltxtp">+E2</span>' +
'		        <span id="txte2m" class="jntlbltxtm">-E2</span>' +
'		        <div id="stick_je2" class="jogstickbtn jogstickjnt"></div>' +
'		      </div>' +
'		      <div id="e3row" class="jointrow j3row">' +
'		        <div id="cbar_e3h" class="jnthorzbar"></div>' +
'		        <div id="cbar_e3v" class="jntvertbar"></div>' +
'		        <span id="txte3p" class="jntlbltxtp">+E3</span>' +
'		        <span id="txte3m" class="jntlbltxtm">-E3</span>' +
'		        <div id="stick_je3" class="jogstickbtn jogstickjnt"></div>' +
'		      </div>' +
'		    </div>' +
'		  </div>' +
'	    </div>' +
'	  </div>' +
'	</div>';	// jogwindow

// Empty definition.
var ct_empty =
'	<div>' +
'	</div>';

var subLayoutVertical = [
	{'to': 'resizehorzv',  'from': 'resizeposmarkh'},
	{'to': 'posdataareav', 'from': 'posdatawin'},
	{'to': 'resizevertv',  'from': 'resizeposmarkv'},
	{'to': 'jogwinareav',  'from': 'jogwindow'}
];

var subLayoutHorizontal = [
	{'to': 'resizeverth',  'from': 'resizeposmarkv'},
	{'to': 'posdataareah', 'from': 'posdatawin'},
	{'to': 'resizehorzh',  'from': 'resizeposmarkh'},
	{'to': 'jogwinareah',  'from': 'jogwindow'}
];

var innerSubLayout = [
	{'id': 'posdataareah', 'gridclass': 'grid38 first posdataareah', 'content': ''},
	{'id': 'resizehorzh',  'gridclass': 'grid38 first resizehbarh',  'content': ''},
	{'id': 'jogwinareah',  'gridclass': 'grid38 first jogwinareah',  'content': ''}
];

var windowLayoutVertical = [
	{'id': 'prglistwin',   'gridclass': 'grid70 first prgwinarea',  'disp': 'disp', 'content': ct_prglist},
	{'id': 'cmdlistwin',   'gridclass': 'grid30 cmdlistarea',       'disp': 'disp', 'content': ct_cmdlist},
	{'id': 'resizehorzv',  'gridclass': 'grid00 first resizehbarv', 'disp': 'disp', 'content': ct_horzbar},
	{'id': 'posdataareav', 'gridclass': 'grid58 first posdataarea', 'disp': 'disp', 'content': ct_poswin},
	{'id': 'resizevertv',  'gridclass': 'grid02 resizevbarv',       'disp': 'disp', 'content': ct_vertbar},
	{'id': 'jogwinareav',  'gridclass': 'grid40 jogwinarea',        'disp': 'disp', 'content': ct_jogwin},
	{'id': 'resizeverth',  'gridclass': 'grid02 resizevbarh',       'disp': 'none', 'content': ''},
	{'id': 'posjogarea',   'gridclass': 'grid38 posjogarea', 'disp': 'none', 'content': '', 'inner': innerSubLayout}
];
var windowLayoutHorizontal = [
	{'id': 'prglistwin',   'gridclass': 'grid40 first prgwinarea',  'disp': 'disp', 'content': ct_prglist},
	{'id': 'cmdlistwin',   'gridclass': 'grid20 cmdlistarea',       'disp': 'disp', 'content': ct_cmdlist},
	{'id': 'resizehorzv',  'gridclass': 'grid00 first resizehbarv', 'disp': 'none', 'content': ''},
	{'id': 'posdataareav', 'gridclass': 'grid58 first posdataarea', 'disp': 'none', 'content': ''},
	{'id': 'resizevertv',  'gridclass': 'grid02 resizevbarv',       'disp': 'none', 'content': ''},
	{'id': 'jogwinareav',  'gridclass': 'grid40 jogwinarea',        'disp': 'none', 'content': ''},
	{'id': 'resizeverth',  'gridclass': 'grid02 resizevbarh',       'disp': 'disp', 'content': ct_vertbar},
	{'id': 'posjogarea',   'gridclass': 'grid38 posjogarea', 'disp': 'disp', 'content': '', 'inner': innerSubLayout}
];

/**
 * Initialize the target layout in specified mode.
 */
function initializeLayout(layout) {
	var $targetDiv = $('#layoutarea');
	var layoutTable = [];
	layoutTable = (layout == LAYOUTVERTICAL) ? windowLayoutVertical: windowLayoutHorizontal;
	// If 1st initialize has already done, the text-editor will not be initialize.
	var tblIdx = 0;
	if (!isInitialised) {
		isInitialised = true;
		tblIdx = 2;	// [9/15/2017] modify : command list too
	}
	for (; tblIdx < layoutTable.length; tblIdx++) {
		var frame = $('<div>', (layoutTable[tblIdx].disp == 'disp') ?
			{id: layoutTable[tblIdx].id, 'class': layoutTable[tblIdx].gridclass}:
			{id: layoutTable[tblIdx].id, 'class': layoutTable[tblIdx].gridclass, 'style': 'display: none'});
		frame.html(layoutTable[tblIdx].content);
		if ((layoutTable[tblIdx].inner != undefined) &&
			(layoutTable[tblIdx].inner.length >= 0)) {	// inner layout is exist...
			var innerLayout = [];
			innerLayout = layoutTable[tblIdx].inner;
			for (var j = 0; j < innerLayout.length; j++) {
				var inner = $('<div>', {id: innerLayout[j].id, 'class': innerLayout[j].gridclass});
				frame.append(inner);
			}
		}
		$targetDiv.append(frame);
	}
}

/**
 * Generate target layout.
 */
function generateLayout(targetLayout) {
	// If not change the layout, do not change the grid.
	var changeGrid = false;
	if (getCurrentLayout() != targetLayout) {	// Change layout mode
		changeGrid = true;
		setCurrentLayout(targetLayout);
	}

	var $targetDiv = $('#layoutarea');
	$targetDiv.hide();
	// Generate layout.
	var layoutTable = [];
	layoutTable = (targetLayout == LAYOUTVERTICAL) ? windowLayoutVertical: windowLayoutHorizontal;
	for (var i = 0; i < layoutTable.length; i++) {
		var $targetGrid = $('#' + layoutTable[i].id);
		if (changeGrid) {	// Grid class change...
			$targetGrid.removeAttr('class');
			$targetGrid.removeAttr('style');
			$targetGrid.attr('class', layoutTable[i].gridclass);
		}
		if (layoutTable[i].disp == 'disp') {
			$targetGrid.show();
		} else {
			$targetGrid.hide();
		}
	}
	$targetDiv.show();

	// Move item element
	layoutTable = (targetLayout == LAYOUTVERTICAL) ? subLayoutVertical: subLayoutHorizontal;
	for (var i = 0; i < layoutTable.length; i++) {
		var $fromid = $('#' + layoutTable[i].from);
		var $toid   = $('#' + layoutTable[i].to);
		var fromH = $fromid.height();
		var toH = $toid.height();
		if (fromH > toH) {	// adjust height to destination height
			$fromid.height(toH);
		}
		$fromid.appendTo($toid);
	}

}

// Initialize of [Move To] button/menu.
function initMovetoMenu() {
  // pickup VIA menu from command list.
  var supportVia = $('.tree-select-leaf[addparam*="TBLVIA"]');
  if (supportVia.length == 0) {	// Not Exist VIA menu
	$('#movetobtnddn').css({'display': 'none'});	// disable menu button(triangle arrow)
  }
}
                                                                                                                                                                                                                                                                                                                    /**********************************************************************
 * Robot Program Editor script
 * common script
 * Created: 2017/04/06 FSI
 * Modified:2017/08/21 Responding to specification changes.
 *                     = Omit status line.
 *                     = Responding to interface module.
 */

// Use jQuery and jQuery UI
/*
 * jQuery JavaScript Library
 * https://jquery.com/
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
*/
/*
 * jQuery UI Widget
 * http://jqueryui.com
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

/*
  Robot Program Editor initialyze.
*/
var winX = 0;	// Current window X size.
var winY = 0;	// Current window Y size.
var fResizeHorz = false;	// Resize mode (Horizontal) true=resize on / false= off
var fResizeVert = false;	// Resize mode (Vertical) true=resize on / false= off

/* --- Set tablet flag for iOS(iPad), Android, Windows tablet --- */
var navUA = navigator.userAgent.toLowerCase();
console.log("[[User Agent]]=>(" + navigator.userAgent + ")");
var isiPad = (navUA.indexOf('ipad') >= 0);
var isAndroid = (navUA.indexOf('android') >= 0) && (navUA.indexOf('mobile') < 0);
var isTablet = (isiPad || isAndroid);
var isIE = ((
  (navigator.userAgent.toLowerCase().indexOf('msie') != -1) ||
  (navigator.userAgent.toLowerCase().indexOf('trident') != -1))
  ? true : false);
// Current layout. vertical <--> horizontal
// vertical layout
//	Editor section + instruction list and position data section + JOG panel is arranged vertically.
// horizontal layout
//	Editor section and instruction list and position data section + JOG panel is arranged horizontally.
var currentLayoutMode = LAYOUTVERTICAL;
function getCurrentLayout() {
  return currentLayoutMode;
}
function setCurrentLayout(layout) {
  currentLayoutMode = layout;
}
function isLayoutVertical() {
  return (currentLayoutMode == LAYOUTVERTICAL) ? true : false;
}

/* Calculate fixed size window total height. */
function calcFixWinHeight() {
  var toolbarH = $('#toolbarbtnarea').height();
  var fixHeightTotal = toolbarH;
  return fixHeightTotal;
}

/* Get scroll bar width */
function getScrollBarWidth() {
  var sbw = window.innerWidth - $(window).width();	// outerWidth(true)?
  return sbw;
}

/* Check the frame where the editor exists. */
function isMyIFrameIdPrim() {
  if (!top.g_jitpky2) { // [Add] by FAC
    // This is not the iPendant connection
    return false;
  }
  return (window.frameElement.id == IFRAMEID_PRIM);
}
function getMyIFrameId() {
  return window.frameElement.id;
}
function existMultiIFrame(iFrameId) {
  var mainFrmObj = window.parent.frameElement.contentDocument;
  var iFrameObj = $(mainFrmObj).find('#' + iFrameId);
  return (iFrameObj.length > 0);
}
function existDualIFrame() {
  var mainFrmObj = window.parent.frameElement.contentDocument;
  var iFrameDual = $(mainFrmObj).find('#' + IFRAMEID_DUAL);
  return (iFrameDual.length > 0);
}
function existThirdIFrame() {
  var mainFrmObj = window.parent.frameElement.contentDocument;
  var iFrameThird = $(mainFrmObj).find('#' + IFRAMEID_THIRD);
  return (iFrameThird.length > 0);
}
function getSpecifiedIFrame(iFrameId) {
  var mainFrmObj = window.parent.frameElement.contentDocument;
  var iFrameObj = $(mainFrmObj).find('#' + iFrameId);
  return iFrameObj;
}

// In order to make the operation possible, remove the screen.
function removeOverlayScreen(additionalID) {
  var progInfo = statusProgramInfoTrans.getCurrentProgramSI();
  if (!isMyIFrameIdPrim() && (additionalID == "exec")) {
    // if iframe#prim has second editor, do not remove overlay
  } else if (($('.fornoprog').length > 0) && (progInfo.prog === '') && (additionalID == "exec")) {
    // if program is no select, do not remove overlay
  } else {
    $('#screenoverlay-' + additionalID).hide();
    $('#screenoverlay-' + additionalID).remove();
  }
}
// In order to make operation impossible, the screen is put up.
function putOverlayScreen(additionalID, targetScr) {
  var overlayCls = 'screenoverlay ' + targetScr;
  var overlayId = 'screenoverlay-' + additionalID;
  if ($('#' + overlayId).length == 0) {    // If it does not already exist, display overlay.
    $('body').append('<div id="' + overlayId + '" class="' + overlayCls + '"></div>');
    $('#' + overlayId).show();
  }
}

/**
 * Initialize Vertical layout window.
 **/
function initVertWindow(upperHalfH, lowerHalfH, leftSideW, rightSideW) {
  $('#posdataareav').hide();
  $('#jogwinareav').hide();
  $('#prglistwin').hide();
  $('#cmdlistwin').hide();

  // position data window
  $('#posdataareav').height(lowerHalfH);
  $('#posdataareav').width(leftSideW);
  $('#posdatawin').height(lowerHalfH);
  var postableH = (lowerHalfH == 0) ? 0 :
    lowerHalfH - $('#posctrl').height() - LOWERWINMARGIN - POSTABLEBORDER;
  $('#posdata').height(postableH - POSBTMMARGIN);
  $('#posregarea').height(postableH);
  // resize bar window
  $('#resizevertv').height(lowerHalfH);
  $('#resizeposmarkh').css("height", "20px");
  // jog window
  $('#jogwinareav').height(lowerHalfH);
  $('#jogwinareav').width(rightSideW);
  $('#jogwindow').height(lowerHalfH); // -LOWERWINMARGIN - POSTABLEBORDER);
  $('#jogbtnarea').height(lowerHalfH - LOWERWINMARGIN - POSTABLEBORDER);

  if (lowerHalfH > 0) {
    $('#resizevertv').show();
    $('#posdataareav').show();
    $('#posdatawin').show();
    $('#posctrl').show();
    $(getSelPosTblId()).show();
    $('#jogwinareav').show();
    $('#jogwindow').show();
    resizeJogDial();
  }

  // Program editor window
  $('#prglistwin').height(upperHalfH);
  $('#programtext').height(upperHalfH * AREARATEPROGW);
  if (upperHalfH > 0) $('#prglistwin').show();
  // command list window
  $('#cmdlistwin').height(upperHalfH);
  resizeVertPrgCmdWindow();
  if (upperHalfH > 0) $('#cmdlistwin').show();

  // resize button reset
  if ((upperHalfH > 0) && (lowerHalfH > 0)) {	// Either one is the maximum
    initResizeButton('#posjogmax', 'restorevert', 'up');
    initResizeButton('#prgcmdmax', 'restorevert', 'dn');
  }
  if ((leftSideW > 0) && (rightSideW > 0)) {	// Either one is the maximum
    initResizeButton('#posareamax', 'restorehorz', 'ri');
    initResizeButton('#jogareamax', 'restorehorz', 'lt');
  }
}
/**
 * Layout of horizontal content area window.
 **/
function resizeHorzPosJogWindow(upperHalfH, lowerHalfH, leftSideW, rightSideW) {
  $('#posjogarea').hide();
  $('#posjogarea').width(rightSideW);
  // position data window
  $('#posdataareah').height(upperHalfH);
  $('#posdataareah').width(rightSideW);
  $('#posdatawin').height(upperHalfH);
  var postableH = (upperHalfH == 0) ? 0 :
    upperHalfH	// Subtract the height of the button area and the margin and the border size.
    - $('#posctrl').height() 	// Control button area height.
    - POSAREAMARGIN - POSTABLEBORDER - POSWINMARGIN;	// each margin, border, padding.
  $('#posdata').height(postableH - POSBTMMARGIN);
  $('#posregarea').height(postableH);
  posResizeRefresh(false);	// poswin
  // resize bar window
  $('#resizehorzh').width(rightSideW);
  // jog window
  $('#jogwinareah').height(lowerHalfH);
  $('#jogwinareah').width(rightSideW);
  // Show each window
  $('#posdatawin').show();
  $('#posdataareah').show();
  $('#resizehorzh').show();
  $('#jogwindow').show();
  $('#jogwinareah').show();
  $('#posjogarea').show();
  $('#jogwindow').height(lowerHalfH); // -JOGAREAMARGIN - POSTABLEBORDER);
  $('#jogbtnarea').height(lowerHalfH - JOGAREAMARGIN - POSTABLEBORDER);
  resizeJogDial();
}
// Common function of Resize command tree window, when Horizontal layout.
function resizeHorzCmdTree() {
  // Command list window
  var prglistarea = $('.programarea').height() + $('#programlistarea').height() + PRGAREAMARGIN;
  var opencloseH = $('#closelistbtn').height() + OPENCLOSEHEIGHT;	// close button height
  var cmdlistH = (prglistarea - CMDWINBORDER - opencloseH) * AREARATEPROGH;
  $('#jstree_div').height(cmdlistH);
}
// Resize Program+Command window, when vertical layout.
function resizeVertPrgCmdWindow() {
  // Window width
  if (cmdwinOpen) {	// Normal
    $('#prglistwin').width(RATEPRGWINPCT);
    $('#cmdlistwin').width(RATECMDWINPCT);
  } else {
    $('#prglistwin').css({ 'width': RATEPRGVERTCLS });	// Width specified by %...
    $('#cmdlistwin').css({ 'width': RATECMDVERTCLS });
  }
  resizeHorzCmdTree();
}
// Resize Program+Command window, when horizontal layout.
function resizeHorzPrgCmdWindow(upperHalfH, lowerHalfH, leftSideW, rightSideW) {
  // Window width
  if (cmdwinOpen) {	// Normal
    $('#prglistwin').width(leftSideW * WINRATELEFT);
    $('#cmdlistwin').width(leftSideW * WINRATERIGHT);
  } else {
    $('#prglistwin').width(leftSideW * PRGWCMDCLOSE);
    $('#cmdlistwin').width(leftSideW * CMDWCMDOPEN);
  }
  $('#prglistwin').show();
  $('#cmdlistwin').show();
  resizeHorzCmdTree();
}
// Initialize Horizontal layout window.
function initHorzWindow(leftSideW, rightSideW, upperHalfH, lowerHalfH) {
  $('#posdataareah').hide();
  $('#jogwinareah').hide();
  $('#prglistwin').hide();
  $('#cmdlistwin').hide();

  // All Height is same. (except Pos win and Jog win each other)
  var fixHeightTotal = calcFixWinHeight();
  var allwinH = (winY - fixHeightTotal - DEFAULTBODYMARGIN);
  $('#prglistwin').height(allwinH);
  $('#cmdlistwin').height(allwinH);
  $('#resizeverth').height(allwinH);
  $('#posjogarea').height(allwinH);

  // Reduction first, after expansion
  var crntPosJogW = $('#posjogarea').width();
  if (crntPosJogW > rightSideW) {	// Reduction PosJogWindow...
    resizeHorzPosJogWindow(upperHalfH, lowerHalfH, leftSideW, rightSideW);
    resizeHorzPrgCmdWindow(upperHalfH, lowerHalfH, leftSideW, rightSideW);
  } else {
    resizeHorzPrgCmdWindow(upperHalfH, lowerHalfH, leftSideW, rightSideW);
    resizeHorzPosJogWindow(upperHalfH, lowerHalfH, leftSideW, rightSideW);
  }

  // resize button reset
  if ((leftSideW > 0) && (rightSideW > 0)) {	// Either one is the maximum
    initResizeButton('#jogareamax', 'restorehorz', 'lt');	// Jog area clear restore
    initResizeButton('#posareamax', 'restorehorz', 'ri');
  }
  if ((upperHalfH > 0) && (lowerHalfH > 0)) {	// Either one is the maximum
    initResizeButton('#posjogmax', 'restorehorz', 'up');
    initResizeButton('#prgcmdmax', 'restorehorz', 'dn');
  }
}

// Initialyze resume button to min/max button
function initResizeButton(id, cls, img) {
  $(id).removeClass(cls);
  $(id).attr('src', 'images/icon_layout_' + img + '.png');
}

// Initialize Editor screen get language kind.
function initEditorScreen() {
  initResource(initLayoutArea);
  // If terminate at unload, Reset moveto program.
  //resetMoveToProgram();	// This process cannot resume perfect...
  // Enable button bind and monitor process.
  top.jQuery.iolis.bind("IOBooleanEvent", null, TPEnableEvent);
  rpcmc_startIOMonitor(tpin_type_c, tp_enbl_c);
}
// Initialize layout area after get resource data.
function initLayoutArea() {
  generateToolbar();
  initPosCtrlButton();	// poswin
  definePositionTable();	// poswin
  correctPageLayout();	// paging
  setPageAreaEvent(changePosRegPage);	// paging(posreg)
  initPositionRegister(1, 20);	// posreg
  getSystemAxesCount(getJointAxesCallback);	// See api
  // Suppress image drag & drop.
  $('img').attr('ondragstart', 'return false;');
  ProgramInfoManager.initProgInfoManager(); // Program stack initialize.
  // Get position config data number of digit
  getPosConfNumOfDigit();
  // Initial process of get edit area info
  createEditorInstance(); // prgwin
  registEditorHandler(getPcEditor());  // prgwin
  preInitEditorInfo(getMyIFrameId()); // prgwin
  // Watch make command tree and call initMovetoMenu.
  waitCmdListComplete();  // cmdwin
  // conf line track
  ProgramApplManager.setLoadAppl();
}
// Initialize Status Info env.
var isInitializedStatusProgInfo = false;
function initStatusProgramInfo() {
  if (!isInitializedStatusProgInfo) { // initialyze first time only.
    debug(DBGINFO, 'Initialize StatusProgramInfo');
    statusProgramInfoTrans.initProgStatConcurrently(getCurrentLanguage(), isExecuteProgram, rcvStatInfoCallback);
    statusProgramInfoTrans.setStatusConcurrent(true); // get program status concurrently
    statusProgramInfoTrans.initCallbackFunc(changeProgStat); // Register processing for when the program is not selected
    isInitializedStatusProgInfo = true;
  }
}

// [4/4/2018] Remove [:hover] style for iPad
function removeHoverStyle() {
  for (var stidx = 0; stidx < document.styleSheets.length; stidx++) {	// Search pceditor_common
    var styleSheet = document.styleSheets[stidx];
    if (styleSheet.href.indexOf('pceditor_common') < 0) {
      continue;
    }
    for (var ruleidx = (styleSheet.rules.length - 1); ruleidx >= 0; ruleidx--) {
      if (!styleSheet.rules[ruleidx].selectorText) {	// no text --> next...
        continue;
      }
      if (styleSheet.rules[ruleidx].selectorText.match(':hover')) {	// remove hover
        if (!isIE) {
          styleSheet.deleteRule(ruleidx);
        } else {
          styleSheet.removeRule(ruleidx);	// for IE
        }
      }
    }
  }
}

$(window).ready(function () {
   top.rpcmc_getVar(top.SYSNAME_C, '$TXRAM.$TABLET_TP', redirectUnSupport);
});

function redirectUnSupport(progName, varName, typeCode, valStr, callbackProg, callbackarg){
  if (valStr == "TRUE") {
    window.location.href="/frh/irprog/pceditor/unsup_tabtp.htm";
  }
}

var loadFlag = false;
var defEditorWidth = 0;
$(window).on('load', function () {
  winX = INITWINDOWWIDTH;
  winY = INITWINDOWHEIGHT;
  loadFlag = true;
  if (isTablet) {
    // remove :hover style
    removeHoverStyle();
  }
  winX = window.innerWidth;
  winY = window.innerHeight;
  $('body').css({ 'width': '99.8%' });	// [7/4/2018] scroll bar is appeared at new mainfrm
  var ovfMode = 'hidden';
  if (winX < MIN_WINDOWWIDTH) {
    winX = MIN_WINDOWWIDTH;
    $(window).width(winX);
    ovfMode = 'auto';
  }
  $('body').css({ 'overflow-x': ovfMode });
  ovfMode = 'hidden';
  if (winY < MIN_WINDOWHEIGHT) {
    winY = MIN_WINDOWHEIGHT;
    $(window).height(winY);
    ovfMode = 'auto';
  }
  $('body').css({ 'overflow-y': ovfMode });
  debug(DBGINFO, 'onLoad: winX=' + winX + '/winY=' + winY);
  $(document).width(winX);
  $(document).height(winY);
  initializeLayout(currentLayoutMode);
  createOuterFrameEvent();// For touch events of tablet
  if (isiPad) {
    $('html').addClass('stop_jump_pceditor');
    $('body').addClass('stop_jump_pceditor'); 
  }
  generateLayout(currentLayoutMode);
  var initLayoutH = winY - (calcFixWinHeight() + DEFAULTBODYMARGIN);
  var initLayoutW = winX - DEFAULTBODYMARGIN;
  $('#layoutarea').height(initLayoutH);
  $('#layoutarea').width(initLayoutW);
  $('#pceditor').width(initLayoutW);
  initLayoutH -= $('#resizehorzv').height();	// Prg+Cmd + Pos+Jog
  initLayoutW -= $('#resizevertv').width();	// Pos + Jog
  initVertWindow(initLayoutH * WINRATEUPPER, initLayoutH * WINRATELOWER, initLayoutW, initLayoutW);
  // If I have not acquired the language type yet, I will go get it.
  if (getCurrentLanguage() === null) {
    // Get lang_suffix from system variable
    setCurrentLanguage(initEditorScreen);	// common_api
  }
  // FSI 20181207 for multi window
  if (!isMyIFrameIdPrim()) {
    mwOverlaySetting();
    putOverlayScreen('exec', 'formulti');
  } else {
    // Callback for program switching on the status bar.
    top.setChgPrgCB(chgProgramCB);
  }
  // Close Jog Panel and prevent it.
  if (!top.dlg_jogkey_closed) { // [Add] by FAC
    top.dlg_jogkey_close();
  }
  top.touchjog_closed = false;

  // FSI 20190806 wait for display repre position data
  $('#posctrljnt').addClass('coordctrloff');

  calcOBWidth();

  top.rpcmc_chkkey(null, top.mor_ss_c, top.SYSNAME_C, '$PG_CFG.$NUM_TASKS', setNumTasks);
  top.rpcmc_chkkey(null, top.mor_ss_c, top.SYSNAME_C, '$SCR.$MULSELENB', setMulSelEnb);
  getMltEnable();
});

// (IN) pgName: Program name after switching.
function chgProgramCB(pgName) {
  var param = {};
  param['selprog'] = pgName;
  selectProgram(param);
}

// calc other button width
function calcOBWidth() {
  var OTHERMARGIN = 2;
  var otherW = $('#toolbarbtn').width() - $('#filemenu').outerWidth(true) - $('#layoutbtn').outerWidth(true);
  $('#otherbutton').width(otherW - OTHERMARGIN);
}

var prevParentW = INITWINDOWWIDTH;	// Previous Parent's parent Width
var prevMyWidth = MIN_WINDOWWIDTH;	// Previous My Window Width
$(window).on('resize', function (evt) {
  var prevWinX = (winX == 0) ? MIN_WINDOWWIDTH : winX;
  var prevWinY = (winY == 0) ? window.innerHeight : winY;
  // This block is check innerWidth for editor refresh.
  if (loadFlag) {	// Not tablet and Already loaded.
    if (getPcEditor() != null) {	// Exist text editor section.
      var doRefresh = false;	// set refresh flag to false(no refresh)
      var myWinDiff = Math.abs(prevMyWidth - window.innerWidth);	// Get "innerWidth" difference from previous one.
      if (prevParentW == evt.target.parent.parent.innerWidth) {  	// Parent's parent window is not expand/reduction.
        if (myWinDiff > 20) {	// and It seems my window has been expand/reduction by tree open/close.
          doRefresh = true;	// '20' is the minimum opening / closing tree width (expected).
        }
      } else {	// When Window (Browser) resize.
        if (myWinDiff > 40) {	// and It seems my window has been expand/reduction by browser drag.
          doRefresh = true;	// '40' is the minimum drag difference width (expected).
        }
      }
      if (doRefresh) {
        getPcEditor().refresh();	// Codemirror to refresh (for cursor position adjusting)
      }
    }
    prevParentW = evt.target.parent.parent.innerWidth;	// save Parent's parent width
    prevMyWidth = window.innerWidth;         	// save My window width
  }
  // [2019/6/7] No.71 When use tablet, prevWinX is 1024. But innerWidth is 986.
  //if ((Math.abs(prevWinX - window.innerWidth) < 2) && (Math.abs(prevWinY - window.innerHeight) < 2)) {
  // So use 'prevMyWidth' when tablet.
  // However, since there is DEFAULTBODYMARGIN, use the value of innerWidth minus 2px.
  var fromResizeWidth = (isTablet) ? prevMyWidth : prevWinX;
  var toResizeWidth = (isTablet) ? (window.innerWidth - DEFAULTBODYMARGIN) : window.innerWidth;
  debug(DBGDUMP, 'Resize check : Prev-W[' + fromResizeWidth + '] / Crnt-W[' + toResizeWidth + ']');
  if ((Math.abs(fromResizeWidth - toResizeWidth) < 2) && (Math.abs(prevWinY - window.innerHeight) < 2)) {
    tabletDebug('trace', 'Resize by system.(may be) and ignore resize.');
    debug(DBGDUMP, 'Resize by system.(may be) and ignore resize.');
    evt.preventDefault();
    return false; // Ignore resize.
  }
  tabletDebug('trace', 'Call cancelPopupWhenResize()');
  cancelPopupWhenResize();  // [2019/6/10] Cancel popup.
  /* add scroll bar controll */
  winX = window.innerWidth;
  winY = window.innerHeight;
  // Adjustment window size.
  var ovfMode = 'hidden';
  if (winX < MIN_WINDOWWIDTH) {
    winX = MIN_WINDOWWIDTH;
    $(window).width(winX);
    ovfMode = 'auto';
  }
  $('body').css({ 'overflow-x': ovfMode });
  ovfMode = 'hidden';
  if (winY < MIN_WINDOWHEIGHT) {
    winY = MIN_WINDOWHEIGHT;
    $(window).height(winY);
    ovfMode = 'auto';
  }
  $('body').css({ 'overflow-y': ovfMode });
  $(document).width(winX);
  $(document).height(winY);
  var resizeLayoutW = winX - DEFAULTBODYMARGIN;
  var resizeLayoutH = winY - (calcFixWinHeight() + DEFAULTBODYMARGIN);
  $('#layoutarea').height(resizeLayoutH);
  $('#layoutarea').width(resizeLayoutW);
  $('#pceditor').width(resizeLayoutW);
  // The difference from the previous size is reflected on each width height
  var diffW = (winX - prevWinX) / 2;
  var diffH = (winY - prevWinY) / 2;
  if (isLayoutVertical()) {
    var upperH = $('#prglistwin').height();
    var lowerH = $('#posdataareav').height();
    var leftW = $('#posdataareav').width();
    var rightW = $('#jogwinareav').width();
    //To fix when resizing browser
    if ((latestRateHorz.top != 0) && (latestRateHorz.bottom != 0)) {
      latestRateHorz.top += diffH;
      latestRateHorz.bottom += diffH;
    }
    if ($('#prglistwin').height() == 0) {
      lowerH += diffH * 2;
    } else if ($('#posdataareav').height() == 0) {
      upperH += diffH * 2;
    } else {
      upperH += diffH;
      lowerH += diffH;
    }
    if ((latestRateVert.left != 0) && (latestRateVert.right != 0)) {
      latestRateVert.left += diffW;
      latestRateVert.right += diffW;
    }
    if ($('#posdataareav').width() == 0) {
      leftW = 0;
      rightW = resizeLayoutW - $('#resizevertv').width();
    } else if ($('#jogwinareav').width() == 0) {
      rightW = 0;
      leftW = resizeLayoutW - $('#resizevertv').width();
    } else {
      leftW += diffW;
      rightW += diffW;
    }
    initVertWindow(upperH, lowerH, leftW, rightW);
  } else {
    var upperH = $('#posdataareah').height();
    var lowerH = $('#jogwinareah').height();
    var leftW = $('#prglistwin').width() + $('#cmdlistwin').width();
    var rightW = $('#posjogarea').width();
    //To fix when resizing browser
    if ((latestRateHorz.top != 0) && (latestRateHorz.bottom != 0)) {
      latestRateHorz.top += diffH;
      latestRateHorz.bottom += diffH;
    }
    if ($('#posdataareah').height() == 0) {
      lowerH += diffH * 2;
    } else if ($('#jogwinareah').height() == 0) {
      upperH += diffH * 2;
    } else {
      upperH += diffH;
      lowerH += diffH;
    }
    if ((latestRateVert.left != 0) && (latestRateVert.right != 0)) {
      latestRateVert.left += diffW;
      latestRateVert.right += diffW;
    }
    if (($('#prglistwin').width() + $('#cmdlistwin').width()) == 0) {
      leftW = 0;
      rightW = resizeLayoutW - $('#resizeverth').width();
    } else if ($('#posjogarea').width() == 0) {
      rightW = 0;
      leftW = resizeLayoutW - $('#resizeverth').width();
    } else {
      leftW += diffW;
      rightW += diffW;
    }
    initHorzWindow(leftW, rightW, upperH, lowerH);
  }
  calcOBWidth();
  if (w2ui[getSelPosTblName()] != undefined) {
    w2ui[getSelPosTblName()].resize();
  }
});

// Cancel pop-up menu or pull-down menu when resize window
function cancelPopupWhenResize() {
  if (!openPopupFlg) { // resize event process for closing popup
    turnoffPopup();
    $('#popmenuoverlay').hide();
    $('#popmenuoverlay').remove();
  }
  closeSelFrameList();
}

// Mouse Down on window
$(document).on('mousedown touchstart', function (evt) {
  debug(DBGDUMP, 'Document Mouse Down ID:' + evt.target.id + ' - Class:' + evt.target.className);
  if ((evt.target.id == 'resizeposmarkh') ||
    (evt.target.id == 'resizemarkh')) {
    resizeDownHorzbar(evt);
    evt.preventDefault();
  } else if ((evt.target.id == 'resizeposmarkv') ||
    (evt.target.id == 'resizemarkv')) {
    resizeDownVertbar(evt);
    evt.preventDefault();
  } else if ((evt.target.className == 'dlgtitlebar') ||
    (evt.target.className == 'mixlogictitle') ||
    (evt.target.className == 'indassttitle') ||
    (evt.target.className == 'commandtitle')) {
    downDialogBox(evt);
    evt.preventDefault();
  } else {
    var tgtClsLst = evt.target.className.split(' ');
    if ($.inArray('CodeMirror-hint', tgtClsLst) >= 0) {
      return false;
    }
  }
});
// Mouse Up on window
$(document).on('mouseup touchend', function (evt) {
  debug(DBGDUMP, 'Document Mouse Up ID:' + evt.target.id + ' - Class:' + evt.target.className);
  if ((evt.target.id == 'resizeposmarkh') ||
    (evt.target.id == 'resizemarkh')) {
    resizeUpHorzbar(evt);
    evt.preventDefault();
  } else if (
    (evt.target.id == 'resizeposmarkv') ||
    (evt.target.id == 'resizemarkv')) {
    resizeUpVertbar(evt);
    evt.preventDefault();
  } else if (
    (evt.target.className == 'dlgtitlebar') ||
    (evt.target.className == 'mixlogictitle') ||
    (evt.target.className == 'indassttitle') ||
    (evt.target.className == 'commandtitle')) {
    upDialogBox(evt);
    evt.preventDefault();
  } else if (evt.target.className == 'w2ui-grid-records') {
    posResizeRefresh(true);
  } else if (evt.target.id != 'page_num') {
    if ($('#pagenumddn').hasClass("pageddnactive")) {	// if page dropdown is ative
      $('#pagenumddn').removeClass('pageddnactive');	// remove active and add inactive.
      $('#pagenumddn').addClass('pageddninactive');
    }
  }
});
// Mouse Move on window
$(document).on('mousemove touchmove', function (evt) {
  if (fResizeHorz) {
    (isLayoutVertical()) ? resizeMoveHorzV(evt) : resizeMoveHorzH(evt);
    evt.preventDefault();
  } else if (fResizeVert) {
    (isLayoutVertical()) ? resizeMoveVertV(evt) : resizeMoveVertH(evt);
    evt.preventDefault();
  } else if (
    (evt.target.className == 'dlgtitlebar') ||
    (evt.target.className == 'mixlogictitle') ||
    (evt.target.className == 'indassttitle') ||
    (evt.target.className == 'commandtitle')) {
    if (isDragDialog()) {
      moveDialogBox(evt);
      evt.preventDefault();
    }
  }
});
// Mouse Out from window
$(document).on('mouseout', function (evt) {
  if ((evt.target.className == 'dlgtitlebar') ||
    (evt.target.className == 'mixlogictitle') ||
    (evt.target.className == 'indassttitle') ||
    (evt.target.className == 'commandtitle')) {
    upDialogBox(evt);
    evt.preventDefault();
  }
});
// Mouse Click on window
function clickMyWindow(evt) {
  debug(DBGDUMP, 'Click MyWindow ID:' + evt.target.id + ' - Class:' + evt.target.className);
  if (evt.target.id == 'popupoverlay') {	// popup output
    // remove popup
    $('#cmdinsconf').remove();
    $('#popupoverlay').hide();
    $('#popupoverlay').remove();
  } else if (evt.target.id == 'popmenuoverlay') {
    // remove menu popup
    turnoffPopup();	// move from popup.js
    $('#popmenuoverlay').hide();
    $('#popmenuoverlay').remove();
  } else if ((evt.target.id != 'selframelist') && (isOpenSelFrameList())) {
    closeSelFrameList();	// jogwin
  } else if ((evt.target.id != 'selpostbllist') && (isOpenSelPosTblList())) {
    closeSelPosTblList();	// poswin
  } else if ((evt.target.id != 'palletButton') && (evt.target.id != '') && (evt.target.id != 'popupButton_font')) {
    defineButtonDlg.close('#palletButton');
  }
  // If the resizing process is in progress, the process is reset
  fResizeHorz = false;
  fResizeVert = false;
}
$(window).on('click', function (evt) {
  clickMyWindow(evt);
});
// for iPad
$('#pceditor').on('click', function (evt) {
  clickMyWindow(evt);
  return false;
});
// Event before unload.
$(window).on('beforeunload', function (evt) {
  debug(DBGINFO, 'Window before unload event:' + evt.type);
  if (isMoveToOnProgram()) {	// if move to exec, stop move to.
    unloadMoveToProgram();	// moveto.js
    chgProg(getCurrentProgram(), completeMoveToProg);
  }
});
// Event unload.
$(window).on('unload', function (evt) {
  debug(DBGINFO, 'Window unload event:' + evt.type);
  if ($('#tabDebInfo').length > 0) {    // Remove debug info area, if exist.
    $('#tabDebInfo').remove();
  }
  if (isExecuteProgram()) {
    // NOTE: In iRProgrammer, program will continue to run even when SHIFT key is released
    // Release SHIFT key so other menus work properly
    sendShiftKey(0);
  }
  crearEditorAreaInfo(getMyIFrameId()); // Crear current iframe ID editor area info.

  // Stop I/O Monitor for Enable button.
  top.rpcmc_stopIOMonitor(tpin_type_c, tp_enbl_c);
  // Detach handler for IOBooleanEvent.
  top.jQuery.iolis.unbind("IOBooleanEvent", TPEnableEvent);

  // Allow Jog Panel
  top.touchjog_closed = true; // [Add] by FAC

  loadFlag = false;
});

// TP Enable status event.
function TPEnableEvent(event, io_type, io_index, io_value) {
  if ((io_type == tpin_type_c) && (io_index == tp_enbl_c)) {
    var progInfo = statusProgramInfoTrans.getCurrentProgramSI();
    // We have a match.
    if (io_value == 0) {
      setEnableStatus(false);	// toolbar
      if ((isWriteProtectWin()) && (progInfo.prog !== '')) {
        protOverlayManager(true);
      }
    } else {
      setEnableStatus(true);
      if ((!isWriteProtectWin()) && (progInfo.prog !== '')) {
        protOverlayManager(false);
      }
    }
    setJogButtonStat();	// jogwin
    changePosBtnBlock(); // poswin
  }
} // TPEnableEvent

var watchExec_value = 0;
function getWatchExecValue() {
  return watchExec_value;
}
function setWatchExecValue(val) {
  watchExec_value = val;
}

function rcvStatInfoCallback() {
  var reflectprog = JSON.parse(JSON.stringify(statusProgramInfoTrans.getCurrentProgramSI()));
  if ((reflectprog.prog === '') || (isMoveToOnProgram())) {  // change to empty name...of moveto
    return; // ignore
  }
  // [2019/6/24] If "MoveTo On" is canceled but the program is still a move-only program,
  if (!isMoveToOnProgram() && (getCurrentProgram() == getMoveProgPrim())) {
    return; // ignore it.
  }
  reflectExecLine(reflectprog);
}
function reflectExecLine(reflectprog) {
  if ((getCurrentProgram() != reflectprog.prog) && (reflectprog.line > 0) &&  // Change prog and exec and
      (!isMoveToOnProgram())) {  // not moveto.
    debug(DBGDUMP, 'reflectExecLine(): Change to [' + reflectprog.prog + '/' + reflectprog.line + ']');
    /* for next time... FSI 201909
    if ((reflectprog.prog !== '') && (isMyIFrameIdPrim())) { // not chnage to empty name.
      // [2019/6/24] If reflect program is a move-only program,
      if (reflectprog.prog == getMoveProgPrim()) {
        debug(DBGWARN, 'updateEditorScreen():' + progName);
        return; // ignore it. for fail safe.
      }
      // May be Call Sub Program
      callSpecifiedProgram(reflectprog);  // prgwin
    }
    */
    // highlight off FSI 201909
    var pceditor = getPcEditor();
    pceditor.setOption('styleActiveLine', false);
    return;
    //reflectprog.line = 0; // [2019/6/27] Comment out to enable the subprogram. ignore subprogram
  }
  highlightExecLine(reflectprog);	// prgwin
}

// Override procedure
$(function () {
  $('#jogwinareav').on('contextmenu', function () {
    return false;
  });
});

// FSI 20181122 Watch the PosReg table.
// Call paintMaskingCell() after specific elements are displayed.
var set_interval_id = setInterval(findTargetElement, 1000);

function findTargetElement() {
  var PRjoinElem = document.getElementById('grid_posregstbl_data_1_2');
  var PRCertElem = document.getElementById('grid_posregstbl_data_1_8');

  if (PRjoinElem || PRCertElem) {
    paintMaskingCell();
    clearInterval(set_interval_id);
  }
}

// FSI 20181207 for multi window
function openMenuSetting() {
  if (!isMyIFrameIdPrim()) {
    return false;
  } else if (getCurrentProgram() === '') {
    return false;
  } else if (progLoadError) {
    return false;
  } else {
    return true;
  }
}

var oldStat = null;
// Executed when the state of the program changes.
function changeProgStat(curProgName) {
  if (oldStat != curProgName.stat) {
    if (isMyIFrameIdPrim()) {
      if (curProgName.prog === "" && getCurrentProgram() === "") {
        protOverlayCleanUp();
        npOverlaySetting();
        putOverlayScreen('exec', 'fornoprog');
      } else if (curProgName.stat == WATCHEXEC_RUNNING) {
        removeOverlayScreen('prot');
        protOverlayCleanUp();
        putOverlayScreen('exec', 'forexec');
      } else if (curProgName.stat == WATCHEXEC_ABORTED || curProgName.stat == WATCHEXEC_PAUSED) {
        if (isWriteProtectWin()) { // program protect editting in editor
          if (!progLoadError) {
            removeOverlayScreen('prot');
            protOverlayManager(true);
          }
        } else if (!checkTPPicture()) {
          setEnableStatus(false); // If TP button image is 'off', change enable status 'false' even if the internal data is true.
        } else {
          setEnableStatus(true);
          protOverlaySetting();
          enabelEditWindow();
        }
        monitorMovetoAlarm();  // moveto.js
      }
    } else {
      if (curProgName.prog === "") {
        mwOverlayCleanUp();
        npOverlaySetting();
      } else {
        mwOverlaySetting();
      }
    }
    setWatchExecValue(curProgName.stat);
    watchExecStatus(getWatchExecValue());
    oldStat = curProgName.stat;
  }
  statLineFirst = JSON.parse(JSON.stringify(curProgName));  // prgwin
  initSetHoldLine();
  setInputPosition();
}

function setInputPosition() { // Controls scrolling by focus operation.
  var grid = w2ui[POSDATAREA]; //
  var $input = $(grid.box).find('#grid_posdata_focus');
  $input.css({ left: 10, top: 10});
  grid = w2ui[POSREGSTBL];
  $input = $(grid.box).find('#grid_posregstbl_focus');
  $input.css({ left: 10, top: 10});
}

function mwOverlaySetting() {
  var ua = navigator.userAgent.toLowerCase();
  $('#filemenu').css({ 'position': 'relative' });
  $('#filemenu').css({ 'z-index': 9992 });
  $('#prglistwin').css({ 'position': 'relative' });
  $('#prglistwin').css({ 'z-index': 9991 });
  $('#selpostbllist').css({ 'z-index': 9992 });
  $('#vctctrlbtn').css({ 'position': 'relative' });
  $('#vctctrlbtn').css({ 'z-index': 9991 });
  $('#posdata').css({ 'z-index': 9991 });
  $('#posregarea').css({ 'position': 'relative' });
  $('#posregarea').css({ 'z-index': 9991 });
  $('#resizeposmarkv').css({ 'position': 'relative' });
  $('#resizeposmarkv').css({ 'z-index': 9992 });
  $('#resizeposmarkh').css({ 'position': 'relative' });
  $('#resizeposmarkh').css({ 'z-index': 9992 });
  $('#layoutbtn').css({ 'position': 'relative' });
  $('#layoutbtn').css({ 'z-index': 9990 }); // under posdata
  $('.selpostblopt').css({ 'z-index': 9991 });
  $('.validexec').css({ 'z-index': 9988 }); // under multi overlay
  $('#closelistbtn').css({ 'position': 'relative' });
  $('#closelistbtn').css({ 'z-index': 9991 });
  if ((ua.indexOf('trident/7') > -1) || (ua.indexOf('edge') > -1)) {
    $('#vertbtnbox').css({ 'position': 'relative' });
    $('#vertbtnbox').css({ 'z-index': 9995 });
    $('#horzbtnbox').css({ 'position': 'relative' });
    $('#horzbtnbox').css({ 'z-index': 9995 });
  }
}

function mwOverlayCleanUp() {
  var ua = navigator.userAgent.toLowerCase();
  $('#filemenu').css({ 'position': '' });
  $('#filemenu').css({ 'z-index': '' });
  $('#prglistwin').css({ 'position': '' });
  $('#prglistwin').css({ 'z-index': '' });
  $('#selpostbllist').css({ 'z-index': '' });
  $('#vctctrlbtn').css({ 'position': '' });
  $('#vctctrlbtn').css({ 'z-index': '' });
  $('#posregarea').css({ 'position': '' });
  $('#posregarea').css({ 'z-index': '' });
  $('#resizeposmarkv').css({ 'position': '' });
  $('#resizeposmarkv').css({ 'z-index': '' });
  $('#resizeposmarkh').css({ 'position': '' });
  $('#resizeposmarkh').css({ 'z-index': '' });
  $('#posdata').css({ 'z-index': '' });
  $('#layoutbtn').css({ 'position': '' });
  $('#layoutbtn').css({ 'z-index': '' });
  $('.selpostblopt').css({ 'z-index': '' });
  $('.validexec').css({ 'z-index': 9997 });
  $('#closelistbtn').css({ 'position': '' });
  $('#closelistbtn').css({ 'z-index': '' });
  if ((ua.indexOf('trident/7') > -1) || (ua.indexOf('edge') > -1)) {
    $('#vertbtnbox').css({ 'position': '' });
    $('#vertbtnbox').css({ 'z-index': '' });
    $('#horzbtnbox').css({ 'position': '' });
    $('#horzbtnbox').css({ 'z-index': '' });
  }
}

function npOverlaySetting() {
  $('#filemenu').css({ 'position': 'relative' });
  $('#filemenu').css({ 'z-index': 9992 });
  $('.btnreset').css({ 'position': 'relative' });
  $('.btnreset').css({ 'z-index': 9992 });
  $('#jogwindow').css({ 'z-index': 9992 });
  $('#resizeposmarkv').css({ 'position': 'relative' });
  $('#resizeposmarkv').css({ 'z-index': 9991 });
  $('#resizeposmarkh').css({ 'position': 'relative' });
  $('#resizeposmarkh').css({ 'z-index': 9991 });
  $('#layoutbtn').css({ 'position': 'relative' });
  $('#layoutbtn').css({ 'z-index': 9991 });
  $('.validexec').css({ 'z-index': 9987 });
}

function npOverlayCleanUp() {
  $('#filemenu').css({ 'position': '' });
  $('#filemenu').css({ 'z-index': '' });
  $('.btnreset').css({ 'position': '' });
  $('.btnreset').css({ 'z-index': '' });
  $('#jogwindow').css({ 'z-index': '' });
  $('#resizeposmarkv').css({ 'position': '' });
  $('#resizeposmarkv').css({ 'z-index': '' });
  $('#resizeposmarkh').css({ 'position': '' });
  $('#resizeposmarkh').css({ 'z-index': '' });
  $('#layoutbtn').css({ 'position': '' });
  $('#layoutbtn').css({ 'z-index': '' });
  $('.validexec').css({ 'z-index': 9997 });
}                                                                                                                          /**********************************************************************
 * Robot Program Editor script
 * for Move to process.
 * Created: 2018/08/29
 *
 */

var movementProgramName = 'MOVEONLYPROG.LS';
var movementMotionInst = 'L P[1] 100mm/sec FINE';
var movementTerminateCh = '	   ;';
var movementOverrideVal = 10;
var movementViaInst = ' VIA(DEFAULT)';

// Get Moveto program primary name.
function getMoveProgPrim() {
	return omitExtension(movementProgramName);
}

/**
 * Main process of "Move to".
 * (IN) frameType : COORDINATECART or COORDINATEJOINT
 * (IN) selFrame  : FRMVAL_XXX
 * (IN) posRec : Move to position data
 */
var movetoPosition = {};
var saveCurrentProgName = '';  // Program name of Current Edit program.
var currentFrame = 0;	// Current select frame index.
var alreadyExchangeStepMode = false;	// Exchange watch flag.
var useVIAExtCommand = false;	// Use VIA flag.
var relatedMovetoBtnId = '';
function moveToMain(posRec, moveToAddInfo) {
	debug(DBGDUMP, 'moveToMain: args: crntFrame[' + moveToAddInfo.crntFrame + '];ufNum[' + moveToAddInfo.ufNum + '];utNum[' + moveToAddInfo.utNum + ']');
	debug(DBGDUMP, 'moveToMain: posRec:   frame[' + posRec.frame + '],    UF[' + posRec.UF + '];   UT[' + posRec.UT + ']');
	relatedMovetoBtnId = (isScrModeEditorTab()) ? '#move_btn' : '#posctrlmov';
	// Check whether TP is valid
	if (!isEnableOn()) {
		defineDialog.open(relatedMovetoBtnId, '#confalertdlg', 'dlgMsgEnableOff');	// Confirm TP disable
		return;
	}
	// Check the alarm is released.
	if (isAlarmOn()) {
		defineDialog.open(relatedMovetoBtnId, '#confalertdlg', 'dlgMsgAlarmOn');	// Confirm alarm on
		return;
	}
	// For MOVETO of position register.
		if ((getSelPosTblValue().tblId == POSREGSTBL) && (isEnablePolling())) {
		stopGetPosRegPolling();
	}
	// For the position register, get the coordinate system.
	if ((getSelPosTblValue().tblId == POSREGSTBL)) {
		posRec.UT = moveToAddInfo.utNum;
		posRec.UF = moveToAddInfo.ufNum;
	}
	// Check 'User Frame number' and 'User Tool number' is valid.
	movetoPosition = posRec;
	currentFrame = moveToAddInfo.crntFrame;
	useVIAExtCommand = moveToAddInfo.cmdMode;
	var validFrame = ((posRec.frame == COORDINATEJOINT) ||	// Valid: Joint, UFUT is match
		((posRec.UF == moveToAddInfo.ufNum) && (posRec.UT == moveToAddInfo.utNum)));
	if (!validFrame) {
		defineDialog.open(relatedMovetoBtnId, '#confchgfrmdlg', 'dlgMsgIlgFrame');	 // Confirm illegal frame
		return;
	}
	checkProgramCondition();
}
function checkProgramCondition() {
	// When program is currently hold, confirm abort and move.
	if (isExecuteProgram() || isExecProgHold() || (statusProgramInfoTrans.getCurrentProgramSI().stat != WATCHEXEC_ABORTED)) {
		defineDialog.open(relatedMovetoBtnId, '#confmvabortdlg', 'dlgMsgMoveAbort');
		return;
	}
  // Check Movement-only program and continue
  checkMovementProgram(IO_SUCCESS, getCurrentProgram());
}

/*
 * Change the frame number to the number of position data.
 */
function changeFrameNumber(transParam) {
	// Set UF/UT value to System, Management data of the JOG win, Management data of the Position.
	var crntGrpNum = getCurrentGroupNum();
	setFrameCoordinate(crntGrpNum, FRMVAL_USER, movetoPosition.UF);	// api
	updateJogFrameNumber(FRMVAL_USER, movetoPosition.UF, true);	  // jogwin
	updateUfUtValue(crntGrpNum, FRMVAL_USER, movetoPosition.UF);	// common api
	setFrameCoordinate(crntGrpNum, FRMVAL_TOOL, movetoPosition.UT);	// api
	updateJogFrameNumber(FRMVAL_TOOL, movetoPosition.UT, true);	  // jogwin
	updateUfUtValue(crntGrpNum, FRMVAL_TOOL, movetoPosition.UT);	// common api
	// Just to be sure, wait for the value to be set.
	setTimeout(function () { }, 10);
	// reset current select frame type...
	sendJogTypeCart(crntGrpNum, currentFrame);	// api
	// Next, Check program condition.
	checkProgramCondition();
}

/*
 * Abort program and continue moveto process.
 * call from dialog.
 * Stop currently exec program and continue.
 */
// === When program is running, abort program by user? ===
// === If abort by user, no need below function. ===
// === After confirm, delete function. ===
//function runAbortAndMoveto() {
//	debug(DBGDUMP, 'runAbortAndMoveto: ');
//	stopProgram(false);	// prgwin
//	abortProgram(getCurrentProgram(), checkMovementProgram);	// io
//}

/*
 * Check Movement-only program
 */
function checkMovementProgram(status, progName) {
  debug(DBGDUMP, 'checkMovementProgram: abortProgram(' + progName + '): status(' + status + ')');
  saveCurrentProgName = progName; // Save for stop/abort moveto.
	defineDialog.open(relatedMovetoBtnId, '#confmovetodlg', '');	// Confirm move to
}

/*
 * Confirm move robot
 */
function confirmOKMoveRobot() {
	// Check Movement-only program exist.
	loadFile(movementProgramName, loadMovementProgram, 0);
}
/*
 * Load Movement-only program
 */
function loadMovementProgram(status, progName, lines, lineCount, arg) {
	debug(DBGDUMP, 'loadMovementProgram: loadFile(' + progName + '): status(' + status + ')');
	progName = omitExtension(progName);
	if (status != IO_SUCCESS) { // May be not exist program...
		// Create movement-only program
		createPrg(progName, invisibleMovementProg);
		return;
  }
  // update motion instruction.
	editPrg(progName, makeMovementInst(), 1, PRGWRITE_OVW, initMovementProg);
}

/*
 * Make Movement-only program
 * (Write motion instruction)
 */
function makeMovementInst() {
  var movementInst = movementMotionInst;
  movementInst += (useVIAExtCommand) ? movementViaInst: '';
  movementInst += movementTerminateCh;
  return movementInst;
}

function invisibleMovementProg(status, progName) {
	debug(DBGDUMP, 'invisibleMovementProg: createPrg status: (' + status + ')');
	if (status != IO_SUCCESS) {	// Create-Error has occurd.
		handle_error(status);
		// Put error dialog...
		defineDialog.open(null, '#confalertdlg', 'dlgMsgSaveErr');
		return;
	}
	setAttr(progName, top.MM_CONTROL_C, "1", makeMovementProg);
}

/*
 * Make Movement-only program
 * (Write motion instruction)
 */
function makeMovementProg(status, progName) {
	debug(DBGDUMP, 'makeMovementProg: setAttr status: (' + status + ')');
	// Ignore status
  // Write motion instruction to program
	editPrg(progName, makeMovementInst(), 1, PRGWRITE_ADD, initMovementProg);
}

/*
 * Initialize Movement-only program
 */
function initMovementProg(status, progName) {
	debug(DBGDUMP, 'initMovementProg: editPrg status: (' + status + ')');
	if (status != 0) {
		handle_error(status);
		// Put error dialog...
		defineDialog.open(null, '#confalertdlg', 'dlgMsgSaveErr');
		return;
	}
	// Set Program attribute same as current program.
  var moveToInfo = ProgramInfoManager.getSpecifiedProgInfo(getMoveProgPrim());
  if (moveToInfo == null) {
    // Make Program Info object
    var progInfoObj = new ProgramFileInfo();
    // Initialyze data
    progInfoObj.init(getMoveProgPrim());
    ProgramInfoManager.setMovetoProgInfo(progInfoObj);
  }
	var currentAttr = ProgramInfoManager.getCurrentProgInfo().getEditAttrValue();
	saveMovetoAttribute(progName, currentAttr, setPositionData);
}

/*
 * Set Specified Position Data.
 */
function setPositionData(progName) {
	debug(DBGDUMP, 'setPositionData: (' + progName + ')');
	var progInfo = ProgramInfoManager.getCurrentProgInfo();
	// Call editPos()
	var posArray = [];
	posTempRec = createPosDataRow();  // poswin
	posArray[0] = $.extend({}, posTempRec, movetoPosition);
	posArray[0].recid = 1;
	posArray[0].rowno = 1;
	posArray[1] = createPosDataRow();	// poswin
	var posDataText = makePosition(progInfo, posArray);	// fileio
	editPos(progName, posDataText[0], setPositionCallback);
}

/*
 * Select(Change) to movement-only program.
 */
function setPositionCallback(status, progName) {
	debug(DBGDUMP, 'setPositionCallback: editPos(' + progName + '): status(' + status + ')');
	// vvv for using ROBOGUIDE
	//	setAttr(progName, top.MM_CONTROL_C, "0", tempVisibleMovetoProg);
	//}
	//function tempVisibleMovetoProg(status, progName) {
	//	debug(DBGDUMP, 'tempVisibleMovetoProg: setAttr(' + progName + '): status(' + status + ')');
	// Select movement-only program
	var cbArg = {};
	cbArg.func = chgMoveProgCallback;
	chgProg(progName, waitChgProgComplete, cbArg);
}

/*
 * execute the moving program.
 */
function chgMoveProgCallback(status, progName) {
	debug(DBGDUMP, 'chgMoveProgCallback: chgProg(' + progName + '): status(' + status + ')');
	setExecProgHold(false);
	setProgramExec(true);
	setMoveToOnProgram(true);
	var execBtnId = (isScrModeEditorTab()) ? '#execbtn' : '#playrun';
	$(execBtnId).removeClass('validexec');
	// Check Program execution mode.
	if (isProgramStepMode()) {	// if current mode is STEP, exchange to CONTINUOUS.
		exchangeStepMode();	// api
	}
	alreadyExchangeStepMode = false;
	// Execute move to program
	startMovetoStatus(execMovetoCallback);	// api
	setWatchExecValue(1); // main.js
	movetoStatus = 1;	// set move to status on
	execProgram(getMoveProgPrim(), execMovetoProgram);	// io
}

/*
 * Monitor execution of movement
 */
function execMovetoProgram(status, progName) {
	debug(DBGDUMP, 'execMovetoProgram: execProgram(' + progName + '): status(' + status + ')');
	// Process of execute program of movement.
	$(window).trigger('blur');	// focus out
	setTimeout(function() {
		debug(DBGDUMP, 'execMovetoProgram: call iovalrd(5)');
		top.rpcmc_iovalrd(top.tpout_type_c, 5, callbackMoveToStatus, 0, 0);
	}, 100);
}
var movetoStatus = 0;	// if 1, call stopMoveToProgram()
function callbackMoveToStatus(type, mode, status) {
	movetoStatus = status;
	debug(DBGDUMP, 'callbackMoveToStatus: status(' + status + ')/movetoStatus=' + movetoStatus);
	if (status == 0) {	// if already finished... stop moveto
		stopMoveToProgram();
	}
}
function execMovetoCallback() {
  debug(DBGDUMP, 'execMovetoCallback: Pass:');
  setTimeout(function() {
    var execStat = statusProgramInfoTrans.getCurrentProgramSI().stat;
    debug(DBGDUMP, 'execMovetoCallback: watchExec.stat(' + execStat + ')/movetoStatus=' + movetoStatus);
    if (movetoStatus == 1) {
      if (execStat == WATCHEXEC_ABORTED) {	// if finished... stop moveto
        stopMoveToProgram();
      } else if (execStat == WATCHEXEC_PAUSED) {
        stopMoveToProgram();  // Same as above now...
      }
    }
  }, 500);
}

/*
 * Monitor occurrence of alarm when move. (Call from watchAlarm(main.js))
 */
function monitorMovetoAlarm() {
	if (isMoveToOnProgram()) {
		debug(DBGINFO, 'Alarm has occured when movement.');
		stopMoveToProgram();
		top.dlg_shift_close();	// close 'Program is Running' popup...
	}
}

/*
 * Execution of movement is completed.
 */
function afterMovetoCallback() {
	var execStat = statusProgramInfoTrans.getCurrentProgramSI().stat;
	debug(DBGDUMP, 'afterMovetoCallback: watchExec.stat(' + execStat + ')');
	if (execStat != WATCHEXEC_ABORTED) {	// if move to exec or paused.
    setTimeout(function() {
      stopMoveToProgram();	// moveto.js
    }, 100);
		return;
	}
	movetoStatus = 0;
	setAttr(getMoveProgPrim(), top.MM_CONTROL_C, "1", finishMoveTo);
}

/*
 * Since the moving process is completed,
 * return to the editing state.
 */
function finishMoveTo(status, progName) {
	debug(DBGDUMP, 'finishMoveTo: ' + progName + ': status(' + status + ')');
	if (isProgramStepMode() && (!alreadyExchangeStepMode)) {	// if current mode is STEP, resume to STEP.
		exchangeStepMode();	// api
		alreadyExchangeStepMode = true;
	}
	// Select back to current edit program
	var cbArg = {};
	cbArg.func = completeMoveToProg;
	chgProg(saveCurrentProgName, waitChgProgComplete, cbArg);
}
function completeMoveToProg(status, progName) {
	debug(DBGDUMP, 'completeMoveToProg: ' + progName + ': status(' + status + ')');
}
/*
 * Reset MoveTo execution when load. (call from prgwin)
 */
function resetMoveToProgram() {
	abortProgram(getMoveProgPrim(), afterMovetoCallback);	// io
	top.rpcmc_iovalrd(top.tpout_type_c, 3, callbackStepStatus, 0, 0);
	return;
}

/*
 * Stop MoveTo program for unload.
 */
function stopMoveToProgram() {
	if ((getSelPosTblValue().tblId == POSREGSTBL) && !(isEnablePolling())) {
		startGetPosRegPolling();
	}
	debug(DBGINFO, 'Stop [Move to].');
	setProgramExec(false);
  setMoveToOnProgram(false);
  setWatchExecValue(0);
	abortProgram(getMoveProgPrim(), afterMovetoCallback);	// io
	removeOverlayScreen('exec');	// Operations such as editing will be enabled.
}
function unloadMoveToProgram() {
	if (isProgramStepMode() && (!alreadyExchangeStepMode)) {	// if current mode is STEP, resume to STEP.
		exchangeStepMode();	// api
		alreadyExchangeStepMode = true;
	}
	stopMoveToProgram();
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /**********************************************************************
 * Robot Program Editor script
 * Popup dialog script
 * Created: 2017/05/10 FSI
 * Modified:2017/08/21 Responding to specification changes.
 *                     = Responding to move override slider.
 *          2018/01/23 Modify Program Menu.
 *                     = Add Open/SaveAs/Rename
 *          2019/02/07 Modify for Tablet mode.
 *                     = Change each ID.
 */

/**********
  Popup dialog.
**********/
/*
 * Popup definition table.
 * id: popup id
 * mode: yesno = Popup with Yes/No button. Mainly for confirmation.
 *       slider = Popup with slider(bar).
 *       selection = Popup with select list. (like submenu)
 * arrow: Popup arrow (triangle) position. (left/right(default))
 * messageId: The ID of the message to insert.
 * resourceId: Message resource id. (Refer to lang.js)
 * slidemin: Slider minimum value.
 * slidemax: Slider maximum value.
 * slidestep: Slider step value.
 * sliderid: Slider element id.
 * selectId: Dropdown button ID. Mainly for calc arrow position.
 * list: Dropdown list. (submenu) :
 *     img = Image file path.
 *     btnid = Select item id.
 *     btncls= Button class.
 *     imgcls= Image tag class.
 *     resId = List(Menu) resource id.
 *     url   = Link URL.
 */
var popupDefTable = [
  {	// Used in command tree
    id: 'cmdinsconf',
    mode: 'yesno',
    arrow: 'left',
    messageId: 'insertconfirm',
    resourceId: 'pupTtlInsert'
  },
  {	// Used in Programm menu
    id: 'selectfile',
    mode: 'selection',
    arrow: 'left',
    adjust: 20,
    targetId: '#filemenu',
    selectId: '#filemenu',
    arrowType: 'ui-icon',
    calcWidth: false,
    list: [
      { 'img': 'images/button_open.png', 'btnid': 'fileopen', 'btncls': 'btnselfile', 'imgcls': 'imgselect', 'resId': 'toolBtnOpenProg' },
      { 'img': 'images/button_newprog.png', 'btnid': 'filenew', 'btncls': 'btnselfile', 'imgcls': 'imgselect', 'resId': 'toolBtnNewProg', 'chkValid': openMenuSetting },
      { 'img': 'images/button_saveprog.png', 'btnid': 'filesave', 'btncls': 'btnselfile', 'imgcls': 'imgselect', 'resId': 'toolBtnSaveProg', 'chkValid': openMenuSetting },
      { 'img': 'images/button_saveas.png', 'btnid': 'filesaveas', 'btncls': 'btnselfile', 'imgcls': 'imgselect', 'resId': 'toolBtnSaveAs', 'chkValid': openMenuSetting },
      { 'img': 'images/button_rename.png', 'btnid': 'filerename', 'btncls': 'btnselfile', 'imgcls': 'imgselect', 'resId': 'toolBtnRename', 'chkValid': openMenuSetting },
      { 'img': 'images/button_attribute.png', 'btnid': 'fileeditattr', 'btncls': 'btnselfile', 'imgcls': 'imgselect', 'resId': 'toolBtnAttribute', 'chkValid': openMenuSetting },
      // 2020/2/18 Hide for tablet TP release.
      // { 'img': 'images/button_applicationdata.png', 'btnid': 'fileappleditor', 'btncls': 'btnselfile', 'imgcls': 'imgselect', 'resId': 'toolBtnApplEditor', 'chkValid': openMenuSetting }
    ]
  },
  {	// Used in Position control button
    id: 'selposedit',
    mode: 'selection',
    arrow: 'left',
    adjust: 20,
    targetId: '#posctrledit',
    selectId: '#editbtn',
    arrowType: 'ui-icon',
    calcWidth: true,
    list: [
      { 'btnid': 'posctrlcopy', 'btncls': 'btnselposedit', 'resId': 'posTableCpy', 'icnPath': 'images/edit_copy.png' },
      { 'btnid': 'posctrlpaste', 'btncls': 'btnselposedit', 'resId': 'posTablePst', 'icnPath': 'images/edit_paste.png', 'chkValid': isValidPosPasteMenu },
      { 'btnid': 'posctrldel', 'btncls': 'btnselposedit', 'resId': 'posTableDel', 'icnPath': 'images/edit_delete.png' },
      { 'btnid': 'posctrlrepre', 'btncls': 'btnselposedit', 'resId': 'posTableRepre', 'icnPath': 'images/edit_repre.png', 'chkValid': isValidPosRepMenu }
    ]
  },
  {	// Used in Execute menu
    id: 'toggleexec',
    mode: 'selection',
    arrow: 'left',
    targetId: '#playrun',
    selectId: '#selexec',
    arrowType: 'ui-icon',
    calcWidth: false,
    list: [
      { 'img': 'images/button_playstep.png', 'btnid': 'playstep', 'btncls': 'btnselexec', 'imgcls': 'imgselect', 'resId': 'toolBtnPlayStep' },
      { 'img': 'images/button_playcont.png', 'btnid': 'playcont', 'btncls': 'btnselexec', 'imgcls': 'imgselect', 'resId': 'toolBtnPlayCont' }
    ]
  },
  {	// Used in Position tab control button of Tablet mode
    id: 'editpos',
    mode: 'selection',
    arrow: 'left',
    adjust: 20,
    targetId: '#edit_btn',
    selectId: '#edit_btn',
    calcWidth: true,
    list: [
      { 'btnid': 'posctrlcopy', 'btncls': 'btnselfile', 'resId': 'posTableCpy', 'icnPath': 'images/edit_copy.png' },
      { 'btnid': 'posctrlpaste', 'btncls': 'btnselfile', 'resId': 'posTablePst', 'icnPath': 'images/edit_paste.png', 'chkValid': isValidPosPasteMenu },
      { 'btnid': 'posctrldel', 'btncls': 'btnselfile', 'resId': 'posTableDel', 'icnPath': 'images/edit_delete.png' },
      { 'btnid': 'posctrlrepre', 'btncls': 'btnselfile', 'resId': 'posTableRepre', 'icnPath': 'images/edit_repre.png', 'chkValid': isValidPosRepMenu }
    ]
  },
  {	// Used in Move To button
    id: 'selposmove',
    mode: 'selection',
    arrow: 'left',
    adjust: 20,
    targetId: '#posctrlmov',
    selectId: '#movetobtn',
    arrowType: 'ui-icon',
    calcWidth: true,
    list: [
      { 'btnid': 'posmovlinear', 'btncls': 'btnselposmove', 'resId': 'posTableLINEAR'/*, 'icnPath': 'images/move_linear.png'*/ },
      { 'btnid': 'posmovusevia', 'btncls': 'btnselposmove', 'resId': 'posTableVIA'/*, 'icnPath': 'images/move_via.png'*/ }
    ]
  },
  {	// Used in Move To button of Tablet mode.
    id: 'movepos',
    mode: 'selection',
    arrow: 'left',
    adjust: 20,
    targetId: '#move_btn',
    selectId: '#movetobtn',
    arrowType: 'ui-icon',
    calcWidth: true,
    list: [
      { 'btnid': 'posmovlinear', 'btncls': 'btnselposmove', 'resId': 'posTableLINEAR'/*, 'icnPath': 'images/move_linear.png'*/ },
      { 'btnid': 'posmovusevia', 'btncls': 'btnselposmove', 'resId': 'posTableVIA'/*, 'icnPath': 'images/move_via.png'*/ }
    ]
  }
];

// To prevent size change that occurs when popup is opened
var openPopupFlg = false;
var popupFlgTimer;

/**
 * Search target id's popup definition from table.
 *  id : Target popup id.
 */
function searchPopupTable(id) {
  for (var i = 0; i < popupDefTable.length; i++) {
    var def = popupDefTable[i];
    if (def.id == id) {
      return def;
    }
  }
  return null;
}

/*
 * Calcurate String Rectangle(Width/Height).
 */
function calcStrRect(str) {
  var rulerTag = $('<span>', { id: 'strruler' });
  rulerTag.css({ 'visibility': 'hidden', 'position': 'absolute', 'font-size': '13px', 'white-space': 'nowrap' });
  rulerTag.text(str);
  $('body').append(rulerTag);
  var strRect = {};
  strRect.strWidth = rulerTag.get(0).offsetWidth;
  strRect.strHeight = rulerTag.get(0).offsetHeight;
  setTimeout(function () {
    $('#strruler').remove();
  }, 0);
  return strRect;
}

/**
 * Popup dialog function.
 * Generate the desired pop-up when needed.
 */
var popupDialog = (function () {
  // Open Dialog
  function open(targetId, popupBox) {
    $(targetId).append(popupBox);
  }
  // Close Dialog
  function close(popupId) {
    var idStr = '#' + popupId;
    $(idStr).remove();
  }
  // Combind process. (close dialog / remove overlay / change triangle button)
  function closePopupAndOverlay(popupId, ddnbtn) {
    close(popupId);
    $('#popmenuoverlay').hide();
    $('#popmenuoverlay').remove();
    ddnbtn.removeClass('ui-icon-triangleup-white');
    ddnbtn.addClass('ui-icon-triangledn-white');
  }
  return {
    // Confirm dialog (Yes/No)
    confirm: function (targetId, pos, procYes, procNo) {
      var defTable = searchPopupTable(targetId);
      var message = resources[defTable.resourceId];
      var popuparrow = (defTable.arrow == 'left') ? 'popupleftdlg' : 'popuprightdlg';
      var popupBox = $('<div>',
        { id: defTable.id, 'class': popuparrow });
      var popupMsg = $('<div>',
        { id: defTable.messageId, 'class': 'popupconfmsg' });
      popupMsg.html(message);
      var popupButton = $('<div>', { id: 'popupbtnarea' });
      var popupBtnYes = $('<button>', { id: 'popupyes', 'class': 'popupbtn popupyes' });
      popupBtnYes.html(resources['dlgBtnYes']);
      var popupBtnNo = $('<button>', { id: 'popupno', 'class': 'popupbtn popupno' });
      popupBtnNo.html(resources['dlgBtnNo']);
      popupBox.append(popupMsg);
      popupButton.append(popupBtnYes);
      popupButton.append(popupBtnNo);
      popupBox.append(popupButton);
      // for instruction list of tablet editor
      if (isIE && isScrModeEditorTab()) {
        var arrowPosition = 70; // adjust top by arrow
        $('head').append('<style>.popupleftdlg::before { top: ' + arrowPosition + 'px ; } </style>');
        $('head').append('<style>.popupleftdlg::after { top: ' + (arrowPosition - 2) + 'px ; } </style>');
      }
      var adjustY = $('#' + targetId);
      popupBox.css({ 'top': pos.y + POPUPARROWHEIGHT, 'left': pos.x });
      // to modal
      var appendId = (isScrModeEditorTab()) ? '#layoutarea' : '#pceditor';
      $(appendId).append('<div id="popupoverlay" class="popupoverlay"></div>');
      $('#popupoverlay').show();
      open(appendId, popupBox);
      $('#popupyes').focus();
      // Event handler
      $('#popupyes').on('click', function () {
        close(defTable.id);
        $('#popupoverlay').hide();
        $('#popupoverlay').remove();
        procYes();
      });
      $('#popupyes').on('keydown', function () {
        if (event.which == KEYCODE_ESC) {
          $('#popupno').click();
          return false;
        } else if (event.which == KEYCODE_TAB) {
          $('#popupno').focus();
          return false;
        }
      });
      $('#popupno').on('click', function () {
        close(defTable.id);
        $('#popupoverlay').hide();
        $('#popupoverlay').remove();
        procNo();
      });
      $('#popupno').on('keydown', function () {
        if (event.which == KEYCODE_ESC) {
          $('#popupno').click();
          return false;
        } else if (event.which == KEYCODE_TAB) {
          $('#popupyes').focus();
          return false;
        }
      });
    },
    selection: function (targetId) {
      var defTable = searchPopupTable(targetId);
      var idStr = '#' + defTable.id;
      var $popupSelecter = $(idStr);
      var $ddnbtn = $(defTable.selectId + 'ddn');	// dropdown button id
      if ($popupSelecter.length == 0) { // It's not currently displaying popup menu.
        $ddnbtn.removeClass('ui-icon-triangledn-white');
        $ddnbtn.addClass('ui-icon-triangleup-white');
        var popuparrow = (defTable.arrow == 'left') ? 'popupleftdlg' :
          (defTable.arrow == 'right') ? 'popuprightdlg' : 'popupmiddledlg';
        var popupBox = $('<div>',
          { id: defTable.id, 'class': popuparrow });
        var maxStrWidth = 0;
        var totalHeight = 0;
        // Inner data of popup
        for (var i = 0; i < defTable.list.length; i++) {
          var defItem = defTable.list[i];
          if ((defItem.chkValid != undefined) && (typeof defItem.chkValid === 'function')) {
            // Is this a valid menu?
            if (!defItem.chkValid()) {	// If invalid, skip append menu.
              if ((i == 1) && (getCurrentProgram() === '') && (isMyIFrameIdPrim()) || (i == 1) && progLoadError) {
                // If program is no select or failed load program, append create new program menu.
              } else {
                continue;
              }
            }
          }
          var pupsel = $('<button>', {
            'class': defItem.btncls,
            id: defItem.btnid
          });
          var popupStr = '<span class="selplayitem">' + resources[defItem.resId] + '</span>';
          if ((defItem.img !== undefined) && (defItem.img.length > 0)) {
            popupStr = '<img src="' + defItem.img + '" class="'
              + defItem.imgcls + '">' + popupStr;
          } else if (defItem.icnPath) {	// for tablet mode
            popupStr = '<img class="popup_icn" src="' + defItem.icnPath + '" >' + popupStr;
          }
          pupsel.html(popupStr);
          var calcRect = calcStrRect(pupsel.text());
          if (defTable.calcWidth) {
            var strWidth = calcRect.strWidth;
            strWidth = (defItem.icnPath) ? strWidth + 40 : strWidth;
            if (maxStrWidth < strWidth) {
              maxStrWidth = strWidth;
            }
          }
          totalHeight++;
          popupBox.append(pupsel);
        }
        // for position data of tablet editor
        if (isIE && isScrModeEditorTab()) {
          var arrowPosition = ((totalHeight * 48) - 12); // adjust top by arrow
          $('head').append('<style>.popupleftdlg::before { top: ' + arrowPosition + 'px ; } </style>');
          $('head').append('<style>.popupleftdlg::after { top: ' + (arrowPosition - 2) + 'px ; } </style>');
        }
        var $targetBtn = $(defTable.targetId);
        var targetAdjust = (isScrModeEditorTab()) ?
            $ddnbtn[0].offsetLeft - ($ddnbtn[0].clientWidth / 2) :
            $targetBtn[0].clientWidth - $ddnbtn[0].clientWidth - ($ddnbtn[0].clientWidth / 2);
        var targetX = $targetBtn.offset().left + targetAdjust;
        if (!openMenuSetting()) {	// FSI 20181207 for multi window
          targetX += 15;
        }
        targetAdjust = (isScrModeEditorTab()) ? -((totalHeight * 38) + 2 + 24) : $targetBtn[0].clientHeight;
        var targetY = $targetBtn.offset().top + targetAdjust;
        popupBox.css({ 'top': targetY, 'left': targetX, 'text-align': 'left' });
        if (maxStrWidth > 0) {
          popupBox.css({ 'width': (maxStrWidth + 10 + 12) });	// add (margin+border+padding)+padding
        }
        // to modal
        var appendId = (isScrModeEditorTab()) ? '#layoutarea' : '#pceditor';
        $(appendId).append('<div id="popmenuoverlay" class="popupoverlay"></div>');
        $('#popmenuoverlay').show();

        // Wait 600 msec for suppression of resize event at popup raise.
        // for Tablet mode.
        popupFlgTimer = setTimeout(function () {
          openPopupFlg = false;
        }, 600);
        debug(DBGDUMP, 'Popup selection:');
        tabletDebug('trace', 'Popup selection:');
        var appendId = (isScrModeEditorTab()) ? '#layoutarea' : '#pceditor';
        open(appendId, popupBox);
      } else {
        closePopupAndOverlay(defTable.id, $ddnbtn);
      }
      // Event handler
      $('.btnselexec').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        closePopupAndOverlay(defTable.id, $ddnbtn);
        var launchId = event.currentTarget.id;
        // change status
        setProgramStepMode((launchId === 'playstep') ? true : false);	// prgwin
        top.rpcmc_iovalrd(top.tpout_type_c, 3, callbackStepStatus, 0, 0);
      });
      $('.btnselfile').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        closePopupAndOverlay(defTable.id, $ddnbtn);
        return false;
      });
      $('.btnselposedit').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        closePopupAndOverlay(defTable.id, $ddnbtn);
        return false;
      });
      $('.btnselposmove').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        closePopupAndOverlay(defTable.id, $ddnbtn);
        return false;
      });
      // click new program button.
      $('#filenew').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        if ((isProgramModified()) || (isPositionModified()) ||	// If modified
          // Add STEP6: When there is an editing program, it is judged that editing is in progress.
          (isExistEditProgramFile(getTempProgName(getCurrentProgram())))) {
          tempEditPrg = isProgramModified();
          tempEditPos = isPositionModified();
          defineDialog.open('#filenew', '#confmodifieddlg', '');	// Confirm save modified
        } else {
        	
          isDispMoveToMoniDlg('',function() {
            defineDialog.open('#filenew', '#getprogdlg', '');	// Get program name
          });
    	}
        return false;
      });
      // click save button.
      $('#filesave').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        if (hasErrorRecord()) {	// Check error only.
          defineDialog.open(null, '#posalertdlg', 'dlgMsgIncompRow');
        } else {
          if ((isProgramModified()) || (isPositionModified()) ||	// If modified
              (isExistEditProgramFile(getTempProgName(getCurrentProgram())))) { // or edit file is exist.
            defineDialog.open('#filesave', '#confsavedlg', '');		// Confirm save
          }
        }
        return false;
      });
      // click open button.
      $('#fileopen').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        if (!isMyIFrameIdPrim()) {
          openOpenDialog();
          return false;
        }
        if ((isProgramModified()) || (isPositionModified()) ||	// If modified
          // Add STEP6: When there is an editing program, it is judged that editing is in progress.
          (isExistEditProgramFile(getTempProgName(getCurrentProgram())))) {
          tempEditPrg = isProgramModified();
          tempEditPos = isPositionModified();
          defineDialog.open('#fileopen', '#selchangedlg', '');	// Confirm save modified
        } else {
          openOpenDialog();
        }
        return false;
      });
      // click save as button.
      $('#filesaveas').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        if (hasErrorRecord()) {	// Check error only.
          defineDialog.open(null, '#posalertdlg', 'dlgMsgIncompRow');
        } else {
          isDispMoveToMoniDlg('',function() {
            defineDialog.open('#filesaveas', '#getsvasprogdlg', 'dlgMsgIptPgSaveAs');		// Get program name
          });
        }
        return false;
      });
      // click rename button.
      $('#filerename').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        if (hasErrorRecord()) {	// Check error only.
          defineDialog.open(null, '#posalertdlg', 'dlgMsgIncompRow');
        } else {
        	isDispMoveToMoniDlg('',function() {
              defineDialog.open('#filerename', '#getrenameprogdlg', 'dlgMsgIptPgRename');		// Get program name
            });
        }  
        return false;
      });
      // click editattribute button.
      $('#fileeditattr').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        if ((isProgramModified()) || (isPositionModified()) ||	// If modified
          // When there is an editing program, it is judged that editing is in progress.
          (isExistEditProgramFile(getTempProgName(getCurrentProgram())))) {
          defineDialog.open('#fileeditattr', '#confsaveprgdlg', '');	// Confirm save before edit attr.
        } else {
          editAttrDlg.open('#fileeditattr', '#editattrdlg', false);		// Get program attribute
        }
        return false;
      });
      // click appleditor button.
      $('#fileappleditor').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        if (hasErrorRecord()) {	// Check error only.
          defineDialog.open(null, '#posalertdlg', 'dlgMsgIncompRow');
        } else {
          defineDialog.open('#fileappleditor', '#appleditordlg', "");
        }
        return false;
      });
      // Click Delete button.
      $('#posctrldel').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        selectPosDeleteMenu(event);
        return false;
      });
      // Click Copy button.
      $('#posctrlcopy').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        selectPosCopyMenu(event);
        return false;
      });
      // Click Paste button.
      $('#posctrlpaste').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        selectPosPasteMenu(event);
        return false;
      });
      // Click Repre button.
      $('#posctrlrepre').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        selectPosRepreMenu(event);
        return false;
      });
      // Click Linear menu
      $('#posmovlinear').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        moveToPosition(MOVETO_LINEAR);
        return false;
      });
      // Click Use VIA menu
      $('#posmovusevia').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        moveToPosition(MOVETO_USEVIA);
        return false;
      });
    }
  }
})();

function callbackStepStatus(iotype, index, stepstatus, callbackarg1, callbackarg2) {
  // Step mode exchange
  if ((isProgramStepMode() && (stepstatus == '0')) || 	// prgwin current=step set=continuous send command
    (!isProgramStepMode() && (stepstatus == '1'))) {	//        current=continuous set=step send command
    exchangeStepMode();	// api
  }
}

/**
 * Catch window click event ... Turn off popup.
 **/
function turnoffPopup() {
  if ($('#selectfile').length > 0) {
    $('#selectfile').remove();
    $('#filemenuddn').removeClass('ui-icon-triangleup-white');
    $('#filemenuddn').addClass('ui-icon-triangledn-white');
  } else if ($('#selposedit').length > 0) {
    $('#selposedit').remove();
    $('#editbtnddn').removeClass('ui-icon-triangleup-white');
    $('#editbtnddn').addClass('ui-icon-triangledn-white');
    //setFocusAfterPosCtrl('');	// poswin May be no need...
  } else if ($('#editpos').length > 0) {
    $('#editpos').remove();
    $('#edit_btnddn').removeClass('ui-icon-triangleup-white');
    $('#edit_btnddn').addClass('ui-icon-triangledn-white');
  } else if ($('#toggleexec').length > 0) {
    $('#toggleexec').remove();
    $('#selexecddn').removeClass('ui-icon-triangleup-white');
    $('#selexecddn').addClass('ui-icon-triangledn-white');
  } else if ($('#selposmove').length > 0) { // PC mode MoveTo Popup
    $('#selposmove').remove();
    $('#movetobtnddn').removeClass('ui-icon-triangleup-white');
    $('#movetobtnddn').addClass('ui-icon-triangledn-white');
  } else if ($('#movepos').length > 0) {  // Tablet mode MoveTo Popup
    $('#movepos').remove();
    $('#movetobtnddn').removeClass('ui-icon-triangleup-white');
    $('#movetobtnddn').addClass('ui-icon-triangledn-white');
  }
}
                                                                                                                                                                               /**********************************************************************
 * Robot Program Editor script
 * for Position data window.
 * Created: 2017/04/12
 * Modified:2019/04/02 for STEP8
 *                     Fix for code with quality problems.
 */
// Use w2ui.
/* w2ui 1.5.rc1 (nightly) (c) http://w2ui.com, vitmalina@gmail.com */
/* Code licensed under the MIT License. */
/* https://github.com/vitmalina/w2ui/blob/master/license.txt */

/*
  Position data window process.
*/

/**
 * Definition for Position data window.
 */
var currentFrameType = -1;
function getCurrentFrameType() {
  return currentFrameType;
}
function setCurrentFrameType(frame) {
  currentFrameType = frame;
}
var currentCsrRec = 0;

var currentAxesCount = 6;
var SELGRID_CELL = 'cell';
var SELGRID_ROW = 'row';
var FIELD_UF = 'UF';
var FIELD_UT = 'UT';
var FIELD_CONFIG = 'Config';
var postblValueList = [
  { 'resId': 'lblCartPos', 'tblId': POSDATAREA, 'gridPref': GRIDPOSDAT_PREF },
  { 'resId': 'titlePosReg', 'tblId': POSREGSTBL, 'gridPref': GRIDPOSREG_PREF }
];
var CELLBGCOL_MASK = 'rgba(204, 192, 204, 0.8)';
var CELLBGCOL_LRED = 'rgba(255, 16, 16, 0.4)';
var CELLBGCOL_LGRY = 'rgba(199, 206, 215, 1.0)';
var COLUMN_SHOW = 1;
var COLUMN_HIDE = 0;
// Position data table column offset
var COLTBLOFS_CMNT = 1;
var COLTBLOFS_J1 = 2;
var COLTBLOFS_J2 = 3;
var COLTBLOFS_J3 = 4;
var COLTBLOFS_J4 = 5;
var COLTBLOFS_J5 = 6;
var COLTBLOFS_J6 = 7;
var COLTBLOFS_X = 8;
var COLTBLOFS_Y = 9;
var COLTBLOFS_Z = 10;
var COLTBLOFS_W = 11;
var COLTBLOFS_P = 12;
var COLTBLOFS_R = 13;
var COLTBLOFS_EX1 = 14;
var COLTBLOFS_EX2 = 15;
var COLTBLOFS_EX3 = 16;
var COLTBLOFS_UF = 17;
var COLTBLOFS_UT = 18;
var COLTBLOFS_CONF = 19;

// robot posdata config
var POS_CONF;

function setPosConf(config_str) {
  POS_CONF = config_str;
}
function getPosConf() {
  return POS_CONF;
}

/* --- position data modify flag --- */
var positionModified = false;
function isPositionModified() {
  return positionModified;
}
function setPositionModified(modify) {
  positionModified = modify;
  if (isScrModeEditorTab()) {
    changeSavebtnstate();
  }
};
/* --- Position table kind list --- */
var openSelPosTblList = false;
function isOpenSelPosTblList() {
  return openSelPosTblList;
}
function setOpenSelPosTblList(stat) {
  openSelPosTblList = stat;
}
/* --- Position table kind value --- */
var selPosTblKind = POSTBLKIND_DATA;	// position table kind initial value is 'data'.
function getSelPosTblValue() {
  return postblValueList[selPosTblKind];
}
function getSelPosTblId() {
  return '#' + getSelPosTblName();
}
function getSelPosTblName() {
  return getSelPosTblValue().tblId;
}
function getSelPosTblKind() {
  return selPosTblKind;
}
function setSelPosTblKind(index) {
  selPosTblKind = index;
}
function getPosRecIdPrefix() {
  return (getSelPosTblKind() == POSTBLKIND_DATA) ? '#' + GRIDPOSDAT_PREF : '#' + GRIDPOSREG_PREF;
}

/* posdata = position data array */
//var entrykeys = ['X','Y','Z','W','P','R','J1','J2','J3','J4','J5','J6'];	// may be no need...
var posDatHead = ['No.', 'Comment'];
var entrykeysCart = ['X', 'Y', 'Z', 'W', 'P', 'R'];
var entrykeysJoint = ['J1', 'J2', 'J3', 'J4', 'J5', 'J6'];
var entrykeysExt = ['EXT1', 'EXT2', 'EXT3'];
var entryColPosExt = [COLTBLOFS_EX1, COLTBLOFS_EX2, COLTBLOFS_EX3];	// Extend column position
var entrykeysForm = [FIELD_UF, FIELD_UT, FIELD_CONFIG];
// FSI 20181122 Toggle display hidden in PosReg table
var entrykeysConf = [FIELD_CONFIG];
var captionPosTbl = [];
captionPosTbl = captionPosTbl.concat(posDatHead).concat(entrykeysJoint).concat(entrykeysCart).concat(entrykeysExt).concat(entrykeysForm);
var POSFIELDARRAY = ['rowno', 'Comment'];
POSFIELDARRAY = POSFIELDARRAY.concat(entrykeysJoint).concat(entrykeysCart).concat(entrykeysExt).concat(entrykeysForm);
function getEntryVal(entrykey, poskeys) {
  for (posarr in poskeys) {
    if (entrykey == poskeys[posarr].key) {
      return poskeys[posarr].val;
    }
  }
  return ('');
}
// Find the maximum record number in the position data.
function getPosRecMax(posData) {
  var posRecMax = 0;
  for (index in posData) {
    if (posRecMax < posData[index].posNumber) {
      posRecMax = posData[index].posNumber;
    }
  }
  return posRecMax;
}
// Get specified record number data
function getSpecifiedRecData(recNum, posData) {
  for (index in posData) {
    if (posData[index].posNumber == recNum) {
      return posData[index];
    }
  }
  return null;
}
// Generate position record.
function generateRecords(posdata) {
  var records = [];
  // Find the maximum record number in the position data.
  var recMax = getPosRecMax(posdata);
  for (var index = 0; index < recMax; index++) {
    var newRowData = createPosDataRow();	// [10/4/2017] {} -> createPosDataRow()
    var posRecData = getSpecifiedRecData(index + 1, posdata);
    if ((posRecData != null) && (posRecData.posData != undefined)) {
      var posRecNumber = posRecData.posNumber;
      var grpPosRec = posRecData.posData[getCurrentGroupNum() - 1];
      grpNum = grpPosRec.groupNumber;
      newRowData.GP = grpNum;
      newRowData.recid = posRecNumber;
      newRowData.rowno = posRecNumber;
      newRowData.Comment = (posRecData.Comment == undefined) ? '' : posRecData.Comment;
      var poskeys = grpPosRec.poskey;	// position key array
      for (entry in entrykeysCart) {
        var entrykey = entrykeysCart[entry];
        newRowData[entrykey] = getEntryVal(entrykey, poskeys);
      }
      for (entry in entrykeysJoint) {
        var entrykey = entrykeysJoint[entry];
        newRowData[entrykey] = getEntryVal(entrykey, poskeys);
      }
      // Check frame type
      newRowData.frame = checkPositionMode(newRowData);
      if (newRowData.frame == COORDINATECART) {
        newRowData.UF = grpPosRec.ufVal;
        newRowData.UT = grpPosRec.utVal;
        newRowData.Config = grpPosRec.configStr;
        newRowData.rep = (getExtendAxesCount(grpNum) > 0) ? POS_REP_BOTH : POS_REP_CART;
      } else if (newRowData.frame == COORDINATEJOINT) {
        newRowData.UF = grpPosRec.ufVal;	// need UF / UT value.
        newRowData.UT = grpPosRec.utVal;
        newRowData.rep = POS_REP_JOINT;
      } else {
        newRowData.rep = POS_REP_NONE;
      }
      // Set External axes value.
      for (entry in entrykeysExt) {
        var entrykey = entrykeysExt[entry];
        newRowData[entrykey] = getEntryVal(entrykey, poskeys);
      }
      newRowData.save = true;
    } else {	// Specified record is nothing.
      newRowData.recid = index + 1;
      newRowData.rowno = index + 1;
    }
    records[records.length] = newRowData;
  }
  return records;
}

/*
 * Column Show or Hide (Toggle)
 * @param target Target column type (0=Cartesian/1=Joint/2=UF,UT,Config/3=Config/4=Extend)
 */
function columnShowHide(tblKind, target) {
  var crntGrpNum = getCurrentGroupNum();
  switch (target) {
    case COORDINATECART:
      //w2ui[getSelPosTblName()].toggleColumn(...entrykeysCart);	// IE is not support "Spread syntax"
      w2ui[tblKind].toggleColumn.apply(w2ui[tblKind], entrykeysCart);
      break;
    case COORDINATEJOINT:
      var jointHidden = w2ui[tblKind].columns[COLTBLOFS_J1].hidden;
      if ((jointHidden !== undefined) && (jointHidden)) {	// current display is hidden
        // to show column
        var robotAxes = getJointRobotAxes(crntGrpNum);
        var jointCount = 0;
        for (; jointCount < robotAxes; jointCount++) {
          w2ui[tblKind].showColumn(entrykeysJoint[jointCount]);
        }
      } else {
        w2ui[tblKind].hideColumn.apply(w2ui[tblKind], entrykeysJoint);
      }
      break;
    case FIELDUFUTCONFIG:		// [7/6/2017] add: by request
      w2ui[tblKind].toggleColumn.apply(w2ui[tblKind], entrykeysForm);
      break;
    // FSI 20181122 Switch frame in position register table
    case FIELDCONFIG:
      w2ui[tblKind].toggleColumn.apply(w2ui[tblKind], entrykeysConf);
      break;
    case COORDINATEEXT:
      var extendHidden = w2ui[tblKind].columns[COLTBLOFS_EX1].hidden;
      if ((extendHidden !== undefined) && (extendHidden)) {	// current display is hidden
        // Show Ext. Column
        var extAxes = getExtendAxesCount(crntGrpNum);
        var extCount = 0;
        for (; extCount < extAxes; extCount++) {
          w2ui[tblKind].showColumn(entrykeysExt[extCount]);
        }
      } else {	// Hide
        w2ui[tblKind].hideColumn.apply(w2ui[tblKind], entrykeysExt);
      }
      break;
    default:
      debug(DBGERROR, 'Poswin: Illegal target type');
  }
}
/**
 * Get Position table select data condition.
 */
function getSelectCondition(myGrid, cmpRecid, selRecArray) {
  var selPosCond = {};
  // Check multi row by selection.
  selPosCond.isMultiRow = (crntGridSelType == SELGRID_CELL) ? isSelectMultiRow(selRecArray) : (selRecArray.length > 1);
  selPosCond.isNumColumn = (crntGridSelType == SELGRID_CELL) ? isSelectNumberColumn(selRecArray) : true;
  var targetRec = (crntGridSelType == SELGRID_CELL) ? selRecArray[0].recid : selRecArray[0];
  selPosCond.frameMatch = (selPosCond.isMultiRow) ? false : (getCurrentFrameType() == checkPositionMode(myGrid.records[targetRec - 1]));
  selPosCond.rowCond = (selPosCond.isMultiRow) ? POSROW_MULTIROW : getPosRowCondition(myGrid.records[targetRec - 1]);
  return selPosCond;
}
/**
 * Get Record row status
 */
function getPosRowCondition(posLine) {
  var rowCond = POSROW_EMPTY;
  if (isExistCartPosData(posLine)) {
    rowCond = (isIncompleteCartPos(posLine)) ? POSROW_NOCOMP : POSROW_CARTFRM;
  } else if (isExistJointPosData(posLine)) {
    rowCond = (isIncompleteJointPos(posLine)) ? POSROW_NOCOMP : POSROW_JOINTFRM;
  } else if (isAnyOtherDataExist(posLine)) {
    rowCond = POSROW_NOTANY;
  }
  return rowCond;
}
// Function of after position control button process.
function setFocusAfterPosCtrl(btnId) {
  if (btnId.length > 0) {
    $(btnId).blur();
  }
  // Set focus to current selected position table.
  if (isScrModePcEditor()) {
    $(getSelPosTblId()).w2grid().focus();
  }
}
// Function of resize and refresh procedure.
function posResizeRefresh(isRefresh) {
  w2ui[getSelPosTblName()].resize();
  var resizeEvent = { phase: 'before', target: getSelPosTblName(), type: 'resizeColumn', event: event };
  w2ui[getSelPosTblName()].trigger(resizeEvent);
  if (isRefresh) {
    w2ui[getSelPosTblName()].refresh();
  }
}

// Select grid type
var crntGridSelType = SELGRID_CELL;	// Initialization necessary.

// Variables for copy and paste
function getCopyGridSel() {
  var crntFrmObj = loadEditorStorage(SAVE_COPY_DATA[COPY_GRID_SEL]);
  return crntFrmObj;
}
function getCopyCrntFrm() {
  var gridSelObj = loadEditorStorage(SAVE_COPY_DATA[COPY_CRNT_FRAME]);
  return gridSelObj;
}
function setCopyGridSel(gridSel) {
  top.sessionStorage.setItem(SAVE_COPY_DATA[COPY_GRID_SEL], gridSel);
}
function setCopyCrntFrm(crntFrm) {
  top.sessionStorage.setItem(SAVE_COPY_DATA[COPY_CRNT_FRAME], crntFrm);
}
var copyEventInfo = {};
copyEventInfo.text = '';
copyEventInfo.key = '';
copyEventInfo.frame = -1;
copyEventInfo.tblKind = '';
function getSelectGridRecid(tblKind) {
  var selGrid = w2ui[tblKind].getSelection();
  var selRecIds = [];
  for (var i = 0; i < selGrid.length; i++) {
    var selRecId = (crntGridSelType == SELGRID_CELL) ? selGrid[i].recid : selGrid[i];
    // Check already exist.
    if ($.inArray(selRecId, selRecIds) < 0) {
      var gridObj = {};
      gridObj.id = selRecId;
      gridObj.frame = w2ui[tblKind].get(selRecId).frame;
      selRecIds.push(gridObj);
    }
  }
  return selRecIds;
}
function setCopyEventInfo(text, tblKind, key, currentFrame, selType) {
  setSaveCopyObj(text, tblKind, key, currentFrame, selType)
}
function getCopyEventInfo() {
  var copyObj = loadEditorStorage(null);
  return copyObj;
}

// valid refresh when draw polling data.
var posEditFieldOn = { cond: false, rec: 0, col: 0 };
function isPosEditFieldOn() {
  return posEditFieldOn.cond;
}
function isUnselectEditField(recid, column) {
  // If it does not match the EditField, it ends editing.
  return ((posEditFieldOn.rec != recid) || (posEditFieldOn.col != column));
}
function setPosEditFieldOn(cond, rec, col) {
  posEditFieldOn.cond = cond;
  posEditFieldOn.rec = rec;
  posEditFieldOn.col = col;
}

/**
 * Position table define by w2ui library.
 */
function definePositionTable() {
  $('#' + POSDATAREA).w2grid({
    name: POSDATAREA,
    method: 'GET',
    selectType: SELGRID_CELL,
    recordHeight: 28,
    columns: [
      { field: 'rowno', caption: captionPosTbl[0], size: '35px', min: 35, style: 'text-align: right; background-color: rgba(204, 192, 204, 0.8)' },
      { field: 'Comment', caption: captionPosTbl[COLTBLOFS_CMNT], size: '15%', min: 75, resizable: true, editable: { type: 'text' } },
      { field: 'J1', caption: captionPosTbl[COLTBLOFS_J1], size: '10%', min: 58, resizable: true, style: 'text-align: right', editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosDataRender },
      { field: 'J2', caption: captionPosTbl[COLTBLOFS_J2], size: '10%', min: 58, resizable: true, style: 'text-align: right', editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosDataRender },
      { field: 'J3', caption: captionPosTbl[COLTBLOFS_J3], size: '10%', min: 58, resizable: true, style: 'text-align: right', editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosDataRender },
      { field: 'J4', caption: captionPosTbl[COLTBLOFS_J4], size: '10%', min: 57, resizable: true, style: 'text-align: right', editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosDataRender },
      { field: 'J5', caption: captionPosTbl[COLTBLOFS_J5], size: '10%', min: 57, resizable: true, style: 'text-align: right', editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosDataRender },
      { field: 'J6', caption: captionPosTbl[COLTBLOFS_J6], size: '10%', min: 57, resizable: true, style: 'text-align: right', editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosDataRender },
      { field: 'X', caption: captionPosTbl[COLTBLOFS_X], size: '10%', min: 58, resizable: true, style: 'text-align: right', editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosDataRender },
      { field: 'Y', caption: captionPosTbl[COLTBLOFS_Y], size: '10%', min: 58, resizable: true, style: 'text-align: right', editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosDataRender },
      { field: 'Z', caption: captionPosTbl[COLTBLOFS_Z], size: '10%', min: 58, resizable: true, style: 'text-align: right', editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosDataRender },
      { field: 'W', caption: captionPosTbl[COLTBLOFS_W], size: '10%', min: 57, resizable: true, style: 'text-align: right', editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosDataRender },
      { field: 'P', caption: captionPosTbl[COLTBLOFS_P], size: '10%', min: 57, resizable: true, style: 'text-align: right', editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosDataRender },
      { field: 'R', caption: captionPosTbl[COLTBLOFS_R], size: '10%', min: 57, resizable: true, style: 'text-align: right', editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosDataRender },
      { field: 'EXT1', caption: captionPosTbl[COLTBLOFS_EX1], size: '7%', min: 40, resizable: true, style: 'text-align: right', editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosDataRender },
      { field: 'EXT2', caption: captionPosTbl[COLTBLOFS_EX2], size: '7%', min: 40, resizable: true, style: 'text-align: right', editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosDataRender },
      { field: 'EXT3', caption: captionPosTbl[COLTBLOFS_EX3], size: '6%', min: 40, resizable: true, style: 'text-align: right', editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosDataRender },
      { field: FIELD_UF, caption: captionPosTbl[COLTBLOFS_UF], size: '5%', min: 32, resizable: true, style: 'text-align: center', editable: { type: 'int', min: 0 }, render: setPosUFUTRender },
      { field: FIELD_UT, caption: captionPosTbl[COLTBLOFS_UT], size: '5%', min: 32, resizable: true, style: 'text-align: center', editable: { type: 'int', min: 1 }, render: setPosUFUTRender },
      { field: FIELD_CONFIG, caption: captionPosTbl[COLTBLOFS_CONF], size: '10%', min: 58, resizable: true, style: 'text-align: left', editable: { type: 'text' }, render: setConfRender}
    ],
  });

  // Position register grid
  $('#' + POSREGSTBL).w2grid({
    name: POSREGSTBL,
    method: 'GET',
    selectType: SELGRID_CELL,
    recordHeight: 28,
    columns: [
      { field: 'rowno', caption: 'No.', size: '10%', min: 35, style: 'text-align: right; background-color:#c7ced7' },
      { field: 'Comment', caption: captionPosTbl[COLTBLOFS_CMNT], size: '15%', min: 75, editable: { type: 'text' }, render: setRenderStr },
      { field: 'J1', caption: captionPosTbl[COLTBLOFS_J1], size: '10%', min: 58, editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosRegRender, hidden: false },
      { field: 'J2', caption: captionPosTbl[COLTBLOFS_J2], size: '10%', min: 58, editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosRegRender, hidden: false },
      { field: 'J3', caption: captionPosTbl[COLTBLOFS_J3], size: '10%', min: 58, editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosRegRender, hidden: false },
      { field: 'J4', caption: captionPosTbl[COLTBLOFS_J4], size: '10%', min: 57, editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosRegRender, hidden: false },
      { field: 'J5', caption: captionPosTbl[COLTBLOFS_J5], size: '10%', min: 57, editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosRegRender, hidden: false },
      { field: 'J6', caption: captionPosTbl[COLTBLOFS_J6], size: '10%', min: 57, editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosRegRender, hidden: false },
      { field: 'X', caption: captionPosTbl[COLTBLOFS_X], size: '10%', min: 58, editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosRegRender, hidden: false },
      { field: 'Y', caption: captionPosTbl[COLTBLOFS_Y], size: '10%', min: 58, editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosRegRender, hidden: false },
      { field: 'Z', caption: captionPosTbl[COLTBLOFS_Z], size: '10%', min: 58, editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosRegRender, hidden: false },
      { field: 'W', caption: captionPosTbl[COLTBLOFS_W], size: '10%', min: 57, editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosRegRender, hidden: false },
      { field: 'P', caption: captionPosTbl[COLTBLOFS_P], size: '10%', min: 57, editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosRegRender, hidden: false },
      { field: 'R', caption: captionPosTbl[COLTBLOFS_R], size: '10%', min: 57, editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosRegRender, hidden: false },
      { field: 'EXT1', caption: captionPosTbl[COLTBLOFS_EX1], size: '7%', min: 40, editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosRegRender, hidden: false },
      { field: 'EXT2', caption: captionPosTbl[COLTBLOFS_EX2], size: '7%', min: 40, editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosRegRender, hidden: false },
      { field: 'EXT3', caption: captionPosTbl[COLTBLOFS_EX3], size: '6%', min: 40, editable: { type: 'float', min: -99999999, max: 99999999 }, render: setPosRegRender, hidden: false },
      { field: 'UF', caption: captionPosTbl[COLTBLOFS_UF], size: '5%', min: 32, style: 'background-color:#c7ced7' },
      { field: 'UT', caption: captionPosTbl[COLTBLOFS_UT], size: '5%', min: 32, style: 'background-color:#c7ced7' },
      { field: FIELD_CONFIG, caption: captionPosTbl[COLTBLOFS_CONF], size: '10%', min: 58, editable: { type: 'text' }, render: setRenderStr }
    ]
  });

  // Set Paging area for Position Register
  if (isScrModePcEditor()) {
    setPageLayout($('#posregpage'));	// paging.js
    initResourceAfterLayout();	// lang.js
    setPosRegColumnsData();	// posreg
    getPosRegMaxNumber(posRegMaxNumCallback);	// api
  }

  var backUpPositionData = null;
  var backUpPosRegData = null;

	/*
	* Add event listener...
	*/
  // cell click or move cursor
  w2ui[POSDATAREA].on('click', function (event) {
    debug(DBGDUMP, 'Grid click (PosData): recid=' + event.recid + ': col=' + event.column);
    gridClickOrMoveProc(event, POSDATAREA);
  });
  if (isScrModePcEditor()) {
    w2ui[POSREGSTBL].on('click', function (event) {
      debug(DBGDUMP, 'Grid click (PosRegs): recid=' + event.recid + ': col=' + event.column);
      gridClickOrMoveProc(event, POSREGSTBL);
    });
  }
  // cell input control
  w2ui[POSDATAREA].on('editField', function (event) {
    debug(DBGDUMP, 'Grid editField (PosData): recid=' + event.recid + ': col=' + event.column);
    // back up original position data for J1~6,XYZWPR,EX1~3
    if ((event.column >= COLTBLOFS_J1) && (event.column <= COLTBLOFS_EX3)) { // POSFIELDARRAY
      var record = w2ui[POSDATAREA].records[event.recid - 1];
      backUpPositionData = record[POSFIELDARRAY[event.column]];
      if (backUpPositionData != "") {
        if (typeof backUpPositionData == "string") {
          backUpPositionData = Number(backUpPositionData);
        }
        record[POSFIELDARRAY[event.column]] = Number(backUpPositionData.toFixed(3));
      }
    }
    gridEditFieldProc(event, POSDATAREA);
  });
  if (isScrModePcEditor()) {
    w2ui[POSREGSTBL].on('editField', function (event) {
      debug(DBGDUMP, 'Grid editField (PosRegs): recid=' + event.recid + ': col=' + event.column);
      // back up original position register data for J1~6,XYZWPR,EX1~3
      if ((event.column >= COLTBLOFS_J1) && (event.column <= COLTBLOFS_EX3)) { // POSFIELDARRAY
        var record = w2ui[POSREGSTBL].records[event.recid - 1];
        backUpPosRegData = record[POSFIELDARRAY[event.column]];
        if (backUpPosRegData != "") {
          if (typeof backUpPosRegData == "string") {
            backUpPosRegData = Number(backUpPosRegData);
          }
          record[POSFIELDARRAY[event.column]] = Number(backUpPosRegData.toFixed(3));
        }
      }
      gridEditFieldProc(event, POSREGSTBL);
    });
  }
  // if change cell data, save cell the data
  w2ui[POSDATAREA].on('change', function (event) {
    debug(DBGDUMP, 'Grid change (PosData): recid=' + event.recid + ': col=' + event.column);
    if ((event.column >= COLTBLOFS_J1) && (event.column <= COLTBLOFS_EX3) && (event.value_new !== "")) {
      event.value_new = Number(event.value_new.toFixed(3));
    }
    gridChangeCellData(event, POSDATAREA);
  });
  if (isScrModePcEditor()) {
    w2ui[POSREGSTBL].on('change', function (event) {
      debug(DBGDUMP, 'Grid change (PosRegs): recid=' + event.recid + ': col=' + event.column);
      if ((event.column >= COLTBLOFS_J1) && (event.column <= COLTBLOFS_EX3) && (event.value_new !== "")) { // POSFIELDARRAY
        event.value_new = Number(event.value_new.toFixed(3));
      }
      gridChangeCellData(event, POSREGSTBL);
    });
  }
  //paste event check
  w2ui[POSDATAREA].on('paste', function (event) {
    debug(DBGDUMP, 'Grid paste (PosData): recid=' + event.recid + ': col=' + event.column);
    gridPasteProc(event, POSDATAREA);
  });
  if (isScrModePcEditor()) {
    w2ui[POSREGSTBL].on('paste', function (event) {
      debug(DBGDUMP, 'Grid paste (PosRegs): recid=' + event.recid + ': col=' + event.column);
      gridPasteProc(event, POSREGSTBL);
    });
  }
  //copy event check
  w2ui[POSDATAREA].on('copy', function (event) {
    debug(DBGDUMP, 'Grid copy (PosData): copy data is \n' + event.text);
    setCopyEventInfo(event.text, POSDATAREA, '', getCurrentFrameType(), crntGridSelType);
  });
  if (isScrModePcEditor()) {
    w2ui[POSREGSTBL].on('copy', function (event) {
      debug(DBGDUMP, 'Grid copy (PosRegs): copy data is \n' + event.text);
      setCopyEventInfo(event.text, POSREGSTBL, '', getCurrentFrameType(), crntGridSelType);
    });
  }
  // resize column
  w2ui[POSDATAREA].on('columnResize', function (event) {
    event.onComplete = function (event) {
      debug(DBGDUMP, "Grid columnResize Complete (PosData): column:" + event.column + "/resize:" + event.resizeBy);
      paintMaskingCell();
    }
  });
  if (isScrModePcEditor()) {
    w2ui[POSREGSTBL].on('columnResize', function (event) {
      event.onComplete = function (event) {
        debug(DBGDUMP, "Grid columnResize Complete (PosRegs): column:" + event.column + "/resize:" + event.resizeBy);
        paintMaskingCell();
      }
    });
  }
  // for cut
  w2ui[POSDATAREA].on('keydown', function (event) {
    debug(DBGDUMP, 'Grid Keydown (PosData): Keycode=[' + event.originalEvent.keyCode + ']');
    gridKeyDownProc(event, POSDATAREA);
  });
  if (isScrModePcEditor()) {
    w2ui[POSREGSTBL].on('keydown', function (event) {
      debug(DBGDUMP, 'Grid Keydown (PosRegs): Keycode=[' + event.originalEvent.keyCode + ']');
      gridKeyDownProc(event, POSREGSTBL);
    });
  }
  // Select record
  w2ui[POSDATAREA].on('select', function (event) {
    debug(DBGDUMP, 'Grid select (PosData): recid=' + event.recid + ': col=' + event.column);
    gridPosSelectProc(event, POSDATAREA);
  });
  if (isScrModePcEditor()) {
    w2ui[POSREGSTBL].on('select', function (event) {
      debug(DBGDUMP, 'Grid select (PosRegs): recid=' + event.recid + ': col=' + event.column);
      gridPosSelectProc(event, POSREGSTBL);
    });
  }
  // Unselect record
  w2ui[POSDATAREA].on('unselect', function (event) {
    debug(DBGDUMP, 'Grid unselect (PosData): Col[' + event.column + ']/Rec[' + event.recid + ']');
    gridPosUnselectProc(event, POSDATAREA);
  });
  if (isScrModePcEditor()) {
    w2ui[POSREGSTBL].on('unselect', function (event) {
      debug(DBGDUMP, 'Grid unselect (PosData): Col[' + event.column + ']/Rec[' + event.recid + ']');
      gridPosUnselectProc(event, POSREGSTBL);
    });
  }
  w2ui[POSDATAREA].scroll_bak = w2ui[POSDATAREA].scroll;
  w2ui[POSDATAREA].scroll = function (event) {
    this.scroll_bak(event); // Add a paint masking cell to the scroll for grid.
    setTimeout(paintMaskingCell);
  };
  w2ui[POSREGSTBL].scroll_bak = w2ui[POSREGSTBL].scroll;
  w2ui[POSREGSTBL].scroll = function (event) {
    this.scroll_bak(event); // Add a paint masking cell to the scroll for grid.
    setTimeout(paintMaskingCell);
  };
  // restore original position data
  w2ui[POSDATAREA].on('restore', function (event) {
    if ((event.column >= COLTBLOFS_J1) && (event.column <= COLTBLOFS_EX3)) { // POSFIELDARRAY
      var record = w2ui[POSDATAREA].records[event.recid - 1];
      record[POSFIELDARRAY[event.column]] = backUpPositionData;
      backUpPositionData = null;
    }
  });
  if (isScrModePcEditor()) {
    // restore original position register data
    w2ui[POSREGSTBL].on('restore', function (event) {
      if ((event.column >= COLTBLOFS_J1) && (event.column <= COLTBLOFS_EX3)) { // POSFIELDARRAY
        var record = w2ui[POSREGSTBL].records[event.recid - 1];
        record[POSFIELDARRAY[event.column]] = backUpPosRegData;
        backUpPosRegData = null;
      }
    });
  }
  /* --- Functions for event processing ---*/
  // Click event procedure
  function gridClickOrMoveProc(event, tblKind) {
    if (isUnselectEditField(event.recid, event.column)) {
      setPosEditFieldOn(false, event.recid, event.column);
    }
    posSaveRec = w2ui[tblKind].get(event.recid);
    // save current cell info (row/column and record data)
    posCrntCol = event.column;
    var grid = w2ui[tblKind];
    crntGridSelType = grid.selectType;
    // 2018/08/09 FSI prevent keyboard appearance in Android
    var $input = $(grid.box).find('#grid_' + grid.name + '_focus');
    if (w2utils.isAndroid) {
      $($input).attr('readonly', true);
      setTimeout(function () {
        $($input).attr('readonly', false);
      }, 10);
    }
    if ((event.column == 0) || (event.column == undefined)) { // Click Number column. Add check undefined
      if (crntGridSelType == SELGRID_CELL) { // change selectType
        grid.selectType = SELGRID_ROW; // to row select
        crntGridSelType = grid.selectType; //memory of current mode
        grid.selectNone();
        grid.refresh();
      }
    } else { // valid column
      if (crntGridSelType == SELGRID_ROW) { // change selectType
        grid.selectType = SELGRID_CELL; // to cell select
        crntGridSelType = grid.selectType; //memory of current mode
        grid.selectNone();
        grid.refresh();
      }
    }
    event.onComplete = function (event) {	// Update after applying changes
      // FSI add 2017/10/30 for coloring invalid rows ([2019/6/3] Move from w2ui.js)
      paintIncompleteRows(w2ui[tblKind].records);
    };
  }

  // Check masked cell. true = Masked cell, false = Unmasked cell (editable).
  function isMaskedCell(targetRec, col) {
    var cellid = getPosRecIdPrefix() + 'data_' + (targetRec.rowno - 1) + '_' + col;
    var cellbg = $(cellid).css('background-color');
    return (cellbg == CELLBGCOL_MASK);
  }

  // Edit-Field event procedure
  function gridEditFieldProc(event, tblKind) {
    if (!isMyIFrameIdPrim()) {	// FSI 20181219 if not change, it is dual or triple window.
      defineDialog.open(null, '#confalertdlg', 'dlgMsgSecondEditor');	// Alert on
      event.preventDefault();
      return;
    }
    if (ProgramInfoManager.getCurrentProgInfo() !== null) {
      if ((ProgramInfoManager.getCurrentProgInfo().getEditAttrValue().PROTECT == PROTECTON) &&
        (getSelPosTblKind() == POSTBLKIND_DATA)) {
        defineDialog.open(null, '#confalertdlg', 'dlgMsgProtectEditor'); // Alert on
        event.preventDefault(); // FSI 20190527 if not change, it is protect program.
        return;
      }
    }
    if ((checkEditInvalid(true)) && (getSelPosTblKind() == POSTBLKIND_DATA)) {
      var alertStr = ((isScrModePcEditor()) ? 'dlgMsgNotEditableEditor' : 'dlgMsgNotEditableEditorTb');
      defineDialog.open(null, '#confalertdlg', alertStr); // Alert on
      event.preventDefault(); // FSI 20190618 if not change, it is not editable mode.
      return;
    }
    setPosEditFieldOn(true, event.recid, event.column);
    var allrecords = w2ui[tblKind].records;
    if (posCrntCol == 1) {
      return;
    }
    // Check cousor column is extend
    // [STEP6] if extend cell is gray, edit ignore.
    //if ((event.column >= COLTBLOFS_EX1) && (event.column <= (COLTBLOFS_EX3))) {
    //	return;	// cursor column is extend column, then continue...
    //}
    // Check current coordinate kind and gray cell ignore.
    if ((getCurrentFrameType() == COORDINATEJOINT) &&
      (checkCellValue(allrecords[event.index], 1))) {
      event.preventDefault();
    } else if ((getCurrentFrameType() == COORDINATECART) &&
      (checkCellValue(allrecords[event.index], 2))) {
      event.preventDefault();
    }
    if (!isMaskedCell(allrecords[event.index], event.column)) { // not exist cart/joint data.
      return;
    }
  }

  // Change event procedure
  function gridChangeCellData(event, tblKind) {
    if (event.value_new === event.value_previous) {	// if not change, no operation. (Strictly equivalent for empty cell)
      return;
    }
    dispOnWaitExchange();
    // Other than comment and config.
    if ((event.column != COLTBLOFS_CMNT) && (event.column != COLTBLOFS_CONF)) {
      var num = event.value_new;
      var str = String(num);
      if ((str.indexOf('.') > 0) && (str.startsWith('-'))) {
        if (str.length > 12) {
          str = str.substr(0, 12);
          event.value_new = parseFloat(str);
        }
      } else if ((str.indexOf('.') > 0) && (!str.startsWith('-'))) {
        if (str.length > 11) {
          str = str.substr(0, 11);
          event.value_new = parseFloat(str);
        }
      } else {
        if (str.length > 10) {
          str = str.substr(0, 10);
          event.value_new = parseFloat(str);
        }
      }
    }
    if (event.column == COLTBLOFS_CONF) { // FSI 20181018 converted position data(Config)
      var numSearch = event.value_new;
      if (confirmConfigAxisNum(numSearch)) {
        numSearch = numSearch.replace(/\s+/g, ""); // delete all spaces
        numSearch = numSearch.replace(/,(?![0-9]|[\-])/g, ""); // delete unnecessary commas
        numSearch = numSearch.replace(/,/g, ", "); // insert a space after commas
        numSearch = numSearch.replace(/(([a-zA-Z]))/g, " $1"); // insert a space before alphabetical letters
        numSearch = numSearch.trim(); // delete a leading space
        event.value_new = numSearch.toUpperCase(); // converted to capital letters
      } else {
        event.value_new = event.value_previous;
      }
    } else if (event.column == COLTBLOFS_CMNT) {
      if (checkLangAndCharBytes(event.value_new) && (tblKind == POSREGSTBL)) {
        event.value_new = event.value_previous ;
        w2ui[tblKind].records[event.recid - 1][COLTBLOFS_CMNT] = event.value_previous;
        defineDialog.open(null, '#confalertdlg', 'ERR2ByteChars'); // Alert on
        dispOffWaitExchange();
        return;
      }
      if (event.value_new.match(/[&']/)) {
        event.value_new = event.value_previous ;
        w2ui[tblKind].records[event.recid - 1][COLTBLOFS_CMNT] = event.value_previous;
        defineDialog.open(null, '#confalertdlg', 'msgInvalidChars'); // Alert on
        dispOffWaitExchange();
        return;
      }
      var cmntStr = event.value_new;
      if (cmntStr.sjisBytes() > POSCOMMENT_MAX) {
        event.value_new = cmntStr.cutOutBytes(POSCOMMENT_MAX);
      }
      cmtUpdateFlg[event.recid - 1] = true;
    } else {
      if ((tblKind == POSREGSTBL) && (event.value_new === "") && (event.value_previous !== "")) {
        event.value_new = event.value_previous;	// overwrite previous value
      }
    }
    var posLine = w2ui[tblKind].records[event.recid - 1];
    if (tblKind == POSDATAREA) {
      setPositionModified(true);
    }
    posLine.error = 0;
    if (($.inArray(event.column, entryColPosExt) < 0) &&
      (event.column != 1)) {	// row frame set. except extend Axes (column 14-16) and comment.
      posLine.frame = getCurrentFrameType();
    }
    dispOffWaitExchange();
    event.onComplete = function (event) {	// Update after applying changes
      if (tblKind == POSREGSTBL) {
        setContinuousUpdate(true);	// posreg
        var recData = { clm: event.column, num: 1 };
        recordPosRegValue(posLine, recData, null, false); // posreg
      } else {	// POSDATAREA
        // Pos data input directly, set rep.
        if (posLine.rep == POS_REP_NONE) {
          var newRep = POS_REP_NONE;
          if (posLine.frame == COORDINATECART) {
            newRep = (getExtendAxesCount(posLine.GP) > 0) ? POS_REP_BOTH : POS_REP_CART;
          } else if (posLine.frame == COORDINATEJOINT) {
            newRep = POS_REP_JOINT;
          }
          posLine.rep = newRep;
        }
      }
      // FSI add 2017/10/27 for coloring invalid rows ([2019/6/3] move from w2ui.js)
      paintIncompleteRows(w2ui[tblKind].records);
      addNewPosRecLine(event.recid, (event.value_new !== event.value_previous));
      dispOffWaitExchange();
    };
  }

  // Paste event procedure.
  function gridPasteProc(event, tblKind) {
    if (!isMyIFrameIdPrim()) {	// FSI 20181218 if not change, it is dual or triple window.
      defineDialog.open(null, '#confalertdlg', 'dlgMsgSecondEditor');	// Alert on
      event.preventDefault();
      return;
    }
    if (ProgramInfoManager.getCurrentProgInfo() !== null) {
      if ((ProgramInfoManager.getCurrentProgInfo().getEditAttrValue().PROTECT == PROTECTON) &&
        (getSelPosTblKind() == POSTBLKIND_DATA)) {
        defineDialog.open(null, '#confalertdlg', 'dlgMsgProtectEditor'); // Alert on
        event.preventDefault(); // FSI 20190527 if not change, it is protect program.
        return;
      }
    }
    if ((checkEditInvalid(true)) && (getSelPosTblKind() == POSTBLKIND_DATA)) {
      var alertStr = ((isScrModePcEditor()) ? 'dlgMsgNotEditableEditor' : 'dlgMsgNotEditableEditorTb');
      defineDialog.open(null, '#confalertdlg', alertStr); // Alert on
      event.preventDefault(); // FSI 20190618 if not change, it is not editable mode.
      return;
    }
    var copyInfo = getCopyEventInfo();
    if (copyInfo === null) {
      event.preventDefault();
      return false;
    }
    if (copyInfo.selType != crntGridSelType) {
      event.preventDefault();
      return false;
    }
    var currentFrame = getCurrentFrameType();
    if (copyInfo.frame !== currentFrame) {
      event.preventDefault();
      return false;
    }
    var selId = getSelectGridRecid(tblKind);	// get select paste record list
    var selIdList = [];
    dispOnWaitExchange();
    for (var i = 0; i < selId.length; i++) {
      selIdList.push(selId[i].id);
    }
    copyInfo.selId = selIdList;
    if (copyInfo.selType == SELGRID_ROW) {
      pasteCopiedRowsData(copyInfo);
    } else {
      pasteCopiedCellsData(event, tblKind, currentFrame, copyInfo);
    }
    w2ui[tblKind].save();
    event.isCancelled = true;
    event.stopPropagation();
    dispOffWaitExchange();
    paintIncompleteRows(w2ui[tblKind].records);
    paintMaskingCell();
    event.onComplete = function (event) {	// Update after applying changes
      // FSI add 2017/10/26 for coloring invalid rows ([2019/6/3] Move from w2ui.js)
      paintIncompleteRows(w2ui[tblKind].records);
    };
    return false;
  }

  function changeToolBtnMode() {
    setCopyGridSel(crntGridSelType);
    var crntFrmType = getCurrentFrameType();
    setCopyCrntFrm(crntFrmType);
    posCopyRec.frameType = crntFrmType;
    sessionStorage.posCopyRecFrameType = posCopyRec.frameType;
    clipPositionData = true;
    setFocusAfterPosCtrl(getSelPosTblId());
  }
  // Keydown event procedure.
  function gridKeyDownProc(event, tblKind) {
    var kdnKeyCode = event.originalEvent.keyCode;
    if ((event.originalEvent.ctrlKey) && (kdnKeyCode == KEYCODE_X)) { // if input key code of cut process
      if (!isMyIFrameIdPrim()) {	// If it is not the prim screen, the processing is invalidated.
        defineDialog.open(null, '#confalertdlg', 'dlgMsgSecondEditor');	// Alert on
        event.preventDefault();
        return;
      }
      if (ProgramInfoManager.getCurrentProgInfo() !== null) {
        if ((ProgramInfoManager.getCurrentProgInfo().getEditAttrValue().PROTECT == PROTECTON) &&
          (getSelPosTblKind() == POSTBLKIND_DATA)) {
          defineDialog.open(null, '#confalertdlg', 'dlgMsgProtectEditor'); // Alert on
          event.preventDefault(); // FSI 20190527 if not change, it is protect program.
          return;
        }
      }
      if ((checkEditInvalid(true)) && (getSelPosTblKind() == POSTBLKIND_DATA)) {
        var alertStr = ((isScrModePcEditor()) ? 'dlgMsgNotEditableEditor' : 'dlgMsgNotEditableEditorTb');
        defineDialog.open(null, '#confalertdlg', alertStr); // Alert on
        event.preventDefault(); // FSI 20190618 if not change, it is not editable mode.
        return;
      }
      event.text = w2ui[tblKind].copy();
      debug(DBGDUMP, 'Keydown: cut data is \n' + event.text);
      // copy process
      setCopyEventInfo(event.text, tblKind, kdnKeyCode, getCurrentFrameType(), crntGridSelType);
      cutSelectedPosData(tblKind);
      // turn on paste button
      changeToolBtnMode();
      positionButtonManager(event);
      event.preventDefault();
      event.stopPropagation();
    } else if ((event.originalEvent.ctrlKey) && (kdnKeyCode == KEYCODE_C)) { // if input key code of copy process
      // copy process
      // by w2ui copy event
      // turn on paste button
      changeToolBtnMode();
      positionButtonManager(event);
    } else if (kdnKeyCode == KEYCODE_DEL) { // input delete key
      if (!isMyIFrameIdPrim()) {	// If it is not the prim screen, the processing is invalidated.
        defineDialog.open(null, '#confalertdlg', 'dlgMsgSecondEditor');	// Alert on
        event.preventDefault();
        return;
      }
      if (ProgramInfoManager.getCurrentProgInfo() !== null) {
        if ((ProgramInfoManager.getCurrentProgInfo().getEditAttrValue().PROTECT == PROTECTON) &&
          (getSelPosTblKind() == POSTBLKIND_DATA)) {
          defineDialog.open(null, '#confalertdlg', 'dlgMsgProtectEditor'); // Alert on
          event.preventDefault(); // FSI 20190527 if not change, it is protect program.
          return;
        }
      }
      if ((checkEditInvalid(true)) && (getSelPosTblKind() == POSTBLKIND_DATA)) {
        var alertStr = ((isScrModePcEditor()) ? 'dlgMsgNotEditableEditor' : 'dlgMsgNotEditableEditorTb');
        defineDialog.open(null, '#confalertdlg', alertStr); // Alert on
        event.preventDefault(); // FSI 20190618 if not change, it is not editable mode.
        return;
      }
      cutSelectedPosData(tblKind);
      positionButtonManager(event);
      event.preventDefault();
      event.stopPropagation();
    } else if (kdnKeyCode == KEYCODE_ENTER) {
      if (crntGridSelType == SELGRID_ROW) {
        var crntSelect = w2ui[tblKind].getSelection();
        var crntRow = crntSelect[crntSelect.length - 1];
        for (var i = 0; i < crntSelect.length; i++) {
          w2ui[tblKind].unselect(crntSelect[i]);
        }
        w2ui[tblKind].select(crntRow + 1);
        w2ui[tblKind].scrollIntoView();
        event.preventDefault();
        event.stopPropagation();
      }
    } else if (kdnKeyCode == KEYCODE_TAB) {
      $(getSelPosTblId()).w2grid().focus();
      event.preventDefault();
      event.stopPropagation();
    }
  }
  function gridPosSelectProc(event, tblKind) {
    if (isUnselectEditField(event.recid, event.column)) {
      setPosEditFieldOn(false, event.recid, event.column);
    }
    event.onComplete = function (event) {	// Process after select complete.
      debug(DBGDUMP, 'Position select (' + tblKind + '): Col[' + event.column + ']/Rec[' + event.recid + ']/Type[' + crntGridSelType + ']');
      if (event.recid != undefined) {
        posSaveRec = w2ui[tblKind].get(event.recid);	// save recored data when select cell.
      }
      if (posTableStatus.mode != POSTABLE_TAB_CMNT) { // PC mode or Full mode
        positionButtonManager(event);
      }
    };
  }
  function gridPosUnselectProc(event, tblKind) {
    var unselCol = event.column;
    var unselRec = event.recid;
    event.onComplete = function (event) {	// Process after select complete.
      debug(DBGDUMP, 'Position unselect (' + tblKind + '): Col[' + unselCol + ']/Rec[' + unselRec + ']/Type[' + crntGridSelType + ']');
      positionButtonManager(event);
    };
  }

  /* === Each controll button event handler. === */

  $('#posdata').on('focusin', function (event) {
    if (isMyIFrameIdPrim()) {
      if (ProgramInfoManager.getCurrentProgInfo().getEditAttrValue().MTNGRP == 0) {
        setPosControlButton(0, 0);
        return;
      }
      positionButtonManager(event);
    }
  });
  $('#posdata').on('focusout', function (event) {
    if (editBtnFlg) { //click edit button for tablet mode position data.
      editBtnFlg = false;
      return false;
    }
    setPosControlButton(0, 0);
  });
  $('#posregstbl').on('focusin', function (event) {
    if (ProgramInfoManager.getCurrentProgInfo().getEditAttrValue().MTNGRP == 0) {
      setPosControlButton(0, 0);
      return;
    }
    positionButtonManager(event);
  });
  $('#posregstbl').on('focusout', function (event) {
    if (editBtnFlg) { //click edit button for tablet mode position data.
      editBtnFlg = false;
      return false;
    }
    setPosControlButton(0, 0);
  });
  var editBtnFlg = false;
  $('#edit_btn').on('mousedown', function (event) {
    editBtnFlg = true;
  });
  $('#move_btn').on('mousedown', function (event) {
    editBtnFlg = true;
  });
  $('#posctrledit').on('mousedown', function (event) {
    if (w2utils.isIOS) {  // When use iPad.
      tabletDebug('dump', 'posctrledit mousedown:');  // for DEBUG
    }
    return false;
  });
  $('#posctrledit').on('mouseup', function (event) {
    if (!($(this).hasClass("posctrlactiv"))) {
      return false;
    }
    tabletDebug('trace', 'posctrledit mouseup:');
    if (w2utils.isIOS) {  // Prevent keyboard appearance in iPad.
      $('#grid_posdata_records').attr('readonly', true);
      $(getPosRecIdPrefix() + 'focus').blur();  // Focus out from grid area when 'Edit' button click.
    }
    var pupLeng = $('#selposedit').length;
    turnoffPopup();
    if (pupLeng == 0) {	// If it does not already exist, display popup.
      tabletDebug('trace', 'posctrledit : pupLeng == 0');
      clearTimeout(popupFlgTimer);
      openPopupFlg = true;
      popupDialog.selection('selposedit');
    }
    if (w2utils.isIOS) {  // Prevent keyboard appearance in iPad.
      setTimeout(function () {
        $('#grid_posdata_records').attr('readonly', false);
      }, 100);
    }
    return false;
  });
  $('#posctrlmov').on('mousedown', function (event) {
    return false;
  });
  $('#posctrlmov').on('mouseup', function (event) {
    if (!($(this).hasClass("posctrlactiv"))) {
      return false;
    }
    tabletDebug('trace', 'posctrlmov mouseup:');
    var movetoBtn = $('#movetobtnddn').css('display');
    if (movetoBtn == 'none') {  // Button
      // move controller at cursor row position.
      moveToPosition(MOVETO_LINEAR);  // see below
    } else {  // Menu!
      if (w2utils.isIOS) {  // Prevent keyboard appearance in iPad.
        $('#grid_posdata_records').attr('readonly', true);
        $(getPosRecIdPrefix() + 'focus').blur();  // Focus out from grid area when 'MoveTo' button click.
      }
      var pupLeng = $('#selposmove').length;
      turnoffPopup();
      if (pupLeng == 0) {	// If it does not already exist, display popup.
        tabletDebug('trace', 'posctrlmov : pupLeng == 0');
        clearTimeout(popupFlgTimer);
        openPopupFlg = true;
        popupDialog.selection('selposmove');
      }
      if (w2utils.isIOS) {  // Prevent keyboard appearance in iPad.
        setTimeout(function () {
          $('#grid_posdata_records').attr('readonly', false);
        }, 100);
      }
    }
    return false;
  });
  $('#posctrltup').on('mousedown', function (event) {
    return false;	// throw away event...
  });
  $('#posctrltup').on('mouseup', function (event) {
    if (!($(this).hasClass("posctrlactiv"))) {
      return false;
    }
    // touch up to cursor row data from robot position.
    // To prevent display of keyboard panel in iPad.
    if (w2utils.isIOS) {
      $(getPosRecIdPrefix() + 'focus').blur();
    }
    setFocusAfterPosCtrl('#posctrltup');
    dispOnWaitExchange();
    isTchUpPosReg = true;	// posreg
    // Call API
    var cbArg = {};
    var grpNum = getCurrentGroupNum();
    cbArg.callback = posExtendAxisCallback;
    cbArg.tblKind = getSelPosTblKind();
    if (getCurrentFrameType() == COORDINATECART) {
      cbArg.rep = ((getExtendAxesCount(grpNum) > 0) ? POS_REP_BOTH : POS_REP_CART);
    } else {
      cbArg.rep = POS_REP_JOINT;
    }
    var posRec = createPosDataRow();
    posRec.recid = posSaveRec.recid;
    posRec.rowno = posSaveRec.rowno;
    posRec.column = posSaveRec.column;
    posRec.Comment = posSaveRec.Comment;
    cbArg.rec = posRec;
    cbArg.force = (posSaveRec.frame == getCurrentFrameType()) ? false : true;
    if (cbArg.tblKind == POSTBLKIND_DATA) {
      cbArg.grp = grpNum;
      setEditorCurrentPosition(cbArg);
    } else {
      getEditorCurrentPosition(getCurrentFrameType(), grpNum, cbArg);
    }
  });
  $('#posctrljnt').on('click touchend', function (event) {
    if(event.type.indexOf('touch') >= 0){
      event.preventDefault();
    }
    if (getCurrentFrameType() === COORDINATEJOINT) {
      return;
    }
    if ($('#posctrljnt').hasClass("coordctrloff")) {
      return;
    }
    setCurrentFrameType(COORDINATEJOINT);
    $('#posctrljnt').addClass('coordctrlon');
    $('#posctrlcrt').removeClass('coordctrlon');
    exchangePosTblColumn(getCurrentFrameType());
    var tblName = getSelPosTblName();
    makeDisplayRepPos(w2ui[tblName].records, getSelPosTblKind());
    //w2ui[tblName].resize(); Is it need?
    if (isSelectCommonCol()) {
      setFocusAfterPosCtrl('#posctrljnt');
    } else {
      w2ui[tblName].selectNone();
    }
    w2ui[tblName].refresh();
    paintIncompleteRows(w2ui[tblName].records);
  });
  $('#posctrlcrt').on('click touchend', function (event) {
    if(event.type.indexOf('touch') >= 0){
      event.preventDefault();
    }
    if (getCurrentFrameType() === COORDINATECART) {
      return;
    }
    if ($('#posctrlcrt').hasClass("coordctrloff")) {
      return;
    }
    setCurrentFrameType(COORDINATECART);
    $('#posctrljnt').removeClass('coordctrlon');
    $('#posctrlcrt').addClass('coordctrlon');
    exchangePosTblColumn(getCurrentFrameType());
    var tblName = getSelPosTblName();
    makeDisplayRepPos(w2ui[tblName].records, getSelPosTblKind());
    if (isSelectCommonCol()) {
      setFocusAfterPosCtrl('#posctrlcrt');
    } else {
      w2ui[tblName].selectNone();
    }
    w2ui[tblName].refresh();
    paintIncompleteRows(w2ui[tblName].records);
  });
  $('#layoutarea').on('click touchstart', '#selpostbllist', function (event) {
    positionTableSelection(event, event.target.id);
    event.preventDefault();
    event.stopPropagation();
    return false;
  });
  $('#layoutarea').on('click touchstart', '#selpostblddn', function (event) {
    positionTableSelection(event, event.target.id);
    event.preventDefault();
    event.stopPropagation();
    return false;
  });
  $('#layoutarea').on('click touchstart', '#selpostblimg', function (event) {
    positionTableSelection(event, event.target.id);
    event.preventDefault();
    event.stopPropagation();
    return false;
  });
}

// Insert position command on Tablet editor-tab mode.
// insertFunction : Callback function to insert position variable string.
// return : result true = call insert procedure, false = mode is not match.
function insertPosCommand(insertFunction) {
  var result = false;
  if (posTableStatus.mode == POSTABLE_TAB_CMNT) {
    setTimeout(function () {
      var crntTblKind = getSelPosTblName();
      var selRecord = w2ui[crntTblKind].getSelection(); // get select record id
      var selRecId = (selRecord.length == 0) ? posSaveRec.recid :   // not get selection, use save recid.
        (selRecord[0].recid != undefined) ? selRecord[0].recid : selRecord[0]; // select cell/row exist.
      if (selRecId != undefined) {
        var posStr = getCommandParts().selRegP + '[' + selRecId + ']'; // build command
        insertFunction(posStr); // call insert function (may be prgwin)
        result = true;
      }
    }, 100);
  }
  return result;
}

// === Procedure for position table list selection. ===
function positionTableSelection(event, tblIdVal) {
  if (isOpenSelPosTblList()) {	// if open, close the window.
    selectPosTblListProc(event, tblIdVal);
    closeSelPosTblList();
  } else if ($('#waitExchange').length > 0) {
    // If waiting process animation for exchange is displayed, do not Make Position type list HTML.
  } else {
    // Make Position type list HTML.
    $('#selpostblddn').removeClass('ddnbtninactive');
    $('#selpostblddn').addClass('ddnbtnactive');
    var $postbloptbox = $('<div>', { 'id': 'selpostblopt', 'class': 'selpostblbox' });
    for (var postbl = 0; postbl < postblValueList.length; postbl++) {
      var $postbloptitem = $('<div>', { 'id': postblValueList[postbl].resId, 'class': 'selpostblopt' });
      $postbloptitem.html(resources[postblValueList[postbl].resId]);
      if (postblValueList[postbl].resId == getSelPosTblValue().resId) {
        $postbloptitem.css({ 'background-color': '#0E6EB8', 'color': '#ffffff' });
      }
      if (isTablet) {
        $postbloptitem.css({ 'min-height': '34px', 'min-width': '84px', 'font-size': '13px' });
      }
      if (postbl == 0) { 	// start of item
        $postbloptitem.addClass('selframeopttop');
      }
      $postbloptitem.addClass('selframeoptend');
      $postbloptbox.append($postbloptitem);
    }
  $('#selpostbllist').append($postbloptbox);
  setOpenSelPosTblList(true);
  }
}
function selectPosTblListProc(event, tblIdVal) {
  var selPosTblVal = tblIdVal;
  var selIndex = -1;
  for (var i = 0; i < postblValueList.length; i++) {
    if (postblValueList[i].resId == selPosTblVal) {
      selIndex = i;
      break;
    }
  }
  if (selIndex < 0) {
    return;
  }
  setSelPosTblKind(selIndex);
  // refrect to pos table name box
  if (!isScrModePcEditor()) {
    $('#selpostbllist').html(resources[selPosTblVal]
      + ' <div id="selframebtn" class="selframebtn">'
      + '	<div id="selpostblddn" class="ui-icon ui-icon-triangle-white">'
      + '	</div>');
  } else {
    $('#selpostbllist').html(resources[selPosTblVal] + ct_selposkind);
  }
  var selPosTable = '';
	var movetoBtnId = (isScrModeEditorTab()) ? '#move_btn' : '#posctrlmov';
  if (selIndex == 0) {	// Select Position data table
    w2ui[POSREGSTBL].selectNone();
    $('#' + POSREGAREA).hide();
    $('#' + POSDATAREA).show();
    $(movetoBtnId).show();
    selPosTable = POSDATAREA;
    stopGetPosRegPolling();	// posreg
  } else {
    w2ui[POSDATAREA].selectNone();
    $('#' + POSDATAREA).hide();
    $('#' + POSREGAREA).show();
    selPosTable = POSREGSTBL;
    startGetPosRegPolling();	// posreg
  }
  makeDisplayRepPos(w2ui[selPosTable].records, getSelPosTblKind());
  w2ui[selPosTable].refresh();
  $('#' + selPosTable).w2grid().focus();
  paintIncompleteRows(w2ui[selPosTable].records);
  setFocusAfterPosCtrl('#selpostbllist');
  positionButtonManager(event);
}
function closeSelPosTblList() {
  $('#selpostblopt').remove();
  setOpenSelPosTblList(false);
  $('#selpostblddn').removeClass('ddnbtnactive');
  $('#selpostblddn').addClass('ddnbtninactive');
}

/* === Initialize Position table select list === */
function initPosCtrlButton() {
  setSelPosTblKind(POSTBLKIND_DATA);
  var selPosTblRes = getSelPosTblValue().resId;	// initial value
  // refrect to pos table name box
  if (!isScrModePcEditor()) {
    $('#selpostbllist').html(resources[selPosTblRes]
      + ' <div id="selframebtn" class="selframebtn">'
      + '	<div id="selpostblddn" class="ui-icon ui-icon-triangle-white">'
      + '	</div>');
  } else {
    var selpostblhtml = $('#selpostbllist').html();
    $('#selpostbllist').html(resources[selPosTblRes] + selpostblhtml);
  }
}

/* === Position Edit menu procedure === */
// Delete
function selectPosDeleteMenu(event) {	// Call from menu
  // cursor row delete.
  cutSelectedPosData(getSelPosTblName());
  positionButtonManager(event);
}

// Copy
function selectPosCopyMenu(event) {	// Call from menu
  // To prevent display of keyboard panel in iPad.
  if (w2utils.isIOS) {
    $(getPosRecIdPrefix() + 'focus').blur();
  }
  // Copy cursor row position data to clip data area.
  var copyText = w2ui[getSelPosTblName()].copy();
  var crntFrmType = getCurrentFrameType();
  setCopyEventInfo(copyText, getSelPosTblName(), '', crntFrmType, crntGridSelType);
  setCopyGridSel(crntGridSelType); // memory of copy mode
  setCopyCrntFrm(crntFrmType);
  posCopyCol = posCrntCol;
  posCopyRec = $.extend({}, posSaveRec);
  posCopyRec.frameType = crntFrmType;
  sessionStorage.posCopyRecFrameType = posCopyRec.frameType;
  // turn on paste button
  setFocusAfterPosCtrl('#posctrlcpy');
  positionButtonManager(event);
}

// Paste
function selectPosPasteMenu(event) {	// Call from menu
  // To prevent display of keyboard panel in iPad.
  if (w2utils.isIOS) {
    $(getPosRecIdPrefix() + 'focus').blur();
  }
  // Paste cursor row position data from cliped data.
  var copyInfo = getCopyEventInfo();
  // if copy frametype is not same or copydata is null ,to cansel the paste
  posCopyRec.frameType = Number(sessionStorage.getItem('posCopyRecFrameType'));
  if ((posCopyRec.frameType !== getCurrentFrameType()) || (copyInfo === null)) {
    return false;
  }
  dispOnWaitExchange();
  var tblName = getSelPosTblName();
  var selId = getSelectGridRecid(tblName);	// get select paste record list
  var selIdList = [];
  for (var i = 0; i < selId.length; i++) {
    selIdList.push(selId[i].id);
  }
  copyInfo.selId = selIdList;
  if (copyInfo.selType == SELGRID_ROW) {
    pasteCopiedRowsData(copyInfo);
  } else {
    w2ui[tblName].paste(copyInfo.text);
    addNewPosRecLine(posSaveRec.recid, true);
  }
  dispOffWaitExchange();
  w2ui[tblName].refresh();
  paintIncompleteRows(w2ui[tblName].records);
  setFocusAfterPosCtrl('#posctrlpst');
}

// Represent
var exchangeRecList = [];	// Record List for repre.
var exchangeRecIndex = 0;	// Record index for repre.
function isDuplicateRecord(recId) {
  for (var k = 0; k < exchangeRecList.length; k++) {
    if (recId == exchangeRecList[k].recId) {
      return true;
    }
  }
  return false;
}
function selectPosRepreMenu(event) {
  exchangeRecList = [];
  exchangeRecIndex = 0;
  // Make Select Record List.
  var tblKind = getSelPosTblName();
  var selRecord = w2ui[tblKind].getSelection();
  var selRecId = 0;
  for (var i = 0; i < selRecord.length; i++) {
    if (crntGridSelType == SELGRID_CELL) {
      selRecId = selRecord[i].recid
    } else if (crntGridSelType == SELGRID_ROW) {
      selRecId = selRecord[i];
    }
    if (selRecId > 0) {
      var selRec = w2ui[tblKind].get(selRecId);
      if ((selRec.error != 1) && (selRec.rep != POS_REP_NONE) && (selRec.frame != COORDINATEUNKOWN)) {
        if (!isDuplicateRecord(selRecId)) {	// Record ID is not duplicated.
          exchangeRecList[exchangeRecIndex] = selRec;
          exchangeRecIndex++;
        }
      }
    }
  }
  // Confirm Different UF/UT when PosReg exchange.
  if (getSelPosTblKind() == POSTBLKIND_REGS) {
    defineDialog.open('#posctrlrepre', '#confposregfrmdlg', 'dlgMsgAlertFrame');
    return;
  }
  // Call Relay process for call exchange process.
  mnchgrepRelay(null);
}
function execExchangePosFrame(srcRec) {
  // Create Arguments
  var exchgInfo = {};
  exchgInfo.srcRec = srcRec;
  exchgInfo.cb = mnchgrepCallback;
  var tblKind = ((exchgData[srcRec.trgtTbl]['isExchg']) ? srcRec.trgtTbl : getSelPosTblKind());
  exchgInfo.tbl = tblKind;
  exchgInfo.exchgTo = (srcRec.frame == COORDINATECART) ? COORDINATEJOINT : COORDINATECART;
  var groupNum = getCurrentGroupNum();
  exchgInfo.grp = groupNum;
  exchgInfo.robot = getJointRobotAxes(groupNum);
  exchgInfo.ext = getExtendAxesCount(groupNum);
  exchgInfo.unit = getJointUnitGroup(groupNum);
  // Set(Initialize) target new record
  var newRec = createPosDataRow();
  newRec.recid = srcRec.recid;
  newRec.rowno = srcRec.rowno;
  newRec.Comment = srcRec.Comment;
  newRec.frame = exchgInfo.exchgTo;
  newRec.id = srcRec.id;	// for PosReg
  newRec.force = true;	// for PosReg
  newRec.config_flag = false;	// for PosReg
  newRec.UF = srcRec.UF;
  newRec.UT = srcRec.UT;
  newRec.tbl = tblKind;
  exchgInfo.newRec = newRec;
  // Set _default_ UF/UT value.
  if (tblKind == POSTBLKIND_DATA) {
    exchgInfo.UFVal = getUfUtSystemValue(groupNum).UF;
    exchgInfo.UTVal = getUfUtSystemValue(groupNum).UT;
  } else {
    exchgInfo.UFVal = POS_REG_UF_VAL;
    exchgInfo.UTVal = POS_REG_UT_VAL;
  }
  // Call exchange process
  exchangePosFrame(exchgInfo);	// api
}
function mnchgrepRelay(saveParam) {
  exchangeRecIndex = 0;
  if (exchangeRecList.length == 0) {
    return;	// if no list, no operation.
  }
  if (getSelPosTblKind() == POSTBLKIND_REGS) {
    isConvPosReg = true;	// posreg
    stopGetPosRegPolling();	// posreg
  } else {
    dispOnWaitExchange();
  }
  execExchangePosFrame(exchangeRecList[exchangeRecIndex]);
}
function mnchgrepRelayDis(tbl) { // for display data

  exchgData[tbl]['index'] = 0; // reset index
  if (exchgData[tbl]['afList'].length == 0) {
    return; // if no list, no operation.
  }

  if (getSelPosTblKind() == POSTBLKIND_REGS) {
    isConvPosReg = true; // posreg
    stopGetPosRegPolling(); // posreg
  }

  execExchangePosFrame(exchgData[tbl]['afList'][exchgData[tbl]['index']]);
}
var multiRowExchgError = false;
function mnchgrepCallback(status, chgRecData, selTblKind) {
  if (status != IO_SUCCESS) {
    multiRowExchgError = true;
  }
  if (exchgData[selTblKind]['isExchg']) { // for making back data
    pasteDisplayChgRep(chgRecData, selTblKind);
    return;
  }
  if (chgRecData != null) {	// Data exchange is succeed.

    // Set before position data to dispData (for display)
    exchgData[getSelPosTblKind()]['dispData'][getCurrentGroupNum() + "_" + chgRecData.rowno] = JSON.parse(JSON.stringify(exchangeRecList[exchangeRecIndex]));

    // Set exchanged position data to target record (refer Touch up process)
    var posTblName = getSelPosTblName();
    if (getSelPosTblKind() == POSTBLKIND_DATA) {	// Position Data table
      w2ui[posTblName].set(chgRecData.recid, chgRecData);
      checkAndPutPosData(chgRecData.recid);
      setPositionModified(true);
    } else {
      setPosRegRecord(chgRecData);
      w2ui[posTblName].refreshRow(chgRecData.recid);
      checkAndPutPosRegister(chgRecData.recid, POSREG_NOTWAIT);	// posreg
    }
  }
  // Index to next record
  exchangeRecIndex++;
  // Data exists in the list.
  if (exchangeRecIndex < exchangeRecList.length) {
    execExchangePosFrame(exchangeRecList[exchangeRecIndex]);
    return;
  }
  dispOffWaitExchange();
  exchangeRecList = [];
  setFocusAfterPosCtrl('#posctrlrepre');
  w2ui[getSelPosTblName()].save();
  paintMaskingCell();
}

// display repre data (can not edit)
function pasteDisplayChgRep(chgRecData, tblKind) {
  var tblName = ((tblKind == POSTBLKIND_REGS) ? POSREGSTBL : POSDATAREA);

  if (chgRecData !== null) { // Push generate data if exchange is successful.
    exchgData[tblKind]['generate'].push(chgRecData);
  } else {
    var groupNum = getCurrentGroupNum(); // delete display data if exchange is fails.
    var delRecId = exchgData[tblKind]['afList'][exchgData[tblKind]['index']].recid;
    delete exchgData[tblKind]['dispData'][groupNum + "_" + delRecId];
    w2ui[tblName].refreshRow(delRecId);
  }
  exchgData[tblKind]['index']++;

  // Data exists in the list.
  if (exchgData[tblKind]['index'] < exchgData[tblKind]['afList'].length) {
    execExchangePosFrame(exchgData[tblKind]['afList'][exchgData[tblKind]['index']]);

  } else {
    // No data exists in the list.
    var grpNum = getCurrentGroupNum();

    exchgData[tblKind]['isExchg'] = false;
    isConvPosReg = false;
    exchgData[tblKind]['afList'] = []; // clear 'afList' (storage of the data to be converted)

    for (var k = 0; k < exchgData[tblKind]['generate'].length; k++) {
      if (exchgData[tblKind]['generate'][k].error == 1) {
        exchgData[tblKind]['generate'][k].frame = COORDINATEUNKOWN; // It will not be displayed.
      }
    }

    for (var k = 0; k < exchgData[tblKind]['generate'].length; k++) { // Store generate data to data list for display.
      var setRow = exchgData[tblKind]['generate'][k].rowno;
      exchgData[tblKind]['dispData'][grpNum + "_" + setRow] = exchgData[tblKind]['generate'][k];
      w2ui[tblName].refreshRow(setRow);
    }

    // repaint row
    paintMaskingCell();

    if ((tblKind == POSTBLKIND_REGS) && (getSelPosTblKind() == POSTBLKIND_REGS)) {
      // When loading for the first time, I try not to enter this process.
      startGetPosRegPolling(); // posreg
    } else if (tblKind == POSTBLKIND_DATA) {
      // Unprotect position data
      enablePosCtrlJnt();
      dispOffWaitExchange();

    }
  }
}

/* === Exchange Position table column === */
// Toggle table column Show/Hide
function togglePosTblColumn(tblName, targetFrameType) {
  if (targetFrameType == COORDINATECART) {
    // Hide Joint column
    columnShowHide(tblName, COORDINATEJOINT);
    // Show Cartesian column
    columnShowHide(tblName, COORDINATECART);
    // FSI 20181122 Switch frame in position register table
    if (tblName == POSDATAREA) {
      columnShowHide(tblName, FIELDUFUTCONFIG);
    } else {
      columnShowHide(tblName, FIELDCONFIG);
    }
  } else {
    // Hide Cartesian column
    columnShowHide(tblName, COORDINATECART);
    // Show Joint column
    columnShowHide(tblName, COORDINATEJOINT);
    // FSI 20181122 Switch frame in position register table
    if (tblName == POSDATAREA) {
      columnShowHide(tblName, FIELDUFUTCONFIG);
    } else {
      columnShowHide(tblName, FIELDCONFIG);
    }
  }
  // Show Ext. Column
  var extAxes = getExtendAxesCount(getCurrentGroupNum());
  var extCount = 0;
  for (; extCount < extAxes; extCount++) {
    w2ui[tblName].showColumn(entrykeysExt[extCount]);
  }
  // Hide nonexistent extend axes
  //for (; extCount < MAXEXTAXES; extCount++) {
  //	w2ui[tblName].toggleColumn(entrykeysExt[extCount]);
  //}
}
// Exchange Column display Position Data <-> Position Register
function exchangePosTblColumn(targetFrameType) {
  togglePosTblColumn(POSDATAREA, targetFrameType);
  togglePosTblColumn(POSREGSTBL, targetFrameType);
}
// Initialyze Position Table column show/hide.
function initPosTblColumn() {
  if (getCurrentFrameType() == -1) {	// Uninitialized...
    setCurrentFrameType(COORDINATECART);
    // for Pos Data Table
    w2ui[POSDATAREA].hideColumn.apply(w2ui[POSDATAREA], entrykeysJoint);
    // Hide nonexistent extend axes
    var extAxes = getExtendAxesCount(getCurrentGroupNum());
    for (var extCount = extAxes; extCount < MAXEXTAXES; extCount++) {
      w2ui[POSDATAREA].hideColumn(entrykeysExt[extCount]);
    }
    if (isScrModePcEditor()) {
      // for Pos Reg Table
      w2ui[POSREGSTBL].hideColumn.apply(w2ui[POSREGSTBL], entrykeysJoint);
      // Hide nonexistent extend axes
      for (var extCount = extAxes; extCount < MAXEXTAXES; extCount++) {
        w2ui[POSREGSTBL].hideColumn(entrykeysExt[extCount]);
      }
    }
  }
}
// Draw Position Data column of Tablet mode.
// mode: 0=PC mode, 1=Tablet Comment only, 2=Tablet Full.
// Processing when only comments are displayed in the position information
// of the editor tab of the tablet mode.
var posTableStatus = {};
posTableStatus.mode = POSTABLE_PC_MODE;
posTableStatus.type = SELGRID_CELL;
function drawTabletPositionColumn(mode) {
  var crntTblKind = getSelPosTblName();
  if (mode == POSTABLE_TAB_CMNT) {  // drow mode is Comment only.
    w2ui[crntTblKind].hideColumn.apply(w2ui[crntTblKind], entrykeysJoint);
    w2ui[crntTblKind].hideColumn.apply(w2ui[crntTblKind], entrykeysCart);
    w2ui[crntTblKind].hideColumn.apply(w2ui[crntTblKind], entrykeysForm);
    w2ui[crntTblKind].hideColumn.apply(w2ui[crntTblKind], entrykeysExt);
    w2ui[crntTblKind].columns[COLTBLOFS_CMNT].editable = null;  // Read only
    posTableStatus.type = crntGridSelType;  // Save current grid select type.
    w2ui[crntTblKind].selectType = SELGRID_ROW;
    crntGridSelType = SELGRID_ROW;
  } else if (mode == POSTABLE_TAB_FULL) { // draw mode is Full.
    // Show column by current selected frame.
    if (getCurrentFrameType() == COORDINATECART) {
      w2ui[crntTblKind].showColumn.apply(w2ui[crntTblKind], entrykeysCart);
      w2ui[crntTblKind].showColumn.apply(w2ui[crntTblKind], entrykeysForm);
    } else {
      w2ui[crntTblKind].showColumn.apply(w2ui[crntTblKind], entrykeysJoint);
    }
    // Show Ext. Column
    var extAxes = getExtendAxesCount(getCurrentGroupNum());
    for (var extCount = 0; extCount < extAxes; extCount++) {
      w2ui[crntTblKind].showColumn(entrykeysExt[extCount]);
    }
    w2ui[crntTblKind].columns[COLTBLOFS_CMNT].editable = { type: 'text' };
    w2ui[crntTblKind].selectType = posTableStatus.type;  // Resume grid select type.
    crntGridSelType = posTableStatus.type;
  }
  posTableStatus.mode = mode;
  w2ui[crntTblKind].selectNone();
  w2ui[crntTblKind].refresh();
}

/*
 * select cell or row or record
 */
var posSaveRec = {};
var posCopyRec = {};
var posCrntCol = 0;
var posCopyCol = 0;
var posSelectRow = 0;	// for select/unselect event
var posSelectCol = 0;

// Check cell data exist.
// type1 = cart data, type2 = joint data, type4 = ext. data, type8 = config data
function checkCellValue(record, type) {
  if ((type & 1) == 1) {	// Check cartesian value
    for (var entry = 0; entry < entrykeysCart.length; entry++) {
      var entrykey = entrykeysCart[entry];
      if (record[entrykey] !== '') {	// cartesian data exist
        return (true);
      }
    }
    for (var entry = 0; entry < entrykeysJoint.length; entry++) {
      var entrykey = entrykeysJoint[entry];
      if (record[entrykey] !== '') {	// joint data exist
        return (false);
      }
    }
    for (var entry = 0; entry < entrykeysForm.length; entry++) {
      var entrykey = entrykeysForm[entry];
      if (record[entrykey] !== '') {	// UF UT Config data exist
        return (true);
      }
    }
  }
  if ((type & 2) == 2) {	// Check joint value
    for (var entry = 0; entry < entrykeysJoint.length; entry++) {
      var entrykey = entrykeysJoint[entry];
      if (record[entrykey] !== '') {	// joint data exist
        return (true);
      }
    }
  }
  // FSI 20181122 Check Ext and Config value
  if ((type & 4) == 4) {	// Check Ext value
    for (var entry = 0; entry < entrykeysExt.length; entry++) {
      var entrykey = entrykeysExt[entry];
      if (record[entrykey] == '') {
        return (true);
      }
    }
  }
  if ((type & 8) == 8) {	// Check Config value
    for (var entry = 0; entry < entrykeysConf.length; entry++) {
      var entrykey = entrykeysConf[entry];
      if (record[entrykey] == '') {
        return (true);
      }
    }
  }
  return (false);
}

/*
 * draw position
 */
function drawPositionData(posdata) {
  if(w2ui[POSDATAREA] == undefined) {
    return;
  }
  w2ui[POSDATAREA].clear();
  var recorddata = generateRecords(posdata);
  // FSI 20190806 wait for display repre position data
  var targetButton = ((isScrModePcEditor()) ? (((getCurrentFrameType() === COORDINATEJOINT)) ? $('#posctrlcrt') : $('#posctrljnt')) : $('#cart_btn'));
  targetButton.addClass('coordctrloff');
  // FSI 20190509 for display repre position data
  makeDisplayRepPos(recorddata, POSTBLKIND_DATA);
  w2ui[POSDATAREA].add(recorddata);
  //set null line in last row
  var lines = recorddata.length;
  var newline = createPosDataRow();
  newline.recid = lines + 1;
  newline.rowno = lines + 1;
  if (getAxesCount(1) !== undefined) {
    currentAxesCount = getAxesCount(1); // total axes count of group 1
  }
  initPosTblColumn();
  w2ui[POSDATAREA].add(newline);
  w2ui[POSDATAREA].refresh();
  if (getCurrentProgram() === '') {
    lockGrid();
    return;
  }
  refreshPosAreaLock();
}
function refreshPosAreaLock() {
  if (ProgramInfoManager.getCurrentProgInfo().getEditAttrValue().MTNGRP == 0) {	// Motion group nothing...
    lockGrid();
  } else {
    if ((getCurrentProgram() !== '') && ($('#waitExchange').length <= 0)) {
      unlockGrid();
    }
  }
}


/**
 * make repre data for display(can not edit)
 *      generate... temporary storage of data after frame conversion
 *      isExchg... whether conversion is in progress
 *      bfList... storage of previous conversion data
 *      afList... storage of the data to be converted
 *      index... index of the data to be converted
 *      dispData... main storage of data after frame conversion
 */
var exchgData = { // 0 = POSTBLKIND_DATA, 1 = POSTBLKIND_REGS(IE does not support definition using a variable for key)
  0: { generate: [], isExchg: false, bfList: [], afList: [], index: 0, dispData: {} },
  1: { generate: [], isExchg: false, bfList: [], afList: [], index: 0, dispData: {} },
  name: null
};
function makeDisplayRepPos(recorddata, targetTable) {
  var exchangeIndex = 0; // Substitute for index
  var exchangeList = []; // Substitute for afList
  var diffList = []; // Difference between bfGenerateData and bfList
  var bfGenerateData = recorddata.slice(0, recorddata.length);

  exchgData[targetTable]['generate'] = [];
  if (getCurrentProgram() != exchgData.name) {
    // This process is nesessary because if a program with exactly the same data is opened, 
    // the data will be displayed even if the program is set to not display the back data.
    exchgData[targetTable]['dispData'] = {}; // If the program is changing, delete strage.
    exchgData[targetTable]['bfList'] = [];
  }
  
  for (var index = 0; index < bfGenerateData.length; index++) {
    // Convert only lines that are neither errors nor blank lines.
    if ((bfGenerateData[index].error != 1) && // error lines
      (bfGenerateData[index].frame != COORDINATEUNKOWN) && // blank lines
      (bfGenerateData[index].frame != COORDINATEUNINIT)) { // blank lines
      
      exchangeList[exchangeIndex] = bfGenerateData[index];
      exchangeList[exchangeIndex].trgtTbl = targetTable;

      // And even if the data is the same as the previous one, it will not be converted.
      if (JSON.stringify(exchgData[targetTable]['bfList'][exchangeIndex]) != JSON.stringify(exchangeList[exchangeIndex])) {
        diffList.push(exchangeList[exchangeIndex]);
      }
      exchangeIndex++;
      
    }
  }
  // If the data to be converted is the same as the previously converted data, processing is interrupted.
  if (JSON.stringify(exchgData[targetTable]['bfList']) == JSON.stringify(exchangeList)) {
    enablePosCtrlJnt();
    return;
  }
  exchgData[targetTable]['bfList'] = JSON.parse(JSON.stringify(exchangeList)); // Save it for judgment of whether to go to conversion.
  exchgData.name = getCurrentProgram(); // Save it for judgment of whether to go to delete strage.

  // If the data to be converted is nothing, convert processing is skipped.
  // If display POSTBLKIND_DATA table and the program is prohibits conversion of position data, it will be skipped too.
  if ((diffList.length != 0) && ((targetTable == POSTBLKIND_REGS)||(isValidPosRepMenu()))) {
    if (targetTable == POSTBLKIND_DATA) {
      dispOnWaitExchange();
    } else {
      exchgData[targetTable]['dispData'] = {};
    }
    exchgData[targetTable]['afList'] = ((targetTable == POSTBLKIND_DATA) ? diffList : JSON.parse(JSON.stringify(exchangeList)));
    exchgData[targetTable]['isExchg'] = true;
    mnchgrepRelayDis(targetTable);

  } else if (targetTable == POSTBLKIND_DATA) {
    // If the program is prohibits conversion of position data, delete the displayed back data.
    enablePosCtrlJnt();
    if (!isValidPosRepMenu()) {
      w2ui[getSelPosTblName()].refresh();
    }
  }
}
// delete repre data for display(can not edit)
function deleteDisplayRepPos(rowNo, deletRowCnt, targetTable) {
  var groupNum = getCurrentGroupNum();
  var tblName = getSelPosTblName();
  for (var index = 0; index < deletRowCnt; index++) {
    delete exchgData[targetTable]['dispData'][groupNum + "_" + (rowNo + index)];
    w2ui[tblName].refreshRow(rowNo + index);
  }
}
// Enable PosCtrlJnt button to be pressed
function enablePosCtrlJnt() {
  var targetButton = ((isScrModePcEditor()) ? (((getCurrentFrameType() === COORDINATEJOINT)) ? $('#posctrlcrt') : $('#posctrljnt')) : $('#cart_btn'));
  if (targetButton.hasClass("coordctrloff")) {
    targetButton.removeClass("coordctrloff");
  }
}
// clear repre data for display(can not edit)
function clearDisplayRepPos() {
  exchgData[POSTBLKIND_DATA]['bfList'] = [];
  exchgData[POSTBLKIND_DATA]['dispData'] = {};
}

/**
 * Get all row of Position data.
 */
function getAllPosition() {
  w2ui[POSDATAREA].save();
  var posRec = w2ui[POSDATAREA].records;
  paintMaskingCell();
  return posRec;
}

function lockGrid() {
  w2ui[getSelPosTblName()].lock('');
  if (!isScrModeProgAttr()) {
    setPosControlButton(0, 0);
  }
}

function unlockGrid() {
  w2ui[getSelPosTblName()].unlock();
}

/*
 * for TouchUp
 */
// Callback function of get extend axis.
function posExtendAxisCallback(posJson) {
  if ((getSelPosTblKind() == POSTBLKIND_REGS) && (posJson.recid != undefined)) {
    stopGetPosRegPolling();
  }
  w2ui[getSelPosTblName()].set(posJson.recid, posJson);
  if (getSelPosTblKind() == POSTBLKIND_DATA) {	// Position Data table
    // Set the second argument to false so that it does not save(editPos) during TouchUp.
    addNewPosRecLine(posJson.recid, false);
  } else {
    checkAndPutPosRegister(posJson.recid, POSREG_NOTWAIT);	// posreg
  }
  dispOffWaitExchange();
  positionButtonController(posJson.recid, posJson.column);
}

/**
 * Robot move to specified position.
 */
function moveToPosition(cmdMode) {
  debug(DBGINFO, "Move to position...(" + posSaveRec.recid + ")");
	var movetoBtnId = (isScrModeEditorTab()) ? '#move_btn' : '#posctrlmov';
  setFocusAfterPosCtrl(movetoBtnId);
  var addInfo = {};
  addInfo.crntFrame = getSelFrameIndex(); // jogwin
  addInfo.ufNum = getJogFrameNumber(FRMVAL_USER); // jogwin
  addInfo.utNum = getJogFrameNumber(FRMVAL_TOOL); // jogwin
  addInfo.cmdMode = cmdMode;
  moveToMain(posSaveRec, addInfo);
}
function cancelMoveTo() {
  if ((getSelPosTblValue().tblId == POSREGSTBL) && !(isEnablePolling())) {
    startGetPosRegPolling();
  }
  var movetoBtnId = (isScrModeEditorTab()) ? '#move_btn' : '#posctrlmov';
  setFocusAfterPosCtrl(movetoBtnId);
}
function isSelectMultiRow(selRec) {
  if (selRec.length == 0) {
    return false;
  }
  var prevRid = selRec[0].recid;
  for (var i = 0; i < selRec.length; i++) {
    if (prevRid != selRec[i].recid) {	// if multi selection record has not same recid.
      return true;	// multi row...
    }
  }
  return false;
}
function isSelectNumberColumn(selRec) {
  for (var i = 0; i < selRec.length; i++) {
    if ((selRec[i].column !== undefined) && (selRec[i].column != 0)) {	// add check undefined.
      return false;
    }
  }
  return true;
}

/**
 * Delete specified position.
 */
var delSelectedArray = [];
// Call after position data deleted.
function afterDeletePosRow() {
  paintMaskingCell();
  // The function is called when the posdata table is selected.
  if (getSelPosTblKind() == POSTBLKIND_DATA) {	// This branch is fail-safe.
    setPositionModified(true);
  }
  setFocusAfterPosCtrl('#posctrldel');
}
function deletePosRowData(recid) {	// call from api
  var empty = createPosDataRow();
  empty.recid = recid;
  empty.rowno = recid;
  empty.frame = COORDINATEUNKOWN;
  empty.rep = POS_REP_NONE;
  w2ui[POSDATAREA].set(recid, empty);
  w2ui[POSDATAREA].save();
  deleteDisplayRepPos(recid, 1, getSelPosTblKind());
}
function deletePosition() {	// call from dialog
  delSelectedArray = [];	// initialize
  debug(DBGINFO, "Delete position...");
  var tblName = getSelPosTblName();
  var delSelection = w2ui[tblName].getSelection();
  // Pickup selected record.
  for (var i = 0; i < delSelection.length; i++) {
    if (crntGridSelType == SELGRID_CELL) {
      delSelectedArray[i] = delSelection[i].recid;
    } else if (crntGridSelType == SELGRID_ROW) {
      delSelectedArray[i] = delSelection[i];
    }
  }
  w2ui[tblName].save();
  paintMaskingCell();
  if (getSelPosTblKind() == POSTBLKIND_REGS) {
    deletePosRegister(delSelectedArray);	// posreg
  } else {
    delPositionRow(getCurrentProgram(), delSelectedArray, deletePosRowData, afterDeletePosRow);	// api
  }
  setFocusAfterPosCtrl('#posctrldel');
}
function cancelDelete() {
  setFocusAfterPosCtrl('#posctrldel');
}

function getValidRowCount() {
  // If the line before the last line is empty, erase it.
  var posRec = w2ui[getSelPosTblName()].records;
  var validRow = 0;
  for (var i = 0; i < posRec.length - 1; i++) {
    if (isExistPositionData(posRec[i])) {
      validRow++;
    }
  }
  debug(DBGDUMP, "Valid Row Count is (" + validRow + ")");
  return validRow;
}

// cut process
function cutSelectedPosData(tblKind) {
  var copyRecord = w2ui[tblKind].getSelection();
  if (crntGridSelType == SELGRID_CELL) {
    if (tblKind == POSREGSTBL) {
      if ((copyRecord[0].column != COLTBLOFS_CMNT)
        || (copyRecord[0].column != copyRecord[copyRecord.length - 1].column)) {
        defineDialog.open('#posctrldel', '#confdeletedlg', '');	// Confirm delete record.(OK -> deletePosition())
        w2ui[tblKind].save();
        paintIncompleteRows(w2ui[tblKind].records);
        paintMaskingCell();
        return;
      }
    }
    var cutRecId = 0;
    for (var i = 0; i < copyRecord.length; i++) {
      if ((cutRecId > 0) && (copyRecord[i].recid != cutRecId)) {
        //posLineData.frame = COORDINATEUNKOWN;
        w2ui[tblKind].set(cutRecId, posLineData);
      }
      cutRecId = copyRecord[i].recid
      var posLineData = w2ui[tblKind].get(cutRecId);
      var targetColNum = copyRecord[i].column;
      var selColumn = captionPosTbl[targetColNum];
      // delete select cell date
      if (targetColNum == COLTBLOFS_CMNT) {
        posLineData[selColumn] = '';
      } else if ((tblKind == POSDATAREA) &&
        (posLineData.frame == getCurrentFrameType())) {	// if posreg(except comment column), ignore delete.
        posLineData[selColumn] = '';
        deleteDisplayRepPos(posLineData.rowno, 1, getSelPosTblKind());
      }
      if (!isExistPositionData(posLineData)) {	// Data is nothing, reset record.
        posLineData.frame = COORDINATEUNKOWN;
        posLineData.rep = POS_REP_NONE;
        posLineData.UF = '';	// UF / UT initialize when record frame to Unkown.
        posLineData.UT = '';
      }
    }
    // set row date
    //posLineData.frame = COORDINATEUNKOWN;
    w2ui[tblKind].set(cutRecId, posLineData);
    w2ui[tblKind].save();
    paintIncompleteRows(w2ui[tblKind].records);
    paintMaskingCell();
    if (tblKind == POSDATAREA) {
      setPositionModified(true);
    }else{
      var writeDataArray = [];
      var recData = { clm: COLTBLOFS_CMNT, num: 1 };
      recordPosRegValue(posLineData, recData, writeDataArray, true);
      setPosRegValue(getCurrentGroupNum(), writeDataArray, setPosRegCallback);	// common_api
    }
  } else if (crntGridSelType == SELGRID_ROW) {
    defineDialog.open('#posctrldel', '#confdeletedlg', '');	// Confirm delete record.(OK -> deletePosition())
    w2ui[tblKind].save();
    paintIncompleteRows(w2ui[tblKind].records);
    paintMaskingCell();
  }
}

// Disable/Enable position control button
function getCtrlButtonCond() {
  var btnCtrlMode = 0;
  if (!$('#posctrltup').is(':disabled')) {
    btnCtrlMode = (btnCtrlMode | POSCTRL_TOUCHUP);
  }
  if (!$('#posctrlmov').is(':disabled')) {
    btnCtrlMode = (btnCtrlMode | POSCTRL_MOVETO);
  }
  if (!$('#posctrledit').is(':disabled')) {
    btnCtrlMode = (btnCtrlMode | POSCTRL_EDIT);
  }
  return btnCtrlMode;
}
/*
 * Disable the button when there is no focus.
 * Enable the button when there is focus.
 * However, the paste button is valid only when there is copy data.
 */
var posCtrlSubMenuId = ['#posctrldel', '#posctrlcpy', '#posctrlpst'];
var posCtrlBtnIdTable = [];
if (isScrModeEditorTab()) {
  posCtrlBtnIdTable = ['#edit_btn', '#posctrltup', '#move_btn'];
}else {
  posCtrlBtnIdTable = ['#posctrltup', '#posctrlmov', '#posctrledit'];
}
function isValidPosPasteMenu() {	// Call from popup
  debug(DBGDUMP, 'isValidPosPasteMenu:clip[...]:type[' + getCopyGridSel() + ']:frame[' + getCopyCrntFrm() + ']');
  if ((getCopyGridSel() == crntGridSelType) &&	// Same select type
    (getCopyCrntFrm() == getCurrentFrameType())) {	// Same frame type
    return true;
  }
  return false;
}
function isValidPosRepMenu() { // Call from popup
  if ((ProgramApplManager.isLoadLineTrack()) && (getSelPosTblKind() == POSTBLKIND_DATA)) {
    if (ProgramApplManager.getLineTrackConfList(getCurrentProgram(), "lineschedule") > 0) {
      return false;
    }
  }
  return true;
}
function setPosControlButton(recid, btnCtrlMode) {
  if (getCurrentProgram() === '') {
    return;	// Ignore when grid is locked.
  }
  for (var i = 0; i < posCtrlBtnIdTable.length; i++) {
    var btnEnable = false;
    var btnId = posCtrlBtnIdTable[i];
    if (btnId == '#posctrltup') {
      btnEnable = ((btnCtrlMode & POSCTRL_TOUCHUP) != 0);
    } else if (btnId == '#posctrlmov') {
      btnEnable = ((btnCtrlMode & POSCTRL_MOVETO) != 0);
    } else if (btnId == '#move_btn') {  // tablet mode
      btnEnable = ((btnCtrlMode & POSCTRL_MOVETO) != 0);
    } else if (btnId == '#posctrledit') {
      btnEnable = ((btnCtrlMode & POSCTRL_EDIT) != 0);
    } else if (btnId == '#edit_btn') {  // tablet mode
      btnEnable = (btnCtrlMode != 0);
    }
    if ((checkEditInvalid(false)) && (btnId != "#posctrlmov") &&
      (btnId != "#move_btn") && (getSelPosTblName() != POSREGSTBL)) {
      btnEnable = false; // Ignore when write is blocked.
    }
    if ((!isEnableOn()) && (checkEditInvalid(false))) {
      if ((btnId != "#posctrlmov") || (btnId != "#move_btn")) {
        btnEnable = false; // Ignore when TP is OFF.
      }
    }
    if ($('#waitExchange').length > 0) {
      btnEnable = false; // Ignore exchange now.
    }
    // Refrect
    var removeCls = (btnEnable) ? 'posctrlinact' : 'posctrlactiv';
    var addCls = (btnEnable) ? 'posctrlactiv' : 'posctrlinact';
    $(btnId).removeClass(removeCls);
    $(btnId).addClass(addCls);
    $(btnId).prop('disabled', !btnEnable);
  }
}
// Position Button Manager
function positionButtonManager(event) {
  positionButtonController(event.recid, event.column);
}
// Position Button Controller
function positionButtonController(recid, column) {
  var myGrid = w2ui[getSelPosTblName()];
  var selRecArray = myGrid.getSelection();
  if (selRecArray.length == 0) {
    setPosControlButton(0, 0);	// Disable the button after unselect row.
    return;
  }
  debug(DBGDUMP, 'posBtnCtrl: recid[' + recid + '];column[' + column + '];selArray.len[' + selRecArray.length + ']');
  var cmpRecid = (recid !== undefined) ? recid :
    (selRecArray[0].recid !== undefined) ? selRecArray[0].recid : selRecArray[0];
  var selCond = getSelectCondition(myGrid, cmpRecid, selRecArray);
  posSelectRow = cmpRecid - 1;	// Row is based on 1.
  posSelectCol = (column === undefined) ? selRecArray[0].column : column;
  // Set Control button condition
  var enableBtn = getCtrlButtonCond();
  if (!selCond.isMultiRow) {	// if single cell or single row select
    getPositionStateRow(myGrid.records[posSelectRow]);	// check and paint next row
    enableBtn |= POSCTRL_TOUCHUP;
    if ((selCond.frameMatch) && 	// Frame type is match
      ((selCond.rowCond == POSROW_CARTFRM) || (selCond.rowCond == POSROW_JOINTFRM))) {	// and complete row.
      enableBtn |= POSCTRL_MOVETO;
    } else {
      enableBtn = ((enableBtn & POSCTRL_MOVETO) != 0) ? enableBtn ^ POSCTRL_MOVETO : enableBtn;
    }
  } else {	// if multi row or Frame type is Unmatch.
    enableBtn = ((enableBtn & POSCTRL_MOVETO) != 0) ? enableBtn ^ POSCTRL_MOVETO : enableBtn;
    enableBtn = ((enableBtn & POSCTRL_TOUCHUP) != 0) ? enableBtn ^ POSCTRL_TOUCHUP : enableBtn;
  }
  enableBtn |= POSCTRL_EDIT;
  debug(DBGDUMP, 'Select set Control button:[0x' + enableBtn.toString(16) + ']');
  setPosControlButton(cmpRecid, enableBtn);
  if (selCond.isNumColumn) {
    if (crntGridSelType == SELGRID_CELL) {	// change selectType
      myGrid.selectType = SELGRID_ROW;	// to row select
      crntGridSelType = SELGRID_ROW;	//memory of current mode
      myGrid.selectNone();
      myGrid.refresh();
    }
  } else {
    if (crntGridSelType == SELGRID_ROW) {	// change selectType
      myGrid.selectType = SELGRID_CELL;	// to cell select
      crntGridSelType = SELGRID_CELL;	//memory of current mode
      myGrid.selectNone();
      myGrid.refresh();
    }
  }
}

// paint color on cells (Color masking cells)
function paintMaskingCell() {
  var targetTable = getSelPosTblKind();
  var allrecords = w2ui[getSelPosTblName()].records;
  var lastrowno = allrecords.length;
  var checkRowCount = (targetTable == POSTBLKIND_REGS) ? lastrowno : lastrowno - 1;
  var allframecount = entrykeysJoint.length + entrykeysCart.length + entrykeysExt.length;
  //change color gray J1 to J6
  for (var len = 0; len < lastrowno; len++) {
    if (checkCellValue(allrecords[len], 1)) { // Target record (line) is Cartecian
      for (var c = 0; c < entrykeysJoint.length; c++) {	// Mask Joint column
        if (len != checkRowCount) {
          var cellid = getPosRecIdPrefix() + 'data_' + len + '_' + (c + 2);
          $(cellid).css({ 'background-color': CELLBGCOL_MASK });
        }
      }
      // FSI 20181122 change color Axt
      if (getCurrentFrameType() == COORDINATEJOINT) {
        for (var c = 0; c < entrykeysExt.length; c++) {	// Mask Axt column
          if (len != checkRowCount) {
            var cellid = getPosRecIdPrefix() + 'data_' + len + '_' + (c + 14);
            $(cellid).css({ 'background-color': CELLBGCOL_MASK });
          }
        }
      }
      if (targetTable == POSTBLKIND_REGS) {	// Mask UF/UT
        for (var c = allframecount + 2; c < (captionPosTbl.length - 1); c++) {
          if (len != checkRowCount) {
            var otherid = getPosRecIdPrefix() + 'data_' + len + '_' + c;
            $(otherid).css({ 'background-color': CELLBGCOL_LGRY });
          }
        }
      }
    }
  }
  //change color gray X to R
  for (var len = 0; len < lastrowno; len++) {
    if (checkCellValue(allrecords[len], 2)) { // Target record is Joint
      for (var c = 0; c < entrykeysCart.length; c++) {	// Mask Cartecian column
        if (len != checkRowCount) {
          var cellid = getPosRecIdPrefix() + 'data_' + len + '_' + (c + 8);
          $(cellid).css({ 'background-color': CELLBGCOL_MASK });
        }
      }
      // FSI 20181122 change color Axt and Config
      // [TBD] Color of Config can't change in initial display.
      if (getCurrentFrameType() == COORDINATECART) {
        for (var c = 0; c < entrykeysExt.length; c++) {	// Mask Axt column
          if (len != checkRowCount) {
            var cellid = getPosRecIdPrefix() + 'data_' + len + '_' + (c + 14);
            $(cellid).css({ 'background-color': CELLBGCOL_MASK });
          }
        }
      }
      for (var c = allframecount + 2; c < captionPosTbl.length; c++) {
        if (len != checkRowCount) {
          var otherid = getPosRecIdPrefix() + 'data_' + len + '_' + c;
          var targetBgCol = (targetTable == POSTBLKIND_DATA) ? CELLBGCOL_MASK : (captionPosTbl[c] == 'Config') ? CELLBGCOL_MASK : CELLBGCOL_LGRY;
          $(otherid).css({ 'background-color': targetBgCol });
        }
      }
    }
  }
  if (targetTable == POSTBLKIND_DATA) {	// Check data only position data.
    checkSaveData();
  }
}

// Check if there is an error record.
function hasErrorRecord() {
  var allRecords = w2ui[POSDATAREA].records;
  for (var ofs = 0; ofs < allRecords.length; ofs++) {
    if (allRecords[ofs].error == 1) {
      return true;
    }
  }
  return false;
}

// Save data check ... Position data.
function checkSaveData() {
  var lastrowno = w2ui[POSDATAREA].records.length;
  var allrecords = w2ui[POSDATAREA].records;
  var extErrorFlag = false;  // there are error data in all records data.
  var currentFrame = getCurrentFrameType();
  // check save data
  for (var len = 0; len < (lastrowno - 1); len++) {
    var recErr = -1;	// record is ... error=-1, normal=1, ignore(different frame)=0.
    var chkRec = -1;	// record frame kine ... -1=unkown, 0=cart, 1=joint.
    if (currentFrame == COORDINATECART) {
      chkRec = checkCartDataAllSet(allrecords[len]);
      recErr = (chkRec == COORDINATEUNKOWN) ? -1 : (chkRec == COORDINATEJOINT) ? 0 : 1;
    } else {	// Check JOINT
      chkRec = checkJointDataAllSet(allrecords[len]);
      recErr = (chkRec == COORDINATEUNKOWN) ? -1 : (chkRec == COORDINATECART) ? 0 : 1;
    }
    // only ext data
    if (isExistExtPosData(allrecords[len])) {
      if ((currentFrame == COORDINATECART && isIncompleteCartPos(allrecords[len]))
        || (currentFrame == COORDINATEJOINT && isIncompleteJointPos(allrecords[len]))) {
        recErr = -1;
      }
    }
    if (recErr == -1) {	// if error record, bgcolor to light red, error flag on.
      var idStr = getPosRecIdPrefix() + 'rec_' + allrecords[len].recid;
      $(idStr).css({ 'background-color': CELLBGCOL_LRED });
      w2ui[POSDATAREA].records[allrecords[len].recid - 1].error = 1;
      extErrorFlag = true;
    } else if (recErr == 1) {	// if normal record, error flag off.
      w2ui[POSDATAREA].records[allrecords[len].recid - 1].error = 0;
    }	// if ignore record, no operation.
  }
  return extErrorFlag;
}

//create empty row
function createPosDataRow() {
  var empty = {};
  empty.recid = "";
  empty.rowno = "";
  for (var i = 1; i < captionPosTbl.length; i++) {
    empty[captionPosTbl[i]] = "";
  }
  empty.GP = getCurrentGroupNum();
  empty.frame = COORDINATEUNKOWN;	//getCurrentFrameType();
  empty.rep = POS_REP_NONE;
  empty.save = false;
  empty.error = 0;
  empty.trgtTbl = POSTBLKIND_DATA;
  return empty;
}

var savePositionRecid = 0;
// Processing at the time of saving position data normally
function posSaveComplete() {
  var idStr = getPosRecIdPrefix() + 'rec_' + savePositionRecid;
  $(idStr).css({ 'background-color': '' });
  savePositionRecid = 0;
}
// Processing from the dialog when there is incorrect data in the position data when program saving.
function savePosnError(saveparame) {
  //savePositionRecid = posSaveRec.recid;
  setFocusAfterPosCtrl(getSelPosTblId());
  //var posRec = w2ui[POSDATAREA].records;	=== Error setting processing is unnecessary. ===
  //var posLine = posRec[savePositionRecid - 1];
  //if (((posLine !== undefined) && (posLine.error !== undefined)) || (posLine.error == 0)) {
  //	posLine.error = (saveparame['textResId'] == 'dlgMsgPosUse') ? 0 : 1;
  //}
  //paintIncompleteRows(posRec);
  paintMaskingCell();
}
/*
 * If recid is end of recored, add new recored.
 */
function addNewPosRecLine(recid, changeFlag) {
  debug(DBGDUMP, 'Pass: addNewPosRecLine[' + recid + ']');
  w2ui[getSelPosTblName()].save();
  if (getSelPosTblKind() == POSTBLKIND_DATA) {	// Position Data table
    var lastrowno = w2ui[POSDATAREA].records.length;
    if (recid == lastrowno) {
      var newline = createPosDataRow();
      newline.recid = lastrowno + 1;
      newline.rowno = lastrowno + 1;
      newline.error = 0;
      newline.frame = COORDINATEUNKOWN;
      newline.rep = POS_REP_NONE;
      w2ui[POSDATAREA].add(newline);
    }
    // If uninitialized JOINT record, set UF / UT value. ex) key input directly.
    var targetRec = w2ui[POSDATAREA].get(recid);
    if (targetRec.frame == COORDINATEJOINT) {
      // If the UF / UT value has already been set, it use the set value.
      // Otherwise, the default value is used.
      targetRec.UF = (targetRec.UF !== '') ? targetRec.UF : getUfUtSystemValue(targetRec.GP).UF;
      targetRec.UT = (targetRec.UT !== '') ? targetRec.UT : getUfUtSystemValue(targetRec.GP).UT;
    }
    if (changeFlag) {
      // If changeFlag is true, save the location data.
      checkAndPutPosData(recid);
    }
    setPositionModified(true);
  } else {	// Position Register table
    checkAndPutPosRegister(recid, POSREG_NOTWAIT);
  }
  setTimeout(function () {
    paintMaskingCell();
  }, 1);
}

// It is checked whether position data exists.
function isSelectCommonCol() {
  return (crntGridSelType == SELGRID_CELL) &&
    ((posSelectCol == COLTBLOFS_CMNT) || ((posSelectCol >= COLTBLOFS_EX1) && (posSelectCol <= COLTBLOFS_EX3)));
}
function isExistPositionData(posLine) {
  return (isExistCartPosData(posLine) || isExistJointPosData(posLine));
}
function isExistCartPosData(posLine) {
  for (var i = 0; i < entrykeysCart.length; i++) {
    if (posLine[entrykeysCart[i]] !== '') {
      return true;
    }
  }
  if (posLine.frame == COORDINATECART) {	// Check UF / UT value when record is Cartesian.
    for (var i = 0; i < entrykeysForm.length; i++) {
      if (posLine[entrykeysForm[i]] !== '') {
        return true;
      }
    }
  }
  return false;
}
function isIncompleteCartPos(posLine) {
  for (var i = 0; i < entrykeysCart.length; i++) {
    if (posLine[entrykeysCart[i]] === '') {
      return true;
    }
  }
  for (var i = 0; i < entrykeysForm.length; i++) {
    if (posLine[entrykeysForm[i]] === '') {
      return true;
    }
  }
  return false;
}
function isExistJointPosData(posLine) {
  var robotAxes = getJointRobotAxes(getCurrentGroupNum());	// [3/9/2018] modified.
  for (var i = 0; i < robotAxes; i++) {
    if (posLine[entrykeysJoint[i]] !== '') {
      return true;
    }
  }
  return false;
}
function isIncompleteJointPos(posLine) {
  var robotAxes = getJointRobotAxes(getCurrentGroupNum());	// [3/9/2018] modified.
  for (var i = 0; i < robotAxes; i++) {
    if (posLine[entrykeysJoint[i]] === '') {
      return true;
    }
  }
  return false;
}
function isExistExtPosData(posLine) {
  var jointExt = getExtendAxesCount(getCurrentGroupNum());
  for (var i = 1; i <= jointExt; i++) {
    var axesName = 'EXT' + i;
    if (posLine[axesName] !== '') {
      return true;
    }
  }
  return false;
}
/*
 * Check Extend Axes data is incomplete.
 * (IN)  : Position data.
 * Return: true=incomplete, false=complete.
 */
function isIncompleteExtAxesPos(posLine) {
  var jointExt = getExtendAxesCount(getCurrentGroupNum());	// [3/9/2018] modified.
  for (var i = 1; i <= jointExt; i++) {
    var axesName = 'EXT' + i;
    if (posLine[axesName] === '') {
      return true;
    }
  }
  return false;
}
// Checked whether cartesian data are all set.
function checkCartDataAllSet(posLine) {
  if (posLine.frame == COORDINATEJOINT) {
    return COORDINATEJOINT;
  }
  var posMode = COORDINATECART;
  if (!isExistCartPosData(posLine)) {	// If any data exist, return posMode.
    return posMode;
  }
  if (isIncompleteCartPos(posLine)) {
    posMode = COORDINATEUNKOWN;
  }
  if (isIncompleteExtAxesPos(posLine)) {	// [3/9/2018] modified.
    posMode = COORDINATEUNKOWN;
  }
  return posMode;
}
// Checked whether joint data are all set.
function checkJointDataAllSet(posLine) {
  if (posLine.frame == COORDINATECART) {
    return COORDINATECART;
  }
  var posMode = COORDINATEJOINT;
  if (!isExistJointPosData(posLine)) {
    return posMode;
  }
  if (isIncompleteJointPos(posLine)) {
    posMode = COORDINATEUNKOWN;
  }
  if (isIncompleteExtAxesPos(posLine)) {	// [3/9/2018] modified.
    posMode = COORDINATEUNKOWN;
  }
  return posMode;
}
// Check any other data exist.
// Ex1, 2, 3, or Comment
function isAnyOtherDataExist(posLine) {
  if ((posLine.Comment != undefined) && (posLine.Comment.length > 0)) {
    return true;
  }
  for (var entryCount = 0; entryCount < entrykeysExt.length; entryCount++) {
    if (posLine[entrykeysExt[entryCount]] != "") {
      return true;
    }
  }
  return false;
}

/*
 * Check position data mode.
 * If exist joint data, position mode is JOINT.
 * If exist cartesian data, position mode is CARTESIAN.
 * If exist UF/UT/Config data, position mode is CARTESIAN.
 * If not exist data, position mode is Unknown(-1).
 * return : Position mode.
 */
function checkPositionMode(posLine) {
  var posMode = COORDINATEUNKOWN;
  for (var keyIndex = 0; keyIndex < entrykeysJoint.length; keyIndex++) {
    if (posLine[entrykeysJoint[keyIndex]] !== '') {		// Data exist.
      posMode = COORDINATEJOINT;
      break;
    }
  }
  if (posMode == COORDINATEUNKOWN) {
    for (var keyIndex = 0; keyIndex < entrykeysCart.length; keyIndex++) {
      if (posLine[entrykeysCart[keyIndex]] !== '') {		// Data exist.
        posMode = COORDINATECART;
        break;
      }
    }
  }
  if (posMode == COORDINATEUNKOWN) {
    if ((posLine.UF !== '') || (posLine.UT !== '') || (posLine.Config !== '')) {
      posMode = COORDINATECART;
    }
  }
  return posMode;
}

/*
 * Check position data and Put row data to file.
 * recid : Target record id.
 */
function checkAndPutPosData(recid) {
  if (recid == undefined) {
    return COORDINATEUNKOWN;
  }
  var posRec = w2ui[POSDATAREA].records;
  var posLine = posRec[recid - 1];
  // Do not save if any one is not set.
  var rowInfo = getPositionStateRow(posLine);
  // All data input, update position data.
  if (rowInfo.posMode != COORDINATEUNKOWN) {
    var posElem = ProgramInfoManager.getCurrentProgInfo().getProgPositionElement(0);
    var posText = constructPositionText(rowInfo.savePos, posElem, getGroupCount());	// fileio
    debug(DBGDUMP, 'call putPositionRow: posText [' + posText + ']');
    putPositionRow(getCurrentProgram(), posText);	// api
  }
}

/*
 * Paint incomplete row and get position row data.
 * posLine : Position data of row.
 */
function getPositionStateRow(posLine) {
  var rowInfo = {};
  var posMode = checkPositionMode(posLine);
  // Do not save if any one is not set.
  var savePos = createPosDataRow();
  savePos = $.extend({}, posLine);	// Copy(Clone) position data to save data.
  if (posMode == COORDINATECART) {
    savePos.frame = posMode;
    posMode = checkCartDataAllSet(savePos);
  } else if (posMode == COORDINATEJOINT) {
    savePos.frame = posMode;
    posMode = checkJointDataAllSet(savePos);
  } else {	// Input data is nothing! Clear background color.
    var idStr = getPosRecIdPrefix() + 'rec_' + posLine.recid;
    if (isExistExtPosData(posLine)) {
      $(idStr).css({ 'background-color': CELLBGCOL_LRED });
    } else {
      $(idStr).css({ 'background-color': '' });
    }
    rowInfo.posMode = posMode;
    return rowInfo;
  }
  // All data input, update position data.
  if ((posMode != COORDINATEUNKOWN) && (savePos.error == 0)) {
    savePositionRecid = posLine.recid;
    if (posMode == COORDINATEJOINT) {	// Add UF/UT info to Joint data.
      // If the UF / UT value has already been set, it use the set value.
      // Otherwise, the default value is used.
      savePos.UF = (savePos.UF !== '') ? savePos.UF : getUfUtSystemValue(savePos.GP).UF;
      savePos.UT = (savePos.UT !== '') ? savePos.UT : getUfUtSystemValue(savePos.GP).UT;
    }
  } else {
    var idStr = getPosRecIdPrefix() + 'rec_' + posLine.recid;
    $(idStr).css({ 'background-color': CELLBGCOL_LRED });
  }
  rowInfo.posMode = posMode;
  rowInfo.savePos = savePos;
  return rowInfo;
}

// Paint incomplete rows
function paintIncompleteRows(records) {
  // Called from w2ui.js when all grids are clicked.
  // This process is not necessary for dialogs and tablet editors.
  if (($("#pltmainfrmdlg").length > 0) ||
     ((isScrModeEditorTab()) &&
      (getSelEditListVal() == 'Position') &&
      ($('#tab_left').hasClass('select')))) {
    return;
  }
  for (var rec = 0; rec < records.length; rec++) {
    getPositionStateRow(records[rec]);	// no use savePos data...
  }
}

// for row data copy & paste
function pasteCopiedRowsData(copiedInfo) {
  var emptyrow = '';
  var rowCount = 0;
  var crntGrpNum = getCurrentGroupNum();
  var extAxes = getExtendAxesCount(crntGrpNum);
  var tblKind = getSelPosTblName();
  var currentFrame = getCurrentFrameType();
  copiedText = copiedInfo.text;
  for (var startstr = 0; startstr < copiedText.length;) {
    var strcount = copiedText.indexOf(CODELF, startstr);
    if (strcount == -1) {
      strcount = copiedText.length - 1;
    }
    var tab = copiedText.indexOf(CODETAB, startstr);
    if (startstr != 0) {
      // If match selected record frame and current frame.
      var targetRecid = copiedInfo.selId[0] + rowCount;
      var targetRecord = w2ui[tblKind].get(targetRecid);
      var targetFrame = targetRecord.frame;
      var sourceFrame = copiedInfo.grid[rowCount].frame;
      debug(DBGDUMP, "Paste src frm [" + sourceFrame + "]/ dst frm [" + targetFrame + "]/ crnt frm [" + currentFrame + "]");
      if ((currentFrame == targetFrame) ||
        (targetFrame == COORDINATEUNKOWN)) {
        emptyrow = copiedText.substring(tab + 1, strcount + 1);
        emptyrow = emptyrow.replace(/"/g, "");
        var elemnt = emptyrow.split(CODETAB);
        var pasterow = createPosDataRow();
        pasterow.recid = targetRecid;
        pasterow.rowno = targetRecord.rowno;
        pasterow.Comment = elemnt[0];
        if (getCurrentFrameType() == COORDINATECART) {
          pasterow.X = elemnt[1];
          pasterow.Y = elemnt[2];
          pasterow.Z = elemnt[3];
          pasterow.W = elemnt[4];
          pasterow.P = elemnt[5];
          pasterow.R = elemnt[6];
          var i = 0;
          for (; i < extAxes; i++) {
            pasterow['EXT' + (i + 1)] = elemnt[i + 7].trim();
          }
          if (copiedInfo.tblKind == tblKind) {	// Same table kind
            pasterow.UF = elemnt[i + 7];
            pasterow.UT = elemnt[i + 8];
          } else {	// Unmatch table kind
            if (tblKind == POSDATAREA) {
              pasterow.UF = getUfUtSystemValue(crntGrpNum).UF;
              pasterow.UT = getUfUtSystemValue(crntGrpNum).UT;
            } else {
              pasterow.UF = POS_REG_UF_VAL;
              pasterow.UT = POS_REG_UT_VAL;
            }
          }
          pasterow.Config = elemnt[i + 9].trim();
          pasterow.rep = (extAxes > 0) ? POS_REP_BOTH : POS_REP_CART;
          pasterow.frame = COORDINATECART;
          if (getSelPosTblKind() == POSTBLKIND_REGS) {
            pasterow.force = true;
          }
        } else {
          var robotAxes = getJointRobotAxes(crntGrpNum);
          for (var i = 1; i <= robotAxes; i++) {
            pasterow['J' + i] = elemnt[i].trim();
          }
          for (var i = 1; i <= extAxes; i++) {
            pasterow['EXT' + i] = elemnt[robotAxes + i].trim();
          }
          if (getSelPosTblKind() == POSTBLKIND_REGS) {
            pasterow.UF = POS_REG_UF_VAL;
            pasterow.UT = POS_REG_UT_VAL;
            pasterow.force = true;
          } else {
            pasterow.UF = targetRecord.UF;
            pasterow.UT = targetRecord.UT;
          }
          pasterow.frame = COORDINATEJOINT;
          pasterow.rep = POS_REP_JOINT;
        }
        if (sourceFrame == COORDINATEUNKOWN) { // If paste empty row, paste comment only.
          pasterow = $.extend({}, targetRecord);
          pasterow.Comment = elemnt[0];
        }
        // FSI 20181122 Add Copy process in PosReg
        w2ui[tblKind].set(pasterow.recid, pasterow);
        cmtUpdateFlg[pasterow.recid] = true;
        addNewPosRecLine(pasterow.recid, true);
      } else {
        if (tblKind == POSDATAREA) {
          var lastrowno = w2ui[POSDATAREA].records.length;
          if (targetRecid == lastrowno) {
            var newline = createPosDataRow();
            newline.recid = lastrowno + 1;
            newline.rowno = lastrowno + 1;
            newline.error = 0;
            newline.frame = COORDINATEUNKOWN;
            newline.rep = POS_REP_NONE;
            w2ui[POSDATAREA].add(newline);
          }
        }
      }
      rowCount++;
    }
    startstr = strcount + 1;
  }
}

// for cell data copy & paste
function pasteCopiedCellsData(event, tblKind, currentFrame, copiedInfo) {
  var pasteRowPos = event.index;
  var pastecolumnpos = event.column;
  var copydata = copiedInfo.text.split(CODELF);
  var crntGrpNum = getCurrentGroupNum();
  var extAxesCount = getExtendAxesCount(crntGrpNum);
  for (var i = 0; i < copydata.length; i++) {
    var targetIndex = pastecolumnpos - 1;
    var cellData = copydata[i].split(CODETAB);
    var recordData = w2ui[tblKind].get(pasteRowPos + i + 1);
    var newRec = createPosDataRow();
    newRec = $.extend({}, recordData);
    if (newRec.frame != COORDINATEUNKOWN) {
      if ((copiedInfo.frame != currentFrame) || (newRec.frame != currentFrame) &&
        (!((cellData.length == 1) && (pastecolumnpos == COLTBLOFS_CMNT)))) {
        continue;
      }
    }
    // Rewrite rep and frame to generate back data.
    // Not target data is only comments, blank data for empty lines, for position register.
    if (!((cellData.length == 1) && (pastecolumnpos == COLTBLOFS_CMNT)) && (tblKind == POSDATAREA) &&
      (!((newRec.frame == COORDINATEUNKOWN) && (copydata[i].replace(/\s+/g, "") === "")))) {
      if (getCurrentFrameType() == COORDINATECART) {
        newRec.rep = (extAxesCount > 0) ? POS_REP_BOTH : POS_REP_CART;
      } else {
        newRec.rep = POS_REP_JOINT;
      }
      newRec.frame = currentFrame;
    }
    for (var j = 0; j < cellData.length; j++) {
      targetIndex++
      if (targetIndex == COLTBLOFS_CMNT) {
        cmtUpdateFlg[newRec.recid] = true;
        // Paste as it is
      } else if ((targetIndex >= COLTBLOFS_J1) && (targetIndex <= COLTBLOFS_J6)) {
        /* joint */
        if (currentFrame == COORDINATECART) {
          targetIndex += entrykeysJoint.length;
        } else {
          if ((targetIndex - 1) > getJointRobotAxes(crntGrpNum)) {
            targetIndex += (entrykeysJoint.length - getJointRobotAxes(crntGrpNum));
            targetIndex += entrykeysCart.length;
            if (extAxesCount == 0) {
              targetIndex += entrykeysExt.length;
              targetIndex--;
              continue;
            }
          }
        }
      } else if ((targetIndex >= COLTBLOFS_X) && (targetIndex <= COLTBLOFS_R)) {
        /* cartesian */
        if (currentFrame == COORDINATEJOINT) {
          targetIndex += entrykeysCart.length;
          if (extAxesCount == 0) {
            targetIndex += entrykeysExt.length;
          }
        }
      } else if ((targetIndex >= COLTBLOFS_EX1) && (targetIndex <= COLTBLOFS_EX3)) {
        /* extend Axes */
        if (extAxesCount == 0) {
          targetIndex += entrykeysExt.length;
          if (currentFrame == COORDINATEJOINT) {
            targetIndex--;
            continue;
          }
        } else {
          if ((targetIndex - COLTBLOFS_R) > extAxesCount) {	// correct calc index J6 to R
            targetIndex += (entrykeysExt.length - extAxesCount);
            if ((targetIndex == COLTBLOFS_UF) && (currentFrame == COORDINATEJOINT)) {
              targetIndex--;
              continue;
            }
          }
        }
      } else if ((targetIndex >= COLTBLOFS_UF) && (targetIndex <= COLTBLOFS_CONF)) {
        /* UF UT Config */
        if (currentFrame == COORDINATEJOINT) {
          continue;
        }
      } else {
        debug(DBGDUMP, 'no exist ' + targetIndex);
        continue;
      }
      if ((cellData[j] === "") && (tblKind == POSREGSTBL)) {	// posreg data is empty string
        if ((targetIndex != COLTBLOFS_CMNT) && (targetIndex != COLTBLOFS_CONF)) {
          cellData[j] = 0;	// if Number column, set to 0
        }
      }
      // check valid cell (same as copy frame and paste frame)
      var targetFrame = newRec.frame;
      var sourceFrame = copiedInfo.grid[i].frame;
      debug(DBGDUMP, "Paste cell src frm [" + sourceFrame + "]/ dst frm [" + targetFrame + "]/ crnt frm [" + currentFrame + "]");
      newRec[captionPosTbl[targetIndex]] = cellData[j];
    }
    // reflect and padding empty cell.
    if (tblKind == POSREGSTBL) {
      setContinuousUpdate(true);	// posreg
      var recData = { clm: event.column, num: cellData.length };
      recordPosRegValue(newRec, recData, null, false); // posreg
    }
    w2ui[tblKind].set(newRec.recid, newRec);
    addNewPosRecLine(newRec.recid, true);
  }
}

// It will be displayed in the cell if back data exists.
function backDataRender(orignalRec, originalVal, col_index, fixed) {
  var return_val = originalVal;
  var group_num = getCurrentGroupNum();
  var target_table = getSelPosTblKind();

  if (exchgData[target_table]['dispData'][group_num + "_" + orignalRec.rowno].frame == getCurrentFrameType()) {
    return_val = (exchgData[target_table]['dispData'][group_num + "_" + orignalRec.rowno][POSFIELDARRAY[col_index]]);
  }
  if ((fixed) && (return_val !== "")) {
    return_val = parseFloat(return_val).toFixed(3);
  }
  return return_val;
}

// Hide the back data of error Line.
function checkBackData(record) {
  var returnVal = BACKDATA_HIDDEN;
  var groupNum = getCurrentGroupNum();
  var targetTable = getSelPosTblKind();

  if (record.frame != getCurrentFrameType()) {
    if ([groupNum + "_" + record.rowno] in exchgData[targetTable]['dispData']) {
      returnVal = BACKDATA_DISPLAY;
    } else {
      returnVal = BACKDATA_DELETE;
    }
  }
  return returnVal;
}

// POSFIELDARRAY: Position register column string array
/*
 * Set render for Joint/Cart
 */
function setPosRegRender(record, index, col_index) {
  var return_val = "";
  if (record[POSFIELDARRAY[col_index]] !== "") {
    var recordData = Number(record[POSFIELDARRAY[col_index]])
    if (getDecimalPointLength(recordData) >= 4) {
      return_val = recordData.toFixed(3);
    } else {
      return_val = ((checkBackData(record) == BACKDATA_DELETE) ? "" : recordData);
    }
    return return_val;
  } else if (checkBackData(record) == BACKDATA_DISPLAY) {
    return_val = backDataRender(record, return_val, col_index, true);
    return return_val;
  }
  return return_val;
}

/*
 * Set render for String
 */
function setRenderStr(record, index, col_index) {
  var return_val = record[POSFIELDARRAY[col_index]];
  if ((POSFIELDARRAY[col_index] == FIELD_CONFIG) &&
    (return_val === "") && (checkBackData(record) == BACKDATA_DISPLAY)) {
    return_val = backDataRender(record, return_val, col_index, false);
  }
  return return_val;
}

function confirmConfigAxisNum(confData) {
  var conf = confData.split(",");
  var numCount = 0;
  var regexp = /[0-9]+/;
  for (var num = conf.length - 1; num > 0; num--) {
    if (regexp.test(conf[num])) {
      numCount++;
    }
  }
  if (numCount != confNumofDigits) {
    // defineDialog.open(null, '#nobtndlg', this, resources["dlgMsgCfgErr"]);
    defineDialog.open(null, '#posregconferr', 'dlgMsgCfgErr');
    return false;
  }
  return confData;
}

/*
 * Set render for Joint/Cart
 */
function setPosDataRender(record, index, col_index) {
  var return_val = "";
  if (record[POSFIELDARRAY[col_index]] !== "") {
    var recordData = Number(record[POSFIELDARRAY[col_index]])
    if (getDecimalPointLength(recordData) >= 4) {
      return_val = Number(recordData.toFixed(3));
    } else if ($.inArray(col_index, entryColPosExt) != -1) {
      return_val = recordData;
    } else {
      return_val = ((checkBackData(record) == BACKDATA_DELETE) ? "" : recordData);
    }
  } else if (checkBackData(record) == BACKDATA_DISPLAY) {
    return_val = backDataRender(record, return_val, col_index, true);
  }
  return return_val;
}

/*
 * Set render for Config
 */
function setConfRender(record, index, col_index) {
  var return_val = record[POSFIELDARRAY[col_index]];
  if ((record[POSFIELDARRAY[col_index]] === "") && (checkBackData(record) == BACKDATA_DISPLAY)) {
    return_val = backDataRender(record, return_val, col_index, false);
  }
  return return_val;
}

function setPosUFUTRender(record, index, colIndex) {
  var result = record[POSFIELDARRAY[colIndex]];
  if ((colIndex == COLTBLOFS_UF) || (colIndex == COLTBLOFS_UT)) {
    if (checkBackData(record) == BACKDATA_DELETE) {
      result = "";
    }
  }
  return result;
}

function getDecimalPointLength(number) {
  var numbers = String(number).split('.');
  var result = 0;
  if (numbers[1]) {
    result = numbers[1].length;
  }
  return result;
};

function getEditDefineConfigCallback(pos_rep, pos_type, grp_num, str, cbArg) {
  var posJson = analyzeCartesianPosition(str, cbArg);
  var confData = posJson.Config;
  setPosConf(confData);
  var conf = confData.split(",");
  var numCount = 0;
  var regexp = /[0-9]+/;
  for (var num = conf.length - 1; num > 0; num--) {
    if (regexp.test(conf[num])) {
      numCount++;
    }
  }
  confNumofDigits = numCount; // common robot api
  // create error message
  var msg = resources["dlgMsgCfgErrBefore"];
  for (var num = 0; num < confNumofDigits; num++) {
    msg += resources["dlgMsgCfgErrTrnNum"];
  }
  msg += resources["dlgMsgCfgErrAfter"];
  resources["dlgMsgCfgErr"] = msg;
}

function getPosConfNumOfDigit() {
  var cbArg = {};
  cbArg.tblKind = POSTBLKIND_REGS;
  var posRec = createPosRegRow();
  cbArg.rec = posRec;
  get_curpos(top.KXYZWPR, top.TXML_TP_REC_TYPE, getCurrentGroupNum(), getEditDefineConfigCallback, cbArg);
}

/*
 * In the tablet mode, select the position tab.
 * bool:true = Select position tab, false = Select programming tab
 */
function selPosInTablet(isPos) {
  if (isPos) {
    $('#tab_right').click();
  } else {
    $('#tab_left').click();
  }
}

// save copy data to sessionStorage
function setSaveCopyObj(text, tblKind, key, currentFrame, selType) {
  var saveObj = [];
  var gridObj = getSelectGridRecid(tblKind);
  var gridObjId = "";
  var gridObjFrame = "";

  for (var j = 0; j < gridObj.length; j++){
    gridObjId = gridObjId + gridObj[j]['id'] + CODELF;
    gridObjFrame = gridObjFrame + gridObj[j]['frame'] + CODELF;
  }

  saveObj.push(text);
  saveObj.push(key);
  saveObj.push(gridObjId);
  saveObj.push(gridObjFrame);
  saveObj.push(String(currentFrame));
  saveObj.push(tblKind);
  saveObj.push(selType);
  saveObj.push(getCopyGridSel());
  saveObj.push(String(currentFrame));

  for (var i = 0; i < SAVE_COPY_DATA.length; i++) {
    top.sessionStorage.setItem(SAVE_COPY_DATA[i], saveObj[i]);
  }
}

// delete copy data of sessionStorage
function deleteSessionCopyObj() {
  // top.sessionStorage.clear(); // Delete all session strage data
  for (var i = 0; i < SAVE_COPY_DATA.length; i++) {
  top.sessionStorage.removeItem(SAVE_COPY_DATA[i]);
  }
}

// load copy data from sessionStorage
function loadEditorStorage(itemName) {
  var sessiondata = [];
  var sessionResult = {};

  // read sessionStorage
  for (var i = 0; i < SAVE_COPY_DATA.length; i++) {
    if (top.sessionStorage.getItem(SAVE_COPY_DATA[i]) !== null) {
      sessiondata.push(top.sessionStorage.getItem(SAVE_COPY_DATA[i]));
    }
  }
  // load failed or empty character
  if (sessiondata.length === 0) {
    return null;
  }

  if ((itemName === null) && (sessiondata.length == SAVE_COPY_DATA.length)) {

    var gridObjId = sessiondata[COPY_GRID_ID].split(CODELF);
    var gridObjFrame = sessiondata[COPY_GRID_FRAME].split(CODELF);
    var gridObj = [];
    for (k = 0; k < gridObjId.length - 1; k++) {
      gridObjItem = {
        id: gridObjId[k],
        frame: Number(gridObjFrame[k])
      }
      gridObj.push(gridObjItem);
    }

    sessionResult = {
      'text': sessiondata[COPY_TEXT_DATA],
      'key': sessiondata[COPY_KEY_DATA],
      'grid': gridObj,
      'frame': Number(sessiondata[COPY_FRAME_DATA]),
      'tblKind': sessiondata[COPY_KIND_DATA],
      'selType': sessiondata[COPY_TYPE_DATA]
    };
    return sessionResult;

  } else if (top.sessionStorage.getItem(SAVE_COPY_DATA[SAVE_COPY_DATA.indexOf(itemName)]) !== null) {
    var ResultObj = top.sessionStorage.getItem(SAVE_COPY_DATA[SAVE_COPY_DATA.indexOf(itemName)]);
    if ((itemName == SAVE_COPY_DATA[COPY_GRID_ID]) ||
      (itemName == SAVE_COPY_DATA[COPY_GRID_FRAME]) ||
      (itemName == SAVE_COPY_DATA[COPY_FRAME_DATA]) ||
      (itemName == SAVE_COPY_DATA[COPY_CRNT_FRAME])) {
      ResultObj = Number(ResultObj);
    }
    return ResultObj;
  }
  return null;
}

function checkEditInvalid(lockFlag) {
  if (lockFlag) { // check edit lock
    return isNotEditableWin();
  } else { // check edit lock and write protect
    return isWriteProtectWin();
  }
}

function changePosBtnBlock() {
  var changeFlag = (((isScrModePcEditor()) && (getSelPosTblKind() == POSTBLKIND_DATA)) ? true : false);
  if (!isScrModePcEditor()) { 
    if ($('#posdata').css('display') == 'block') {
      changeFlag = true;
    }
  }
  if (changeFlag) {
    turnoffPopup();
    setPosControlButton(0, 0);
    defineButtonDlg.close('#palletButton');
  }
}

// Waiting process animation for exchange.
function dispOffWaitExchange() {
  if ($('#waitExchange').length > 0) {
    $('#waitExchange').hide();
    $('#waitExchange').remove();
    enablePosCtrlJnt();
    unlockGrid();
  }
}

function dispOnWaitExchange() {
  if ($('#waitExchange').length > 0) {
    return;
  }
  var popupFrame = $('<div>', { id: 'waitExchange' });
  var waitingImage = $('<img>', { id: 'waitExchange', 'src': 'images/waitnotice.gif' });
  var targetButton = ((isScrModePcEditor()) ? (((getCurrentFrameType() === COORDINATEJOINT)) ? $('#posctrlcrt') : $('#posctrljnt')) : $('#cart_btn'));

  popupFrame.css({ 'position': 'absolute', 'left': '50%', 'top': '50%', 'z-index': '1401' });
  popupFrame.append(waitingImage);
  targetButton.addClass('coordctrloff');
  
  if (getSelPosTblKind() == POSTBLKIND_REGS) { 
    $('#posregarea').append(popupFrame);
  } else {
    $('#posdata').append(popupFrame);
  }
  lockGrid();
}
                                                                                                                                                                                                                                                                                                                      P C E D I  &T O R _ P R   G W PCEDI~15JS    MjXX  MjXֹ BZ E B A R  F. J S     P C E D I  FT O R _ R E   S I PCEDI~16JS    MjXX  MjXkU  BT A P I .  J S     P C E D I  T O R _ R O   B O PCEDI~17JS    MjXX  MjXx BK E Y . J  S     P C E D I  T O R _ S E   N D PCEDI~18JS    MjXX  MjX'  BB A R . J  S     P C E D I  T O R _ T O   O L PCEDI~19JS    MjXX  MjXג  BT I P . J  S     P C E D I  T O R _ T O   O L /**********************************************************************
 * PC Editor script
 * for Program text edit part.
 * Created: 2017/04/12
 * Modified:2017/08/21 Responding to specification changes.
 *                     = Omit status line.
 *          2019/04/02 for STEP8
 *                     Fix for code with quality problems.
 */
// Use CodeMirror.
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// Use jQuery
/*
* jQuery JavaScript Library
* https://jquery.com/
* Copyright JS Foundation and other contributors
* Released under the MIT license
* https://jquery.org/license
*/

// Step mode flag.
var programStepMode = false;
function isProgramStepMode() {
  return programStepMode;
}
function setProgramStepMode(step) {
  programStepMode = step;
}
// Current editting program name.
var currentProgramName = '';
function getCurrentProgram() {
  return currentProgramName;
}
function setCurrentProgram(name) {
  currentProgramName = name;
}
function getLimitCurrentProgram() {
  var prgName = currentProgramName.substr(0, 15)
  if (prgName.length == 15) {
    return prgName + "&gt;";
  } else {
    return prgName;
  }
}

// save function is called for 'blur' check
var blurSaveFlag = false;

/**
 * Build Program dropdown list.
 */
var editProgramFiles = [];	// Edit Program file list
var programFileList = [];
var karelprogramList = [];
var monitorFileList = [];
function getProgramFileList() {
  return programFileList;
}
function inProgramList(name) {
  for (var i = 0; i < programFileList.length; i++) {
    if (name == programFileList[i].name) {
      return i;
    }
  }
  return -1;
}
function inKarelProgramList(name) {
  return $.inArray(name, karelprogramList);
}
function sortProgramList() {
  programFileList.sort(function (one, two) {	// Sort object.
    return (one.name < two.name) ? -1 : 1;
  });
}
function getProgramType(progName) {
  var progIndex = inProgramList(progName);
  if (progIndex >= 0) {
    return programFileList[progIndex].type;
  }
  return '';
}
function getRecentEditCallback(sysName, sysValueName, noUse, progName) {
  var emptyPos = [];
  if ((progName == undefined) || (progName.length == 0)) {
    //progName = programFileList[0].name;	// set current to top of list
    if (isScrModeProgAttr()) {
      attrBtnDisable();
      chgSaveBtnCallback(null, progName);
      drawProgramList();
      // drawAttribute();  // does not move
      //progName = programFileList[0].name;	// set current to top of list
      return;
    } else {
      drawPositionData(emptyPos);
      if (isScrModeEditorTab()) {
        defineDialog.open('#btnconfok', '#notSelectdlg', 'dlgProgNotSelect');
      } else {
        initStatusProgramInfo();
      }
      return;
    }
  } else if (isScrModeProgAttr()) {
    // Program has been selected editing program with another tool.
    if (progName.startsWith('*')) {
      progName = progName.substr(1);	// Pickup regular program name
      if (inProgramList(progName) < 0) {	// regularName is not found in array
        progName = programFileList[0].name;	// set current to top of list
      }
    }
  }
  // process only after pressing the delete button
  if (delBtnFlg == true) {
    drawProgramList();
    delBtnFlg = false;
    return;
  }
  if (!(isScrModeEditorTab())) {
    // Program has been selected editing program with another tool.
    if (isProgramNameTemporary(progName)) {
      progName = progName.substr(1);	// Pickup regular program name
      if (inProgramList(progName) < 0) {	// regularName is not found in array
        progName = programFileList[0].name;	// set current to top of list
      }
    }
  }
  // until stop moveto program...
  if (progName == getMoveProgPrim()) {
    resetMoveToProgram();
    programFileList = programFileList.filter(function (val) {
      return (val.name != progName);
    });
    drawPositionData(emptyPos);
    setCurrentProgram(progName);	// set current select
    setProgramNameValue(progName);
    return;
  }
  if (isScrModeProgAttr()) {
    if (isMyIFrameIdPrim()) {
      setCurrentProgram(progName);	// set current select
    } else {
      var urlPgName = location.hash.slice(1) == "" ? progName : location.hash.slice(1);
      setCurrentProgram(urlPgName);	// set current select
    }
    setSelectProgram(progName);
    $('#progNameText').text(getCurrentProgram());
    readProgramFile(getCurrentProgram());	// fileio
  } else {
    var multiScreenProgName = sessionStorage.getItem('selectProg');
    if (multiScreenProgName == null) {
      setCurrentProgram(progName);	// set current select
      setProgramNameValue(progName);
      readProgramFile(progName);	// fileio
    } else {
      setCurrentProgram(multiScreenProgName);
      setProgramNameValue(multiScreenProgName);
      readProgramFile(multiScreenProgName);
      sessionStorage.removeItem('selectProg');
    }
  }
}

// use attribute configuration
var subTypeArray = [
  { arg: top.MM_SUB_UNDEF_C, type: 'attrSubNone' },
  { arg: top.MM_SUB_MACRO_C, type: 'attrSubMacro' },
  { arg: top.MM_SUB_COND_C, type: 'attrSubCond' }
];
var subTypeIndex = 0;
//
/**
 *
 * @param prglist Program List Array
 * @param subTypeCallback Callback for Subtype loop
 * @return true = Complete. false = Incomplete.
 */
function makeProgramListArray(prglist, subTypeCallback) {
  // Make to list.
  // Preprocessing of list construction
  for (var i = 0; i < prglist.length; i++) {
    var regularName = prglist[i];
    if (isProgramNameTemporary(regularName)) {
      // Save to edit program file list
      editProgramFiles[editProgramFiles.length] = regularName;
      // Extract product file name
      regularName = prglist[i].substr(1);
      // Existing edit-file and no regular program.
      if ($.inArray(regularName, prglist) < 0) {	// Not found in array
        // add regular program to list
        if (inProgramList(regularName) < 0) {	// Not found in array
          var allProgList = {};
          allProgList['name'] = regularName;
          allProgList['type'] = resources[subTypeArray[subTypeIndex].type];
          programFileList[programFileList.length] = allProgList;
          //programFileList[programFileList.length] = regularName;
        }
      }
    } else if (regularName.length > 0) {
      if (inProgramList(regularName) < 0) {	// Not found in array
        // add regular program to list
        var allProgList = {};
        allProgList['name'] = regularName;
        allProgList['type'] = resources[subTypeArray[subTypeIndex].type];
        programFileList[programFileList.length] = allProgList;
      }
    }
  }
  subTypeIndex++;
  if (subTypeIndex < subTypeArray.length) {
    getProgramList(subTypeArray[subTypeIndex].arg, subTypeCallback);	// robotapi
    return false;
  }
  sortProgramList();	// Sort
  if (isScrModeProgAttr()) {
    rpcmc_gtmcrlst(getMacroListCB);
  }
  return true;
}
var macro_list;
function getMacroListCB(status, macroList, listNum) {
  macro_list = macroList;
  if (!(macro_list[macro_list.length - 1])) {
    macro_list.pop();
  }

  if (isScrModeProgAttr()) {
    drawProgramList();
  } else if (programFileList.length > 0) {
    //$('#programlist').append(pgmOptions);	// append to select tag
    getRecentTopProgram(getRecentEditCallback);
  }
}
function prgListInitCallback(datatype, prglist, listNum) {
  var result = makeProgramListArray(prglist, prgListInitCallback);
  if (!result) {
    return;
  }
  lstProg(top.TV_PRG_ALL, top.MM_KRLPRG_C, subTypeArray[0].arg, getKrlPrgListCB); // io
  if (programFileList.length > 0) {
    //$('#programlist').append(pgmOptions);	// append to select tag
    if (isScrModeProgAttr()) {
      if (buttonName != 'detailstab') {
        getRecentTopProgram(getRecentEditCallback);
      }
    } else {
      getRecentTopProgram(getRecentEditCallback);
    }
  } else {
    if(isScrModeProgAttr()) {
      attrBtnDisable();
    } else if (isScrModePcEditor()) {
      var emptyPos = [];
      drawPositionData(emptyPos);
    }
  }
}
function prgListRebldCallback(datatype, prglist, listNum) {
  var result = makeProgramListArray(prglist, prgListRebldCallback);
  if (!result) {
    return;
  }
  lstProg(top.TV_PRG_ALL, top.MM_KRLPRG_C, subTypeArray[0].arg, getKrlPrgListCB); // io
  // Open [Open]Dialog.
  defineDialog.open('#fileopen', '#selprogdlg', '');	// Select program
  if ($('#proglisthdr-ttl') != undefined) {
    var titleHeight = $('#proglisthdr-ttl').height();
    var typeHeight = $('#proglisthdr-typ').height();
    $('.proglistelem').css('height', titleHeight);
  }
}
// get KAREL program list callback
function getKrlPrgListCB(datatype, prglist, listNum) { 
  for (var i = 0; i < prglist.length; i++) { 
    if ($.inArray(prglist[i], karelprogramList) < 0) {
      karelprogramList.push(prglist[i]);
    }
  }
}
function buildProgramList() {
  // Call Interface of get program list
  subTypeIndex = 0;
  programFileList.length = 0;	// initialize.
  karelprogramList.length = 0; // initialize.
  getProgramList(subTypeArray[subTypeIndex].arg, prgListInitCallback);	// robotapi
}
// Open the [Open]Dialog, after reBuild Program list.
function openOpenDialog() {
  // Call Interface of get program list
  subTypeIndex = 0;
  programFileList.length = 0;	// initialize.
  karelprogramList.length = 0; // initialize.
  getProgramList(subTypeArray[subTypeIndex].arg, prgListRebldCallback);	// robotapi
}
// If the list has been changed, restore it.
function restoreProgramList(progName) {
  //var pgName = $('#programlist').val();
  if (isScrModeProgAttr()) {
    var pgName = $('#progNameText').text();
    if (pgName !== progName) {
      //$('#programlist').val(progName);
      $('#progNameText').text(progName);
    }
    return;
  }
  var pgName = (isScrModeEditorTab()) ? $('#programname').text() : $('#programname').val();
  if (pgName !== progName) {
    //$('#programlist').val(progName);
    setProgramNameValue(progName);
  }
}

// Edit program file list operations
// check name exist in list
function isExistEditProgramFile(progName) {
  return ($.inArray(progName, editProgramFiles) >= 0) ? true : false;
}
// remove name from list
function removeEditProgramFile(progName) {
  editProgramFiles = editProgramFiles.filter(function (val, index) {
    return (val !== progName);
  });
  saveStorage();
}
// append name to list
function addEditProgramFile(progName) {
  if ($.inArray(progName, editProgramFiles) < 0) {
    editProgramFiles.push(progName);
    saveStorage();
  }
}
// change name
function replaceEditProgramFile(prevName, progName) {
  if ($.inArray(prevName, editProgramFiles) >= 0) {	// if exist.
    removeEditProgramFile(prevName);	// remove one
    setTimeout(function () {
      addEditProgramFile(progName);
    }, 10);
  }
}

// save status to storage for logout
function saveStorage() {
  if (isExistEditProgramFile(getTempProgName(getCurrentProgram()))) {
    top.sessionStorage.setItem("unsaved", "true");
    top.sessionStorage.setItem("program", getTempProgName(getCurrentProgram()));
  } else {
    top.sessionStorage.setItem("unsaved", "false");
    top.sessionStorage.removeItem("program");
  }
}

/* --- Is it a new program? --- */
var newEditProgram = false;
function isNewEditProgram() {
  return newEditProgram;
}
function setNewEditProgram(flag) {
  newEditProgram = flag;
}

/* --- program modify flag --- */
var programModified = false;
function isProgramModified() {
  return programModified;
}
function setProgramModified(flag) {
  programModified = flag;
  if (isScrModeEditorTab()) {
    changeSavebtnstate();
  }
}

/* --- program execute condition --- */
var programOnExecute = false;
function isExecuteProgram() {
  return programOnExecute;
}
function setProgramExec(exec) {
  programOnExecute = exec;
}
/* --- Measures to make change.cancel () in beforeChange pass through. ---*/
var programOnSwitching = false;
function isSwitchingProgram() {
  return programOnSwitching;
}
function setSwitchingProgram(switching) {
  programOnSwitching = switching;
}
/* --- Program execution when moveto --- */
var programOnMoveTo = false;
function isMoveToOnProgram() {
  return programOnMoveTo;
}
function setMoveToOnProgram(moveto) {
  programOnMoveTo = moveto;
}

/* --- program area on refresh --- */
var isProgramAreaRefresh = false;

/* --- Is an error occurring? true=Occurring, false=Not occurred --- */
var rowErrorOccurring = false;
function isRowErrorOccurring() {
  return rowErrorOccurring;
}
function setRowErrorOccurring(condition) {
  rowErrorOccurring = condition;
}

// Restrict Keydown event on Codemirror.
function keydownCMCallback() {
  //getPcEditor().setCursor({line: to.line, ch: to.ch});
  getPcEditor().focus();
}

// Open Search dialog
function textSearchDialog(srhOption) {
  // Already display Search/Replace dialog?
  if (searchDialog.isDialogOpen()) {
      // Set focus to dialog
      searchDialog.setFocus();
      return;
  }
  // Open dialog
  searchDialog.open(getPcEditor(), srhOption);
}
// Replace confirm dialog
function replaceConfirmDialog(srhOption) {
  // Open dialog
  repConfDialog.open(getPcEditor(), srhOption);
}

// Cursor position management variable
var currentEditPos = { line: 0, ch: 0 };
var previousEditPos = { line: 0, ch: 0 };
var nextCursorPos = { line: 0, ch: 0 };
var beforeChgPos = { line: 0, ch: 0 };
var beforeCusStaPos = { line: 0, ch: 0 };
// Line count management variable
var currentLineCnt = 0;
var previousLineCnt = 0;
// other...
var modifiedText = false;	// Text modified yes/no. = true/false
function setModifiedText(mode) {	// true=yes, false=no
  modifiedText = mode;
}
function isModifiedText() {
  return modifiedText;
}
var originCommandString = '';	// Origin command when change.
var originDragStartFrom = {};	// Range of Drag start line/ch.
var editEventKey = '';		// editor event key name.
// Insert edit line info for multiple line.
var InsertEditInfo = (function() {
  var lines = [];	// Line number(0 base) for multiple line insert.
  var index = 0;	// Line number(0 base) for multiple line insert.
  return {
    init: function() {
      lines = [];
      index = 0;
    },
    setLines: function(lineArray) {
      lines = lineArray;
      index = 0;
    },
    getLines: function() {
      return lines;
    },
    setLine: function(line) {
      lines[index] = line;
    },
    putLine: function(idx, line) {
      lines[idx] = line;
    },
    getTargetLine: function() {
      return lines[index];
    },
    getLine: function(idx) {
      return lines[idx];
    },
    setSaved: function(cond) {
      lines[index].saved = cond;
    },
    getLength: function() {
      return lines.length;
    },
    getIndex: function() {
      return index;
    },
    isExistLines: function() {
      return (lines.length > 0);
    },
    incIndex: function() {
      index++;
    }
  }
})();
var copiedEditLines = [];	// Copied data for paste.
var issaveeditline = false; // save edit line
var selTarget = {};	// save select target row info. (line, ch)
var pasteSrcText = []; // save clipboardData
var viewChanged = false; // cange flag = true/false

/* use multiPaste method*/
var lastLineData = '';
var lastLineCh = 0;

// Constant of origin string
var ORIGINSTR_UNDO = 'undo';
var ORIGINSTR_CMPLT = 'complete';
var ORIGINSTR_PDEL = '+delete';
var ORIGINSTR_PASTE = 'paste';
var ORIGINSTR_PIPT = '+input';
var ORIGINSTR_CUT = 'cut';
var ORIGINSTR_COPY = 'copy';
var ORIGINSTR_DRAG = 'drag';
var ORIGINSTR_MLTPAS = 'multiPaste';	// original origin. multiple paste source rows.
var ORIGINSTR_RNGPST = 'pasteRange';	// original origin. paste target row is 'Range'.
var ORIGINSTR_SELDRAG = 'selectDrag';	// original origin. Drag selection.
var EVENTKEY_DEL = 'Delete';
var EVENTKEY_BS = 'Backspace';
var EVENTKEY_ENTER = 'Enter';

// Check Multiple rows paste.
// return: true=Multiple rows, false=Single rows
function isMultiRowsPaste(pasteRow) {
  // If the end of the copied data is not a line feed, add newline data.
  if (pasteRow[pasteRow.length - 1].length != 0) {
    pasteRow[pasteRow.length] = '';
  }
  // Set to copied data for paste.
  for (var i = 0; i < pasteRow.length; i++) {
    copiedEditLines[copiedEditLines.length] = pasteRow[i];
  }
  // Multiple rows of paste is not support.
  return (pasteRow.length > 2);

}
// Check Mlultiple command at row.
// return: true=Semicolon is exist in the middle of row, false=Not in the middle.
function isMultiCmdPaste(lineText) {
  var semiColonPos = lineText.trim().indexOf(';');
  // An error if there is a semicolon in the middle of the line.
  return ((semiColonPos >= 0) && (semiColonPos < lineText.trim().length - 1));
}

function updateCurrentLine() {
  currentLineCnt = getEditorDoc().lineCount();
}
function updateCursorPos() {
  previousEditPos = currentEditPos;
  currentEditPos = nextCursorPos;
}
// function for save replace line.  call from search.
var saveReplaceInfo = {};
saveReplaceInfo.replace = false;
function saveEditReplaceLine(repArgs, pos) {
  currentEditPos = pos;
  setModifiedText(true);
  saveReplaceInfo.replace = true;
  saveReplaceInfo.callback = repArgs.nextRep;
  saveReplaceInfo.cbArgs = repArgs;
  saveEditLine();
}

function saveEditLine() {
  previousLineCnt = currentLineCnt;
  // data change?
  if (isProgramModified()) {
    setModifiedText(false);
    setReadOnly(true);
    issaveeditline = true;
    // Overwrite line
    var lineData = getEditorDoc().getLine(currentEditPos.line);
    if (lineData == undefined) {
      debug(DBGWARN, 'saveEditLine: lineData is undefined.');
      setReadOnly(false);
      return;
    }
    var crntLineCh = lineData.length;
    lineData = lineData.trim();
    // Check multiple command in the row.
    if (isMultiCmdPaste(lineData)) {
      debug(DBGWARN, 'saveEditLine: Multiple Command per line.');
      defineDialog.open(null, '#mltcmddlg', 'dlgMltCmdPaste');
      return;
    }
    // Write target is top of row, data insert to TOR.
    // Target is within row count, data overwrite to specified row.
    // Target is over row cont, data insert after to end of row...
    var writeMode = (isNewEditProgram()) ? PRGWRITE_INS : PRGWRITE_OVW;
    //setNewEditProgram(false);
    var lineNumber = currentEditPos.line + 1;	// Line number is from 1
    
    putProgramLine(getCurrentProgram(), lineNumber, writeMode, lineData);	// api
  }
  // saveEditLineTimer = setTimeout(function () {
  //   waitSaveEditLine(getCurrentProgram());
  // }, 50); // Keep a interval
}
// Pre-process for paste line, when modified text.
function preProcPstLine() {
  setModifiedText(false);
  // Overwrite line
  var lineData = getEditorDoc().getLine(currentEditPos.line);
  if (lineData == undefined) {
    debug(DBGWARN, 'preProcPstLine: lineData is undefined.');
    return;
  }
  // Check multiple command in the row.
  if (isMultiCmdPaste(lineData)) {
    debug(DBGWARN, 'preProcPstLine: Multiple Command per line.');
    defineDialog.open(null, '#mltcmddlg', 'dlgMltCmdPaste');
    return;
  }
  // Write target is top of row, data insert to TOR.
  // Target is within row count, data overwrite to specified row.
  // Target is over row cont, data insert after to end of row...
  var writeMode = (isNewEditProgram()) ? PRGWRITE_INS : PRGWRITE_OVW;
  //setNewEditProgram(false);
  var lineNumber = currentEditPos.line + 1;	// Line number is from 1
  setReadOnly(true);
  issaveeditline = true;
  previousLineCnt = currentLineCnt;
  putPrePasteLine(getCurrentProgram(), lineNumber, writeMode, lineData);	// api
}
/**
 * for multiple lines paste when not select lines
 */
function pasteSaveEditLine(line, mode) {
  // data change?
  if (isModifiedText()) {
    // Overwrite line
    var lineData = getEditorDoc().getLine(line);
    if (lineData == undefined) {
      debug(DBGWARN, 'pasteSaveEditLine: lineData is undefined.');
      return;
    }
    var crntLineCh = lineData.length;
    lineData = lineData.trim();
    if (lineData.trim().length == 0) {
      lineData = ';';
    }
    // Check multiple command in the row.
    if (isMultiCmdPaste(lineData)) {
      debug(DBGWARN, 'pasteSaveEditLine: Multiple Command per line.');
      defineDialog.open(null, '#mltcmddlg', 'dlgMltCmdPaste');
      return;
    }
    var lineNumber = line + 1;	// Line number is from 1
    //issaveeditline = true;	// move. [set true after paste]
    previousLineCnt = currentLineCnt;
    // in this case, insert only
    pasteProgramLine(getCurrentProgram(), lineNumber, mode, lineData);	// api
  }
}

/*
 * Cancel Drag and Drop of the selected range.
 */
function cancelDragAndDrop(cmObj, range) {
  var newSelect = {};
  newSelect.line = range.line;
  newSelect.ch = range.ch;
  cmObj.doc.setSelection(newSelect, newSelect, { origin: ORIGINSTR_SELDRAG });
  cmObj.focus();
  //cmObj.setCursor({line: newSelect.line, ch: newSelect.ch});	Cursor set to origin line/ch
  cmObj.setCursor(originDragStartFrom);
}

/*
 * Insert command string to cursor position.
 */
function insertCommandStr(cmdStr) {
  var editor = getPcEditor();
  var csrLine = editor.getCursor().line;
  var csrChar = editor.getCursor().ch;
  editor.replaceRange(cmdStr, CodeMirror.Pos(csrLine, csrChar));
  // focus set to editor
  csrChar += cmdStr.length;	// Cursor move to end of insert string.
  editor.focus();
  editor.setCursor({ line: csrLine, ch: csrChar });
}

/*
 * Key Event Send To Browser
 */
function sendKeyEventToBrowser(keyCh, keyCode, shiftKey, ctrlKey, altKey) {
  var keyEvent = new KeyboardEvent( 'keydown',
    {'key': keyCh, 'ctrlKey': ctrlKey, 'keyCode': keyCode, 'which': keyCode });
  document.getElementById('programarea').dispatchEvent(keyEvent) ;
}

/* Return editor object. */
var cmEditorObj = null;
function getPcEditor() {
  return cmEditorObj;
}
function getEditorDoc() {
  return cmEditorObj.getDoc();
}
// change editor read only mode
function getReadOnly() {
  var edit = getPcEditor();
  return edit.options.readOnly;
}
function setReadOnly(boolean) {
  var edit = getPcEditor();
  edit.options.readOnly = boolean;
}
/*
 * Create Editor Instance. (call from main)
 */
function createEditorInstance() {
  cmEditorObj = CodeMirror.fromTextArea(document.getElementById('programtext'), cmEditOption);
}
/*
 * Option define for Editor. (Separation from argument for future.)
 */
var cmEditOption = {
  mode: 'text/x-roboprogedit',
  theme: 'roboprogedit',
  indentUnit: 4,
  indentWithTabs: false,
  smartIndent: false,
  tabMode: 'classic',
  enterMode: 'flat',
  electricChars: false,
  lineNumbers: true,
  firstLineNumber: 1,
  gutter: false,
  fixedGutter: true,
  matchBrackets: false,
  styleActiveLine: false,
  searchDialog: textSearchDialog,
  repConfDialog: replaceConfirmDialog,
  // original options
  restrictOKButtonCB: saveEditError,
  restrictKeyDownCB: keydownCMCallback,
  ignoreKeyDialogId: '#edtalertdlg',
  restrictDialog: ['#confmodifieddlg', '#confsavedlg', '#selprogdlg', '#selchangedlg', '#confsvrundlg', '#confalertdlg',
    '#edtalertdlg', '#mltcmddlg', '#pstalertdlg', '#posalertdlg', '#savealertdlg', '#confmovetodlg',
    '#confdeletedlg', '#getprogdlg', '#getsvasprogdlg', '#getrenameprogdlg', '#mltpastedlg', '#confnoticedlg']
};
/*
 * Register an event handler for the given event type on the editor instance.
 */
function registEditorHandler(editorInstance) {
  debug(DBGINFO, 'registEditorHandler()');
  CodeMirror.on(editorInstance, 'change', cmOnChange);
  CodeMirror.on(editorInstance, 'beforeSelectionChange', cmOnBeforeSelectionChange);
  CodeMirror.on(editorInstance, 'beforeChange', cmOnBeforeChange);
  CodeMirror.on(editorInstance, 'keyHandled', cmOnKeyHandled);
  //CodeMirror.on(editorInstance, 'contextmenu', cmOnContextmenu);
  CodeMirror.on(editorInstance, 'cursorActivity', cmOncursorActivity);
  CodeMirror.on(editorInstance, 'blur', cmOnBlur);
  CodeMirror.on(editorInstance, 'focus', cmOnFocus);
  CodeMirror.on(editorInstance, 'touchstart', cmOnTouchstart);
  CodeMirror.on(editorInstance, 'mousedown', cmOnMousedown);
  CodeMirror.on(editorInstance, 'refresh', cmOnRefresh);
  CodeMirror.on(editorInstance, 'paste', cmOnPaste);
}
/*
 * Remove an event handler on the editor instance.
 */
function removeEditorHandler(editorInstance) {
  debug(DBGINFO, 'removeEditorHandler()');
  CodeMirror.off(editorInstance, 'change', cmOnChange);
  CodeMirror.off(editorInstance, 'beforeSelectionChange', cmOnBeforeSelectionChange);
  CodeMirror.off(editorInstance, 'beforeChange', cmOnBeforeChange);
  CodeMirror.off(editorInstance, 'keyHandled', cmOnKeyHandled);
  //CodeMirror.off(editorInstance, 'contextmenu', cmOnContextmenu);
  CodeMirror.off(editorInstance, 'cursorActivity', cmOncursorActivity);
  CodeMirror.off(editorInstance, 'blur', cmOnBlur);
  CodeMirror.off(editorInstance, 'focus', cmOnFocus);
  CodeMirror.off(editorInstance, 'touchstart', cmOnTouchstart);
  CodeMirror.off(editorInstance, 'mousedown', cmOnMousedown);
  CodeMirror.off(editorInstance, 'refresh', cmOnRefresh);
  CodeMirror.off(editorInstance, 'paste', cmOnPaste);
}

/* Key input on editor window. */
function cmOnChange(cm, change) {
  setProgramModified(true);
  var tempCsrPos = cm.getCursor();
  debug(DBGDUMP, 'onChange: line:' + tempCsrPos.line + '/ch:' + tempCsrPos.ch + '/change.origin:' + change.origin + ';');
  debug(DBGTRACE, 'onChange: text:[' + change.text + ']');
  originCommandString = change.origin;
  if (change.origin == ORIGINSTR_UNDO) {
    return false;
  }
  // The first time the display is the unedited state.
  setModifiedText(((isNewEditProgram()) && (tempCsrPos.line == 0) && (tempCsrPos.ch == 0)) ? false : true);
  if (change.origin == ORIGINSTR_CMPLT) {
    tempCsrPos.ch -= change.text[0].length;
    tempCsrPos.ch += countCommandCursorPos(change.text[0]);
    cm.setCursor(tempCsrPos);
    return false;
  }
  //if (change.from.ch == 0) {	// Input key beginning of line?
  return watchChange(cm);
  //}
}
function cmOnBeforeSelectionChange(cm, change) {
  if (change.origin == ORIGINSTR_SELDRAG) {
    debug(DBGDUMP, 'beforeSelectionChange: from:line' + change.from.line + '/ch:' + change.from.ch + '/change.origin:' + change.origin);
    var newSelect = {};
    newSelect.line = change.from.line;
    newSelect.ch = change.from.ch;
    change.ranges.anchor = newSelect;
    change.ranges.head = newSelect;
  }
}
function cmOnBeforeChange(cm, change) {
  beforeChgPos = cm.getCursor();
  debug(DBGDUMP, 'onBeforeChange: from:' + change.from.line + '/to:' + change.to.line + '/change.origin:' + change.origin + ';');
  debug(DBGTRACE, 'onBeforeChange: text:[' + change.text + ']');
  if (getCurrentProgram() == '') {
    // It is not editable when the file is not created.
    change.cancel();
    return;
  }
  if ((isExecuteProgram()) && (isMyIFrameIdPrim()) && (!isSwitchingProgram())) {
    // Can not edit while running. (STEP8) Except for change to sub program.
    change.cancel();
    return;
  }
  if ((!isMyIFrameIdPrim()) && (change.origin != "setValue")) {
    // FSI 20181207 Can not edit from restricted window
    change.cancel();
    defineDialog.open(null, '#confalertdlg', 'dlgMsgSecondEditor');	// Alert on
    return;
  }
  if ((ProgramInfoManager.getCurrentProgInfo() !== null) &&
    (change.origin != "setValue")) {
    if (ProgramInfoManager.getCurrentProgInfo().getEditAttrValue().PROTECT == PROTECTON) {
      change.cancel(); // FSI 20190527 if not change, it is protect program.
      defineDialog.open(null, '#confalertdlg', 'dlgMsgProtectEditor'); // Alert on
      if (isAndroid) {
        getPcEditor().refresh();
      }
      return;
    }
  }
  if ((isNotEditableWin()) && (change.origin != "setValue")) {
    var alertStr = ((isScrModePcEditor()) ? 'dlgMsgNotEditableEditor' : 'dlgMsgNotEditableEditorTb');
    change.cancel(); // FSI 20190618 if not change, it is not editable mode.
    defineDialog.open(null, '#confalertdlg', alertStr); // Alert on
    if (isAndroid) {
      getPcEditor().refresh();
    }
    return;
  }
  if (isRowErrorOccurring()) {
    debug(DBGDUMP, 'beforeChange(Row error): originCommand=' + originCommandString);
    switch (change.origin) {
      case ORIGINSTR_PDEL:
        if ((change.from.line != change.to.line) && (change.text[0] == '')) {
          change.cancel();
        }
        break;
      case ORIGINSTR_UNDO:
        if (!isUndoExecution) {
          change.cancel();
        }
        break;
      case ORIGINSTR_PASTE:
        if (originCommandString == ORIGINSTR_DRAG) {	// Even if it is an error line, check drag and drop.
          cancelDragAndDrop(cm, originDragStartFrom);
          change.cancel();
          break;
        }
        pasteSrcText = change.text;
        break;
      case ORIGINSTR_DRAG:	// Even if it is an error line, check drag and drop.
        originCommandString = change.origin;
        originDragStartFrom = change.from;
        change.cancel();
        break;
      default:
        break;
    }
    return;
  } 	// Row error is not occurring.
  debug(DBGDUMP, 'beforeChange: originCommand=' + originCommandString);
  switch (change.origin) {
    case ORIGINSTR_UNDO:
      change.cancel();
      break;
    case ORIGINSTR_PASTE:
      if (originCommandString == ORIGINSTR_DRAG) {
        cancelDragAndDrop(cm, change.from);
        change.cancel();
        break;
      }
      pasteSrcText = change.text;
      change.cancel();
      multiRowPaste(true, pasteSrcText);
      break;
    case ORIGINSTR_PDEL:
      previousEditPos = currentEditPos;
      currentEditPos = beforeChgPos;
      // fall next case
    case ORIGINSTR_CUT:
      var selRange = cm.doc.sel.ranges[0];
      if (selRange.head.line == selRange.anchor.line) { // how to select row
        if (selRange.head.ch < selRange.anchor.ch) { // secelt type is up to down
          selTarget.startRow = selRange.head;
          selTarget.endRow = selRange.anchor;
        } else {  // secelt type is down to up
          selTarget.startRow = selRange.anchor;
          selTarget.endRow = selRange.head;
        }
      } else if (selRange.head.line < selRange.anchor.line) {
        selTarget.startRow = selRange.head;
        selTarget.endRow = selRange.anchor;
      } else {	// If the selection of the pasting destination is upward
        selTarget.startRow = selRange.anchor;
        selTarget.endRow = selRange.head;
      }
      var lastRowCh = cm.doc.getLine(selTarget.endRow.line).length;
      if ((selTarget.startRow.ch == 0) &&
          (selTarget.startRow.ch != selTarget.endRow.ch) &&
          (selTarget.endRow.ch == lastRowCh)) {	//  end column is top of row
        selTarget.endRow.ch = 0;	// The last ch is the end of row.
        selTarget.endRow.line = selTarget.endRow.line + 1;
        selRange.head = selTarget.startRow;
        selRange.anchor = selTarget.endRow;
      }
      break;
    case ORIGINSTR_DRAG:
      originCommandString = change.origin;
      originDragStartFrom = change.from;
      change.cancel();
      break;
    default:
      break;
  }
}
/* key up event not use ... Comment out (It may be used in the future) */
function cmOnKeyHandled(cm, name, event) {
  debug(DBGDUMP, 'onKeyHandled: name:' + name + '/event.key:' + event.key + '/event.type:' + event.type);
  if (isExecuteProgram()) {	// Can not cursor move while running
    event.preventDefault();
    event.stopPropagation();
    return false;
  }
  editEventKey = event.key;
}
/* Context menu process */
/*
  =====================
  Since there is a problem with Android, suppress own context menu.
  =====================
function cmOnContextmenu(cm, event) {
  debug(DBGDUMP, 'onContextmenu: event.type:' + event.type);
  if ($('#edtctxMenu').length > 0) {  // already open, close.
    $('#edtctxMenu').hide();
    $('#edtctxMenu').remove();
  }
  var textSelection = cm.doc.getSelection();
  // add find/replace context menu to program area.
  var ctxMenu = $('<div>', { id: 'edtctxMenu', 'class': 'ctxmenubox'});
  var ctxMenuFrame = $('<ul>', {id: 'edtctxMenuFrame'});
  ctxMenuFrame.css({'list-style' : 'none', 'margin' : '0px', 'padding' : '5px'});
  var ctxMenuItem = $('<li>', {id: 'ctxSearch', 'class': 'ctxmenuitem ctxmenuselect'});
  ctxMenuItem.html('Find / Replace');
  ctxMenuFrame.append(ctxMenuItem);
  var copyClass = (textSelection.length > 0) ? 'ctxmenuitem ctxmenuselect' : 'ctxmenudisable';
  ctxMenuItem = $('<li>', {id: 'ctxCopy', 'class': copyClass});
  ctxMenuItem.html('Copy');
  ctxMenuFrame.append(ctxMenuItem);
  ctxMenuItem = $('<li>', {id: 'ctxCut', 'class': 'ctxmenuitem ctxmenuselect'});
  ctxMenuItem.html('Cut');
  ctxMenuFrame.append(ctxMenuItem);
  ctxMenuItem = $('<li>', {id: 'ctxPaste', 'class': 'ctxmenuitem ctxmenuselect'});
  ctxMenuItem.html('Paste');
  ctxMenuFrame.append(ctxMenuItem);
  ctxMenuItem = $('<li>', {id: 'ctxSelectAll', 'class': 'ctxmenuitem ctxmenuselect'});
  ctxMenuItem.html('Select All');
  ctxMenuFrame.append(ctxMenuItem);
  ctxMenu.append(ctxMenuFrame);
  ctxMenu.css({'top' : event.pageY + 'px', 'left' : event.pageY + 'px'});
  $('#programarea').append(ctxMenu);
  event.preventDefault();
  event.stopPropagation();
  return false;
}
*/
  /* Move cursor */
function cmOncursorActivity(cm) {
  if (isExecuteProgram()) {	// if execute program, skip process...
    debug(DBGDUMP, 'cursorActivity: isExecuteProgram() ture.');
    return;
  }
  if (isFileLoading()) {	// if loading file, skip process...
    debug(DBGDUMP, 'cursorActivity: isFileLoading() ture.');
    return;
  }
  if (isUndoExecution) {	// if undo process, skip process...
    debug(DBGDUMP, 'cursorActivity: isUndoExecution ture.');
    return;
  }
  if (isProgramAreaRefresh) {	// if refresh program area, skip process...
    debug(DBGDUMP, 'cursorActivity: isProgramAreaRefresh ture.');
    return;
  }
  if (issaveeditline) {	// if during save processing, skip process...
    debug(DBGDUMP, 'cursorActivity: issaveeditline ture.');
    return;
  }
  if (($('#confnoticedlg').length == 1)) {	// if on display error dialog, skip process...
    debug(DBGDUMP, 'cursorActivity: #confnoticedlg on open.');
    return;
  }
  // if context menu is open, close it.
  if ($('#edtctxMenu').length > 0) {
    $('#edtctxMenu').hide();
    $('#edtctxMenu').remove();
    event.preventDefault();
    event.stopPropagation();
    return false;
  }

  // when browser is IE and hint popup is displaying, cansel blur event.
  if (isIE) {
    if ($(".CodeMirror-hints").length !== 0) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  // Notify the execution panel of the cursor line  except during sub program execution.
  if ((getCurrentProgram() == statusProgramInfoTrans.getCurrentProgramSI().prog) && (cm.getCursor().line != nextCursorPos.line) 
      && (WATCHEXEC_RUNNING != statusProgramInfoTrans.getCurrentProgramSI().stat)) {
    if (!statusProgramInfoTrans.getCurrentProgramSI().initSetLineFlag && WATCHEXEC_PAUSED == statusProgramInfoTrans.getCurrentProgramSI().stat) {
      // Do not do setLine when first loaded, when paused, and when $SHELL_WRK.$BY_MANUAL:false
    } else {
      getRecentTopProgram(getRecentDispCB);
    }
    statusProgramInfoTrans.getCurrentProgramSI().initSetLineFlag = true;
    function getRecentDispCB(sysName, sysValueName, noUse, progName) {
      setLine(progName, cm.getCursor().line + 1);
    }
  }
  nextCursorPos = cm.getCursor();
  var viewChanged = cm.curOp.viewChanged;
  if (!viewChanged) {
    // for palletButton
    var lineText = cm.getLine(nextCursorPos.line);
    if (typeof lineText !== 'undefined') {
      switchPltBtn(lineText);
    }
  }
  debug(DBGDUMP, 'onCursorActivity: line:(' + nextCursorPos.line + ')ch:(' + nextCursorPos.ch + ')viewChg:[' + viewChanged + ']savedOrigin:[' + originCommandString + ']');
  if (originCommandString == ORIGINSTR_DRAG) {	// if drag, cancel drag process.
    cm.focus();
    cm.doc.setCursor(originDragStartFrom);
    originCommandString = '';
    originDragStartFrom = {};
    return;
  }
  debug(DBGDUMP, 'cursorActivity(B): prevLine(' + previousEditPos.line + '):crntLine(' + currentEditPos.line + '):NextLine(' + nextCursorPos.line + ')');
  // When you try to move the line when there is an error, so as not to move.
  if ((isRowErrorOccurring()) && (nextCursorPos.line != currentEditPos.line) && (!isModifiedText())) {
    currentEditPos.ch = nextCursorPos.ch;
    cm.setCursor(currentEditPos);
    defineDialog.open('programarea', '#confnoticedlg', '');	// Alert on
    return;
  }
  // line move... or data change (when cursor dont move)
  if ((nextCursorPos.line != currentEditPos.line) ||	// line moved... or
      ((nextCursorPos.line == currentEditPos.line) &&	// same cursor position
      // (nextCursorPos.ch == currentEditPos.ch) &&
        (viewChanged)) ||	//  and changed
      (originCommandString == ORIGINSTR_MLTPAS)) {	// or Multiple source paste.
    updateCurrentLine();
    debug(DBGDUMP, 'cursorActivity(C): prevCnt (' + previousLineCnt + '):crntCnt (' + currentLineCnt + ')');
    if (previousLineCnt > currentLineCnt) {	// decreased
      // call delete line
      var diffLines = previousLineCnt - currentLineCnt;
      var targetDelLine = currentEditPos.line;
      if (currentEditPos.line > nextCursorPos.line) {
        if (diffLines == 1) {	// case of BS key or 1 line delete.
          // In the case of row deletion by the BS key,
          // the target line is the current line.
          if (editEventKey == EVENTKEY_BS) {	// BS key
            currentEditPos = nextCursorPos;	// for cursor position line update.
          } else {	// Other than BS key
            targetDelLine -= diffLines;		// adjust target line.
            // Set the row to be deleted to the current row. (To be updated)
            currentEditPos.line = targetDelLine;
          }
        } else {
          targetDelLine -= diffLines;		// adjust target line.
          // Set the row to be deleted to the current row. (To be updated)
          currentEditPos.line = targetDelLine;
        }
      } else if (currentEditPos.line == nextCursorPos.line) {
        // Cursor is on the same line.
        if (diffLines > 0) {
          // If the same line at the time of deletion,
          // The target line is the next line after the current line.
          targetDelLine = currentEditPos.line + 1;
        } else {
          debug(DBGWARN, 'Same line but diffLines eq 0.');
          targetDelLine = previousEditPos.line;
        }
      }
      if (originCommandString == ORIGINSTR_PASTE) {
        // Line has decreased in the Paste
        multiRowPaste(true, pasteSrcText);
        //originCommandString = "";
        previousLineCnt = currentLineCnt;
        //setModifiedText(false);
        return;
      }
      setModifiedText(true);	// Make changes
      deleteEditLines(getCurrentProgram(), targetDelLine + 1,	// Line number is from 1
        diffLines);	// api
      return;
    } else if (previousLineCnt < currentLineCnt) {	// Increased
      var targetLine = (originCommandString == ORIGINSTR_PASTE) ?
          currentEditPos.line : nextCursorPos.line;	// Paste does not move the cursor
      // Set up insert (add) row data.
      for (var i = 0; i < (currentLineCnt - previousLineCnt); i++) {
        var lineInfo = {};
        if ((targetLine + i + 1) < currentLineCnt) {
          if (originCommandString == ORIGINSTR_PASTE) {
            lineInfo.tgtRow = targetLine + i;	// Paste target row
            lineInfo.opt_sw = PRGWRITE_ADD;		// Write option 'add'.
            lineInfo.insData = cm.getLine(targetLine + i);//copiedEditLines[i];
          } else {
            lineInfo.tgtRow = targetLine + i + 1;	// Insert target row
            lineInfo.opt_sw = PRGWRITE_INS;		// Write option 'ins'.
            lineInfo.insData = cm.getLine(targetLine + i);
          }
        } else {	// Set the mode to "Add" and target the last line.
          lineInfo.tgtRow = targetLine + i;	// Line number to last line
          lineInfo.opt_sw = PRGWRITE_ADD;		// append new line data.
          lineInfo.insData = cm.getLine(targetLine + i);
        }
        lineInfo.datRow = targetLine + i;	// Data reference row
        lineInfo.origin = originCommandString;
        lineInfo.saved = false;
        InsertEditInfo.putLine(i, lineInfo);
      }
      // In the case of paste,
      // it is necessary to process by inserting from the beginning,
      // not by inserting after overwriting...
      if (originCommandString == ORIGINSTR_PASTE) {
        multiRowPaste(true, pasteSrcText);
        previousLineCnt = currentLineCnt;
      } else if (originCommandString == ORIGINSTR_MLTPAS) {
        //var pstSrc = PasteLineInfo.getSrcArray(); // return []
        //pasteSaveEditLine(currentEditPos.line, pstSrc[currentEditPos.line].mode);
        pasteSaveEditLine(currentEditPos.line, PRGWRITE_INS);
        //currentEditPos.line = 0; //mistake to initilize
        return;
      } else {
        saveEditLine();
      }
      return;
    }
    // When changing on the same line, save processing is not called.
    if (isModifiedText()) {
      // However, if pasted, it will be processed.
      if (originCommandString == ORIGINSTR_PASTE) {
        multiRowPaste(true, pasteSrcText);
        previousLineCnt = currentLineCnt;
        return;
      } else if (originCommandString == ORIGINSTR_MLTPAS) {
        //var pstSrc = PasteLineInfo.getSrcArray(); // return []
        //pasteSaveEditLine(currentEditPos.line, pstSrc[currentEditPos.line].mode);
        var pasteSrc = PasteLineInfo.getPasteSrc();
        pasteSaveEditLine(selTarget.startRow.line, pasteSrc.mode);
        //currentEditPos.line = 0; //mistake to initilize
        return;
      }
      if ((nextCursorPos.line != currentEditPos.line) && (isMyIFrameIdPrim())) {
        saveEditLine();
        return;
      }
    }
  }
  updateCursorPos();
  debug(DBGDUMP, 'cursorActivity(A): prevLine(' + previousEditPos.line + '):crntLine(' + currentEditPos.line + '):NextLine(' + nextCursorPos.line + ')');
  var lineText = cm.getLine(nextCursorPos.line);
  if (typeof lineText !== 'undefined') {
    if ((cm.getCursor().ch == lineText.length) && (!isWriteProtectWin())) {
      return watchChange(cm);
    }
  }
}
/* unfocus event */
function cmOnBlur(cm, event) {
  //tooltipOff('programarea');
  // when browser is IE and hint popup is displaying, cansel blur event.
  if (isIE) {
    if ($(".CodeMirror-hints").length !== 0) {
      event.preventDefault();
      event.stopPropagation();
      return;
    }
  }
  // a few wait for complete blur event process.
  setTimeout(function () {
    var crntFocus = document.activeElement;
    debug(DBGDUMP, 'Editor blur: current focus class:' + crntFocus.className);
    // current focus is Grid.
    if (crntFocus.className.startsWith('w2ui-grid')) {
      var ins = insertPosCommand(insertCommandStr);	// poswin
      if (ins) {  // if call insert process.
        if (event != undefined) {
          event.preventDefault();
          event.stopPropagation();
        }
        return false;
      }
    }
    // focus is back to editor
    if ($(crntFocus).parents().find('.CodeMirror').length > 0) {
      debug(DBGDUMP, 'Editor blur: current focus is CodeMirror');
      if (event != undefined) {
        event.preventDefault();
        event.stopPropagation();
      }
      return false;
    }
    saveFocusOut();
  }, 100);
}
/* focus event */
function cmOnFocus(cm, event) {
  document.body.style.cursor = 'text';
  blurSaveFlag = false;
}
/* Touch start event same as Mouse down... */
function cmOnTouchstart(cm, event) {
  if (!isMyIFrameIdPrim()) { // if program runnning, stop user operation...
    var reflectprog = JSON.parse(JSON.stringify(statusProgramInfoTrans.getCurrentProgramSI()));
    if (reflectprog.stat == WATCHEXEC_RUNNING) {
      event.preventDefault();
      event.stopPropagation();
      return;
    }
  }
}
/* Mouse down event */
function cmOnMousedown(cm, event) {
  if (!isMyIFrameIdPrim()) { // if program runnning, stop user operation...
    var reflectprog = JSON.parse(JSON.stringify(statusProgramInfoTrans.getCurrentProgramSI()));
    if (reflectprog.stat == WATCHEXEC_RUNNING) {
      event.preventDefault();
      event.stopPropagation();
      return;
    }
  }
}
/* resize... */
// When resizing, the cursor position will be shifted, so display it again.
function cmOnRefresh(cm) {
  if (isProgramAreaRefresh) {
    return;
  }
  debug(DBGDUMP, 'refresh!!');
  isProgramAreaRefresh = true;
  var cmDoc = cm.getDoc();
  var csrPos = cmDoc.getCursor();
  cm.save();
  var content = cmDoc.getValue();
  var currentModified = isProgramModified();
  cmDoc.setValue('');
  setTimeout(function () {	// To reflect the setting of the value
    cmDoc.setValue(content);
    if (!isExecuteProgram()) {	// Can not set cursor while running
      cm.focus();
      cmDoc.setCursor(csrPos);
    }
    var reflectprog = JSON.parse(JSON.stringify(statusProgramInfoTrans.getCurrentProgramSI()));
    if ((reflectprog.stat == WATCHEXEC_PAUSED) && (getCurrentProgram() == reflectprog.prog)) {
      getPcEditor().addLineClass(reflectprog.line - 1, "gutter", "CodeMirror-pause-number");
      debug(DBGDUMP, 'setLineNumVar: add gutter class to [' + reflectprog.line - 1 + '].');
    }
    setProgramModified(currentModified);
    isProgramAreaRefresh = false;
  }, 0);
}
function cmOnPaste(cm, event) {
  debug(DBGDUMP, ' paste is start');
  // The selection of the pasting destination range is downward
  if (cm.doc.sel.ranges[0].head.line < cm.doc.sel.ranges[0].anchor.line) {
    selTarget.startRow = cm.doc.sel.ranges[0].head;
    selTarget.endRow = cm.doc.sel.ranges[0].anchor;
  } else {	// If the selection of the pasting destination is upward
    selTarget.startRow = cm.doc.sel.ranges[0].anchor;
    selTarget.endRow = cm.doc.sel.ranges[0].head;
  }
  // Start column larger than end column...
  if (selTarget.startRow.ch > selTarget.endRow.ch) {
    // Replace start column and end column
    var ch = selTarget.startRow.ch
    selTarget.startRow.ch = selTarget.endRow.ch;
    selTarget.endRow.ch = ch;
  }
  // It checks whether the last line includes the line feed...
  var lastRowCh = cm.doc.getLine(selTarget.endRow.line).length;
  if ((selTarget.startRow.line != selTarget.endRow.line) &&	// Line is difference,
      ((selTarget.startRow.ch == 0) &&	// and start column is top of row,
        (selTarget.endRow.ch == 0))) {		// and end column is top of row
    selTarget.endRow.line = selTarget.endRow.line - 1;	// The last row is the previous row.
    lastRowCh = cm.doc.getLine(selTarget.endRow.line).length;
    selTarget.endRow.ch = lastRowCh;	// The last ch is the end of row.
  }
  // Calculate the number of rows in the selected range
  PasteLineInfo.setTargetLines((selTarget.endRow.line - selTarget.startRow.line) + 1);
  if (selTarget.endRow.line == selTarget.startRow.line) {	// cursor position is same line.
    if ((selTarget.startRow.ch == 0) && (selTarget.endRow.ch == 0)) {
      PasteLineInfo.setTargetLines(0);	// No range selection.
    }
  }
}

$(function () {
  $('#programarea').on('click', '#ctxSearch', function (event) {
    debug(DBGDUMP, 'context menu item: Find/Replace');
    $('#edtctxMenu').hide();
    $('#edtctxMenu').remove();
    getPcEditor().execCommand('find');
  });
  $('#programarea').on('click', '#ctxCopy', function (event) {
    debug(DBGDUMP, 'context menu item: Copy');
    $('#edtctxMenu').hide();
    $('#edtctxMenu').remove();
    sendKeyEventToBrowser('C', 67, false, true, false);
  });
  $('#programarea').on('click', '#ctxCut', function (event) {
    debug(DBGDUMP, 'context menu item: Cut');
    $('#edtctxMenu').hide();
    $('#edtctxMenu').remove();
    sendKeyEventToBrowser('X', 88, false, true, false);
  });
  $('#programarea').on('click', '#ctxPaste', function (event) {
    debug(DBGDUMP, 'context menu item: Paste');
    $('#edtctxMenu').hide();
    $('#edtctxMenu').remove();
    getPcEditor().execCommand('paste');
    sendKeyEventToBrowser('V', 86, false, true, false);
  });
  $('#programarea').on('click', '#ctxSelectAll', function (event) {
    debug(DBGDUMP, 'context menu item: Select All');
    $('#edtctxMenu').hide();
    $('#edtctxMenu').remove();
    getPcEditor().execCommand('selectAll');
  });
});

/**
 * Draw Program to Edit window
 */
var initCursorPos = { line: 0, ch: 0 };
function drawProgramText(programText) {
  debug(DBGDUMP, 'Pass: drawProgramText()');
  var pcEdt = getPcEditor();
  var cmDoc = pcEdt.getDoc();
  cmDoc.setValue('');
  cmDoc.clearHistory();
  cmDoc.clearGutter();
  pcEdt.save();
  cmDoc.setValue(programText);
  if (programText == '') {
    setNewEditProgram(true);
  }
  // Cursor initial position set to end of line.
  //var linecount = cmDoc.lineCount();
  //cmDoc.setCursor({line: linecount, ch: 0});
  // Cursor initial position set to saved line.
  if (!EditScrollPosInfo.isEmptyPos()) {	// if exist scroll position info.
    if (EditScrollPosInfo.getPos().top > 0) {	// set scroll position to editor.
      pcEdt.scrollTo(0, EditScrollPosInfo.getPos().top);
      EditScrollPosInfo.init();	// initialize...
    }
  }
  if (getWatchExecValue() == 0) {	// If the program is running, do not set the cursor.
    pcEdt.focus();
  }
  if (pasteCursorPos != 0) {  // What is this doing???
    if (pcEdt.display.renderedView[initCursorPos.line] != undefined) {
      var pasCursorData = pcEdt.display.renderedView[initCursorPos.line].line.text;
      initCursorPos.ch = pasCursorData.length;
    }
    pasteCursorPos = 0;
  }
  beforeCusStaPos = currentEditPos;
  currentEditPos = initCursorPos;
  previousEditPos = initCursorPos;
  nextCursorPos = initCursorPos;
  currentLineCnt = cmDoc.lineCount();
  previousLineCnt = currentLineCnt;
  setRowErrorOccurring(false);
  setProgramModified(false);
  setPositionModified(false);
  resetTempModified();
  setModifiedText(false);
  cmDoc.setCursor(initCursorPos);
}
// Change exec program text.
function changeProgramText(programText) {
  debug(DBGDUMP, 'Pass: changeProgramText()=' + getCurrentProgram());
  var cmObj = getPcEditor();
  var cmDoc = cmObj.getDoc();
  setSwitchingProgram(true);  // for change.cancel () in beforeChange pass through.
  cmDoc.setValue(programText);  // Set text to editor area
  cmDoc.clearHistory();
  if (EditScrollPosInfo.getPos().top > 0) {	// set scroll position to editor.
    cmObj.scrollTo(0, EditScrollPosInfo.getPos().top);
    EditScrollPosInfo.init();	// initialize...
  }
  setSwitchingProgram(false);
  // Initialize each data.
  beforeCusStaPos = currentEditPos;
  currentEditPos = initCursorPos;
  previousEditPos = initCursorPos;
  nextCursorPos = initCursorPos;
  currentLineCnt = cmDoc.lineCount();
  previousLineCnt = currentLineCnt;
  setRowErrorOccurring(false);
  setProgramModified(false);
  setPositionModified(false);
  resetTempModified();
  setModifiedText(false);
}

/**
 * Show 'Hint box' when change(input key) editor window.
 *
 */

function watchChange(cm) {
  return CodeMirror.showHint(cm, function () {
    // Build hint table.
    var cur = cm.getCursor();
    var token = cm.getTokenAt(cur);
    var start = token.start;
    var end = token.end;
    var from = CodeMirror.Pos(cur.line, start);
    var to = CodeMirror.Pos(cur.line, end);
    var upStr = token.string.toUpperCase();
    var upChar = upStr.charAt(0);
    var lineStr = getEditorDoc().getLine(cur.line);
    var aclist = getAutoCompTextList(upChar); // cmdwin
    if ((aclist != undefined) && (aclist.length > 0)) {
      var stLeng = upStr.length; // Correspond to multiple characters
      var sglist = [];
      var c = 0;
      if (aclist.length >= 1) {
        for (var i = 0; i < aclist.length; i++) { // for list count
          if (aclist[i].length >= stLeng) { // List data is longer than command
            var j = 0;
            var targetItem = aclist[i].toUpperCase();
            for (; j < stLeng; j++) { // Repeat for the number of characters
              if (upStr[j] != targetItem[j]) { // Not match...
                break;
              }
            }
            if (j == stLeng) { // Matches for characters
              sglist[c] = aclist[i]; // Add to list
              c++;
            }
          }
        }
        if (typeof lineStr !== 'undefined') {
          switchPltBtn(lineStr);
        }
        return {
          list: sglist,
          completeSingle: false,
          from: from,
          to: to
        };
      }
    }
    return undefined;
  }, {
    completeSingle: false
  });
}

/**
 * Get Program Text data.
 **/
function getAllProgramText() {
  var textall = getEditorDoc().getValue();
  return textall;
}

/**
 * Callback function of program modify time.
 * Check modify time and confirm overwrite.
 * status : 0=success, other=error
 * progName : Program name
 * varName : Variable name
 * modifyTime : Modified string
 */
var prodModifyTime = '';
var progModifyTime = '';
var progCreateTime = '';
function checkProgramModify(status, progName, varName, modifyTime) {
  debug(DBGDUMP, 'Product(' + progName + ') Modify time is [' + modifyTime + ']');
  // Compare modified time
  // Modified time is over, confirm overwright.
  prodModifyTime = modifyTime;
  debug(DBGDUMP, 'Program: Modify time[' + progModifyTime + ']/Create time[' + progCreateTime + ']');
  //if (prodModifyTime > progModifyTime) {
  if (prodModifyTime > progCreateTime) {
    // Confirm overwrite
    var btnObj = {
      btnData : top.irpDlgBtnYN,
      btn1Cb : overwriteProgram,
      btn2Cb : reConfDiscardChg
    };
    top.openCmpConfirm(webPage, window, 'confovwrdlg', resources['dlgMsgOverwrProg'], btnObj, true);  // This program is edited in other than this editor.
  } else {
    if (isScrModeProgAttr()) {
      programNonSelection(progName);
    } else {
      composeProgramFile();	// fileio
    }
  }
}
function overwriteProgram(saveParam) {  // save changes made by this editor
  debug(DBGDUMP, 'overwriteProgram');
  if (holdingTransmitInfo == null) {	// if already set action (ex:rename), not set.
    holdingTransmitInfo = new TransProgramInfo();
    holdingTransmitInfo.progName = saveParam.selprog;
    holdingTransmitInfo.afterProc = saveParam.aftersave;
  }
  if (isScrModeProgAttr()) {
    actionAfterSaving = saveParam;
    programNonSelection(getCurrentProgram());
  } else {
    composeProgramFile();	// fileio 
  }
}
// reconfirm discard changes...
function reConfDiscardChg(saveParam) {
  var callbackFnc = function(){};
  if (isScrModeProgAttr()) {
    callbackFnc = initFlag;
  }
  var btnObj = { 
    btnData : top.irpDlgBtnYN,
    btn1Cb  : discardChangeProg,
    btn2Cb  : callbackFnc
  };
  top.openCmpConfirm(webPage, window, 'reconfdiscard', resources['dlgMsgDiscChg'], btnObj, true);
}
// This program is edited in other than this editor.
// Are you sure you want to discard changes made by this editor?
function discardChangeProg(saveParam) {
  // remove edit file and reload program.
  discardEditProgram(getTempProgName(getCurrentProgram()));	// api
}
function tempFileDiscarded(progName) {
  debug(DBGDUMP, 'tempFileDiscarded: reset modified flag and reload program.');
  removeEditProgramFile(getTempProgName(progName));	// remove edit program name from list
  setProgramModified(false);	// reset modified flag
  setPositionModified(false);
  resetTempModified();	// [add] Reset temporary modify flag for dialog cancel.
  if (!(isScrModeProgAttr())) {
    saveSuccessProc();
  }
  // Set Trans info
  if (holdingTransmitInfo.afterProc == AFTERPROC_EDITATTR) {
    holdingTransmitInfo.progName = getProdProgName(getCurrentProgram());
  } else if ((isScrModeProgAttr()) && (holdingTransmitInfo.afterProc == AFTERPROC_OPENPROG)) {
    var pgName = getSelectProgram();
    chgProg(pgName, jmpEditPage);
  }
  holdingTransmitInfo.modifyTime = true;
  // Reload...
  reloadProgramFile(getProdProgName(getCurrentProgram()), reloadPrgCallback);	// fileio
}
function renameReloadedProgram(status, progName) {
  renameProgram(getProdProgName(progName), holdingTransmitInfo.progName);	// Rename process. api
  holdingTransmitInfo = null;
}
/**
 * caution delete edit program. (Call from dialog)
 * (The changes is discarded.)(When open program or create.)
 */
function cautionDelProgram(saveParam) {
  // remove edit file and reload program.
  cautionEditProgram(getTempProgName(getCurrentProgram()));	// api
}
function cancelCautionDele(saveParam) {
  holdingTransmitInfo = null;
  if (isScrModeProgAttr()) initFlag();
}
function tempFileCaution(progName) {
  debug(DBGDUMP, 'tempFileCaution: reset modified flag and reload program.');
  removeEditProgramFile(getTempProgName(progName));	// remove edit program name from list
  setProgramModified(false);	// reset modified flag
  setPositionModified(false);
  resetTempModified();	// [add] Reset temporary modify flag for dialog cancel.
  saveSuccessProc();
  // To reconfirm that there is no * file.
  if (isScrModeProgAttr()) {
    modifiAster = false;
    getProgramText(progName, GETPROG_TEMP, chgSaveBtnCallback);
  }
  // Reload...
  if (holdingTransmitInfo == null) {
    debug(DBGERROR, 'Illegal transInfo:progName=' + progName);
  }
  reloadProgramFile(getProdProgName(getCurrentProgram()), reloadPrgCallback);	// fileio
}

/**
 * Program save process. (Call from dialog)
 */
var actionAfterSaving = null;
function saveProgram(saveParam) {
  // Save program...
  debug(DBGINFO, 'Save current program');
  if (!(isScrModeProgAttr())) {
    getPcEditor().save();	// Reflect on text area
  }
  // Compose and save mnemonic and position and etc...
  holdingTransmitInfo = new TransProgramInfo();
  holdingTransmitInfo.progName = saveParam.selprog;
  holdingTransmitInfo.afterProc = saveParam.aftersave;
  holdingTransmitInfo.modifyTime = true;
  if (isScrModeProgAttr()) {
    actionAfterSaving = saveParam;
    return;
  }
  //setProgramModified(false);	// reset modified flag
  //setPositionModified(false);
  if (isExistEditProgramFile(getTempProgName(getCurrentProgram()))) {
    getModifyTime(getProdProgName(getCurrentProgram()), checkProgramModify);
  } else {
    composeProgramFile();	// fileio call after check modify time.
  }
}
function beforeSaveAsProgram(saveParam) {
  // Check already exist...
  if ((inProgramList(saveParam.progname) >= 0) ||
    (inKarelProgramList(saveParam.progname) >= 0) ||
    (saveParam.progname == getMoveProgPrim())) { // exist
    // disp alart and exit
    top.openCmpConfirm(webPage, window, 'confalertdlg', resources['dlgMsgExistProg'], {btnData:{btn1:top.irpDlgBtnOC.btn1}}, true);
    return;
  }
	/* ===
	  No save...
	// Save program...
	debug(DBGINFO, 'Save As current program');
	holdingTransmitInfo = new TransProgramInfo();
	holdingTransmitInfo.progName = saveParam.selprog;
	holdingTransmitInfo.afterProc = saveParam.aftersave;
	if ((isProgramModified()) || (isPositionModified())) {	// If modified, save and save as process.
		getPcEditor().save();	// Reflect on text area
		// Compose and save mnemonic and position and etc...
		composeProgramFile();	// fileio
		return;
	}
  === */
  var crntPGName;
  var savePGname = saveParam.progname;
  if (isScrModeProgAttr()) {
    if (isExistEditProgramFile(getTempProgName(getSelectProgram()))) {	// exist edit file, use one.
      crntPGName = getTempProgName(getSelectProgram());
      var cbArg = {};
      cbArg.func = selRenameSaveASCB;
      originSaveAsName = crntPGName;
      renamePrg(crntPGName, savePGname, renameSaveAsCB, cbArg);
    } else {
      crntPGName = getProdProgName(getSelectProgram());
      var cbArg = {};
      cbArg.func = isExistSelProg;
      cbArg.saveName = savePGname;
      cbArg.targetProc = crntPGName;
      dispOnWaiting();
      chgProg(crntPGName, waitChgProgComplete, cbArg);
    }
  } else {
    if (isModifiedText()) {  // no temp LS saveAs
      beforeTempSave(getCurrentProgram(), saveParam);
    } else {
      if (isExistEditProgramFile(getTempProgName(getCurrentProgram()))) {	// exist edit file, use one.
        crntPGName = getTempProgName(getCurrentProgram());
        var cbArg = {};
        cbArg.func = selRenameSaveASCB;
        originSaveAsName = crntPGName;
        renamePrg(crntPGName, savePGname, renameSaveAsCB, cbArg);
      } else {
        crntPGName = getProdProgName(getCurrentProgram());
        saveAsProgram(crntPGName, savePGname);	// Save as process. api
      }
    }
  }
}
function isExistSelProg(status, progName, cbArg) {
  dispOffWaiting();
  if (status == IOSTAT_MEMO_073) {
    var btnObj = {
      btnData :{ btn1 : top.irpDlgBtnOC.btn1 },
      btn1Cb  : refleshProgList
    };
    top.openCmpConfirm(webPage, window, 'alreadydelerrdlg', resources['dlgMsgAlreadyDelError'], btnObj, true);
    return;
  } else {
    saveAsProgram(cbArg.targetProc, cbArg.saveName);	// Save as process. api
  }
}
function beforeTempSave(programName, saveParam) {
  if (isModifiedText()) { 
    saveEditLine();
    saveEditLineTimer = setTimeout(function () {
      waitSaveAsEditLine(programName, saveParam);
    }, 50); // Keep a interval
  } else {
    putbeforSaveasProgPos(programName, saveParam)
  }
}
function beforeRenameProgram(saveParam) {
  // Check already exist...
  if ((inProgramList(saveParam.progname) >= 0) ||
    (inKarelProgramList(saveParam.progname) >= 0) ||
    (saveParam.progname == getMoveProgPrim())) { // exist
    // disp alart and exit
    top.openCmpConfirm(webPage, window, 'confalertdlg', resources['dlgMsgExistProg'], { btnData : {btn1 : top.irpDlgBtnOC.btn1 }}, true);
    return;
  }
  // Save program...
  debug(DBGINFO, 'Rename current program');
  holdingTransmitInfo = new TransProgramInfo();
  holdingTransmitInfo.progName = saveParam.progname;
  holdingTransmitInfo.afterProc = saveParam.aftersave;
  //if ((isProgramModified()) || (isPositionModified())) {	// If modified, save and rename process.
  //	getPcEditor().save();	// Reflect on text area
  //	// Compose and save mnemonic and position and etc...
  //	composeProgramFile();	// fileio
  //	return;
  //}
  if (isModifiedText() || isPositionModified()) {  // no temp LS saveAs
    beforeRenameTempSave(getCurrentProgram(), saveParam);
  }
  renameProgram(getProdProgName(getCurrentProgram()), saveParam.progname);	// Rename process. api
}
function beforeRenameTempSave(programName, saveParam) {
  if (isModifiedText()) {
    saveEditLine();
    saveEditLineTimer = setTimeout(function () {
      waitRenameEditLine(programName, saveParam);
    }, 50); // Keep a interval
  } else {
    putbeforSaveasProgPos(programName, saveParam)
  }
}
// call when error has occured.
var isUndoExecution = false;
function saveEditError(saveParam) {
  issaveeditline = false;
  setReadOnly(false);
  setRowErrorOccurring(true);
  if (InsertEditInfo.isExistLines()) {
    isUndoExecution = true;
    getEditorDoc().undo();
    isUndoExecution = false;
    updateCurrentLine();
    previousLineCnt = currentLineCnt;
    setModifiedText(true);	// for enable cursor key
    if (InsertEditInfo.isExistLines()) {
      // Rollback saved lines...
      var undoTarget = InsertEditInfo.getLine(0).tgtRow;
      var undoLines = 0;
      for (var i = 0; i < InsertEditInfo.getLength(); i++) {
        if (InsertEditInfo.getLine(0).saved) {
          undoLines++;
        }
      }
      if (undoLines > 0) {
        // [10/27/2017] For now, Rollback correspondence will be put on hold.
        //deleteEditLines(getCurrentProgram(), undoTarget, undoLines);	// api
      }
    }
  } else {
    // At the time of deletion, not the previous line but the current line
    if (originCommandString != ORIGINSTR_PDEL) {
      currentEditPos = previousEditPos;
    }
    initCursorPos = currentEditPos;
  }
  getPcEditor().focus();
  getEditorDoc().setCursor(currentEditPos);
  InsertEditInfo.init();
  copiedEditLines.length = 0;
  if (saveReplaceInfo.replace) {
    debug(DBGDUMP, 'saveReplace Error: rsult=[' + RESULTERROR + ']');
    saveReplaceInfo.replace = false;
    saveReplaceInfo.cbArgs.result = RESULTERROR;
    if (saveReplaceInfo.callback != undefined) {
      saveReplaceInfo.callback(saveReplaceInfo.cbArgs);
    }
  }
}
// call when paste error has occured.
function savePasteError(saveParam) {
  issaveeditline = false;
  setReadOnly(false);
  setRowErrorOccurring(true);
  // At the time of deletion, not the previous line but the current line
  initCursorPos = currentEditPos;
  if ((originCommandString == ORIGINSTR_MLTPAS) ||	// Row deletion occurs in the editor.
      (originCommandString == ORIGINSTR_RNGPST)) {	// Undo delete process.
    isUndoExecution = true;
    getEditorDoc().undo();
    isUndoExecution = false;
    updateCurrentLine();
    previousLineCnt = currentLineCnt;
    setModifiedText(true);	// for enable cursor key
  } else {
    if (holdingTransmitInfo == null) {
      holdingTransmitInfo = new TransProgramInfo();
    }
    holdingTransmitInfo.modifyTime = true;
    reloadProgramFile(getTempProgName(getCurrentProgram()), reloadPrgCallback);	// fileio
  }
  getPcEditor().focus();
  if (pasteCursorPos != 0) {
    currentEditPos.line = afterPastePos.line - 1;
    currentEditPos.ch = afterPastePos.ch;
    pasteCursorPos = 0;
  }
  getEditorDoc().setCursor(currentEditPos);
  InsertEditInfo.init();
  copiedEditLines.length = 0;
}

// Multi row paste error: Range select middle of line.
// Resume cursor.
function multiRowPasteErr(saveParam) {
  getPcEditor().focus();
  getEditorDoc().setCursor(currentEditPos);
  setReadOnly(false);
}

/**
 * multiple lines paste . (call from beforechange)
 */
var savePasteSource = {};
// need to cursor position after pasted
var afterPastePos = {};
var pasteCursorPos = 0;
//
function multiRowPaste(isFirst, pasteSrc) {
  if (isFirst) {	// 1st time call.
    // If on edit, at first save program.
    if (isModifiedText()) {
      savePasteSource = pasteSrc;
      preProcPstLine();
      return;
    }
    // Save destination row info.
    var dstInfo = {};
    dstInfo.startRow = selTarget.startRow.line + 1;	// Codemirror row num to I/F row num.
    dstInfo.endRow = selTarget.endRow.line + 1;
    dstInfo.startCh = selTarget.startRow.ch;
    dstInfo.endCh = selTarget.endRow.ch;
    PasteLineInfo.setDstInfo(dstInfo);
    lastLineData = getEditorDoc().getLine(selTarget.endRow.line);
    lastLineCh = lastLineData.length;
    var lastChLength = lastLineData.replace(/\s+/g, "").length;
    if (lastChLength == 0) { // if empty row data , cursor position is head of row.
      dstInfo.startCh = 0;
      dstInfo.endCh = 0;
      PasteLineInfo.setDstInfo(dstInfo);
    }
    // chech start row data
    var pstSrcArray = [];	// Reset copy(paste source) data.
    // Make paste line info.
    for (var c = 0; c < pasteSrc.length; c++) {
      var pasteElem = {};
      if ((c + 1) < pasteSrc.length) {	// Middle row.
        pasteElem.str = pasteSrc[c] + CODECRLF;	// append CRLF
      } else {	// Last row.
        pasteElem.str = pasteSrc[c];	// as is
      }
      pasteElem.tgtRow = selTarget.startRow.line + c;	// add for row offset.
      pasteElem.wtmode = PRGWRITE_ADD;	// Paste data always add to row.
      if ((c == 0) && (selTarget.startRow.line == 0)) {	// Target is top of program,
        pasteElem.tgtRow++;		// Specify line number,
        pasteElem.wtmode = PRGWRITE_INS;	// and Insert mode.
      }
      pasteElem.origin = (pasteElem.str.indexOf(CODECRLF) < 0) ? '' : ORIGINSTR_MLTPAS;
      var crlfPos = pasteElem.str.indexOf(CODECRLF);
      if (crlfPos > 0) {
        pasteElem.str = pasteElem.str.substr(0, crlfPos);
      }
      pstSrcArray[c] = pasteElem;
    }
    // Adjust paste source data.
    // The line data of the last line is empty. valid row is previous row.
    if (pstSrcArray[pstSrcArray.length - 1].str.length == 0) {
      pstSrcArray.pop();	// Delete last (empty) line.
    }
    PasteLineInfo.setSrcLine(0);
    PasteLineInfo.setSrcArray(pstSrcArray);
    // Current edit position set to target row.
    currentEditPos = { line: selTarget.startRow.line, ch: selTarget.startRow.ch };
    setReadOnly(true);
    issaveeditline = true;
  }
  var pstDstInfo = PasteLineInfo.getDstInfo();
  var pstSrcLength = PasteLineInfo.getSrcArrayLength();
  var pstTargetLines = PasteLineInfo.getTargetLines();
  // Check whether the range selection is valid.
  if ((pstSrcLength > 1) || (pstTargetLines > 1)) {	// Multiple lines exist or target range exist.
    if ((pstDstInfo.startCh != 0) || 	// Start character is middle of row and end character is middle of row.
        ((pstDstInfo.endCh != 0) && (pstDstInfo.endCh != lastLineCh))) {
      defineDialog.open(null, '#mltpastedlg', 'dlgMsgMltPaste');
      return;
    }
  }
  var pasteElement = PasteLineInfo.getPasteSrc(); // srcArray[srcLine];
  // Copy source deta 1 line
  if ((pstSrcLength == 1)) {  // Paste target line is 1(same line).
    if (pstTargetLines <= 1) {
      debug(DBGDUMP, 'multiRowPaste: replace copy data to cursor position');
      if (pasteElement.str.indexOf(CODECRLF) > 0) {	// if terminate CRLF
        pasteElement.str = pasteElement.str.replace(CODECRLF, '');	// trim CRLF
      }
      pasteElement.origin = ORIGINSTR_RNGPST;
      selAreaPaste(currentEditPos.line, currentEditPos.line, pasteElement, pstDstInfo);
      /* not use this step (maybe use next step)
			if ((pstDstInfo.endCh == lastLineCh) || 	// Select range is top to end
				((pstDstInfo.startCh == 0) && (pstDstInfo.endCh == 0))) { 	// or top of row.
				if (pstTargetLines > 1) {	// select multi lines.
					if (pasteElement.str.indexOf(CODECRLF) > 0 ) {	// if terminate CRLF
						pasteElement.str = pasteElement.str.replace(CODECRLF, '');	// trim CRLF
					}
					pasteElement.origin = ORIGINSTR_RNGPST;
				}
				selAreaPaste(selTarget.startRow.line, selTarget.endRow.line, pasteElement, pstDstInfo);
			}
			*/
    } else {
      var apiPasteStr = pasteElement.str;
      updateMultiLine(apiPasteStr, pasteElement.tgtRow, pasteElement.wtmode);
    }
  } else if ((pstSrcLength > 1) && (PasteLineInfo.getSrcLine() < pstSrcLength)) {
    // Paste multiple lines.
    if (pstDstInfo.startRow == pstDstInfo.endRow) {
      if (((pstDstInfo.startCh == 0) && (pstDstInfo.endCh == 0)) ||
          ((pstDstInfo.startCh == 0) && (pstDstInfo.endCh == lastLineCh))) {
        // Target is same(one) line, and colum position is top of line.
        var apiPasteStr = pasteElement.str;
        updateMultiLine(apiPasteStr, pasteElement.tgtRow, pasteElement.wtmode);	// api
      }
    } else if (pstDstInfo.startRow != pstDstInfo.endRow) {
      if (((pstDstInfo.startCh == 0) && (pstDstInfo.endCh == 0)) ||
          ((pstDstInfo.startCh == 0) && (pstDstInfo.endCh == lastLineCh))) {
        var apiPasteStr = pasteElement.str;
        updateMultiLine(apiPasteStr, pasteElement.tgtRow, pasteElement.wtmode);  // api
      }
    }
  } else {
    defineDialog.open(null, '#mltpastedlg', 'dlgMsgMltPaste');
    return;
  }
	/*
	else if ((pstSrcLength > 1) && (PasteLineInfo.getSrcLine() < PasteLineInfo.getTargetLines())){
		var diffLines = PasteLineInfo.getTargetLines() - PasteLineInfo.getSrcLine();
		deleteEditLines(getCurrentProgram(), pstDstInfo.startRow + PasteLineInfo.getSrcLine(), diffLines);	// api
	}
	*/
}
/**
 * only use cursor position paste.
 */
function selAreaPaste(startRow, endRow, pasteElement, pstDstInfo) {
  var editor = getPcEditor();
  var csrLine = editor.getCursor().line;
  var csrChar = editor.getCursor().ch;
  editor.replaceRange(pasteElement.str,
    CodeMirror.Pos(startRow, pstDstInfo.startCh), CodeMirror.Pos(endRow, pstDstInfo.endCh),
    pasteElement.origin);
  // focus set to editor
  csrChar += pasteElement.str.length;	// Cursor move to end of command string.
  editor.focus();
  editor.setCursor({ line: startRow, ch: csrChar });
  issaveeditline = false;
  setReadOnly(false);
}

function saveSuccessProc() {
  if (!(isScrModeProgAttr())) {
    issaveeditline = false;
    setReadOnly(false);
  }
  setNewEditProgram(false);
  setRowErrorOccurring(false);
  if (!(isScrModeProgAttr())) {
    updateCurrentLine();
    previousLineCnt = currentLineCnt;
    setModifiedText(false);
    // set cursor position.
    updateCursorPos();
  }
  dispOffWaiting();	// Just in case.
  if ((!(isScrModeProgAttr())) && (saveReplaceInfo.replace)) {
    debug(DBGDUMP, 'saveReplace Success: rsult=[' + RESULTNORMAL + ']');
    saveReplaceInfo.replace = false;
    saveReplaceInfo.cbArgs.result = RESULTNORMAL;
    if (saveReplaceInfo.callback != undefined) {
      saveReplaceInfo.callback(saveReplaceInfo.cbArgs);
    }
  }
}
function saveSuccessPrePaste() {
  multiRowPaste(true, savePasteSource);
}
function getSaveasModifyCallback(status, progName, varName, modifyTime) {
  debug(DBGDUMP, 'SaveAs(' + progName + ') modify time is [' + modifyTime + ']');
  progModifyTime = modifyTime;	// prgwin
  getFileAttribute(progName, EDITATTRMODE_SAVEAS, afterGetFileAttribute);	// api (fileio)
}
function saveAsSuccessProc(prevProg, specProg) {
  if (isScrModeProgAttr()) {
    $('#progNameText').text(specProg);
    setSelectProgram(specProg);
  } else {
    issaveeditline = false;
    setReadOnly(false);
    //setNewEditProgram(false);	// Information that is a new creation program is keep.
    setRowErrorOccurring(false);
    setModifiedText(false);
    setProgramModified(false);	// reset modified flag
    setPositionModified(false);
    resetTempModified();
    setProgramNameValue(specProg);
  }
  // Append to list with prevProg type.
  var progItem = {};
  progItem.name = specProg;
  progItem.type = getProgramType(getProdProgName(prevProg));
  programFileList[programFileList.length] = progItem;
  sortProgramList();
  setCurrentProgram(specProg);
  if (isScrModeProgAttr()) {
    getFileAttribute(specProg, EDITATTRMODE_SAVEAS, afterGetFileAttribute);
    revertCurrentProg();
  } else {
    var progInfo = ProgramInfoManager.getCurrentProgInfo();
    progInfo.changeProgName(specProg);  // update program name
    getModifyTime(specProg, getSaveasModifyCallback);
  }
}
function renameSaveAsSuccessProc(prevProg, specProg) {
  if (isScrModeProgAttr()) {
    $('#progNameText').text(specProg);
    setSelectProgram(specProg);
  } else {
    issaveeditline = false;
    setReadOnly(false);
    //setNewEditProgram(false);	// Information that is a new creation program is keep.
    setRowErrorOccurring(false);
    setModifiedText(false);
    setProgramModified(false);	// reset modified flag
    setPositionModified(false);
    resetTempModified();
    setProgramNameValue(specProg);
  }
  // Overwrite name to prevProg index.
  var newProg = {};
  newProg.name = specProg;
  newProg.type = getProgramType(getProdProgName(prevProg));
  programFileList[programFileList.length] = newProg;
  //replaceEditProgramFile(getProdProgName(prevProg), specProg);
  setCurrentProgram(specProg);
  if (isScrModeProgAttr()) {
    sortProgramList();
    drawProgramList();
    getProgramText(specProg, 1, chgSaveBtnCallback);
    revertCurrentProg();
  } else {
    removeEditProgramFile(prevProg);
    getModifyTime(specProg, getRenameModifyCallback);
  }
  var progInfo = ProgramInfoManager.getCurrentProgInfo();
  progInfo.changeProgName(specProg);  // update program name
}
function getRenameModifyCallback(status, progName, varName, modifyTime) {
  debug(DBGDUMP, 'Rename(' + progName + ') modify time is [' + modifyTime + ']');
  progModifyTime = modifyTime;	// prgwin
}
function renameSuccessProc(prevProg, specProg) {
  if (isScrModeProgAttr()) {
    $('#progNameText').text(specProg);
    setSelectProgram(specProg);
  } else {
    issaveeditline = false;
    setReadOnly(false);
    //setNewEditProgram(false);	// Information that is a new creation program is keep.
    setRowErrorOccurring(false);
    setModifiedText(false);
    setProgramNameValue(specProg);
  }
  // Overwrite name to prevProg index.
  var progIndex = inProgramList(getProdProgName(prevProg));
  programFileList[progIndex].name = specProg;
  sortProgramList();
  replaceEditProgramFile(getProdProgName(prevProg), specProg);
  setCurrentProgram(specProg);
  if (isScrModeProgAttr()) {
    drawProgramList();
    revertCurrentProg();
  } else {
    reloadMultiScreenProg(specProg, true);
    getModifyTime(specProg, getRenameModifyCallback);
  }
  var progInfo = ProgramInfoManager.getCurrentProgInfo();
  progInfo.changeProgName(specProg);  // update program name
}

// for multiple lines paste
function pasteSuccessProc() {
  issaveeditline = false;
  setReadOnly(false);
  setNewEditProgram(false);
  setRowErrorOccurring(false);
  updateCurrentLine();
  previousLineCnt = currentLineCnt;
  setModifiedText(false);
  currentEditPos.line = 0;
  var pstDstInfo = PasteLineInfo.getDstInfo();
  initCursorPos.line = pstDstInfo.startRow - 1;
  initCursorPos.ch = pstDstInfo.startCh;
  if (pasteCursorPos != 0) {
    initCursorPos.line = afterPastePos.line - 1;
    //initCursorPos.ch = afterPastePos.ch;
  }
  if (holdingTransmitInfo == null) {
    holdingTransmitInfo = new TransProgramInfo();
  }
  holdingTransmitInfo.modifyTime = true;
  reloadProgramFile(getTempProgName(getCurrentProgram()), reloadPrgCallback);	// fileio
  // set cursor position.
  //updateCursorPos();
}
// Display current program name to program name area.
function setProgramNameValue(progname) {
  if (isScrModeEditorTab()) {
    $('#programname').text(progname); // to span tag
  } else {
    $('#programname').val(progname);  // to input tag
  }
}
// Set(Copy) HoldingTransmitInfo object for multi screen
function setTransmitInfo(transInfoObj) {
  if (holdingTransmitInfo == null) {
    holdingTransmitInfo = new TransProgramInfo();
  }
  holdingTransmitInfo.progName = transInfoObj.progName;
}
// Reload program file on Multi screen
function reloadMultiScreenProg(targetProg, forced) {
  if (existDualIFrame()) {	// Call target iFrame prgwin function
    var windowDual = getSpecifiedIFrame(IFRAMEID_DUAL)[0].contentWindow;
    var dualScrnProg = windowDual.getCurrentProgram();
    if ((dualScrnProg == targetProg) || (forced)) {
      windowDual.setCurrentProgram(targetProg);
      windowDual.setProgramNameValue(targetProg);
      windowDual.setTransmitInfo(holdingTransmitInfo);
      windowDual.reloadProgramFile(targetProg, windowDual.reloadPrgCallback);	// fileio
    }
  }
  if (existThirdIFrame()) {	// Call target iFrame prgwin function
    var windowThird = getSpecifiedIFrame(IFRAMEID_THIRD)[0].contentWindow;
    var thirdScrnProg = windowThird.getCurrentProgram();
    if ((thirdScrnProg == targetProg) || (forced)) {
      windowThird.setCurrentProgram(targetProg);
      windowThird.setProgramNameValue(targetProg);
      windowThird.setTransmitInfo(holdingTransmitInfo);
      windowThird.reloadProgramFile(targetProg, windowThird.reloadPrgCallback);	// fileio
    }
  }
}
// Processing when the saving process is successful.
function saveProgramSuccess() {
  debug(DBGDUMP, 'saveProgramSuccess: reset modified flag and action after process.');
  setProgramModified(false);	// reset modified flag
  setPositionModified(false);
  resetTempModified();	// [add] Reset temporary modify flag for dialog cancel.
  if (isScrModeProgAttr()) {
    // Action after saving exists.
    if (holdingTransmitInfo != null) {
      var afterProc = holdingTransmitInfo.afterProc;
      if (afterProc == AFTERPROC_NEWOPEN) {
        openNewProgramProgattr();	// Save when newly created
      } else if (afterProc == AFTERPROC_SELPROG) {
        openSelectProgram();
        //selectProgram(actionAfterSaving);	// Save when list is selected
      } else if (afterProc == AFTERPROC_RUNPROG) {
        // On request, to reload the program before execution.
        holdingTransmitInfo.modifyTime = false;
        reloadProgramFile(getProdProgName(getCurrentProgram()), reloadPrgCallback);	// fileio
      } else if (afterProc == AFTERPROC_SAVEASPG) {
        saveAsProgram(getProdProgName(getCurrentProgram()), holdingTransmitInfo.progName);	// Save as process. api
      } else if (afterProc == AFTERPROC_RENAMEPG) {
        renameProgram(getProdProgName(getCurrentProgram()), holdingTransmitInfo.progName);	// Rename process. api
      } else if (afterProc == AFTERPROC_EDITATTR) {
        top.openCmpPupAppendFrm(window, '/frh/jcgtp/editattrdlg.stm', null, resources['toolBtnAttribute'], true, { width: "600px", height: "600px"});		// Get program attribute
      } else if (afterProc == AFTERPROC_OPENPROG) {
        modifiAster = false;
        if (isMyIFrameIdPrim()) {
          chgProg(getSelectProgram(), jmpEditPage);
        } else {
          jmpEditPage();
        }
      } else if (afterProc == AFTERPROC_NEWPROG) {
        modifiAster = false;
        // To reconfirm that there is no * file.
        getProgramText(getSelectProgram(), GETPROG_TEMP, chgSaveBtnCallback);
        defineDialog.open('#filenew', '#getprogdlg', '');	// Get program name
      } else if (afterProc == 'saveTab') {
        modifiAster = false;
        // To reconfirm that there is no * file.
        getProgramText(getSelectProgram(), GETPROG_TEMP, chgSaveBtnCallback);
        revertCurrentProg();
      } else if (afterProc == 'saveAttrtab') {
        function chgProgSaveAttrCB() {
          btnSaveattribute();
          getProgramText(getSelectProgram(), GETPROG_TEMP, chgSaveBtnCallback);
        }
        chgProg(getProdProgName(getSelectProgram()), chgProgSaveAttrCB);	// Select the saved program.
      } else if (afterProc == 'renametab') {
        defineDialog.open('#filerename', '#getrenameprogdlg', 'dlgMsgIptPgRename');		// Get
      } else if (afterProc == 'detailstab') {
        modifiAster = false;
        getProgramText(getSelectProgram(), GETPROG_TEMP, chgSaveBtnCallback);
        prgbuttonSelectProc();
      } else {
        // Only save file
        debug(DBGDUMP, "Save program complete.");
        // Reload...
        reloadProgramFile(getProdProgName(getCurrentProgram()), reloadPrgCallback);	// fileio
      }
      actionAfterSaving = null;
    }
  } else {
    saveSuccessProc();
    // Action after saving exists.
    if (holdingTransmitInfo != null) {
      var afterProc = holdingTransmitInfo.afterProc;
      if (afterProc == AFTERPROC_NEWOPEN) {
        openNewProgram(null);	// Save when newly created
        holdingTransmitInfo = null;
      } else if (afterProc == AFTERPROC_SELPROG) {
        openSelectProgram(null);
        //selectProgram(holdingTransmitInfo);	// Save when list is selected
        holdingTransmitInfo = null;
      } else if (afterProc == AFTERPROC_RUNPROG) {
        // On request, to reload the program before execution.
        holdingTransmitInfo.modifyTime = false;
        reloadProgramFile(getProdProgName(getCurrentProgram()), reloadPrgCallback);	// fileio
        reloadMultiScreenProg(getCurrentProgram(), false);
      } else if (afterProc == AFTERPROC_SAVEASPG) {
        saveAsProgram(getProdProgName(getCurrentProgram()), holdingTransmitInfo.progName);	// Save as process. api
        //holdingTransmitInfo = null;
      } else if (afterProc == AFTERPROC_RENAMEPG) {
        renameProgram(getProdProgName(getCurrentProgram()), holdingTransmitInfo.progName);	// Rename process. api
        //holdingTransmitInfo = null;
      } else if (afterProc == AFTERPROC_EDITATTR) {
        editAttrDlg.open('#fileeditattr', '#editattrdlg', false);		// Get program attribute
        holdingTransmitInfo = null;
      } else {
        // Only save file
        debug(DBGDUMP, "Save program complete.");
        // Reload...
        holdingTransmitInfo.modifyTime = true;
        reloadProgramFile(getProdProgName(getCurrentProgram()), reloadPrgCallback);	// fileio
        reloadMultiScreenProg(getCurrentProgram(), false);
      }
    }
  }
}
// Process of confirming notification
function confirmNotification() {
  currentEditPos = previousEditPos;
  getPcEditor().focus();
  getEditorDoc().setCursor(currentEditPos);
}

// Transmit information for dialog of createProg/Open.
var holdingTransmitInfo = null;

/**
 * Using progattr page save attribute dialog
 */
function saveBeforAttribute(btnId, cbArg) {
  var saveParam = cbArg.saveParam;
  actionAfterSaving = saveParam;
  // Compose and save mnemonic and position and etc...
  holdingTransmitInfo = new TransProgramInfo();
  holdingTransmitInfo.progName = saveParam.selprog;
  holdingTransmitInfo.afterProc = saveParam.aftersave;
  holdingTransmitInfo.modifyTime = true;
  api_saveProgramName = getCurrentProgram();
  // get *file create time
  getCreateTime(getTempProgName(getCurrentProgram()), getTempCreateTimeCB);
}
function undoAttribute() {
  drawAttribute();
}

/**
 * Program create process. (Call from dialog)
 */
function openNewProgram(saveParam) {
  debug(DBGINFO, 'Open new program');
  // Temporary file is exist, confirm discard temporary file.
  if (isExistEditProgramFile(getTempProgName(getCurrentProgram()))) {
    holdingTransmitInfo = new TransProgramInfo();
    holdingTransmitInfo.progName = saveParam.selprog;
    holdingTransmitInfo.afterProc = saveParam.aftersave;
    holdingTransmitInfo.modifyTime = false;
    holdingTransmitInfo.dialogId = saveParam.dialogid;
    var btnObj ={};
    btnObj = {
      btnData :{ btn1 :top.irpDlgBtnYN.btn1, btn2 :top.irpDlgBtnOC.btn2 },
      btn1Cb   :cautionDelProgram,
      btn2Cb   :cancelCautionDele
    };
    top.openCmpConfirm(webPage, window, 'cautionprogdlg', resources['dlgMsgCoutProg'], btnObj, true);
  } else {
    defineDialog.open('#filenew', '#getprogdlg', '');	// Dialog open
  }
}
function openNewProgramProgattr() {
  debug(DBGINFO, 'Open new program');
  //$('#filenew').click();	// illegal call...
  defineDialog.open('#filenew', '#getprogdlg', '');	// Get program name
}

/**
 * Program open process. (Call from dialog)
 */
function openSelectProgram(saveParam) {
  debug(DBGINFO, 'Open Select program');
  // Temporary file is exist, confirm discard temporary file.
  if (isExistEditProgramFile(getTempProgName(getCurrentProgram()))) {
    holdingTransmitInfo = new TransProgramInfo();
    holdingTransmitInfo.progName = saveParam.selprog;
    holdingTransmitInfo.afterProc = saveParam.aftersave;
    holdingTransmitInfo.modifyTime = false;
    holdingTransmitInfo.dialogId = saveParam.dialogid;
    var btnObj = {
      btnData :{
        btn1 :top.irpDlgBtnYN.btn1,
        btn2 :top.irpDlgBtnOC.btn2
      },
      btn1Cb   :cautionDelProgram,
      btn2Cb   :cancelCautionDele
    };
    top.openCmpConfirm(webPage, window, 'cautionprogdlg', resources['dlgMsgCoutProg'], btnObj, true);
  } else if (!(isScrModeProgAttr())) {
    openOpenDialog();
  }
}

/**
 * Generate New Program process. (Call from dialog)
 */
var dispAttrDlgFlag = true; 
function directCreateProgram(progname) {  //When Create button is pressed
  dispAttrDlgFlag = false; 
  generateNewProgram(progname);
}

function generateNewProgram(progname) { //When Detail button is pressed
  debug(DBGINFO, 'Generate New Program:' + progname);
  // Check already exist...
  if ((inProgramList(progname) >= 0) ||
    (inKarelProgramList(progname) >= 0) ||
    (progname == getMoveProgPrim())) { // exist
    // disp alart and exit
    top.openCmpConfirm(webPage, window, 'confalertdlg', resources['dlgMsgExistProg'], {btnData:{btn1:top.irpDlgBtnOC.btn1 }}, true);
    return;
  }

  createPrg(progname, chkMkPrg);
  function chkMkPrg(status, progname) {
    if (status == "0x7000f") {
      // disp alart and exit
      top.openCmpConfirm(webPage, window, 'confalertdlg', resources['dlgMsgExistProg'], {btnData:{btn1:top.irpDlgBtnOC.btn1 }}, true);
      return;
    }
    if (!(isScrModeProgAttr())) {
      // reset modified flag
      setProgramModified(false);
      setPositionModified(false);
      resetTempModified();
      // Add to program list.
      //$('#programlist').append($('<option>').html(progname).val(progname));
      //$('#programlist').val(progname);
      setProgramNameValue(progname);
    }
    var newProg = {};
    newProg.name = progname;
    newProg.type = resources['attrSubNone'];
    programFileList[programFileList.length] = newProg;
    setCurrentProgram(progname);
    // Generate skeleton data (Initialize program data)
    setFileLoading(true);
    var newProgInfo = new ProgramFileInfo();  // Create program file info instance.
    newProgInfo.init(progname);
    newProgInfo.setDefaultAttr(progname);
    if (isScrModeProgAttr()) {
      ProgramApplManager.initApplData();  // fileio
      ProgramApplManager.setDefaultAppl(); // fileio
      ProgramApplManager.setLineTrack(); // fileio
      ProgramApplManager.setLoadAppl(); // fileio
      ProgramApplManager.initEditApplLocalRegisters(); // fileio
      if (top.g_order.r792) ProgramApplManager.initEditApplSingularity(false); // fileio
      if (top.g_order.wnsp) ProgramApplManager.initEditApplPltzMode(false); // fileio
      //isExistPosData = false; // Comment out because it's no need.
      initCursorPos = { line: 0, ch: 0 };
      newProgInfo.initEditAttrValue();
      ProgramInfoManager.initProgInfoManager();
      ProgramInfoManager.setProgInfo(newProgInfo);
    } else {
      progLoadError = false;
      ProgramApplManager.setDefaultAppl(); // fileio
      ProgramApplManager.initTrackingConfig(); // fileio
      ProgramApplManager.setLineTrack(); // fileio
      ProgramApplManager.putLineTrackConfList(progname);
      if (top.g_order.r792) ProgramApplManager.initEditApplSingularity(false); // fileio
      if (top.g_order.wnsp) ProgramApplManager.initEditApplPltzMode(false); // fileio
      initCursorPos = { line: 0, ch: 0 };
      newProgInfo.initEditAttrValue();
      ProgramInfoManager.initProgInfoManager();
      ProgramInfoManager.setProgInfo(newProgInfo);
      drawProgramText(newProgInfo.getProgMnemonicStr());
      drawPositionData(newProgInfo.getProgPositionArray());
      unlockGrid();
    }
    setFileLoading(false);
    holdingTransmitInfo = null;
    // Call API
    createProgramFile(progname);
  }

}

/**
 * Select change program. (Call from dialog)
 */
function selectProgram(selParam) {
  setCurrentProgram(selParam.selprog);
  setProgramModified(false);	// reset modified flag
  setPositionModified(false);
  resetTempModified();
  if (isScrModeProgAttr()) {
    $('#progNameText').text(getCurrentProgram());
  } else {
    setProgramNameValue(selParam.selprog);
    ProgramInfoManager.initProgInfoManager(); // Program stack initialize.
    ProgramApplManager.initTrackingConfig(); // fileio
  }
  readProgramFile(selParam.selprog);	// fileio
}

function deleteAfterOpenPrg() {
  var pgName = isScrModeProgAttr() ? document.getElementById('proglistview').getSelectedValue() : $('#progrow' + prevprogelem + '-2').text();
  chgProg(pgName, jmpEditPage);
}

/**
 * Select cancel process. (Call from dialog)
 */
function cancelProgramSelect() {
  setProgramNameValue(getCurrentProgram());
  resumePrgPosModify();
}

// Sub program loading information. (For exclusive processing of file loading)
var LoadSubProgInfo = (function() {
  var progList = [];
  return {
    startLoading: function(progName) {
      debug(DBGDUMP, 'LoadSubProgInfo:startLoading()')
      progList.push(progName);
    },
    isLoading: function(progName) {
      debug(DBGDUMP, 'LoadSubProgInfo:progList[' + progList + ']');
      var loading = false;
      for (var idx in progList) {
        if (progList[idx] == progName) {
          loading = true;
          break;
        }
      }
      debug(DBGDUMP, 'LoadSubProgInfo:isLoading(' + progName + '):' + loading);
      return loading;
    },
    finishLoading: function(progName) {
      progList = progList.filter(function(name) {
        return name != progName;
      });
      debug(DBGDUMP, 'LoadSubProgInfo:finishLoading()')
      debug(DBGDUMP, 'LoadSubProgInfo:progList[' + progList + ']');
    }
  }
})();
/*
 * Call sub program or back to caller.
 */
function callSpecifiedProgram(reflectprog) {
  var progStatVal = JSON.parse(JSON.stringify(reflectprog));
  var progName = progStatVal.prog;
  if (LoadSubProgInfo.isLoading(progName)) {
    debug(DBGDUMP, 'callSpecifiedProgram(): loading(update editor) now...[' + progName + ']');
    return;
  }
  getPcEditor().setOption('styleActiveLine', false);
  LoadSubProgInfo.startLoading(progName); // loading(update editor) start
  var progInfo = ProgramInfoManager.getSpecifiedProgInfo(progName);
  if (Object.keys(progInfo).length == 0) { // specified program info is empty
    debug(DBGDUMP, 'callSpecifiedProgram(): progInfo is empty. (' + progName + ')');
    loadSubProgram(progName, progStatVal); // fileio
  } else {
    debug(DBGDUMP, 'callSpecifiedProgram(): Already loaded. (' + progName + ')');
    // already loaded program.
    updateEditorScreen(progStatVal, progInfo, false);
  }
}
// display editor text and position data
function  updateEditorScreen(progStat, progInfo, isPush) {
  var progName = progStat.prog;
  // [2019/6/24] If draw text file is a move-only program,
  if (progName == getMoveProgPrim()) {
    debug(DBGWARN, 'updateEditorScreen():' + progName);
    return; // ignore it. for fail safe.
  }
  setFileLoading(true); // true for cursorActivity in progwin
  //getPcEditor().setOption('styleActiveLine', false);
  setCurrentProgram(progName);
  setProgramNameValue(progName);
  changeProgramText(progInfo.getProgMnemonicStr());
  if (isPush) {
    ProgramInfoManager.pushProgInfo(progInfo);  // Push program info to stack.
  }
  drawPositionData(progInfo.getProgPositionArray());
  setTimeout(function() {
    highlightExecLine(progStat);
    LoadSubProgInfo.finishLoading(progName); // prgwin
    setFileLoading(false);
  }, 200);  // wait reflect output program text
}

// save from progattr page
function progAttrSaveProgram(btnId, cbArg) {
  var saveParam = cbArg.saveParam;
  actionAfterSaving = saveParam;
  // Compose and save mnemonic and position and etc...
  holdingTransmitInfo = new TransProgramInfo();
  holdingTransmitInfo.progName = saveParam.selprog;
  holdingTransmitInfo.afterProc = saveParam.aftersave;
  holdingTransmitInfo.modifyTime = true;
  if (isScrModeProgAttr()) {
    api_saveProgramName = getCurrentProgram();
  } else {
    saveProgramName = getCurrentProgram();
  }
  getCreateTime(getTempProgName(getCurrentProgram()), getTempCreateTimeCB);
}

function progAttrAsterFlg() {
  if (modifiAster !== undefined) {
    modifiAster = false;
  }
}

function getTempCreateTimeCB(status, progName, varName, createTime) {
  progCreateTime = createTime;
  getModifyTime(getProdProgName(progName), checkProgramModify);
}
/** ============================================
 * Relation of program execution processing.
 */
function startExecProgram(status, progName) {
  debug(DBGINFO, 'Exec program callback: status=' + status);
  if (isTablet) {	// Just in case...
    var execBtnId = (isScrModeEditorTab()) ? '#execbtn' : '#playrun';
    $(execBtnId).blur();
    setTimeout(function () { }, 50);
  }
  // focus out
  $(window).trigger('blur');
  startExecStatus(null);
  // The screen mask is processed by LED monitoring process.
  // putOverlayScreen('exec', 'forexec');	// Operations such as editing are disabled.
}

// Set Line from start program.
function setLineProgram(status, progName) {
  shiftFWD();
  startExecStatus(null);
}

// Calculate Editor Area informations.
// Current view top/end, Current Display Line count, Scroll top, etc...
var editorAreaInfo = {};
function setEditorAreaInfo(iFrameId) {
  editorAreaInfo[iFrameId] = new TransEditAreaInfo(iFrameId);
  return editorAreaInfo[iFrameId];
}
function getEditorAreaInfo(iFrameId) {
  return editorAreaInfo[iFrameId];
}
function crearEditorAreaInfo(iFrameId) {
  editorAreaInfo[iFrameId] = null;
}
function preInitEditorInfo(iFrameId) {
  debug(DBGDUMP, 'preInitEditorInfo[' + iFrameId + ']');
  var areaInfo = setEditorAreaInfo(iFrameId);
  areaInfo.editor = getPcEditor();
}
function initEditorAreaInfo(iFrameId) {
  var areaInfo = getEditorAreaInfo(iFrameId);
  var editor = areaInfo.editor;
  if (statusProgramInfoTrans.getCurrentProgramSI().line == 1) {	// Not on execute.
    editor.scrollTo(0, 0);	// reset scroll position
  }
  // This process is unnecessary
  // because the pause line number highlight setting is made 
  // when the scroll information is required at runtime.
  //editor.refresh();	// Editor refresh to clear cache.
  var scrlInfo = editor.getScrollInfo();
  var textHeight = editor.defaultTextHeight();
  debug(DBGDUMP, 'initEditorAreaInfo[' + iFrameId + ']: scrlHeight(' + scrlInfo.clientHeight + '):textHeight(' + textHeight + ')');
  viewLines = Math.floor(scrlInfo.clientHeight / textHeight);
  areaInfo.tol = 1;
  areaInfo.eol = viewLines;
  areaInfo.viewLines = viewLines;
  areaInfo.scrollTop = scrlInfo.top;
  areaInfo.textHeight = textHeight;
  debug(DBGDUMP, 'initEditorAreaInfo[' + iFrameId + ']: viewLines=' + areaInfo.viewLines + ' (top:' + scrlInfo.top + ');');
}
function scrollEditorArea(iFrameId, crntLine) {
  var areaInfo = getEditorAreaInfo(iFrameId);
  var editor = areaInfo.editor;
  var scrlInfo = editor.getScrollInfo();
  areaInfo.scrollTop = scrlInfo.top;
  debug(DBGDUMP, 'scrollEditorArea(before)[' + iFrameId + ']: crntLine=' + crntLine + '; ToL=' + areaInfo.tol + '; EoL=' + areaInfo.eol + '; viewLines=' + areaInfo.viewLines + ' (top:' + scrlInfo.top + ');');
  var needScroll = false;
  if (crntLine >= areaInfo.eol) {	// Execution line is after the end of editor area, need scroll...
    areaInfo.tol = crntLine - 1;	// current line set to 2nd position
    areaInfo.eol = areaInfo.tol + areaInfo.viewLines - 1;
    var crntLineCnt = getEditorDoc().lineCount();
    if (areaInfo.eol > crntLineCnt) {	// Over total line count
      areaInfo.eol = crntLineCnt;
      areaInfo.tol = crntLineCnt - areaInfo.viewLines + 1;
    }
    needScroll = true;
  } else if (crntLine < areaInfo.tol) {	// Execution line is before the top of editor area, need scroll...
    areaInfo.tol = ((crntLine - 1) > 0) ? crntLine - 1 : 1;	// current line set to 2nd position
    areaInfo.eol = areaInfo.tol + areaInfo.viewLines - 1;
    needScroll = true;
  }
  debug(DBGDUMP, 'scrollEditorArea(after) [' + iFrameId + ']: crntLine=' + crntLine + '; ToL=' + areaInfo.tol + '; EoL=' + areaInfo.eol + '; viewLines=' + areaInfo.viewLines + ' (top:' + scrlInfo.top + ');');
  if (needScroll) {	// Scroll to new position
    var scrlPos = { x: 0, y: 0 };
    scrlPos.y = (areaInfo.tol - 1) * areaInfo.textHeight;
    debug(DBGDUMP, 'scrollEditorArea(scroll): Top of Line=' + scrlPos.y);
    editor.scrollTo(scrlPos.x, scrlPos.y);
  }
}
// Execution line highlight processing.
function highlightExecLine(progStatVal) {
  var progStat = JSON.parse(JSON.stringify(progStatVal)); // deep copy
  var crntProg = getCurrentProgram();
  debug(DBGDUMP, 'highlight: progStat.prog(stat)[' + progStat.prog + '(' + progStat.stat + ')]/crntProg[' + crntProg + ']');
  var pceditor = getPcEditor();
  if ((progStat.line < 1) || (isMoveToOnProgram()) || // No highlight when moveto.
      (progStat.prog != crntProg) || (progStat.stat != WATCHEXEC_RUNNING)) {
    pceditor.setOption('styleActiveLine', false);
    if (progStat.prog == crntProg) {
      setFileLoading(true); // true for cursorActivity in progwin
      if (progStat.stat == WATCHEXEC_ABORTED) {
        initLineNumVar();
      } else if (progStat.stat == WATCHEXEC_PAUSED) {
        setLineNumVar(progStat.line - 1);
        // Clearing the highlight before selection.
        if ($('.CodeMirror-gutter-background').length > 1) {
          initLineNumVar();
        }
      }
      setTimeout(function() {
        setFileLoading(false);  // flag off after reflect set cursor.
      }, 10);
    } else if ((progStat.stat == WATCHEXEC_ABORTED) && (isMyIFrameIdPrim()) &&
      (ProgramInfoManager.getCurrentInfoIndex() > 0)) {
      setMainText(); // If stop on sub program, switch display to Main program.
    }
    return;
  }
  if (progStat.stat == WATCHEXEC_PAUSED) {
    pceditor.setOption('styleActiveLine', false);
    setLineNumVar(progStat.line - 1);
    return;
  }
  if ((progStat.stat == WATCHEXEC_RUNNING) && (holdLineNumber.line != -1)) {
    debug(DBGDUMP, 'highlight: holdLineNumber.line [' + holdLineNumber.line + ')');
    initLineNumVar();
  }
  isProgramAreaRefresh = true;
  var crntExecPos = { line: (progStat.line - 1), ch: 0 };
  if (!pceditor.getOption('styleActiveLine')) {
    pceditor.setOption('styleActiveLine', true);
  }
  pceditor.getDoc().setCursor(crntExecPos);
  // end of window, scroll up to 2nd line.
  scrollEditorArea(getMyIFrameId(), crntExecPos.line + 1);
  isProgramAreaRefresh = false;
}

var beforeRunStat = { curLine: 0, setLine: false };
function runProgram() {
  var msg = "";
  var progStat = JSON.parse(JSON.stringify(statusProgramInfoTrans.getCurrentProgramSI().stat));
  var curLine = ((progStat == WATCHEXEC_PAUSED) ? getPcEditor().getDoc().getCursor().line : beforeCusStaPos.line);
  var setLineFlag = ((holdLineNumber.line != curLine) ? true: false);
  beforeRunStat = { curLine: curLine, setLine: setLineFlag };

  if ((progStat == WATCHEXEC_PAUSED) && (holdLineNumber.line != curLine)) {
    // If the paused line and the cursor line are different, TP dialog is displayed.
    runProgramFromCus();
    return;
  } else {
    //  Even when starting from the first line, This popup dialog is displayed.
    if (getCurrentLanguage() == "jp") {
      msg = (curLine + 1) + resources["dlgMsgStartCurBefore"] + resources["dlgMsgStartCurAfter"];
    } else {
      msg = resources["dlgMsgStartCurBefore"] + (curLine + 1) + resources["dlgMsgStartCurAfter"];
    }
    resources["dlgMsgStartCur"] = msg;
    defineDialog.open(null, '#cusstartdlg', '');
    return;
  }
}

var holdLineNumber = { line: -1, ch: -1 };
var statLineFirst = {};
function holdProgram() {
  debug(DBGINFO, 'Hold program...');
  setExecProgHold(true);	// api
  var holdBtnId = (isScrModeEditorTab()) ? '#stepexecbtn' : '#playrun';
  $(holdBtnId).addClass('validexec');
  pauseProgram();
  // Even when stopping with the pause button, cancel the operation restriction.
  stopProgram(true);	// [11/21/2017] request from FN)
  if (!isMoveToOnProgram()) {	// if move to hold, stop move to.
    setExecProgHold(true);	// Re set Hold status. because set to false by stopProgram().
  }
}
function stopProgram(holdFlag) {
  if (isScrModeProgAttr()) {
    setProgramExec(false);
    setExecProgHold(false);
    removeOverlayScreen('exec');	// Operations such as editing will be enabled.
    //stopProgram('', finishExec);
  } else {
    checkHoldProg(holdFlag);
  }
}
function setMainText() {
  debug(DBGDUMP, 'stopProgram(): Change to main...');
  setFileLoading(true); // true for cursorActivity in progwin
  var progMain = ProgramInfoManager.getMainProgInfo();
  changeProgramText(progMain.getProgMnemonicStr());
  drawPositionData(progMain.getProgPositionArray());
  var progName = progMain.getProgName();
  setCurrentProgram(progName); // prgwin
  setProgramNameValue(progName); // prgwin
  // Must be done again after setCurrentProgram
  makeDisplayRepPos(w2ui[getSelPosTblName()].records, POSTBLKIND_DATA); // poswin
  var cbArg = {};
  cbArg.func = programStopProc;
  chgProg(progName, waitChgProgComplete, cbArg); // program change to main
  setFileLoading(false);
}
function checkHoldProg(flag) {
  if ((ProgramInfoManager.getCurrentInfoIndex() > 0) && (!flag)) {
    setMainText();
    return;
  }
  if (!flag) {
    ProgramInfoManager.resetProgInfoManager();
  }
  programStopProc();
}
function programStopProc() {
  setProgramExec(false);
  setExecProgHold(false);
  if(!progLoadError) removeOverlayScreen('exec');	// Operations such as editing will be enabled.
  if ((isScrModePcEditor()) &&  (isWriteProtectWin())) {
      protOverlayManager(true);
  }
  if (isMoveToOnProgram()) {	// if move to hold, stop move to.
    stopMoveToProgram();	// moveto
  }
}
function initMultiFrameEditorArea(frameId) {
  var windowMulti = getSpecifiedIFrame(frameId)[0].contentWindow;
  if (typeof windowMulti.initEditorAreaInfo === 'function') {
    windowMulti.initEditorAreaInfo(frameId);
  }
}
function runProgramFromCus() {  // Processing after cursor line execution.
  debug(DBGINFO, 'Run program...');
  setExecProgHold(false);
  setProgramExec(true);
  var execBtnId = (isScrModeEditorTab()) ? '#execbtn' : '#playrun';
  $(execBtnId).removeClass('validexec');
  var reflectprog = JSON.parse(JSON.stringify(statusProgramInfoTrans.getCurrentProgramSI()));
  debug(DBGDUMP, 'runProgramFromCus: prog stat(' + reflectprog.stat + ')');
  if (reflectprog.stat == WATCHEXEC_PAUSED) { // When executing while paused,
    initLineNumVar();                         // remove the line number highlight.
  }
  // If you moved the page, comment out this 'else block'
  // because you need to get scroll information again.
  //} else {
    if (!isScrModeEditorTab()) {
      protOverlayCleanUp();
    }
    initEditorAreaInfo(IFRAMEID_PRIM);
    if (existDualIFrame()) {	// Call target iFrame prgwin function
      initMultiFrameEditorArea(IFRAMEID_DUAL);
    }
    if (existThirdIFrame()) {	// Call target iFrame prgwin function
      initMultiFrameEditorArea(IFRAMEID_THIRD);
    }
  //}
  var progMain = ProgramInfoManager.getMainProgInfo();
  execProgName = progMain.getProgName();  // When executing, specify the main program name.
  if (beforeRunStat.setLine) {
    setLine(execProgName, beforeRunStat.curLine + 1, setLineProgram); // io
  } else {
    execProgram(execProgName, startExecProgram); // io
  }
}

function moveCusForPauseLine() {  // Processing after cursor line execution dialog. (unexecuted)
  getPcEditor().focus();
  setLineNumVar(holdLineNumber.line);
}
function initLineNumVar() {
  debug(DBGDUMP, 'initLineNumVar: remove gutter class.');
  var editor = getPcEditor();
  var allLine = editor.getDoc().lineCount();
  for (var i = 0; i < allLine; i++) {
    editor.removeLineClass(i, "gutter", "CodeMirror-pause-number");
  }
  holdLineNumber = { line: -1, ch: -1 };
}
function setLineNumVar(lineNum) {  // save line number val and highlighting
  if (lineNum < 0) {
    return; // When program stop from the state of pause, progress comes in this
  }
  var cus = { line: 0, ch: 0 };
  cus.line = lineNum;
  beforeCusStaPos = cus;
  getEditorDoc().setCursor(cus);   // If the program is paused when logging in, move the cursor
  holdLineNumber = cus;
  if (getCurrentProgram() != statusProgramInfoTrans.getCurrentProgramSI().prog) {  // If running sub program or run line 0, hide highlight.
    if (holdLineNumber.line > 0) {
      holdLineNumber.line++; // This process correctly corrects the number on the pause position.
    }
    if (holdLineNumber.line >= 0) {
      getEditorDoc().setCursor(holdLineNumber); // As cursor is one line higher, move down one line.
    }
  } else {
    debug(DBGDUMP, 'setLineNumVar: add gutter class to [' + lineNum + '].');
    getPcEditor().addLineClass(cus.line, "gutter", "CodeMirror-pause-number");
  }
}
function initSetHoldLine() {
if (statLineFirst.line > 0) {
  if (statLineFirst.prog == getCurrentProgram()) { // If the process is in the middle of sub program, hide highlight.
    setLineNumVar(statLineFirst.line - 1);
  }
  currentEditPos = beforeCusStaPos;
  statLineFirst.line = -1;
  }
}

// jump Edit Program Page
function jmpPrgattrPage() {
  var props = { value: "" };
  props.value = top.SELECTPROG_ADDRESS;
  top.treemod.nodeOnClick(null, props);

  var root = top.treemod.document.getElementById('treeScara');
  targetParent = top.treemod.document.getElementById(top.SELECTPROG_ADDRESS);
  target = targetParent.children;
  addClassExclusively(root, target[0], 'tree-select-selected');
}

// Save process at focus out
function saveFocusOut() {
  if (isProgramModified()) {	// Save when modified.
    blurSaveFlag = true;
    saveEditLine();
  }
}

// Check the program line to see if it contains the "palletStr".
function checkPalletText(lineText) {
  var palletLine = false;
  var checkPallet = resources["palletStr"];
  var checkEndPallet = resources["palletEndStr"];
  checkPallet = ((getCurrentLanguage() == "jp") ? checkPallet + " " : checkPallet + "-");

  if ((lineText.indexOf(checkPallet) >= 0) && (lineText.indexOf(checkEndPallet) < 0)) {
    palletLine = true;
  }
  return palletLine;
}

// Check the program line to see if it contains the "palletEndStr".
function checkPalletTextEnd(lineText, palletNum) {
  var palletEndLine = false;
  var checkPallet = resources["palletEndStr"];
  var cutLine = lineText.indexOf(checkPallet);

  if (cutLine >= 0) {
    cutLine += checkPallet.length;
    if (lineText.slice(cutLine, cutLine + 1) == palletNum) {
      palletEndLine = true;
    }
  }
  return palletEndLine;
}

// Check the program line to see speed.
function checkSpeedText(speedText, unit) {
  var palletSpeed = false;
  var checkPallet = ((getCurrentLanguage() == "jp") ? resources["pltprg"].slice(5, 8) + "\\[" : "R\\[");
  var regsSpeed = new RegExp("^" + checkPallet + checkPallet + "[0-9]+" + "\]\]$");
  var regSpeed = new RegExp("^" + checkPallet + "[0-9]+" + "\]$");
  var numSpeed = /^[-+]?[0-9]+(\.[0-9]+)?$/;
  var unitLimit = {
    "%": { "upper": 100, "lower": 1 },
    "mm/sec":{ "upper": 3000, "lower": 1 },
    "cm/min":{ "upper": 18000, "lower": 1 },
    "inch/min":{ "upper": 6553.5, "lower": 0.1 },
    "deg/sec":{ "upper": 260, "lower": 1 },
    "msec":{ "upper": 32000, "lower": 1 },
    "sec":{ "upper": 3200, "lower": 0.1 }
}
  if ((regsSpeed.test(speedText)) || (regSpeed.test(speedText))) {
    var spdNum = Number(speedText.replace(/[^0-9]/g, ''));
    if ((spdNum > 0) && (spdNum <= 32766)) {
      palletSpeed = true;
    }
  }
  if (numSpeed.test(speedText)) {
    var spdNum = Number(speedText);
    if ((spdNum >= unitLimit[unit].lower) && (spdNum <= unitLimit[unit].upper)) {
      palletSpeed = true;
    }
  }
  return palletSpeed;
}

// Check the program line to see Cnt num.
function checkCntText(cntText) {
  var palletCnt = false;
  var checkPallet = ((getCurrentLanguage() == "jp") ? resources["pltprg"].slice(5, 8) + "\\[" : "R\\[");
  var regCnt = new RegExp("^" + checkPallet + "[0-9]+" + "\]$");
  var numCnt = /^[0-9]+$/;

  if (regCnt.test(cntText)) {
    var cntNum = Number(cntText.replace(/[^0-9]/g, ''));
    if ((cntNum > 0) && (cntNum <= 255)) {
      palletCnt = true;
    }
  }
  if (numCnt.test(cntText)) {
    var cntNum = Number(cntText);
    if ((cntNum > 0) && (cntNum <= 100)) {
      palletCnt = true;
    }
  }
  return palletCnt;
}

// Check lineText has the necessary settings.
function setProgDataProc(lineText, palletNum) {
  var unitList = ["%", "mm/sec", "cm/min", "inch/min", "deg/sec", "msec", "sec"]
  var setProgObj = {
    "motion": "J",
    "speed": "30",
    "unit": "%",
    "kind": "FINE",
    "kind_num": 0
  }
  var unitStrCh = 0;
  var kindStrCh = 0;
  var speedStr = ""
  var kindSpeedStr = "";

  if (lineText.indexOf(resources["pltmotionorder"]) < 0) {
    return; // If this lineText is not motion text, skip after process.
  }

  if (lineText.indexOf(resources["pltmotionj"]) >= 0) { // set motion
    setProgObj.motion = resources["pltmotionj"]; // JOINT
  } else if (lineText.indexOf(resources["pltmotionl"]) >= 0) {
    setProgObj.motion = resources["pltmotionl"]; // LINEAR
  } else {
    return; // If this lineText do not have the necessary settings, skip after process.
  }

  for (l = 0; l < unitList.length; l++) { // set unit
    if (lineText.indexOf(unitList[l]) >= 0) {
      setProgObj.unit = unitList[l];
      unitStrCh = lineText.indexOf(unitList[l]);
      break;
    }
  }
  if (unitStrCh == 0) {
    return; // If this lineText do not have the necessary settings, skip after process.
  }

  speedStr = lineText.slice(lineText.lastIndexOf(" ", unitStrCh) + 1, unitStrCh).trim();
  if (checkSpeedText(speedStr, setProgObj.unit)) {
    setProgObj.speed = speedStr; // set speed
  } else {
    return; // If this lineText do not have the necessary settings, skip after process.
  }

  if (lineText.indexOf(resources["pltmotionfine"]) >= 0) { // set kind
    setProgObj.kind = resources["pltmotionfine"]; // FINE
  } else if (lineText.indexOf(resources["pltmotioncnt"]) >= 0) {
    setProgObj.kind = resources["pltmotioncnt"]; // CNT
    kindStrCh = lineText.indexOf(resources["pltmotioncnt"]);
  } else {
    return; // If this lineText do not have the necessary settings, skip after process.
  }

  if (setProgObj.kind == resources["pltmotioncnt"]) {
    var kindObjStr = kindStrCh + resources["pltmotioncnt"].length;
    kindSpeedStr = lineText.slice(kindObjStr).trim();

    if (checkCntText(kindSpeedStr)) { // set kind_num
      setProgObj.kind_num = kindSpeedStr;
    } else {
      return; // If this lineText do not have the necessary settings, skip after process.
    }
  }
  setProgData(palletNum, commandNum, setProgObj);
  commandNum++;
}

var commandNum = 0;
function checkPalletProg(lineNum, lineText) {

  var allLine = getEditorDoc().lineCount();
  var checkPallet = resources["palletStr"];
  var checkLine = "";
  var palletNum = "";
  var endLineNum = 0;
  var checkNum = /^[0-9]+$/;


  checkPallet = ((getCurrentLanguage() == "jp") ? checkPallet + " " : checkPallet + "-");
  checkLine = lineText.slice(lineText.indexOf(checkPallet) + checkPallet.length);
  palletNum = checkLine.replace(/[^0-9]/g,"");
  // palletNum = ((checkLine.slice(1, 2) == "X") ? (checkLine.slice(3, 4)) : (checkLine.slice(2, 3)));

  if (checkNum.test(palletNum)) {
    for (var j = lineNum + 1; j < allLine; j++) {
      if (checkPalletTextEnd(getEditorDoc().getLine(j), palletNum)) {
        endLineNum = j;
        break;
      }
    }
  }
  if (endLineNum > 0) {
    commandNum = 0;
    for (var k = lineNum + 1; k < endLineNum; k++) {
      if (setProgDataProc(getEditorDoc().getLine(k), Number(palletNum))) {
      }
    }
  }
  return palletNum;
}

function checkAllPltNum() {
  var prog_text = getPcEditor().getValue();
  var exist_pltNum = [];
  prog_text = prog_text.split("\n");

  for (var i = 0; i < prog_text.length; i++){
    var str = prog_text[i];
    if (str.indexOf(resources["palletStr"]) >= 0 && /\w+_\d+/.test(str)) {
      exist_pltNum.push(str.replace(/[^0-9]/g,""));
    }
  }
  deleteUnusedPltNum(exist_pltNum);
}

$('#programarea').on('click', '#palletButton', function (event) {
  var cmDoc = getEditorDoc();
  var csrPos = cmDoc.getCursor();
  var progText = cmDoc.getLine(csrPos.line);
  var plt_num = checkPalletProg(csrPos.line, progText);
  if (plt_num == "") {
    defineButtonDlg.close('#palletButton');
  } else {
    pltDialogModifiedProcess(plt_num);
  }
});

function switchPltBtn(text) {
  if ((checkPalletText(text)) && (!isWriteProtectWin())) {
    defineButtonDlg.close('#palletButton');
    defineButtonDlg.open('#palletButton');
  } else {
    defineButtonDlg.close('#palletButton');
  }
}

function getPltProgRange() {
  var cmDoc = getEditorDoc();
  var csrPos = cmDoc.getCursor();
  var progText = cmDoc.getLine(csrPos.line);
  var allLine = cmDoc.lineCount();
  var checkPallet = resources["palletStr"];
  var checkLine = "";
  var palletNum = "";
  var endLineNum = 0;
  var checkNum = /^[0-9]+$/;
  var return_obj = { from: { line: csrPos.line, char: 0 }, to: { line: 0, char: 0} };


  checkPallet = ((getCurrentLanguage() == "jp") ? checkPallet + " " : checkPallet + "-");
  checkLine = progText.slice(progText.indexOf(checkPallet) + checkPallet.length);
  palletNum = ((checkLine.slice(1, 2) == "X") ? (checkLine.slice(3, 4)) : (checkLine.slice(2, 3)));

  if (checkNum.test(palletNum)) {
    for (var j = csrPos.line + 1; j < allLine; j++) {
      if (checkPalletTextEnd(cmDoc.getLine(j), palletNum)) {
        endLineNum = j;
        break;
      }
    }
  }
  var charPos = getPcEditor().getLine(endLineNum);
  return_obj.to.line = endLineNum;
  return_obj.to.char = charPos.length;
  return return_obj;
}

// Paste Palletizing command after delete modify rows.
function pastePalletizingModify() {
  if (holdingTransmitInfo == null) {	// if already set action (ex:rename), not set.
    holdingTransmitInfo = new TransProgramInfo();
    holdingTransmitInfo.progName = getCurrentProgram();
    holdingTransmitInfo.afterProc = AFTERPROC_PLTPASTE;
  }
  reloadProgramFile(getTempProgName(getCurrentProgram()), reloadPrgCallback);	// fileio (api)
}

function protOverlaySetting() {
  $('#prglistwin').css({ 'position': 'relative' });
  $('#prglistwin').css({ 'z-index': 9991 });
  $('#jogwindow').css({ 'z-index': 9992 });
  $('#resizeposmarkv').css({ 'position': 'relative' });
  $('#resizeposmarkv').css({ 'z-index': 9992 });
  $('#resizeposmarkh').css({ 'position': 'relative' });
  $('#resizeposmarkh').css({ 'z-index': 9992 });
  $('#toolbarbtnarea').css({ 'position': 'relative' });
  $('#toolbarbtnarea').css({ 'z-index': 9990 }); // under posdata
  $('#closelistbtn').css({ 'position': 'relative' });
  $('#closelistbtn').css({ 'z-index': 9991 });
  $('#posdatawin').css({ 'position': 'relative' });
  $('#posdatawin').css({ 'z-index': 9989 });
}

function protOverlayCleanUp() {
  if (progLoadError) return;
  $('#prglistwin').css({ 'position': '' });
  $('#prglistwin').css({ 'z-index': '' });
  $('#jogwindow').css({ 'z-index': '' });
  $('#resizeposmarkv').css({ 'z-index': '' });
  $('#resizeposmarkh').css({ 'z-index': '' });
  $('#toolbarbtnarea').css({ 'position': '' });
  $('#toolbarbtnarea').css({ 'z-index': '' });
  $('#closelistbtn').css({ 'position': '' });
  $('#closelistbtn').css({ 'z-index': '' });
  $('.validexec').css({ 'z-index': 9997 });
}

function protOverlayManager(flag) {
  // for tp on/off
  if(progLoadError || progLoadError && isEnableOn()) return;
  if (isMyIFrameIdPrim()) {
    if (flag) { // write protect mode
      protOverlaySetting('prot');
      putOverlayScreen('prot', 'forprotprog');
    } else if (!flag) { // edittable mode
      protOverlayCleanUp('prot');
      removeOverlayScreen('prot');
    }
  }
}

function isWriteProtectWin() {
  if ((isNotEditableWin()) && (isMyIFrameIdPrim())) {
    return true;
  }
  if (ProgramInfoManager.getCurrentProgInfo() === null) {
    return false;
  }
  if ((ProgramInfoManager.getCurrentProgInfo().getEditAttrValue().PROTECT == PROTECTON) &&
    (isMyIFrameIdPrim())) {
    return true;
  }
  return false;
}

function isNotEditableWin() {
  var execMode = false;
  if (isScrModePcEditor()) {
    if (!isEnableOn()) { // TP is invalid
      execMode = true;
    }
  } else {
    if ((!isEnableOn()) || (!getLockBtnStat())) { // TP is invalid or
      execMode = true;
    }
  }
  return execMode;
}

function checkTPPicture() {
  var stat_elem = top.document.getElementById('statbar');
  var img_url = (((top.statbar.location.href).indexOf("statbar_tabtp.htm") > -1) ?
    stat_elem.contentWindow.document.getElementById('tpEnable').children[0].src :
    stat_elem.contentWindow.document.getElementById('tpen').children[0].style.backgroundImage);
  var btn_value = (img_url.indexOf('on') > -1) ? 'ON' : 'OFF';

  if (btn_value == 'ON') {
    return true;
  } else if (btn_value == 'OFF') {
    return false;
  }
}

var backUpProgName = "";
function shiftCurrentProg() {
  if ((getSelectProgram() != getCurrentProgram()) || (isScrModeProgAttr() && (buttonName == 'saveAstab'))) {// Replace current program name with select program name for rename
    if (isExistEditProgramFile(getCurrentProgram())) {
      backUpProgName = getTempProgName(getCurrentProgram());
    } else {
      backUpProgName = getCurrentProgram();
    }
    setCurrentProgram(getSelectProgram());
  }
}

function revertCurrentProg() {
  if (backUpProgName != "") {
    setCurrentProgram(getProdProgName(backUpProgName));
    chgProg(backUpProgName);
    backUpProgName = "";
  }
}

function initBackUpProg() {
  setCurrentProgram(getProdProgName(backUpProgName));
  backUpProgName = "";
}

function refleshProgList() {
  location.reload();
}

function abortProgProc() {
  abortProgram(getCurrentProgram(), procAfterAbort);
}

function abort_prog() {
  top.pnlarea.abort_tpprog(false);
}

// for MultTask
var maxTask = "";
var validMult = false;
var validUOP = false;
function setMulSelEnb(io_type, io_index, valStr, cbArg, chk_status) {
  validMult = valStr == "TRUE" ? true : false; //bool
}

function getMltEnable(io_type, io_index, valStr, cbArg, chk_status) {
  validUOP = null;
  if (top.g_order.j605 || top.g_order.j964) {
    top.rpcmc_chkkey(null, top.mor_ss_c, top.SYSNAME_C, '$MULTI_ROBO.$MLT_ENABLE', setMltEnable);
  }
  function setMltEnable(io_type, io_index, valStr, cbArg, chk_status) {
    validUOP = (valStr == "TRUE") ? true : false; // bool
  }
}

function setNumTasks(io_type, io_index, valStr, cbArg, chk_status) {
  maxTask = valStr; //number
}                                                                                                                                                                                                                                                                                                                                       /**********************************************************************
 * Robot Program Editor script
 * Window resize bar script
 * Created: 2017/05/11 FSI
 *
 */

/*
  Stretch status.
*/
var MIN_STRETCH_UPPER = 20;
var MIN_STRETCH_LOWER = 20;
var MIN_STRETCH_LEFT  = 20;
var MIN_STRETCH_RIGHT = 20;
var MIN_STRETCH_LEFTH = 192;
var previousHorz = {x: 0, y: 0};
var currentHorz  = {x: 0, y: 0};
var previousVert = {x: 0, y: 0};
var currentVert  = {x: 0, y: 0};

/* resize restore rate */
var latestRateVert = {left: 0, right: 0};
var latestRateHorz = {top: 0, bottom: 0};

/**
 * Expand(maximize) Program/Command area Vertical layout Horizontal bar
 **/
function expandPrgCmdVert() {
	// save current rate
	if ((latestRateHorz.top == 0) && (latestRateHorz.bottom == 0)) {
		latestRateHorz.top = $('#prglistwin').height();
		latestRateHorz.bottom = $('#posdataareav').height();
	}
	var horzBarH = $('#resizehorzv').height();	// Height of horizontal resize-bar.
	// hide bottom area
	$('#posdataareav').hide();
	$('#posdataareav').height(0);
	$('#resizevertv').hide();
	$('#resizevertv').height(0);
	$('#jogwinareav').hide();
	$('#jogwinareav').height(0);
	// maximize top area
	var calcH = 'calc(100% - ' + horzBarH + 'px)';
	$('#prglistwin').css({'height': calcH});
	$('#prglistwin').show();
	$('#cmdlistwin').css({'height': calcH});
	resizeHorzCmdTree();
	$('#cmdlistwin').show();
	toggleResizeButton('prgcmdmax', 'restorevert', 'horz');
	if ($('#posjogmax').hasClass('restorevert')) {	// Restore btn...
		resumeResizeButton('posjogmax', 'restorevert', 'up');
	}
}
/**
 * Expand(maximize) Program/Command area Horizontal layout Vertical bar
 **/
function expandPrgCmdHorz() {
	// save current rate
	if ((latestRateVert.left == 0) && (latestRateVert.right == 0)) {
		latestRateVert.left = $('#prglistwin').width() + $('#cmdlistwin').width();
		latestRateVert.right = $('#posjogarea').width();
	}
	var vertBarW = $('#resizeverth').width();
	// hide right area
	var maxwidth = $('#layoutarea').width();
	$('#posjogarea').hide();
	$('#posjogarea').width(0);
	$('#posdataareah').hide();
	$('#posdataareah').width(0);
	$('#resizehorzh').hide();
	$('#jogwinareah').hide();
	$('#jogwinareah').width(0);
	$('#prglistwin').css({'width': (maxwidth - vertBarW) * RATEPRGWINDEF});
	$('#cmdlistwin').css({'width': (maxwidth - vertBarW) * RATECMDWINDEF});
	$('#prglistwin').show();
	$('#cmdlistwin').show();
	toggleResizeButton('posareamax', 'restorehorz', 'vert');
	if ($('#jogareamax').hasClass('restorehorz')) {	// Restore btn...
		resumeResizeButton('jogareamax', 'restorehorz', 'lt');
	}
};
/**
 * Restore Program/Command area Vertical layout Horizontal bar
 **/
function restorePrgCmdVert(direc) {
	// Upper half
	$('#prglistwin').css({'height': latestRateHorz.top});
	$('#prglistwin').show();
	$('#cmdlistwin').css({'height': latestRateHorz.top});
	resizeHorzCmdTree();
	$('#cmdlistwin').show();
	// Lower half
	var restHeight = latestRateHorz.bottom;
	var postableH = restHeight
		- $('#posctrl').height() - LOWERWINMARGIN - POSTABLEBORDER;
	$('#posdata').height(postableH - POSBTMMARGIN);
	$('#posregarea').height(postableH);
	$(getSelPosTblId()).show();
	$('#posdataareav').css({'height': restHeight});
  	$('#posdataareav').show();
  	$('#posdatawin').height(restHeight);
	$('#resizevertv').height(restHeight);
	$('#resizevertv').show();
	$('#jogwindow').height(restHeight); // - LOWERWINMARGIN - POSTABLEBORDER - POSWINMARGIN);
	$('#jogwinareav').css({'height': restHeight});
  $('#jogwinareav').show();
  $('#jogbtnarea').height(restHeight);
	latestRateHorz.top = 0;
	latestRateHorz.bottom = 0;
	resumeResizeButton((direc == 'up') ? 'posjogmax': 'prgcmdmax', 'restorevert', direc);
};
/**
 * Contract(minimize) Program/Command area Vertical layout Horizontal bar
 **/
function contractPrgCmdVert() {
	// save current rate
	if ((latestRateHorz.top == 0) && (latestRateHorz.bottom == 0)) {
		latestRateHorz.top = $('#prglistwin').height();
		latestRateHorz.bottom = $('#posdataareav').height();
	}
	// hide up area
	$('#prglistwin').hide();
	$('#prglistwin').height(0);
	$('#cmdlistwin').hide();
	$('#cmdlistwin').height(0);
	var layoutH = $('#layoutarea').height();
	var horzBarH = $('#resizehorzv').height();
	$('#posdataareav').height(layoutH - horzBarH);
	var postableH = layoutH - horzBarH
		- $('#posctrl').height() - LOWERWINMARGIN - POSTABLEBORDER - POSWINMARGIN;
	$('#posdata').height(postableH - POSBTMMARGIN);
	$('#posregarea').height(postableH);
  	$('#posdataareav').show();
  	$('#posdatawin').height(layoutH - horzBarH);
	$('#resizevertv').height(layoutH - horzBarH);
	$('#resizevertv').show();
	$('#jogwinareav').height(layoutH - horzBarH);
	$('#jogwinareav').show();
  $('#jogwindow').height(layoutH - horzBarH); // - LOWERWINMARGIN - POSTABLEBORDER);
  $('#jogbtnarea').height(layoutH - horzBarH);
	posResizeRefresh(false);	// poswin
	resizeJogDial();
	toggleResizeButton('posjogmax', 'restorevert', 'horz');
	if ($('#prgcmdmax').hasClass('restorevert')) {	// Restore btn...
		resumeResizeButton('prgcmdmax', 'restorevert', 'dn');
	}
};
/**
 * Contract(minimize) Program/Command area Horizontal layout Vertical bar
 **/
function contractPrgCmdHorz() {
	// save current rate
	if ((latestRateVert.left == 0) && (latestRateVert.right == 0)) {
		latestRateVert.left = $('#prglistwin').width() + $('#cmdlistwin').width();
		latestRateVert.right = $('#posjogarea').width();
	}
	// hide left area
	var maxwidth = $('#layoutarea').width();
	$('#prglistwin').width(0);
	$('#prglistwin').hide();
	$('#cmdlistwin').width(0);
	$('#cmdlistwin').hide();
	// show
	var vertBarW = $('#resizeverth').width();
	$('#posjogarea').width(maxwidth - vertBarW);
	$('#posjogarea').show();
	$('#posdataareah').width(maxwidth - vertBarW);
	$('#posdataareah').show();
	$('#resizehorzh').width(maxwidth - vertBarW);
	$('#resizehorzh').show();
	$('#jogwinareah').width(maxwidth - vertBarW);
	$('#jogwinareah').show();
	var posctrlW = document.getElementById('posctrl').clientWidth;
	$('#posdata').width(posctrlW);
	posResizeRefresh(false);	// poswin
	toggleResizeButton('jogareamax', 'restorehorz', 'vert');
	if ($('#posareamax').hasClass('restorehorz')) {	// Restore btn...
		resumeResizeButton('posareamax', 'restorehorz', 'ri');
	}
};
function restorePCHPosJog(halfWidth) {
	$('#posjogarea').width(halfWidth);
	$('#posjogarea').show();
	$('#posdataareah').width(halfWidth);
	$('#posdataareah').show();
	$('#resizehorzh').width(halfWidth);
	$('#resizehorzh').show();
	$('#jogwinareah').width(halfWidth);
	$('#jogwinareah').show();
	$('#jogwindow').show();
	var posctrlW = document.getElementById('posctrl').clientWidth;
	$('#posdata').width(posctrlW);
	posResizeRefresh(false);	// poswin
};
function restorePCHPrgCmd(halfWidth) {
	$('#prglistwin').css({'width': halfWidth * RATEPRGWINDEF});
	$('#cmdlistwin').css({'width': halfWidth * RATECMDWINDEF});
	$('#prglistwin').show();
	$('#cmdlistwin').show();
};
function restorePrgCmdHorz(direc) {
	$('#prglistwin').hide();
	$('#cmdlistwin').hide();
	$('#jogwindow').hide();
	$('#jogwinareav').hide();
	if (direc == 'lt') {
		restorePCHPosJog(latestRateVert.right);
		restorePCHPrgCmd(latestRateVert.left);
	} else {
		restorePCHPrgCmd(latestRateVert.left);
		restorePCHPosJog(latestRateVert.right);
	}
	latestRateVert.left = 0;
	latestRateVert.right = 0;
	resumeResizeButton((direc == 'lt') ? 'jogareamax': 'posareamax', 'restorehorz', direc);
};

/**
 * Expand(maximize) Jog win area Vertical layout Vertical bar
 **/
function expandJogWinVert() {
	// save current rate
	if ((latestRateVert.left == 0) && (latestRateVert.right == 0)) {
		latestRateVert.left = $('#posdataareav').width();
		latestRateVert.right = $('#jogwinareav').width();
	}
	var vertBarW = $('#resizevertv').width();
	// hide left area
	$('#postblarea').hide();
	$('#posctrlare').hide();
	$('#posdatawin').hide();
	$('#posdataareav').width(0);
	var calcW = 'calc(100% - ' + vertBarW + 'px)';
	$('#jogwinareav').css({'width': calcW});
	$('#jogwindow').show();
	$('#jogdialimg').hide();
	resizeJogDial();
	toggleResizeButton('jogareamax', 'restorehorz', 'vert');
	if ($('#posareamax').hasClass('restorehorz')) {	// Restore btn...
		resumeResizeButton('posareamax', 'restorehorz', 'ri');
	}
};
/**
 * Expand(maximize) Jog win area Horizontal layout Horizontal bar
 **/
function expandJogWinHorz() {
	// save current rate
	if ((latestRateHorz.top == 0) && (latestRateHorz.bottom == 0)) {
		latestRateHorz.top = $('#posdataareah').height();
		latestRateHorz.bottom = $('#jogwinareah').height();
	}
	// hide bottom area
	var posjogH = $('#posjogarea').height();
	$('#posdatawin').hide();
	$('#posdataareah').height(0);
	var rszBarH = $('#resizehorzh').height();
	$('#jogwinareah').css({'height': posjogH - rszBarH});
	$('#jogwindow').css({'height': posjogH - rszBarH - JOGAREAMARGIN});
  $('#jogwindow').show();
  $('#jogbtnarea').height(posjogH - rszBarH - JOGAREAMARGIN);
	resizeJogDial();
	toggleResizeButton('posjogmax', 'restorehorz', 'horz');
	if ($('#prgcmdmax').hasClass('restorehorz')) {	// Restore btn...
		resumeResizeButton('prgcmdmax', 'restorehorz', 'dn');
	}
};
/**
 * Restore Position/Jog area Vertical layout Horizontal bar
 **/
function restorePosJogVert(direc) {
	$('#jogwindow').hide();
	$('#jogwinareav').hide();
	$('#posdataareav').css({'width': latestRateVert.left});
	$('#posdataareav').show();
	$('#posdatawin').css({'width': 'calc(100% - ' + POSAREAMARGIN + 'px)'});
	$('#posdatawin').show();
	$('#resizevertv').show();
	$('#jogwindow').show();
	$('#jogwinareav').width(latestRateVert.right);
	$('#jogwinareav').show();
	posResizeRefresh(false);	// poswin
	latestRateVert.left = 0;
	latestRateVert.right = 0;
	resumeResizeButton((direc == 'lt') ? 'jogareamax': 'posareamax', 'restorehorz', direc);
};

/**
 * Contract(minimize) Jog win area Vertical layout Vertical bar
 **/
function contractJogWinVert() {
	// save current rate
	if ((latestRateVert.left == 0) && (latestRateVert.right == 0)) {
		latestRateVert.left = $('#posdataareav').width();
		latestRateVert.right = $('#jogwinareav').width();
	}
	var vertBarW = $('#resizevertv').width();
	//$('#jogwindow').width(0);
	$('#jogwindow').hide();
	$('#jogwinareav').width(0);
	$('#postblarea').show();
	$('#posctrlare').show();
	$('#posdataareav').css({'width': 'calc(100% - ' + vertBarW + 'px)'});
	$('#posdataareav').show();
	$('#posdatawin').css({'width': 'calc(100% - ' + POSAREAMARGIN + 'px)'});
	$('#posdatawin').show();
	posResizeRefresh(false);	// poswin
	toggleResizeButton('posareamax', 'restorehorz', 'vert');
	if ($('#jogareamax').hasClass('restorehorz')) {	// Restore btn...
		resumeResizeButton('jogareamax', 'restorehorz', 'lt');
	}
};
/**
 * Contract(minimize) Jog win area Horizontal layout Horizontal bar
 **/
function contractJogWinHorz() {
	// save current rate
	if ((latestRateHorz.top == 0) && (latestRateHorz.bottom == 0)) {
		latestRateHorz.top = $('#posdataareah').height();
		latestRateHorz.bottom = $('#jogwinareah').height();
	}
	// calc each win
	var posjogH = $('#posjogarea').height();
	var rszBarH = $('#resizehorzh').height();
	var posctrlH = $('#posctrl').height();
	$('#jogwindow').hide();
	$('#jogwinareah').height(0);
	$('#posdatawin').show();
	$('#posdataareah').css({'height': posjogH - rszBarH});
	$('#posdatawin').height(posjogH - rszBarH);
	var posTableH = posjogH - rszBarH - posctrlH - POSAREAMARGIN  - POSTABLEBORDER - POSWINMARGIN;
	$('#posdata').height(posTableH - POSBTMMARGIN);
	$('#posregarea').height(posTableH);
	posResizeRefresh(false);	// poswin
	toggleResizeButton('prgcmdmax', 'restorehorz', 'horz');
	if ($('#posjogmax').hasClass('restorehorz')) {	// Restore btn...
		resumeResizeButton('posjogmax', 'restorehorz', 'up');
	}
};
/**
 * Restore Position/Jog area Horizontal layout Vertical bar
 **/
function restorePosJogHorz(direc) {
	$('#jogwindow').hide();
	$('#jogwinareav').hide();
	var posjogH = ($('#posjogarea').height() - $('#resizehorzh').height()) / 2;
	$('#posdataareah').css({'height': latestRateHorz.top});
	var postableH = latestRateHorz.top
		- $('#posctrl').height() - LOWERWINMARGIN - POSTABLEBORDER - POSWINMARGIN;
	$('#posdata').height(postableH - POSBTMMARGIN);
	$('#posregarea').height(postableH);
	$('#posdatawin').show();
  $('#posdataareah').show();
  $('#posdatawin').height(latestRateHorz.top);
	$('#jogwinareah').height(latestRateHorz.bottom);
	$('#jogwinareah').show();
	$('#jogwindow').height(latestRateHorz.bottom); // - LOWERWINMARGIN - POSTABLEBORDER);
  $('#jogwindow').show();
  $('#jogbtnarea').height(latestRateHorz.bottom);
	posResizeRefresh(false);	// poswin
	resizeJogDial();
	latestRateHorz.top = 0;
	latestRateHorz.bottom = 0;
	resumeResizeButton((direc == 'up') ? 'posjogmax': 'prgcmdmax', 'restorehorz', direc);
};

/* - Toggle resize button face - */
function toggleResizeButton(fromBtnId, toBtnCls, img) {
	var fromIdStr = '#' + fromBtnId;
	$(fromIdStr).attr('src', 'images/icon_layout_' + img + '.png');
	$(fromIdStr).addClass(toBtnCls);
}
function resumeResizeButton(targetId, rmvClass, img) {
	var targetIdStr = '#' + targetId;
	$(targetIdStr).removeClass(rmvClass);
	$(targetIdStr).attr('src', 'images/icon_layout_' + img + '.png');
}

/**
 * Resize bar hendling functions
 **/
/**  Horizontal bar common functions **/
function resizeDownHorzbar(event) {
	var tempClient = getEventClient(event);
	previousHorz.x = tempClient.x;
	previousHorz.y = tempClient.y;
	fResizeHorz = true;
	debug(DBGDUMP, 'resizeHorz- mousedown/touchstart:(' + tempClient.x + '/' + tempClient.y + ')');
}
function resizeUpHorzbar(event) {
	var tempClient = getEventClient(event);
	fResizeHorz = false;
	fResizeVert = false;
	debug(DBGDUMP, 'resizeHorz- mouseup/touchend:(' + tempClient.x + '/' + tempClient.y + ')');
	$(window).trigger('resize');
}
/** Vertical bar common functiosn **/
function resizeDownVertbar(event) {
	var tempClient = getEventClient(event);
	previousVert.x = tempClient.x;
	previousVert.y = tempClient.y;
	fResizeVert = true;
	debug(DBGDUMP, 'resizeVert| mousedown/touchstart:(' + tempClient.x + '/' + tempClient.y + ')');
}
function resizeUpVertbar(event) {
	var tempClient = getEventClient(event);
	fResizeVert = false;
	fResizeHorz = false;
	debug(DBGDUMP, 'resizeVert| mouseup/touchend:(' + tempClient.x + '/' + tempClient.y + ')');
	$(window).trigger('resize');
}
/**  Vertical layout Horz bar move **/
function resizeMoveHorzV(event) {
	var tempClient = getEventClient(event);
	currentHorz.x = tempClient.x;
	currentHorz.y = tempClient.y;
	var upperHalfH = $('#prglistwin').height();
	var lowerHalfH = $('#posdataareav').height();
	var diffHeight = currentHorz.y - previousHorz.y;
	if ((diffHeight > -2) && (diffHeight < 2)) {
		return false;
	}
	debug(DBGDUMP, 'Current-Previous H=(' + diffHeight + ')');
	// check min/max
	if (diffHeight > 0) {	// Down
		if ((lowerHalfH - diffHeight) < MIN_STRETCH_LOWER) {
			return false;
		}
		upperHalfH += diffHeight;
		lowerHalfH -= diffHeight;
	} else if (diffHeight < 0) {	// Up
		if ((upperHalfH - Math.abs(diffHeight)) < MIN_STRETCH_UPPER) {
			return false;
		}
		upperHalfH -= Math.abs(diffHeight);
		lowerHalfH += Math.abs(diffHeight);
	}
	previousHorz.x = currentHorz.x;
	previousHorz.y = currentHorz.y;
	var leftHalfW = $('#posdataareav').width();
	var rightHalfW = $('#jogwinareav').width();
	debug(DBGDUMP, 'moveHorzV:upper(' + upperHalfH + ')/lower(' + lowerHalfH + ')/left(' + leftHalfW + ')/right(' + rightHalfW + ')');
	initVertWindow(upperHalfH, lowerHalfH, leftHalfW, rightHalfW);
	posResizeRefresh(true);	// poswin
}
/**  Vertical layout Vert bar move **/
function resizeMoveVertV(event) {
	var tempClient = getEventClient(event);
	currentVert.x = tempClient.x;
	currentVert.y = tempClient.y;
	var leftHalfW = $('#posdataareav').width();
	var rightHalfW = $('#jogwinareav').width();
	var diffWidth = currentVert.x - previousVert.x;
	if ((diffWidth < -2) && (diffWidth > -2)) {
		return false;
	}
	debug(DBGDUMP, 'Current-Previous W=(' + diffWidth + ')');
	// check min/max
	if (diffWidth > 0) {	// Right
		if ((rightHalfW - diffWidth) <= MIN_STRETCH_RIGHT) {
			return false;
		}
		leftHalfW += diffWidth;
		rightHalfW -= diffWidth;
	} else if (diffWidth < 0) {	// Left
		if ((leftHalfW - Math.abs(diffWidth)) <= MIN_STRETCH_LEFT) {
			return false;
		}
		leftHalfW -= Math.abs(diffWidth);
		rightHalfW += Math.abs(diffWidth);
	}
	debug(DBGDUMP, 'moveVertV:left(' + leftHalfW + ')/right(' + rightHalfW + ')');
	previousVert.x = currentVert.x;
	previousVert.y = currentVert.y;
	var upperHalfH = $('#prglistwin').height();
	var lowerHalfH = $('#posdataareav').height();
	initVertWindow(upperHalfH, lowerHalfH, leftHalfW, rightHalfW);
	posResizeRefresh(false);	// poswin
}
/*** Horizontal layout Vertical bar move ***/
function resizeMoveVertH(event) {
	var tempClient = getEventClient(event);
	currentVert.x = tempClient.x;
	currentVert.y = tempClient.y;
	var leftHalfW = $('#prglistwin').width() + $('#cmdlistwin').width();	// left side from bar
	var rightHalfW = $('#posjogarea').width();	// right side from bar
	var diffWidth = currentVert.x - previousVert.x;
	if ((diffWidth <= 0) && (diffWidth > -2)) {
		return false;
	}
	debug(DBGDUMP, 'Current-Previous W=(' + diffWidth + ')');
	// check min/max
	if (diffWidth > 0) {	// Right
		if ((rightHalfW - diffWidth) <= MIN_STRETCH_RIGHT) {
			return false;
		}
		leftHalfW += diffWidth;
		rightHalfW -= diffWidth;
	} else if (diffWidth < 0) {	// Left
		if ((leftHalfW - Math.abs(diffWidth)) <= MIN_STRETCH_LEFTH) {
			return false;
		}
		leftHalfW -= Math.abs(diffWidth);
		rightHalfW += Math.abs(diffWidth);
	}
	debug(DBGDUMP, 'moveVertH:left(' + leftHalfW + ')/right(' + rightHalfW + ')');
	previousVert.x = currentVert.x;
	previousVert.y = currentVert.y;
	var upperHalfH = $('#posdataareah').height();
	var lowerHalfH = $('#jogwinareah').height();
	initHorzWindow(leftHalfW, rightHalfW, upperHalfH, lowerHalfH);
	posResizeRefresh(true);	// poswin
}
/*** Horizontal layout Horizontal bar move ***/
function resizeMoveHorzH(event) {
	var tempClient = getEventClient(event);
	currentHorz.x = tempClient.x;
	currentHorz.y = tempClient.y;
	var upperHalfH = $('#posdataareah').height();
	var lowerHalfH = $('#jogwinareah').height();
	var diffHeight = currentHorz.y - previousHorz.y;
	if ((diffHeight >= 0) && (diffHeight < 2)) {
		return false;
	}
	debug(DBGDUMP, 'Current-Previous H=(' + diffHeight + ')');
	// check min/max
	if (diffHeight > 0) {	// Down
		if ((lowerHalfH - diffHeight) <= MIN_STRETCH_UPPER) {
			return false;
		}
		upperHalfH += diffHeight;
		lowerHalfH -= diffHeight;
	} else if (diffHeight < 0) {	// Up
		if ((upperHalfH - Math.abs(diffHeight)) <= MIN_STRETCH_UPPER) {
			return false;
		}
		upperHalfH -= Math.abs(diffHeight);
		lowerHalfH += Math.abs(diffHeight);
	}
	previousHorz.x = currentHorz.x;
	previousHorz.y = currentHorz.y;
	var leftHalfW = $('#prglistwin').width() + $('#cmdlistwin').width();
	var rightHalfW = $('#posjogarea').width();
	initHorzWindow(leftHalfW, rightHalfW, upperHalfH, lowerHalfH);
	posResizeRefresh(true);	// poswin
}

$(function() {
	// Min/Max button
	// Changed the listener registration method for click event.
	$('#layoutarea').on('click', '#prgcmdmax', function(event) {
		if (getCurrentLayout() == LAYOUTVERTICAL) {
			if ($('#prgcmdmax').hasClass('restorevert')) {	// Restore btn...
        restorePrgCmdVert('dn');
        posResizeRefresh(true);	// poswin
			} else {	// VertLayout HorzBar Up btn...
        expandPrgCmdVert();
			}
		} else {
			if ($('#prgcmdmax').hasClass('restorehorz')) {	// Restore btn...
        restorePosJogHorz('dn');
			} else {	// HorzLayout VertBar Right btn...
        contractJogWinHorz();
        posResizeRefresh(true);	// poswin
			}
		}
	});
	$('#layoutarea').on('click', '#posjogmax', function(event) {
		if (getCurrentLayout() == LAYOUTVERTICAL) {
			if ($('#posjogmax').hasClass('restorevert')) {	// Restore btn...
        restorePrgCmdVert('up');
        posResizeRefresh(true);	// poswin
			} else {	// VertLayout HorzBar Up btn...
        contractPrgCmdVert();
        posResizeRefresh(true);	// poswin
			}
		} else {
			if ($('#posjogmax').hasClass('restorehorz')) {	// Restore btn...
        restorePosJogHorz('up');
        posResizeRefresh(true);	// poswin
			} else {	// HorzLayout HorzBar Down btn...
				expandJogWinHorz();
			}
		}
	});
	$('#layoutarea').on('click', '#jogareamax', function(event) {
		if (getCurrentLayout() == LAYOUTVERTICAL) {
			if ($('#jogareamax').hasClass('restorehorz')) {	// Restore btn...
        restorePosJogVert('lt');
        posResizeRefresh(true);	// poswin
			} else {
				expandJogWinVert();
			}
		} else {
			if ($('#jogareamax').hasClass('restorehorz')) {	// Restore btn...
				restorePrgCmdHorz('lt');
			} else {
        contractPrgCmdHorz();
        posResizeRefresh(true);	// poswin
			}
		}
	});
	$('#layoutarea').on('click', '#posareamax', function(event) {
		if (getCurrentLayout() == LAYOUTVERTICAL) {
			if ($('#posareamax').hasClass('restorehorz')) {	// Restore btn...
				restorePosJogVert('ri');
			} else {
        contractJogWinVert();
        posResizeRefresh(true);	// poswin
			}
		} else {
			if ($('#posareamax').hasClass('restorehorz')) {	// Restore btn...
        restorePrgCmdHorz('ri');
        posResizeRefresh(true);	// poswin
			} else {
				expandPrgCmdHorz();
			}
		}
	});
});                                                                                                                                                     /**********************************************************************
 * Robot Program Editor
 * Robot API (I/F of Controller)
 * Created: 2017/06/22 FSI
 * Modified:2019/03/14 FSI Organize related processes and unify definitions.
 */

/*
 * Require: common_io.js, pceditor_const.js, pceditor_io.js, pceditor_dialog.js, pceditor_fileio.js,
 *          common_sitrans.js
 */

var dispTempFile = false; // for temp file debug (true=ON, false=OFF)
// Performs a dedicated palletizing process when a command insertion error occurs.
var pltEditCmd = {};
pltEditCmd.isProcess = false;
pltEditCmd.startLine = 0;
pltEditCmd.lineNum = 0;

var progLoadError = false;

/*==========================================
 * Common processing group.
 * Conversion etc...
 */

/*
 * Get program name to temporary name.
 * (IN) progName : Program name.
 * return : Temporary program name.
 */
function getTempProgName(progName) {
  var tempName = (!progName.startsWith('*')) ? '*' + progName : progName;
  return tempName;
}
/*
 * Get production name from temporary name.
 * (IN) progName : Program name.
 * return : Production program name.
 */
function getProdProgName(progName) {
  var prodName = (progName.startsWith('*')) ? progName.slice(1) : progName;
  return prodName;
}
/*
 * Check program name is temporary name.
 * (IN) progName : Target program name.
 * return : true = Temporary name, false = Production name.
 */
function isProgramNameTemporary(progName) {
  return progName.startsWith('*');
}
/*
 * Add the program extension.
 * (IN) progName : Program name
 */
function addProgramExtension(progName) {
  var progWithExt = (progName.indexOf('.LS') < 0) ? progName + '.LS' : progName;
  return progWithExt;
}
/*
 * Omit File extension.
 * (IN) progName : Program file name.
 */
function omitExtension(progName) {
  var extPos = progName.indexOf('.LS'); // have extension
  var progOmitExt = (extPos >= 0) ? progName.substr(0, extPos) : progName;
  return progOmitExt;
}

/**
 * Get program (name) list of undefined type.
 * (IN) callback : A callback function to receive the program list.
 *                 arg2: Program name list. (Array of String)
 *                 arg3: List length
 */
function getProgramList(subType, callback) {
  lstProg(top.TV_PRG_ALL, top.MM_MNEPRG_C, subType, callback);  // io
}

/**
 * Wait for chgProg processing to complete.
 * When complete, call callback function.
 * If retry 2sec and no complete, call callback function.
 * ** Must include common_sitrans.js for get current program name at status. ***
 * (IN) status : set by chgProg()
 * (IN) progName : target program name
 * (IN) cbArg : callback argument object
 *      cbArg.func : Callback function from original chgProg
 *      cbArg.some_argument : If you need other data, set it.
 */
var retryChgProgComplete = 0;
function waitChgProgComplete(status, progName, cbArg) {
  if (isScrModeProgAttr()) {
    function progNameCB(prog, varName, typeCode, val) {
      if (val !== progName && retryChgProgComplete < 100) {
        setTimeout(function () {
          top.rpcmc_getVar(top.SYSNAME_C, '$TP_DEFPROG', progNameCB);
          retryChgProgComplete++;
        }, 50); // Keep a interval
        return;
      }
      retryChgProgComplete = 0;
      cbArg.func(status, progName, cbArg);
      return;
    }
    if (retryChgProgComplete == 0) {
      top.rpcmc_getVar(top.SYSNAME_C, '$TP_DEFPROG', progNameCB);
      retryChgProgComplete++;
      return;
    }
  } else {
    if ((typeof statusProgramInfoTrans.getCurrentProgramSI === 'function') &&
    (statusProgramInfoTrans.getCurrentProgramSI().prog != progName)) {
    debug(DBGDUMP, 'waitChgProgComplete:[' + retryChgProgComplete + ']');
      if (retryChgProgComplete < 100) {
        setTimeout(function () {
          waitChgProgComplete(status, progName, cbArg);
        }, 50); // Keep a interval
        retryChgProgComplete++;
        return;
      }
    }
    retryChgProgComplete = 0;
    cbArg.func(status, progName, cbArg);
  }
}

// wait for save edit line process
var saveEditLineTimer = null
function waitSaveEditLine(progName) {
  if (issaveeditline) {
    saveEditLineTimer = setTimeout(function () {
      waitSaveEditLine(progName);
    }, 50); // Keep a interval
  } else {
    putProgramPosition(progName); // api
  }
}

// wait for save edit line process before save as
function waitSaveAsEditLine(progName, saveParam) {
  if (issaveeditline) {
    saveEditLineTimer = setTimeout(function () {
      waitSaveAsEditLine(progName, saveParam);
    }, 50); // Keep a interval
  } else {
    putbeforSaveasProgPos(progName, saveParam); // api
  }
}

// wait for rename edit line process before save as
function waitRenameEditLine(progName, saveParam) {
  if (issaveeditline) {
    saveEditLineTimer = setTimeout(function () {
      waitRenameEditLine(progName, saveParam);
    }, 50); // Keep a interval
  } else {
    putbeforRenameProgPos(progName, saveParam); // api
  }
}
/*==========================================
 * Get Miscellaneous Initial Common Data.
 */

/* --------- Management of axis unit. --------- */
var posAxesUnit = [];	// Unit string of Axes.
var AXESUNIT_MM = 0;
var AXESUNIT_DEG = 1;
var axesUnitTable = ['mm', 'deg'];
/* - Get Axes unit from system variable. - */
function getAxesUnitCallback(sysName, varName, type_code, isRotary, callParam) {
  var grp = callParam.grp;
  var axs = callParam.axs;
  var axsunit = posAxesUnit[grp - 1];
  if (axsunit == undefined) {
    axsunit = [];
  }
  axsunit[axs - 1] = axesUnitTable[(isRotary.toLowerCase() == 'true') ? AXESUNIT_DEG : AXESUNIT_MM];
  posAxesUnit[grp - 1] = axsunit;
  axs++;
  if (axs > (MAXROBOTAXES + MAXEXTAXES)) {	// target group axes count over
    grp++;	// count up group
    axs = 1;	// reset axes count
  }
  if (grp <= getGroupCount()) {
    callParam.grp = grp;
    callParam.axs = axs;
    getAxesUnit(getAxesUnitCallback, callParam);	// api
    return;
  }
  callParam.acb();	// Callback to draw
}
function getSystemAxesUnit(callback) {
  // At first, get 1st group, 1st axes
  var callParam = {};
  callParam.grp = 1;
  callParam.axs = 1;
  callParam.acb = callback;
  getAxesUnit(getAxesUnitCallback, callParam);	// api
}
/* - Get Joint Axes Unit String. - */
function getJointUnitStr(grp, axes) {
  var axesUnits = posAxesUnit[grp - 1];
  if ((posAxesUnit.length >= grp) && (axesUnits.length > axes)) {
    return axesUnits[axes];
  }
  // If the unit is not the acquisition target, it returns the default unit.
  return axesUnitTable[AXESUNIT_MM]; // return default unit. (axesUnitTable is in the poswin.)
}
/* - Get Joint Axes Unit Group Array. - */
function getJointUnitGroup(grp) {
  var axesUnits = posAxesUnit[grp - 1];
  return axesUnits;
}

/*
 * Get Joint Axes count from system variable.
 */
var posAxesCount = { 'joint': [], 'robot': [] };
function getAxesCount(grpNum) {	// return axes count object.
  return posAxesCount.joint[grpNum - 1];
}
function getJointRobotAxes(grpNum) {
  return posAxesCount.robot[grpNum - 1];
}
function getExtendAxesCount(grpNum) {
  // Get joint axes count.
  var axesCount = posAxesCount.joint[grpNum - 1];	// Get Axes count of current group (total axes count)
  var robotCount = posAxesCount.robot[grpNum - 1];
  var extAxes = axesCount - robotCount;
  return extAxes;
}
function getRobotAxesCallback(sysName, varName, type_code, axesStr, callParam) {
  var grp = callParam.grp;
  posAxesCount.robot[grp - 1] = parseInt(axesStr);
  grp++;
  if (grp <= getGroupCount()) {
    callParam.grp = grp;
    getRobotAxesCount(getRobotAxesCallback, callParam);
    return;
  }
  // After obtaining the number of groups, call drawing.
  getSystemAxesUnit(callParam.acb);	// Callback to get axes unit.
}
function getAxesCountCallback(sysName, varName, type_code, axesStr, callParam) {
  var grp = callParam.grp;
  posAxesCount.joint[grp - 1] = parseInt(axesStr);
  grp++;
  if (grp <= getGroupCount()) {
    callParam.grp = grp;
    getJointAxesCount(getAxesCountCallback, callParam);
    return;
  }
  callParam.grp = 1;	// reset group number
  getRobotAxesCount(getRobotAxesCallback, callParam);
}
function getSystemAxesCount(callback) {
  var callParam = {};
  callParam.grp = 1;
  callParam.acb = callback;
  getJointAxesCount(getAxesCountCallback, callParam);
}

/*
 * Get specified group joint axes number / robot axes number.
 * (IN) callback : A callback function to get axes
 *          arg1 : SYSNAME_C
 *          arg2 : $SCR_GRP[grp].$NUM_AXES
 *          arg3 : no use
 *          arg4 : axes number
 * (IN) callParam :
 *          .grp : Group number
 *          .acb : Callback to call after acquiring number of axes.
 */
function getJointAxesCount(callback, callParam) {
  top.rpcmc_getVar(top.SYSNAME_C, '$SCR_GRP[' + callParam.grp + '].$NUM_AXES', callback, callParam);
}
// Get specified group Robot Axes number.
function getRobotAxesCount(callback, callParam) {
  top.rpcmc_getVar(top.SYSNAME_C, '$SCR_GRP[' + callParam.grp + '].$NUM_ROB_AXS', callback, callParam);
}

/*
 * Get specified group axes unit.
 * (IN) callback : A callback function to get axes
 *          arg1 : SYSNAME_C
 *          arg2 : $SCR_GRP[grp].$ROTARY_AXS[axes]
 *          arg3 : no use
 *          arg4 : axes unit (true=rotary(deg), false=cart(mm))
 * (IN) callParam :
 *          .grp : Group number
 *          .axs : Axes number
 *          .acb : Callback to call after acquiring number of axes.
 */
function getAxesUnit(callback, callParam) {
  var strVariable = '$SCR_GRP[' + callParam.grp + '].$ROTARY_AXS[' + callParam.axs + ']';
  top.rpcmc_getVar(top.SYSNAME_C, strVariable, callback, callParam);
}

/*==========================================
 * Management of Position Data for Position/Position Register touch up and represent.
 */

/**
 * Get current position data.
 * (IN) coord_type : COORDINATECART(0)=Cartesian, COORDINATEJOINT(1)=Joint
 * (IN) grp_num    : Group number
 * (IN) cb_arg     : Callback argument.
 */
function getEditorCurrentPosition(coord_type, grp_num, cb_arg) {
  if (coord_type == COORDINATECART) { // Cartesian coordinate
    get_curpos(top.KXYZWPR, top.TXML_TP_REC_TYPE, grp_num, getCurposCallback, cb_arg);	// common_io
  } else if (coord_type == COORDINATEJOINT) { // Joint coordinate
    get_curang(grp_num, getCurangCallback, cb_arg);	// common_io
  } else {
    debug(DBGERROR, 'getCurPos: Invalid value of coord_type(' + coord_type + ')');
  }
}
function setEditorCurrentPosition(cb_arg) {
  var curProg = getCurrentProgram();
  if (!isExistEditProgramFile(getTempProgName(curProg))) {
    copyProductToEditProg(getProdProgName(curProg));
    mkEditProg_setLine(curProg, cb_arg);
    return;
  }
  recPos(getTempProgName(curProg), cb_arg.rec.rowno, cb_arg.rep, top.TXML_TP_REC_TYPE, cb_arg.grp, recPosCallback, cb_arg); // common_io
}
/*
 * Set UF / UT value according to table kind.
 */
function setUFUTbyTableKind(tblKind, crntJson) {
  if (tblKind == POSTBLKIND_DATA) {
    crntJson.UF = getUfUtSystemValue(crntJson.GP).UF;
    crntJson.UT = getUfUtSystemValue(crntJson.GP).UT;
  } else {
    crntJson.UF = POS_REG_UF_VAL;
    crntJson.UT = POS_REG_UT_VAL;
  }
}
// Get Cartesian position callback
function getCurposCallback(pos_rep, pos_type, grp_num, str, cbArg) {
  // Return object
  var posJson = analyzeCartesianPosition(str, cbArg);	// common api
  setUFUTbyTableKind(cbArg.tblKind, posJson);
  // Get extend axis
  cbArg.rec = posJson;
  get_curang(grp_num, getExtAxisCallback, cbArg);	// common_io
  // See below...
}
function recPosCallback(status, prog_name, str, cbArg) {
  if (status == IO_SUCCESS) { // Return object
    if (cbArg.rep == POS_REP_JOINT) {
      getCurangCallback(cbArg.grp, str, cbArg);
    } else {
      getCurposCallback(cbArg.rep, cbArg.tblKind, cbArg.grp, str, cbArg);
    }
  } else {
    if (!(isProgramModified()) && !(isPositionModified())) {
      cautionDelProgram();
    }
    if (!isScrModeProgAttr()) {
      dispOffWaitExchange();
    }
  }
}
// Get Extend Axis Position data.
function getExtAxisCallback(grp_num, str, cbArg) {
  // Analyze
  var posJson = cbArg.rec;
  var posTemp = $.extend({}, posJson);	// Copy(Clone) position data to temp data.
  var tempJson = analyzeJointPosition(str, posTemp);	// common api
  // Set data
  for (var i = 0; i < curangExtElem.length; i++) {
    posJson[curangExtElem[i].elem] = tempJson[curangExtElem[i].elem];
  }
  posJson.frame = COORDINATECART;
  posJson.rep = (curangExtElem.length > 0) ? POS_REP_BOTH : POS_REP_CART;
  posJson.force = cbArg.force;
  if (cbArg.callback != undefined) {
    cbArg.callback(posJson);
  }
}
// Get Joint position callback
function getCurangCallback(grp_num, str, cbArg) {
  var posJson = analyzeJointPosition(str, cbArg.rec);
  setUFUTbyTableKind(cbArg.tblKind, posJson);
  posJson.frame = COORDINATEJOINT;
  posJson.rep = POS_REP_JOINT;
  posJson.force = cbArg.force;
  if (cbArg.callback != undefined) {
    cbArg.callback(posJson);
  }
}

/*==========================================
 * Text data and Position data read/write
 */

/**
 * Get edit program text.
 * (IN) progName : Ascii format file name. (String)
 * (IN) targetKind : Target program kind. 0=Product file, 1=Edit file.
 * (IN) callback : A callback function to receive the program list.
 *                 arg1: progName
 *                 arg2: ProgramText (String (Ascii format string))
 *                 arg3: ProgramText line count
 */
function getProgramText(progName, targetKind, callback) {
  if (targetKind == GETPROG_PROD) { // specified product program file.
    if (isProgramNameTemporary(progName)) { // if already search edit file
      progName = getProdProgName(progName);
    } else {
      // product file is nothing...
      dispOffWaiting();
      if (isScrModeProgAttr()) {
        if (selProgFlag) {
          var btnObj = {
            btnData :{ btn1 : top.irpDlgBtnOC.btn1 },
            btn1Cb : refleshProgList
          };
          // top.openCmpConfirm(webPage, window, 'alreadydelerrdlg', resources['dlgMsgAlreadyDelError'], btnObj, true);
          top.openCmpConfirm(webPage, window, 'alreadydelerrdlg', resources['dlgMsgSelectError'], btnObj, true);
        } else {
          chgDispPrgName('');
          attrBtnDisable();
          drawProgramList();
        }
      } else {
        defineDialog.open(null, '#failedloaderrdlg', 'dlgMsgLoadOtherSelectError');
        setCurrentProgram("");
        changeProgStat({prog: '', line: 0, stat: -1, shellLine: 0, initSetLineFlag: false});
        progLoadError = true;
        progName = getTempProgName(progName);
        var progFile = addProgramExtension(progName);
        readPrgCallback(IO_SUCCESS, progFile, "", 0);
      }
      return;
    }
  } else {
    progLoadError = false;
    progName = getTempProgName(progName);
  }
  var progFile = addProgramExtension(progName);
  if (isScrModeProgAttr()) {
    loadFileBypErr(progFile, '*', callback);
  } else {
    loadFile(progFile, callback);
  }
}

/**
 * Put error dialog with interface error string.
 */
function putIFErrorDialog(status, errorStr, dlgId, preMsgId) {

  var errorMsg = (preMsgId.length > 0) ? resources[preMsgId] : '';
  if ((preMsgId.length > 0) && (dlgId == '#attralertdlg')) { // Provisional response (temporary)
    errorMsg = errorMsg + '<br/>' + errorStr;
  }
  defineDialog.open(null, dlgId, errorMsg);
}

/**
 * Create Program file to controller.
 * (IN) progName : Program name
 */
// Callback of set invisible attr.
function setAttrInvisibleCB(status, progName) {
  debug(DBGINFO, 'Change attribute to invisible. status(' + status + ')');
  dispOffWaiting();
}
// Callback of Select(Change) saved program.
function selSavedProgramCB(status, progName) {
  debug(DBGINFO, 'Change(save) program:' + progName + '(' + status + ')');
  dispOffWaiting();
  setCurrentProgram(progName);
  saveProgramSuccess();
}
// Callback of Select(Change) saveas program.
function selSaveASProgramCB(status, progName) {
  debug(DBGINFO, 'Change(saveas) program:' + progName + '(' + status + ')');
  saveAsSuccessProc(ApiProgramInfo.getTargetProc(), progName); // prgwin
  ApiProgramInfo.init();
}
// Callback of Select(Change) rename program when saveas program.
function selRenameSaveASCB(status, progName) {
  debug(DBGINFO, 'Change(rename) program:' + progName + '(' + status + ')');
  renameSaveAsSuccessProc(originSaveAsName, progName); // prgwin
  ApiProgramInfo.setTargetProc('');
}
// Callback of Select(Change) rename program.
function selRenameProgramCB(status, progName) {
  debug(DBGINFO, 'Change(rename) program:' + progName + '(' + status + ')');
  dispOffWaiting();
  renameSuccessProc(ApiProgramInfo.getTargetProc(), progName); // prgwin
  ApiProgramInfo.setTargetProc('');
}
// Callback of rename error proc.
function renameErrorCB() {
  dispOffWaiting();
  ApiProgramInfo.setTargetProc('');
}
// Callback of set saveas visible attribute.
function setAttrSaveAsVisibleCB(status, progName) {
  var cbArg = {};
  cbArg.func = selSaveASProgramCB;
  chgProg(getProdProgName(progName), waitChgProgComplete, cbArg); // Select the saved program.
}
// Callback of set rename visible attribute.
function setAttrRenameVisibleCB(status, progName) {
  var cbArg = {};
  cbArg.func = selRenameProgramCB;
  chgProg(getProdProgName(progName), waitChgProgComplete, cbArg); // Select the saved program.
}
// Callback of set visible attribute when rename for save.
function setAttrVisibleCB(status, progName) {
  debug(DBGINFO, 'Change attribute to visible. status(' + status + ')');
  // Save complete!
  removeEditProgramFile(getTempProgName(progName)); // remove edit program name from list
  var cbArg = {};
  cbArg.func = selSavedProgramCB;
  chgProg(getProdProgName(progName), waitChgProgComplete, cbArg); // Select the saved program.
}
// Callback of get modify time new program.
function getNewModifyTimeCallback(status, progName, varName, modifyTime) {
  debug(DBGDUMP, 'NewProg(' + progName + ') modify time is [' + modifyTime + ']');
  progModifyTime = modifyTime; // prgwin
  // Attribute edit dialog call.
  if (dispAttrDlgFlag) {
  editAttrDlg.open(null, '#editattrdlg', false); // Get program attribute
  } else {
    saveattribute();
  }
}
// Callback of change program to new program.
function changeNewProgCB(status, progName) {
  debug(DBGINFO, 'Change program:' + progName + '(' + status + ')');
  // Set attribute to invisible...
  // [Modify] (4/20/2018) Req. from F. Comment out!
  //          The production program does not set invisibility attribute.
  //if (!dispTempFile) setAttr(getTempProgName(progName), top.MM_CONTROL_C, "1", setAttrInvisibleCB);
  getModifyTime(progName, getNewModifyTimeCallback);
}
// Callback of create new program.
function createPrgCB(status, progName) {
  debug(DBGINFO, 'Create. progName=' + progName);
  if (status != 0) {
    debug(DBGERROR, 'Create error occurred. status=(' + status + ')');
    handle_error(status);
  }
  addEditProgramFile(progName); // Append to edit program list
  setNewEditProgram(true); // Set program condition to new-program.
  var cbArg = {};
  if (isScrModeProgAttr()) {  // Screen is Tablet mode program/attribute.
    cbArg.func = showAttrDlg;
  } else {
    // Set not to add '*' to the program name of the status line.
    cbArg.func = changeNewProgCB;
  }
  chgProg(getProdProgName(progName), waitChgProgComplete, cbArg);
}
// Create new program.
function createProgramFile(progName) {
  // [Modify] (4/20/2018) Req. from F. Create Main Program File
  //createPrg(getTempProgName(progName), createPrgCB);	// Create tempolary file
  createPrg(progName, createPrgCB);
}

/* Escape special character */
function apiEscape(progText) {
  var newProgText = '';
  if (progText != undefined) { // exist data...
    for (var txtIdx = 0; txtIdx < progText.length; txtIdx++) {
      var textChar = progText.charAt(txtIdx);
      if (textChar == '%') {
        newProgText += '%25';
      } else if (textChar == '+') {
        newProgText += '%2b';
      } else if (textChar === ' ') {
        newProgText += '%20';
        // newProgText += textChar;
      } else {
        newProgText += textChar;
      }
    }
  }
  return newProgText;
}

// Position data array
var PositionLineData = (function () {
  var text = []; // Position data text string array
  var index = 0; // Position data array index
  return {
    init: function () {
      text = [];
      index = 0;
    },
    set: function (txt, idx) {
      text = txt;
      index = idx;
    },
    getText: function () {
      return text;
    },
    getTargetLine: function () {
      return text[index];
    },
    getIndex: function () {
      return index;
    },
    incIndex: function () {
      index++;
    }
  };
})();

// Editor window (Codemirror) scroll position info.
var EditScrollPosInfo = (function () {
  var pos = {};
  return {
    init: function () {
      pos = {};
    },
    setPos: function (posData) {
      pos = posData;
    },
    getPos: function () {
      return pos;
    },
    isEmptyPos: function () {
      return !Object.keys(pos).length;
    }
  };
})();

// ----- Filter process for copy edit program file.
// temporary save for copy edit program file...
var EditLineInfo = (function () {
  var text = '';
  var num = 1;
  var writeMode = PRGWRITE_OVW;
  return {
    init: function () {
      text = '';
      num = 1;
      writeMode = PRGWRITE_OVW;
    },
    set: function (txt, no, mode) {
      text = txt;
      num = no;
      writeMode = mode;
    },
    getText: function () {
      return text;
    },
    getNum: function () {
      return num;
    },
    getWriteMode: function () {
      return writeMode;
    }
  };
})();

// Waiting process animation.
function dispOffWaiting() {
  if ($('#waiting').length > 0) {
    $('#waiting').hide(); // no need?
    $('#waiting').remove();
  }
}

function dispOnWaiting() {
  if ($('#waiting').length > 0) {
    return;
  }
  var popupFrame = $('<div>', { id: 'waiting' });
  popupFrame.css({
    'position': 'absolute',
    'left': '50%',
    'top': '20%',
    'margin-left': '-20px;'
  });
  var waitingImage = $('<img>', { id: 'waitimg', 'src': 'images/waitnotice.gif' });
  popupFrame.append(waitingImage);
  $('body').append(popupFrame);
}

// Watch dog status
var watchStatus = 0;
function setWatchStatus() {
  watchStatus = 1;
}
function resetWatchStatus() {
  watchStatus = 0;
}
// for Delete lines
function mkEditProg_delLines(progName, start, lines, cbArg) {
  var wdTimer_delLines = null;
  if (watchStatus == 1) { // Watch status is ongoing.
    wdTimer_delLines = setTimeout(function () {
      mkEditProg_delLines(progName, start, lines, cbArg);
    }, 100);
  } else {
    clearTimeout(wdTimer_delLines);
    wdTimer_delLines = null;
    delLine(getTempProgName(progName), start, lines, deleteEditLineCallback, cbArg);
  }
}
// for Edit line
function mkEditProg_editLine(progName, editInfo, callback) {
  var wdTimer_editLine = null;
  if (watchStatus == 1) { // Watch status is ongoing.
    wdTimer_editLine = setTimeout(function () {
      mkEditProg_editLine(progName, editInfo, callback);
    }, 100);
  } else {
    clearTimeout(wdTimer_editLine);
    wdTimer_editLine = null;
    beforeEditPrg(getTempProgName(progName), editInfo, callback);
  }
}
// for set line
function mkEditProg_setLine(progName, cb_arg) {
  var wdTimer_setLine = null;
  if (watchStatus == 1) { // Watch status is ongoing.
    wdTimer_setLine = setTimeout(function () {
      mkEditProg_setLine(progName, cb_arg);
    }, 100);
  } else {
    clearTimeout(wdTimer_setLine);
    wdTimer_setLine = null;
    recPos(getTempProgName(progName), cb_arg.rec.rowno, cb_arg.rep, top.TXML_TP_REC_TYPE, cb_arg.grp, recPosCallback, cb_arg); // common_io
  }
}
// for Put position data
function mkEditPos_putPosRow(progName, editPosRowText) {
  var wdTimer_putPos = null;
  if (watchStatus == 1) { // Watch status is ongoing.
    wdTimer_putPos = setTimeout(function () {
      mkEditPos_putPosRow(progName, editPosRowText);
    }, 100);
  } else {
    clearTimeout(wdTimer_putPos);
    wdTimer_putPos = null;
    editPos(getTempProgName(progName), editPosRowText, putPosRowCallback);
  }
}
// for Delete position row
function mkEditPos_delPosRow(progName, posRowNum) {
  var wdTimer_delPos = null;
  if (watchStatus == 1) { // Watch status is ongoing.
    wdTimer_delPos = setTimeout(function () {
      mkEditPos_delPosRow(progName, posRowNum);
    }, 100);
  } else {
    clearTimeout(wdTimer_delPos);
    wdTimer_delPos = null;
    delPos(getTempProgName(progName), posRowNum, delPosRowCallback);
  }
}

// Callback of delete line.
function deleteEditLineCallback(status, progName, lineNum, num, cbArg) {
  debug(DBGDUMP, 'deleteEditLine : target row (' + lineNum + ')');
  debug(DBGDUMP, 'deleteEditLine : status (' + status + ')');
  if (status != 0) { // Error has occurd.
    handle_error(status);
    // Put error dialog...
    defineDialog.open(null, '#edtalertdlg', 'dlgMsgSaveErr');
    return;
  }
  previousLineCnt = currentLineCnt;
  if (pltEditCmd.isProcess) {
    pastePalletizingModify(cbArg.buildCmd, cbArg.csrPos); // progwin
    return;
  }
  saveEditLine();
}

function deleteEditLines(progName, startLine, lineCount, cbArg) {
  deleteStartLine = startLine;
  deleteLineCount = lineCount;
  if (!isExistEditProgramFile(getTempProgName(progName))) {
    // program copy to edit program file.
    copyProductToEditProg(getProdProgName(progName))
    mkEditProg_delLines(progName, deleteStartLine, deleteLineCount, cbArg);
    return;
  }
  delLine(getTempProgName(progName), startLine, lineCount, deleteEditLineCallback, cbArg);
}

// Callback of Insert line
function insertLineCallback(status, progName) {
  debug(DBGDUMP, 'insertEditLine status: (' + status + ')');
  if (status != 0) {
    //handle_error(status);
    handleErrorString(status, putIFErrorDialog, '#edtalertdlg', 'dlgMsgPrgLineErr');
    // Put error dialog...
    //defineDialog.open(null, '#edtalertdlg', 'dlgMsgPrgLineErr');
    return;
  }
  getEditorDoc().clearHistory(); // Clears the editor's undo history.
  InsertEditInfo.setSaved(true);  // prgwin
  InsertEditInfo.incIndex();
  if (InsertEditInfo.getIndex() < InsertEditInfo.getLength()) {
    constuctEditLine(progName);
    return;
  }
  InsertEditInfo.init();
  copiedEditLines.length = 0; // prgwin
  saveSuccessProc();
}
// Insert editor line
function insertEditLine(progName, targetLine, writeMode, lineText) {
  debug(DBGDUMP, 'insertEditLine: line data  (' + lineText + ')');
  debug(DBGDUMP, 'insertEditLine: target row (' + targetLine + ')');
  debug(DBGDUMP, 'insertEditLine: writeMode  (' + writeMode + ')');
  if (isMultiCmdPaste(lineText)) {
    debug(DBGWARN, 'Multiple Command paste.');
    defineDialog.open(null, '#mltcmddlg', 'dlgMltCmdPaste');
    return;
  }
  EditLineInfo.set(lineText, targetLine, writeMode);
  if (!isExistEditProgramFile(getTempProgName(progName))) {
    // program copy to edit program file.
    copyProductToEditProg(getProdProgName(progName))
    mkEditProg_editLine(progName, EditLineInfo, insertLineCallback);
    return;
  }
  beforeEditPrg(getTempProgName(progName), EditLineInfo, insertLineCallback);
}
// Construction and transmission of line saved data.
function constuctEditLine(progName) {
  var insLine = InsertEditInfo.getTargetLine();
  var targetRow = insLine.tgtRow;
  var writeMode = insLine.opt_sw;
  var lineData = insLine.insData;
  if ((lineData == undefined) || // Not exist line data.
    (lineData.trim().length == 0)) {
    lineData = '';
  }
  insertEditLine(progName, targetRow, writeMode, lineData); // see above
}
// Callback for put edit line.
function editLineCallback(status, progName) {
  debug(DBGDUMP, 'putProgramLine status: (' + status + ')');
  if (status != 0) {
    //handle_error(status);
    EditScrollPosInfo.setPos(getPcEditor().getScrollInfo());
    if (blurSaveFlag == true) {
      blurSaveFlag == false;
      issaveeditline = false;
      setReadOnly(false);
      setModifiedText(true);
      turnoffPopup();
      // Put error dialog...
      defineDialog.open(null, '#edtalertdlg', 'dlgMsgPrgLineErr');
      return;
    } else {
      handleErrorString(status, putIFErrorDialog, '#edtalertdlg', 'dlgMsgPrgLineErr');
      if (saveEditLineTimer != null) {
        clearTimeout(saveEditLineTimer);
        saveEditLineTimer = null;
      }
      // Put error dialog...
      //defineDialog.open(null, '#edtalertdlg', 'dlgMsgPrgLineErr');
      return;
    }
  }
  // call insert line
  if (InsertEditInfo.getLength() > 0) {
    constuctEditLine(getCurrentProgram());
    return;
  }
  saveSuccessProc();
}
// Callback for put pre-paste proc.
function prePstLineCallback(status, progName) {
  debug(DBGDUMP, 'prePstLine status: (' + status + ')');
  if (status != 0) {
    //handle_error(status);
    handleErrorString(status, putIFErrorDialog, '#edtalertdlg', 'dlgMsgPrgLineErr');
    //defineDialog.open(null, '#edtalertdlg', 'dlgMsgPrgLineErr');
    return;
  }
  saveSuccessPrePaste();
}

/* Callback function. (change program again (reselect)) */
function reselectProgramCallback(status, progName) {
  debug(DBGDUMP, 'chgProg(reselectProgram): status(' + status + ')');
}
/* Callback of complete renamePrg for save program. */
function renProgCallback(status, progName, cbArg) {
  debug(DBGDUMP, 'renamePrg: status(' + status + ')');
  if (status != 0) { // rename error eq save error...
    handle_error(status);
    dispOffWaiting();
    defineDialog.open(null, '#savealertdlg', 'dlgMsgSaveErr');
    // If the list has been changed, restore it.
    restoreProgramList(getProdProgName(progName));
    return;
  }
  // Set attribute to visible...
  setAttr(getProdProgName(progName), top.MM_CONTROL_C, "0", setAttrVisibleCB);
}
/* Callback to delete edit file for save as program. */
function delProgSaveAsCallback(status, progName) {
  debug(DBGDUMP, 'deletePrg: status(' + status + ')');
  if (status != 0) { // ignore delete error...
    handle_error(status);
    dispOffWaiting();
  }
  removeEditProgramFile(getTempProgName(ApiProgramInfo.getTargetProc())); // remove edit program name from list
  setAttr(getProdProgName(ApiProgramInfo.getSaveName()), top.MM_CONTROL_C, "0", setAttrSaveAsVisibleCB);
}
// Callback of Rename (Temp to Temp) complete.
function renameReplaceProgCallback(status, progName, cbArg) {
  debug(DBGDUMP, 'renameReplacePrg: status(' + status + ')');
  if (status != 0) { // rename error eq save error...
    handle_error(status);
    dispOffWaiting();
    defineDialog.open(null, '#savealertdlg', 'dlgMsgSaveErr');
    return;
  }
  // Set attribute to visible...
  removeEditProgramFile(getTempProgName(cbArg.currentName)); // remove edit program name from list
  setAttr(getProdProgName(progName), top.MM_CONTROL_C, "0", setAttrRenameVisibleCB);
}
/* Callback to delete production program before save program. */
function delProgCallback(status, progName) {
  debug(DBGDUMP, 'deletePrg: status(' + status + ')');
  if (status != 0) {
    // It can not be deleted because it is in use elsewhere.
    if (status == IOSTAT_MEMO_044) {
      handle_error(status);
      dispOffWaiting();
      top.openCmpConfirm(webPage, window, 'savealertdlg', resources['dlgMsgAlreadyUse'], {btnData :{btn1:top.irpDlgBtnOC.btn1}}, true);
      if (isScrModeProgAttr() && (buttonName == 'saveAttrtab')) undoAttribute();
      // Since the program is unselected, select it again.
      var cbArg = {};
      cbArg.func = reselectProgramCallback;
      chgProg(getProdProgName(progName), waitChgProgComplete, cbArg);
      // If the list has been changed, restore it.
      restoreProgramList(getProdProgName(progName));
      return;
    } else if (status == IOSTAT_MEMO_006) {
      handle_error(status);
      dispOffWaiting();
      top.openCmpConfirm(webPage, window, 'deleteprotecterr', resources['dlgMsgDelProtectErr'], {btnData:{btn1:top.irpDlgBtnYN.btn1}}, true);
      // Since the program is unselected, select it again.
      var cbArg = {};
      cbArg.func = reselectProgramCallback;
      chgProg(getProdProgName(progName), waitChgProgComplete, cbArg);
      // If the list has been changed, restore it.
      restoreProgramList(getProdProgName(progName));
      return;
    }
  }
  debug(DBGDUMP, "Call renamePrg():" + getTempProgName(progName) + " to " + progName);
  var cbArg = {};
  cbArg.currentName = progName;
  cbArg.targetName = progName;
  renamePrg(getTempProgName(progName), progName, renProgCallback, cbArg);
}

/* Callback function to delete program after change prog to empty */
function changeEmptyProgCallback(status, progName, cbArg) {
  debug(DBGDUMP, 'chgProg (Empty) called. progName=' + progName + '. status(' + status + ')');
  debug(DBGDUMP, "Call deletePrg():" + getProdProgName(cbArg.saveName));
  deletePrg(getProdProgName(cbArg.saveName), delProgCallback);
}
/* Callback to save as program */
function changeSaveAsProgCallback(status, progName, cbArg) {
  debug(DBGDUMP, 'chgProg (SaveAs) called. progName=' + progName + '. status(' + status + ')');
  debug(DBGDUMP, "Call copyPrg():" + getProdProgName(cbArg.saveName));
  ApiProgramInfo.setSaveName(cbArg.saveName);	// To use later.
  ApiProgramInfo.setTargetProc(cbArg.targetProc);
  saveAsCopyProgram(cbArg.targetProc, cbArg.saveName);
}
/* Callback to rename program */
function changeRenameProgCallback(status, progName, cbArg) {
  debug(DBGDUMP, 'chgProg (Rename) called. progName=' + progName + '. status(' + status + ')');
  debug(DBGDUMP, "Call renamePrg():" + getProdProgName(cbArg.saveName));
  ApiProgramInfo.setSaveName(cbArg.saveName);	// To use later.
  ApiProgramInfo.setTargetProc(cbArg.targetProc);
  renameReplaceProgram(cbArg.targetProc, cbArg.saveName); // api
}

// Temporary reference program names used in API.
var ApiProgramInfo = (function () {
  var saveProgramName = '';
  var targetProcProgName = '';

  return {
    init: function () {
      saveProgramName = '';
      targetProcProgName = '';
    },
    setSaveName: function (saveName) { saveProgramName = saveName; },
    setTargetProc: function (targetName) { targetProcProgName = targetName; },
    getSaveName: function () { return saveProgramName; },
    getTargetProc: function () { return targetProcProgName; }
  }
})();

/* Callback to edit position. */
function editPosCallback(status, progName) {
  debug(DBGDUMP, 'editPos called. status(' + status + ')');
  if (status != 0) {
    handle_error(status);
    // error dialog....
    dispOffWaiting();
    if (!isScrModeProgAttr()) {
      dispOffWaitExchange();
    }
    defineDialog.open(null, '#posalertdlg', 'dlgMsgPosErr');
    // If the list has been changed, restore it.
    restoreProgramList(getProdProgName(progName));
    return;
  }
  PositionLineData.incIndex();
  if (PositionLineData.getIndex() < PositionLineData.getText().length) {
    // I/F call
    editPos(progName, PositionLineData.getTargetLine(), editPosCallback);
    return;
  }
  if (!isScrModeProgAttr()) {
    dispOffWaitExchange();
  }
  programNonSelection(progName);
}
// create edit file
function editPosAsterCallback(status, progName) {
  debug(DBGDUMP, 'editPos called. status(' + status + ')');
  if (status != 0) {
    handle_error(status);
    // error dialog....
    dispOffWaiting();
    if (!isScrModeProgAttr()) {
      dispOffWaitExchange();
    }
    defineDialog.open(null, '#posalertdlg', 'dlgMsgPosErr');
    // If the list has been changed, restore it.
    restoreProgramList(getProdProgName(progName));
    return;
  }
  PositionLineData.incIndex();
  if (PositionLineData.getIndex() < PositionLineData.getText().length) {
    // I/F call
    editPos(progName, PositionLineData.getTargetLine(), editPosAsterCallback);
    return;
  }
  // programNonSelection(progName);
  if (!isScrModeProgAttr()) {
    dispOffWaitExchange();
  }
  getCreateTime(getTempProgName(progName), copyResetWatch); // get create time of edit program for save.
}
// copy SaveAs postion
function editPosSaveAsCallback(status, progName) {
  debug(DBGDUMP, 'editPos called. status(' + status + ')');
  if (status != 0) {
    handle_error(status);
    // error dialog....
    dispOffWaiting();
    if (!isScrModeProgAttr()) {
      dispOffWaitExchange();
    }
    defineDialog.open(null, '#posalertdlg', 'dlgMsgPosErr');
    // If the list has been changed, restore it.
    restoreProgramList(getProdProgName(progName));
    return;
  }
  if (srcPosNum < posDataText.length) {
    // I/F call
    editPos(progName, posDataText[srcPosNum], editPosSaveAsCallback);
    srcPosNum++;
    return;
  }
  srcPosNum = 0;
  if (!isScrModeProgAttr()) {
    dispOffWaitExchange();
  }
  saveAsComp(progName);
}

// Change program to empty name.
function programNonSelection(progName) {
  // Rename temporaly file (edit file) to production file
  var cbArg = {};
  cbArg.func = changeEmptyProgCallback;
  cbArg.saveName = progName;
  chgProg('', waitChgProgComplete, cbArg);
}

// Save as process.
function saveAsProgram(currentProg, saveAsProgName) {
  // Copy current program to specified program, and temporaly file to specified name.
  var cbArg = {};
  cbArg.func = changeSaveAsProgCallback;
  cbArg.saveName = saveAsProgName;
  cbArg.targetProc = currentProg;
  chgProg('', waitChgProgComplete, cbArg);
}
// Rename process.
function renameProgram(currentProg, renameProgName) {
  // Copy current program to specified program, and temporaly file to specified name.
  var cbArg = {};
  cbArg.func = changeRenameProgCallback;
  cbArg.saveName = renameProgName;
  cbArg.targetProc = currentProg;
  chgProg('', waitChgProgComplete, cbArg);
}

/*
   mode : edit mode
          0=Overwrite, 1=Insert to specified line, 2=Insert after specified line
*/
function putProgramLine(progName, lineNum, mode, lineData) {
  // Overwrite the specified line.
  debug(DBGDUMP, 'putProgramLine: line data  (' + lineData + ')');
  debug(DBGDUMP, 'putProgramLine: target row (' + lineNum + ')');
  debug(DBGDUMP, 'putProgramLine: writeMode  (' + mode + ')');
  EditLineInfo.set(lineData, lineNum, mode);
  if (!isExistEditProgramFile(getTempProgName(progName))) {
    // program copy to edit program file.
    copyProductToEditProg(getProdProgName(progName))
    mkEditProg_editLine(progName, EditLineInfo, editLineCallback);
    return;
  }
  beforeEditPrg(getTempProgName(progName), EditLineInfo, editLineCallback);
}
// pre process for paste, when modified text.
function putPrePasteLine(progName, lineNum, mode, lineData) {
  // Overwrite the specified line.
  debug(DBGDUMP, 'putPrePasteLine: line data  (' + lineData + ')');
  debug(DBGDUMP, 'putPrePasteLine: target row (' + lineNum + ')');
  debug(DBGDUMP, 'putPrePasteLine: writeMode  (' + mode + ')');
  EditLineInfo.set(lineData, lineNum, mode);
  if (!isExistEditProgramFile(getTempProgName(progName))) {
    // program copy to edit program file.
    copyProductToEditProg(getProdProgName(progName))
    mkEditProg_editLine(progName, EditLineInfo, prePstLineCallback);
    return;
  }
  beforeEditPrg(getTempProgName(progName), EditLineInfo, prePstLineCallback);
}

/*
    for multiple lines paste
    mode : edit mode
          0=Overwrite, 1=Insert to specified line, 2=Insert after specified line
*/
function pasteProgramLine(progName, lineNum, mode, lineData) {
  // Overwrite the specified line.
  debug(DBGDUMP, 'pasteProgramLine: line data  (' + lineData + ')');
  debug(DBGDUMP, 'pasteProgramLine: target row (' + lineNum + ')');
  debug(DBGDUMP, 'pasteProgramLine: writeMode  (' + mode + ')');
  EditLineInfo.set(lineData, lineNum, mode);
  if (!isExistEditProgramFile(getTempProgName(progName))) {
    // program copy to edit program file.
    copyProductToEditProg(getProdProgName(progName))
    mkEditProg_editLine(progName, EditLineInfo, updateMultiLineCallback);
    return;
  }
  beforeEditPrg(getTempProgName(progName), EditLineInfo, updateMultiLineCallback);
}

/*
  for multiple lines paste or multiple lines select to paste
*/
var PasteLineInfo = (function () {
  var srcLine = 0;
  var srcArray = [];
  var selectTargetLines = 0; // select line count
  var pasteDstInfo = {};
  return {
    getSrcLine: function () { return srcLine; },
    setSrcLine: function (line) { srcLine = line; },
    incSrcLine: function () { srcLine++; },
    getSrcArray: function () { return srcArray; },
    setSrcArray: function (array) { srcArray = array; },
    getSrcArrayLength: function () { return srcArray.length; },
    getPasteSrc: function () { return srcArray[srcLine]; },
    getTargetLines: function () { return selectTargetLines; },
    setTargetLines: function (lines) { selectTargetLines = lines; },
    getDstInfo: function () { return pasteDstInfo; },
    setDstInfo: function (dst) { pasteDstInfo = $.extend({}, dst); }
  }
})();

// Callback of delete select line at paste.
function deleteDstSelLinesCallback(status, progName, lineNum) {
  debug(DBGDUMP, 'deleteDstSelLines : target row (' + lineNum + ')');
  debug(DBGDUMP, 'deleteDstSelLines : status (' + status + ')');
  if (status != 0) { // Error has occurd.
    handle_error(status);
    // Put error dialog...
    top.openCmpConfirm(webPage, window, '#edtalertdlg', resources['dlgMsgSaveErr'], {btnData :{ btn1 : top.irpDlgBtnOC.btn1 }}, true);
    return;
  }
  pasteSuccessProc();
}
// Delete excess lines when pasting multiple lines.
function deleteDstSelLines(progName, startLine, lineCount) {
  delLine(getTempProgName(progName), startLine, lineCount, deleteDstSelLinesCallback);
}
// Callback of update multi row when paste process.
function updateMultiLineCallback(status, progName) {
  debug(DBGDUMP, 'updateMultiLine status: (' + status + ')');
  if (status != 0) { // save error...
    dispOffWaiting();
    handle_error(status);
    // Performs a dedicated palletizing process when a command insertion error occurs.
    if (pltEditCmd.isProcess) {
      delLine(progName, pltEditCmd.startLine + 1, pltEditCmd.lineNum);
      defineDialog.open(null, '#pltcmdsaveerr', 'dlgMsgPrgLineErr');
      $("#pltcmdsaveerr").css({ "z-index": "10003" });
      pltEditCmd.isProcess = false;
      setReadOnly(false);
      return;
    }
    EditScrollPosInfo.setPos(getPcEditor().getScrollInfo());
    defineDialog.open(null, '#pstalertdlg', 'dlgMsgIlgCopy');
    // If the list has been changed, restore it.
    restoreProgramList(getProdProgName(progName));
    return;
  }
  pasteCursorPos = 1;
  afterPastePos.line = PasteLineInfo.getDstInfo().startRow + PasteLineInfo.getSrcLine();
  try {
    var split = PasteLineInfo.getPasteSrc().str.split('\r\n');
  } catch (error) {
    alert("updateMultiLineCallback err!");
    console.log("PasteLineInfo", PasteLineInfo);
    console.log("getPasteSrc", PasteLineInfo.getPasteSrc());
  }

  var splitCh = split[0].length + 1;
  afterPastePos.ch = splitCh;
  PasteLineInfo.incSrcLine();
  currentEditPos.line++;
  // Performs a dedicated palletizing process when a command insertion error occurs.
  if (pltEditCmd.isProcess) {
    pltEditCmd.lineNum++;
  }
  // There is still the rest.
  if ((PasteLineInfo.getSrcLine() < PasteLineInfo.getSrcArrayLength())) {
    multiRowPaste(false, null); // prgwin
    return;
  }
  if ((!isNewEditProgram()) && (PasteLineInfo.getTargetLines() == 0)) {
    PasteLineInfo.setTargetLines(1);
  }
  // Paste finish. Check select target(destination) line range.
  if (PasteLineInfo.getTargetLines() > 0) {
    deleteDstSelLines(getCurrentProgram(), PasteLineInfo.getDstInfo().startRow + PasteLineInfo.getSrcLine(), PasteLineInfo.getTargetLines());
    return;
  }
  // Performs a dedicated palletizing process when a command insertion error occurs.
  pltEditCmd.isProcess = false;
  pasteSuccessProc();
}
// Update multi row when paste process.
function updateMultiLine(apiStr, pasteLineNum, mode) {
  EditLineInfo.set(apiStr, pasteLineNum, mode);
  var progName = getCurrentProgram();
  if (!isExistEditProgramFile(getTempProgName(progName))) {
    // program copy to edit program file.
    copyProductToEditProg(getProdProgName(progName))
    mkEditProg_editLine(progName, EditLineInfo, updateMultiLineCallback);
    return;
  }
  beforeEditPrg(getTempProgName(progName), EditLineInfo, updateMultiLineCallback);
}
// Delete diff line when saving. (Call from fileio)
function deleteProgLine(progName, line, count, callback, cbArg) {
  delLine(progName, line, count, callback, cbArg);  // io
}
// Pre process of editPrg. Add semi colon and escape.
function beforeEditPrg(progName, editInfo, callback, cbArg) {
  var lineData = editInfo.getText();
  var lineNum = editInfo.getNum();
  var writeMode = editInfo.getWriteMode();
  lineData = exceptEndEmp(lineData);
  if (lineData[lineData.length - 1] != ';') {
    lineData = lineData + ';';
  } else {
    var endCh = lineData.length;
    var replaceData = lineData.substr(0, lineData.length - 1);
    var checkData = ((replaceData == "") ? ';' : replaceData);
    var blankCnt = (getPcEditor().getLine(lineNum - 1).indexOf(checkData));
    getPcEditor().replaceRange(replaceData, CodeMirror.Pos(lineNum - 1, blankCnt), CodeMirror.Pos(lineNum - 1, endCh + blankCnt));
  }
  lineData = apiEscape(lineData);
  editPrg(progName, lineData, lineNum, writeMode, callback, cbArg);
}
/**
 * Read program for Compare to save.
 * (IN) progName : Program name without extention. (String)
 */
function readProgramForCompare(progName, callback) {
  // Save file.
  progSaveLine = 0;
  // === Write again if there is a different line or position. ===
  // reload edit file.
  dispOnWaiting();
  var progFile = addProgramExtension(progName);
  loadFile(progFile, callback);
}

/**
 * Put position data.
 * (IN) progName : Program name without extention. (String)
 */
function putProgramPosition(progName) {
  // 2nd. position text...
  var posText = ProgramInfoManager.getSpecifiedProgInfo(progName).getEditPositionArray(); // proginfo
  PositionLineData.set(posText, 0);
  if (Object.keys(posText).length > 0) { // Position data is exist
    if (!isScrModeProgAttr()) {
      dispOnWaitExchange();
    }
    // I/F call
    editPos(getTempProgName(progName), PositionLineData.getTargetLine(), editPosCallback);
  } else {
    // Rename temporaly file (edit file) to production file
    programNonSelection(getProdProgName(progName));
  }
}
function putbeforSaveasProgPos(progName, saveParam) {
  // 2nd. position text...
  var posText = ProgramInfoManager.getSpecifiedProgInfo(progName).getEditPositionArray(); // proginfo
  PositionLineData.set(posText, 0);
  if (Object.keys(posText).length > 0) { // Position data is exist
    if (!isScrModeProgAttr()) {
      dispOnWaitExchange();
    }
    // I/F call
    editPos(getTempProgName(progName), PositionLineData.getTargetLine(), editPosCallback);
  } else {
    var crntProgName = (isExistEditProgramFile(getTempProgName(getCurrentProgram()))) ?	// exist edit file, use one.
      getTempProgName(getCurrentProgram()) : getProdProgName(getCurrentProgram());
    saveAsProgram(crntProgName, saveParam.progname);	// Save as process. api
  }
}
function putbeforRenameProgPos(progName, saveParam) {
  // 2nd. position text...
  var posText = ProgramInfoManager.getSpecifiedProgInfo(progName).getEditPositionArray(); // proginfo
  PositionLineData.set(posText, 0);
  if (Object.keys(posText).length > 0) { // Position data is exist
    if (!isScrModeProgAttr()) {
      dispOnWaitExchange();
    }
    // I/F call
    editPos(getTempProgName(progName), PositionLineData.getTargetLine(), editPosCallback);
  } else {
    if (isExistEditProgramFile(getTempProgName(progName))) {
      programNonSelection(progName);
    } else {
      renameProgram(getProdProgName(getCurrentProgram()), saveParam.progname);	// Rename process. api
    }
  }
}
// create asterisk file position
function putAsterPosition(progName) {
  // 2nd. position text...
  var progInfo = ProgramInfoManager.getSpecifiedProgInfo(progName);
  // var posText = progInfo.getProgPositionArray(); // fileio
  var posTextArray = updatePositionText(progInfo); // fileio
  PositionLineData.set(posTextArray, 0);
  if (posTextArray.length > 0) { // Position data is exist
    if (!isScrModeProgAttr()) {
      dispOnWaitExchange();
    }
    // I/F call
    editPos(getTempProgName(progName), PositionLineData.getTargetLine(), editPosAsterCallback);
  } else {
    // programNonSelection(getProdProgName(progName));
    getCreateTime(getTempProgName(progName), copyResetWatch); // get create time of edit program for save.
  }
}
/**
 * Put position row.
 * (IN) progName : Program name without extention. (String)
 * (IN) posRowText : Position data text. (LS format)
 */
function putPosRowCallback(status, progName) {
  debug(DBGDUMP, 'editPos callback status: (' + status + ')');
  if (status != 0) {
    handle_error(status);
    // error dialog....
    defineDialog.open(null, '#posalertdlg', 'dlgMsgPosErr');
    return;
  }
  posSaveComplete(); // poswin
}

function putPositionRow(progName, posRowText) {
  // Copy and use. It does not matter if the original variable is changed. maybe...
  var editPosRowText = posRowText;
  // Program is not exist. (Edit program file)
  if (!isExistEditProgramFile(getTempProgName(progName))) {
    // program copy to edit program file.
    copyProductToEditProg(getProdProgName(progName));
    mkEditPos_putPosRow(progName, editPosRowText);
    return;
  }
  // I/F call
  editPos(getTempProgName(progName), editPosRowText, putPosRowCallback);
}

/**
 * Delete specified row positoin data.
 * (IN) progName : Program name
 * (IN) posNo : Position row number
 */
// Callback
var deletePosInfo = {}; // Position delete informations
deletePosInfo.line = 0;
deletePosInfo.errorStat = 0;
deletePosInfo.list = [];
deletePosInfo.successCall = null;	// Function at the time of success.
deletePosInfo.afterCall = null;	// Function after deleting.
function delPosRowCallback(status, progName, posNo) {
  debug(DBGDUMP, 'delPosRow status.(' + status + ') target=' + posNo);
  if (status != 0x0) {
    if (status == IOSTAT_MEMO_188) {
      deletePosInfo.errorStat = status;
    } else {
      if (deletePosInfo.errorStat != IOSTAT_MEMO_188) {
        deletePosInfo.errorStat = status;
      }
    }
  } else {
    if (deletePosInfo.successCall != null) {
      deletePosInfo.successCall(deletePosInfo.list[deletePosInfo.line]); // Delete success, data clear.
    }
  }
  deletePosInfo.line++;
  if (deletePosInfo.line < deletePosInfo.list.length) {
    // I/F call
    delPos(getTempProgName(progName), deletePosInfo.list[deletePosInfo.line], delPosRowCallback);
    return;
  }
  if (deletePosInfo.errorStat != 0) {
    var msgResId = (deletePosInfo.errorStat == IOSTAT_MEMO_188) ? 'dlgMsgPosUse' : 'dlgMsgPosDelErr';
    defineDialog.open(null, '#posalertdlg', msgResId);
    deletePosInfo.errorStat = 0;
    return;
  }
  if (deletePosInfo.afterCall != null) {
    deletePosInfo.afterCall();
    deletePosInfo.line = 0;
    deletePosInfo.errorStat = 0;
    deletePosInfo.list = [];
  }
}
function delPositionRow(progName, posNoList, delSuccessFunc, delAfterFunc) {
  deletePosInfo.line = 0; // delete pos counter
  deletePosInfo.list = posNoList;
  deletePosInfo.successCall = delSuccessFunc;
  deletePosInfo.afterCall = delAfterFunc;
  // Program is not exist. (Edit program file)
  if (!isExistEditProgramFile(getTempProgName(progName))) {
    // program copy to edit program file.
    copyProductToEditProg(getProdProgName(progName));
    mkEditPos_delPosRow(progName, deletePosInfo.list[deletePosInfo.line]);
    return;
  }
  delPos(getTempProgName(progName), deletePosInfo.list[deletePosInfo.line], delPosRowCallback);
}

/**
 * Copy productoin program file to edit program file.
 * (IN) productName : original file name
 */
function copyProductToEditProg(productName) {
  // Call I/F
  setWatchStatus();
  copyPrg(getProdProgName(productName), getTempProgName(productName), copyProgCallback); // io
}
// Callback of copy prod to temp.
function copyProgCallback(status, src, dst) {
  debug(DBGINFO, 'Copy ' + src + ' to ' + dst + ' is ' + ((status == IO_SUCCESS) ? 'succeeded.' : 'failed.') + ' (' + status + ')');
  if (status == IO_SUCCESS) {
    addEditProgramFile(dst); // Append to edit program list
  }
  // --> Set edit program file attribute to invisible...
  if (!dispTempFile) setAttr(dst, top.MM_CONTROL_C, "1", setAttrInvisibleCB); // io.js
  var progInfo = ProgramInfoManager.getSpecifiedProgInfo(dst);
  updatePositionText(progInfo); // each position to array
  putAsterPosition(dst);
}
// Call after get create time.
// (To perform the next process after copying is complete.)
function copyResetWatch(status, progName, varName, createTime) {
  debug(DBGDUMP, 'copyResetWatch(' + progName + ') create time is [' + createTime + ']');
  progCreateTime = createTime; // prgwin
  top.sessionStorage.setItem("progCreateTime", createTime);
  resetWatchStatus();
}

/**
 * Copy current program file to specified program file.
 * (IN) productName : current file name
 * (IN) targetName  : specified program file.
 */
var originSaveAsName = "";
var srcPosNum = 0;
function saveAsCopyCallback(status, src, dst) {
  debug(DBGDUMP, 'SaveAs Copy ' + src + ' to ' + dst + ' is ' + ((status == IO_SUCCESS) ? 'succeeded.' : 'failed.') + ' (' + status + ')');
  originSaveAsName = src;
  resetWatchStatus();
  if (status != IO_SUCCESS) {
    handle_error(status);
    // error dialog....
    dispOffWaiting();
    top.openCmpConfirm(webPage, window, 'savealertdlg', resources['dlgMsgSaveErr'], {btnData :{btn1:top.irpDlgBtnOC.btn1}}, true);
    return;
  }
  var srcProgInfo = ProgramInfoManager.getSpecifiedProgInfo(originSaveAsName);
  srcProgInfo.changeProgName(dst);
  if (srcProgInfo.getProgPositionArray().length > 0) { // Position data is exist
    posDataText = makePosition(srcProgInfo, generateRecords(srcProgInfo.getProgPositionArray()));	// fileio
    if (posDataText.length == 0 || isScrModeProgAttr()) {
      saveAsComp(dst); // self
      return;
    }
    dispOnWaitExchange();
    // I/F call
    editPos(getProdProgName(dst), posDataText[srcPosNum], editPosSaveAsCallback);
  } else {
    saveAsComp(dst); // self
  }
}
function saveAsComp(inputName) {
  // Need to delete temp(Edit) file.
  if (isExistEditProgramFile(getTempProgName(originSaveAsName))) { // exist edit file, rename one.
    deletePrg(getTempProgName(originSaveAsName), delProgSaveAsCallback);
  } else {
    // Need to change attribute.
    setAttr(getProdProgName(inputName), top.MM_CONTROL_C, "0", setAttrSaveAsVisibleCB);
  }
}
// Callback of SaveAs when modify program is exist. (renamePrg:io)
function renameSaveAsCB(status, dst, cbArg) {
  resetWatchStatus();
  if (status != IO_SUCCESS) { // target file rename OK?
    debug(DBGERROR, 'resetReplaceCallBack: dst=' + dst + '; status=' + status);
    handle_error(status);
    // error dialog....
    top.openCmpConfirm(webPage, window, 'savealertdlg', resources['dlgMsgSaveErr'], {btnData :{btn1:top.irpDlgBtnOC.btn1}}, true);
    return;
  }
  chgProg(getProdProgName(dst), waitChgProgComplete, cbArg); // Select the saved program.
}
// Callback of Rename Replace Program. (renamePrg:io)
function renameReplaceCallback(status, dst, cbArg) {
  resetWatchStatus();
  // The specified program does not exist.
  if (status == IOSTAT_MEMO_073) {
    var btnObj = {
      btnData :{ btn1 : top.irpDlgBtnOC.btn1 },
      btn1Cb : refleshProgList
    };
    top.openCmpConfirm(webPage, window, 'alreadydelerrdlg', resources['dlgMsgAlreadyDelError'], btnObj, true);
    return;
  }
  if (status != IO_SUCCESS) { // target file rename OK?
    if (isScrModeProgAttr()) {
      initBackUpProg();
    }
    debug(DBGERROR, 'resetReplaceCallBack: dst=' + dst + '; status=' + status);
    handle_error(status);
    // Show error dialog and restore empty program.
    cbArg.func = renameErrorCB;
    top.openCmpConfirm(webPage, window, 'savealertdlg', resources['dlgMsgSaveErr'], {btnData :{btn1:top.irpDlgBtnOC.btn1}}, true);
    var progMain = ProgramInfoManager.getMainProgInfo();
    var progName = progMain.getProgName();
    chgProg(getProdProgName(progName), waitChgProgComplete, cbArg);
    return;
  }
  if (isExistEditProgramFile(getTempProgName(cbArg.currentName))) { // exist edit file, rename one.
    renamePrg(getTempProgName(cbArg.currentName), getTempProgName(dst), renameReplaceProgCallback, cbArg);
  } else {
    cbArg.func = selRenameProgramCB;
    chgProg(getProdProgName(dst), waitChgProgComplete, cbArg); // Select the saved program.
  }
}
// Save as target name. (Copy -> Rename)
function saveAsCopyProgram(currentName, targetName) {
  // Call I/F
  setWatchStatus();
  copyPrg(currentName, targetName, saveAsCopyCallback); // io
}
// Rename Program after change prog.
function renameReplaceProgram(currentName, targetName) {
  // Call I/F
  setWatchStatus();
  var cbArg = {};
  cbArg.targetName = targetName;
  cbArg.currentName = currentName;
  renamePrg(currentName, targetName, renameReplaceCallback, cbArg); // io
}

// Delete edit file for discard change.
function discardProgCallback(status, progName) {
  if (status != IO_SUCCESS) {
    debug(DBGERROR, 'discardProgCallBack: progName=' + progName + '; status=' + status);
    handle_error(status);
  }
  tempFileDiscarded(progName); // prgwin
}
// Callback of Change program before delete.
function changeDiscardProgCallback(status, progName, cbArg) {
  if (status != IO_SUCCESS) {
    debug(DBGERROR, 'changeDiscardProgCallBack: progName=' + progName + '; status=' + status);
    handle_error(status);
  }
  deletePrg(getTempProgName(cbArg.targetProc), discardProgCallback);
}
// Delete edit program file and reload production program file when save.
//  -> This program is edited in other than this editor.
//  -> Are you sure you want to discard changes made by this editor?
function discardEditProgram(progName) {
  var cbArg = {};
  cbArg.func = changeDiscardProgCallback;
  cbArg.targetProc = progName;
  chgProg('', waitChgProgComplete, cbArg);
}

// caution delete edit program
function cautionProgCallback(status, progName) {
  if (status != IO_SUCCESS) {
    debug(DBGERROR, 'cautionProgCallBack: progName=' + progName + '; status=' + status);
    handle_error(status);
  }
  tempFileCaution(progName); // prgwin
}

function changeCautionProgCallback(status, progName, cbArg) {
  if (status != IO_SUCCESS) {
    debug(DBGERROR, 'changeCautionCallBack: progName=' + progName + '; status=' + status);
    handle_error(status);
  }
  if (isExistEditProgramFile(getTempProgName(getCurrentProgram()))) {
    deletePrg(getTempProgName(getCurrentProgram()), cautionProgCallback);
  } else {
    tempFileCaution(progName); // prgwin
  }
  //deletePrg(getTempProgName(cbArg.targetProc()), cautionProgCallback);
}
// Delete edit program file and reload production program file when open program or create.
//   -> The changes is discarded.
function cautionEditProgram(progName) {
  ApiProgramInfo.setTargetProc(progName); // I can not find out who is using it, but I will leave it just in case.
  var cbArg = {};
  cbArg.func = changeCautionProgCallback;
  cbArg.targetProc = progName;  // Normally, it should be carried in this way...
  chgProg('', waitChgProgComplete, cbArg);
}

/*==========================================
 * File reload callback.
 */
// callback of get create time. Next draw program data.
function getCreateTimeCallback(status, progName, varName, createTime) {
  debug(DBGDUMP, 'Program(' + progName + ') create time is [' + createTime + ']');
  progCreateTime = createTime; // prgwin
  top.sessionStorage.setItem("progCreateTime", createTime);
  drawProgramData(getCurrentProgram(), changeProgCallback); // fileio
}
// call after reload. (after get modify time.)
function getModifyTimeCallback(status, progName, varName, modifyTime) {
  debug(DBGDUMP, 'Program(' + progName + ') modify time is [' + modifyTime + ']');
  progModifyTime = modifyTime; // prgwin
  getCreateTime(progName, getCreateTimeCallback); // Next get the creation date.
}
// call after reload when rename. (after get modify time.)
function renameModifyCallback(status, progName, varName, modifyTime) {
  debug(DBGDUMP, 'Rename progrem(' + progName + ') modify time is [' + modifyTime + ']');
  progModifyTime = modifyTime; // prgwin
  drawProgramData(progName, renameReloadedProgram); // fileio (prgwin)
}

/*==========================================
 * File attribute relationship.
 */
/*
* Get editable attribute.
*/
var afterGetAttribute = {}; // Attribute management data
function getFileAttrSubtypeCB(status, progType, subType) {
  if (status != IO_SUCCESS) { // get attribute OK?
    debug(DBGERROR, 'getFileAttrSubtypeCB: subType=' + subType + '; status=' + status);
    handle_error(status);
    // error dialog....
    //defineDialog.open(null, '#attralertdlg', 'dlgMsgFileErr');
    //return;
  }
  crntProgramAttr.SUBTYPE = subType;
  if (afterGetAttribute.reflect != null) {
    afterGetAttribute.reflect(afterGetAttribute.progName, afterGetAttribute.attrMode, crntProgramAttr);
  }
  afterGetAttribute = {};	// Initialize
}
function getFileAttrMotionGrpCB(status, progName, mmVarName, mmValue) {
  if (status != IO_SUCCESS) { // get attribute OK?
    debug(DBGERROR, 'getFileAttrMotionGrpCB: progName=' + progName + '; status=' + status);
    handle_error(status);
    // error dialog....
    //defineDialog.open(null, '#attralertdlg', 'dlgMsgFileErr');
    //return;
  }
  crntProgramAttr.MTNGRP = parseInt(mmValue);
  getPrgType(progName, getFileAttrSubtypeCB);
}
function getFileAttrPrtctCB(status, progName, mmVarName, mmValue) {
  if (status != IO_SUCCESS) { // get attribute OK?
    debug(DBGERROR, 'getFileAttrPrtctCB: progName=' + progName + '; status=' + status);
    handle_error(status);
    // error dialog....
    //defineDialog.open(null, '#attralertdlg', 'dlgMsgFileErr');
    //return;
  }
  crntProgramAttr.PROTECT = parseInt(mmValue);
  getAttr(progName, top.MM_DEF_GROUP_C, getFileAttrMotionGrpCB); // io.js
}
function getFileAttrPauseCB(status, progName, mmVarName, mmValue) {
  if (status != IO_SUCCESS) { // get attribute OK?
    debug(DBGERROR, 'getFileAttrPauseCB: progName=' + progName + '; status=' + status);
    handle_error(status);
    // error dialog....
    //defineDialog.open(null, '#attralertdlg', 'dlgMsgFileErr');
    //return;
  }
  crntProgramAttr.PAUSE = parseInt(mmValue);
  getAttr(progName, top.MM_PROTECT_C, getFileAttrPrtctCB); // io.js
}
function getFileAttrStackCB(status, progName, mmVarName, mmValue) {
  if (status != IO_SUCCESS) { // get attribute OK?
    debug(DBGERROR, 'getFileAttrStackCB: progName=' + progName + '; status=' + status);
    handle_error(status);
    // error dialog....
    //defineDialog.open(null, '#attralertdlg', 'dlgMsgFileErr');
    //return;
  }
  crntProgramAttr.STACK_SIZE = parseInt(mmValue);
  getAttr(progName, top.MM_IGNR_PAUS_C, getFileAttrPauseCB); // io.js
}
function getFileAttrCmntCB(status, progName, mmVarName, mmValue) {
  if (status != IO_SUCCESS) { // get attribute OK?
    debug(DBGERROR, 'getFileAttrCmntCB: progName=' + progName + '; status=' + status);
    handle_error(status);
    // error dialog....
    //defineDialog.open(null, '#attralertdlg', 'dlgMsgFileErr');
    //return;
  }
  crntProgramAttr.COMMENT = mmValue;
  getAttr(progName, top.MM_STACK_SIZE_C, getFileAttrStackCB); // io.js
}
// Start get attribute.
function getFileAttribute(progName, attrMode, reflectCall) {
  if (isExistEditProgramFile(getTempProgName(progName))) {
    progName = getTempProgName(progName);
  }
  crntProgramAttr = {};
  afterGetAttribute.progName = progName;
  afterGetAttribute.attrMode = attrMode;
  afterGetAttribute.reflect = reflectCall;
  getAttr(progName, top.MM_COMMENT_C, getFileAttrCmntCB); // io.js
}

/*
* Save (Editable) Program Attributes.
*/
var crntProgramAttr = {};
var afterSetAttrCall = null;
var reflectSetAttrVal = null;
var isStackSizeInput = false;
// Callback chain
function setAttrProtectCB(status, progName) {
  if (status != IO_SUCCESS) {
    handleErrorString(status, putIFErrorDialog, '#attralertdlg', 'dlgMsgSetAttrErr');
    return;
  }
  var progInfo = ProgramInfoManager.getSpecifiedProgInfo(progName);
  for (key in crntProgramAttr) {
    progInfo.putEditAttrValue(key, crntProgramAttr[key]);
  }
  if ((reflectSetAttrVal !== undefined) && (reflectSetAttrVal !== null)) {
    reflectSetAttrVal(crntProgramAttr);
  }
  if ((top.g_order.r792) || (ProgramApplManager.isLoadLineTrack()) || (top.g_order.wnsp)) {// Line Track Option
    if (crntProgramAttr.PROTECT != PROTECTON && progName != omitExtension(movementProgramName)) {// no read only and no moveto
      saveAppl(progName);
      return;
    }
  }
  if (!isScrModeProgAttr()) {
    refreshPosAreaLock(); // refresh posarea for group mask
  }
  if ((afterSetAttrCall !== undefined) && (afterSetAttrCall !== null)) {
    afterSetAttrCall(progName);
  }
}
function setLocalRegsCB(status, progName) {
  if (status != IO_SUCCESS) {
    handleErrorString(status, putIFErrorDialog, '#attralertdlg', 'dlgMsgSetAttrErr');
    return;
  }
  var protect = parseInt(crntProgramAttr.PROTECT, 10);
  if (protect == PROTECTON) {
    setAttr(progName, top.MM_PROTECT_C, protect, setAttrProtectCB); // io.js
  } else {
    setAttrProtectCB(status, progName);
  }
}
function setAttrPauseCB(status, progName) {
  if (status != IO_SUCCESS) {
    handleErrorString(status, putIFErrorDialog, '#attralertdlg', 'dlgMsgSetAttrErr');
    return;
  }
  if(isScrModeProgAttr()) {
    saveLocalRegs(progName, setLocalRegsCB);
  } else {
    setLocalRegsCB(status, progName);
  }
}
function setAttrMotinoGrpCB(status, progName) {
  if (status != IO_SUCCESS) {
    handleErrorString(status, putIFErrorDialog, '#attralertdlg', 'dlgMsgSetAttrErr');
    return;
  }
  setAttr(progName, top.MM_IGNR_PAUS_C, crntProgramAttr.PAUSE, setAttrPauseCB); // io.js
}
function setAttrSubtypeCB(status, progName) {
  if (status != IO_SUCCESS) {
    handleErrorString(status, putIFErrorDialog, '#attralertdlg', 'dlgMsgSetAttrErr');
    return;
  }
  setAttr(progName, top.MM_DEF_GROUP_C, crntProgramAttr.MTNGRP, setAttrMotinoGrpCB); // io.js
}
function setAttrStacksizeCB(status, progName) {
  if (status != IO_SUCCESS) {
    handleErrorString(status, putIFErrorDialog, '#attralertdlg', 'dlgMsgSetAttrErr');
    return;
  }
  chgPrgType(progName, crntProgramAttr.SUBTYPE, setAttrSubtypeCB); // io.js
}
function setAttrCommentCB(status, progName) {
  if (status != IO_SUCCESS) {
    handleErrorString(status, putIFErrorDialog, '#attralertdlg', 'dlgMsgSetAttrErr');
    return;
  }
  debug(DBGINFO, 'stack flag true');
  if (isStackSizeInput) {
    setAttr(progName, top.MM_STACK_SIZE_C, crntProgramAttr.STACK_SIZE, setAttrStacksizeCB); // io.js
  } else {
    chgPrgType(progName, crntProgramAttr.SUBTYPE, setAttrSubtypeCB); // io.js
  }
}
function clearProtectCB(status, progName) {
  if (status != IO_SUCCESS) {
    if (dispRefleshPopup(status)) return;
    handleErrorString(status, putIFErrorDialog, '#attralertdlg', 'dlgMsgSetAttrErr');
    return;
  }
  setAttr(progName, top.MM_COMMENT_C, crntProgramAttr.COMMENT, setAttrCommentCB); // io.js
}
function dispRefleshPopup(status) {
  if (isScrModeProgAttr() && status == IOSTAT_MEMO_073) { // The specified program does not exist.
    var btnObj = {
      btnData :{ btn1 : top.irpDlgBtnOC.btn1 },
      btn1Cb : refleshProgList
    };
    top.openCmpConfirm(webPage, window, 'alreadydelerrdlg', resources['dlgMsgAlreadyDelError'], btnObj, true);
    return true;
  }
  return false;
}
// Start(Main) save process.
function saveProgramAttribute(progName, progAttr, stackInput, afterCall, reflectCall) {
  crntProgramAttr = progAttr;
  afterSetAttrCall = afterCall;
  reflectSetAttrVal = reflectCall;
  isStackSizeInput = stackInput;
  if (isExistEditProgramFile(getTempProgName(progName))) {
    progName = getTempProgName(progName);
  } else {
    progName = getProdProgName(progName); // No *Prog, Product Prog name.
  }
  setAttr(progName, top.MM_PROTECT_C, PROTECTOFF, clearProtectCB); // io.js
}
// for Move to
function saveMovetoAttribute(progName, progAttr, afterCall) {
  debug(DBGDUMP, 'saveMovetoAttribute: progName=' + progName + ';');
  crntProgramAttr = progAttr;
  afterSetAttrCall = afterCall;
  setAttr(progName, top.MM_DEF_GROUP_C, crntProgramAttr.MTNGRP, setMovetoMotinoGrpCB); // io.js
}
function setMovetoMotinoGrpCB(status, progName) {
  debug(DBGDUMP, 'setMovetoMotinoGrpCB: progName=' + progName + '; status=' + status);
  if (status != IO_SUCCESS) {
    handleErrorString(status, null, '', '');
  }
  if (!isScrModeProgAttr()) {
    refreshPosAreaLock(); // poswin: refresh posarea for group mask
  }
  if ((afterSetAttrCall !== undefined) && (afterSetAttrCall !== null)) {
    afterSetAttrCall(progName);
  }
}

/*
 * Get Program Modify/Create time.
 * (IN) progName : Program name.
 * (IN) callback : A callback function.
 */
function getModifyTime(progName, callback) {
  getAttr(progName, top.MM_MDFY_TIME_C, callback); // io.js
}
function getCreateTime(progName, callback) {
  getAttr(progName, 6, callback); // io.js
}

/*==========================================
 * Append APPL data to specified program file.
 */

/*
 * Output of APPL data to program file.
 * (IN) progName : Program name. (With * if editing)
 * (IN) callback : Callback function.
 * (IN) cbArg : Callback argument.
 *              cbArg.applKey : APPL text keyword. (like a 'LINE_TRACK')(No need semicolon.)
 *              cbArg.applText : APPL text data.
 *              cbArg.some_argument : If you need other data, set it.
 */
function putApplDataToProgram(progName, callback, cbArg) {
  // load program file to append APPL text.
  var progFile = addProgramExtension(progName);
  var copiedArg = $.extend(true, {}, cbArg);
  copiedArg.progName = progName;
  copiedArg.call = callback;
  loadFile(progFile, loadForPutApplCallback, copiedArg);
}
/*
 * cbArg.progName : Program name. (With * if editing)
 *      .call : Callback function. (Call when completed)
 */
function loadForPutApplCallback(status, fileName, progLines, numLines, cbArg) {
  if (status != IO_SUCCESS) {
    if (cbArg.call != undefined) {
      dispOffWaiting();
      cbArg.call(status, cbArg);
      return;
    }
  }
  // Convert program text lines
  initConvertLines();
  convertLSData(progLines, numLines, setConvertLines); // common api.
  var callbackArg = { fileName: fileName, cbArg: cbArg };
  waitCnvTextComplete(loadForPutApplCnvCallback, callbackArg);
}
function loadForPutApplCnvCallback(callbackArg) {
  var cbArg = callbackArg.cbArg;
  var progTextLines = getConvertLines();
  // Search target keyword applKey
  var posTargetAppl = -1;
  var posTargetTerm = -1;
  var posMnBlock = -1;
  var detectTargetAppl = false;
  $(progTextLines).each(function (i, textLine) {
    if (textLine.indexOf(cbArg.applKey) >= 0) {
      // if target APPL, set status to detected.
      posTargetAppl = i;
      detectTargetAppl = true;
      for (var j = i; j < progTextLines.length; j++) {
        var applLine = progTextLines[j].trim();
        // if empty line, skip to next
        if (applLine.length == 0) {
          continue;
        }
        // check last word
        if (applLine.indexOf("/APPL") >= 0 || applLine.indexOf("/MN") >= 0) {
          posTargetTerm = j;
          posMnBlock = j;
          break;
        }
      }
      return false;
    }
  });
  // Make LocalRegisters for text
  for (var i = 0; i < progTextLines.length; i++) {
    if (progTextLines[i].indexOf(cbArg.localRegsKey) >= 0) {
      progTextLines[i] = cbArg.localRegsKey + cbArg.localRegsData;
      break;
    }
  }
  // Make APPL array from text
  if (cbArg.applText != "") {
    var applTextArray = cbArg.applText.split(/\r\n|\n/);
      // Remove target appl block if exist.
    if (detectTargetAppl) {
      var cntApplLines = posTargetTerm - posTargetAppl;
      progTextLines.splice(posTargetAppl, cntApplLines);
      posMnBlock -= cntApplLines;
    } else {
      for (var num = 0; num < progTextLines.length; num++){
        if (progTextLines[num].indexOf("/MN") >= 0) {
          posMnBlock = num;
        }
      }
    }

    // Appl text inert before /MN
    Array.prototype.splice.apply(progTextLines, [posMnBlock, 0].concat(applTextArray));
  }
  // change Program to empty.
  cbArg.text = progTextLines;
  cbArg.file = callbackArg.fileName;
  cbArg.func = chgApplEmptyCallback;
  chgProg('', waitChgProgComplete, cbArg);
}

/*
 * cbArg.text : Program (LS data) converted text.
 *      .file : File name for send.
 */
function chgApplEmptyCallback(status, progName, cbArg) {
  var lsText = manufactProgramText(cbArg.text);
  // Create File program.ls
  var blobLsObj = createBlob(lsText); // commonapi
  // send text data
  sendFile(cbArg.file, blobLsObj, sendLsCallback, cbArg);
}
// Text manufacturing with escape processing.
function manufactProgramText(inputLines) {
  var outputText = '';
  for (index in inputLines) {
    outputText += inputLines[index] + CODECRLF;
  }
  return outputText;
}
function sendLsCallback(status, cbArg) {
  debug(DBGINFO, 'Post LS File to MD: status[' + status + ']');
  // changeProgram to current edit program name
  cbArg.sedStat = status;
  cbArg.func = chgApplProgCallback;
  chgProg(getCurrentProgram(), waitChgProgComplete, cbArg);
}
function chgApplProgCallback(status, progName, cbArg) {
  // Finish. (call callback function)
  if (cbArg.call != undefined) {
    cbArg.call(status, cbArg);	// Call callback function.
  }
}
function convertProgramLines(progLines, lineCount) {
  // Convert program text data...
  var decodedProg = [];
  if (lineCount > 0) { // If online data read, need to decode.
    for (var txtIndex = 0; txtIndex < progLines.length; txtIndex++) {
      decodedProg[txtIndex] = convertSjistoUcd(window.atob(progLines[txtIndex].buf)); // utils
    }
  } else { // For offline reading No need to decode.
    decodedProg = progLines;
  }
  return decodedProg;
}

var retryCnvTextComplete = 0;

function waitCnvTextComplete(callback, cbArg) {
  if (getConvertLines().length <= 0) {
    if (retryCnvTextComplete < 1000) {
      setTimeout(function () {
        waitCnvTextComplete(callback, cbArg);
      }, 50);
      retryCnvTextComplete++;
      return;
    }
  }
  dispOffWaiting();
  retryCnvTextComplete = 0;
  callback(cbArg);
}

var convProgLines = [];
function setConvertLines(progText) {
  convProgLines = progText;
}

function getConvertLines() {
  return convProgLines;
}

function initConvertLines() {
  convProgLines = [];
}

function getApplText(progName, callback, cbArg) {
  var progFile = addProgramExtension(progName);
  var copiedArg = $.extend(true, {}, cbArg);
  copiedArg.progName = progName;
  copiedArg.call = callback;
  loadFile(progFile, loadForGetApplTextCallback, copiedArg);
}

function loadForGetApplTextCallback(status, fileName, progLines, numLines, cbArg) {
  if (status != IO_SUCCESS) {
    if (cbArg.call != undefined) {
      dispOffWaiting();
      defineDialog.open(null, '#applloaderrdlg', 'dlgMsgApplLoadError');
      closeDialog("#appleditordlg");
      return;
    }
  }
  // Convert program text lines
  initConvertLines();
  convertLSData(progLines, numLines, setConvertLines); // common api.
  var callbackArg = { fileName: fileName, cbArg: cbArg };
  waitCnvTextComplete(loadForGetApplCnvCallback, callbackArg);
}
function loadForGetApplCnvCallback(callbackArg) {
  var cbArg = callbackArg.cbArg;
  var progTextLines = getConvertLines();
  // Search target keyword applKey
  var posTargetAppl = -1;
  var posTargetTerm = -1;
  var posMnBlock = -1;
  var detectTargetAppl = false;
  var appltext = "";

  for (var line_num = 0; line_num < progTextLines.length; line_num++){
    var textLine = progTextLines[line_num];
    if (textLine.length == 0) {
      continue;
    }
    if (textLine.indexOf("/APPL") >= 0) {
      posTargetAppl = line_num;
      detectTargetAppl = true;
      break;
    }
  }
  for (var secondLine = progTextLines.length - 1; posTargetAppl < secondLine; secondLine--) {
    var applLine = progTextLines[secondLine];
    if (applLine.length == 0) {
      continue;
    }
    if (applLine.indexOf("/MN") >= 0) {
      posTargetTerm = secondLine;
      posMnBlock = secondLine;
      break;
    }
  }
  if (posTargetAppl != -1 && posTargetTerm != -1) {
    var applBlock = progTextLines.slice(posTargetAppl, posTargetTerm);
    for (var i = 0; i < applBlock.length; i++){
      appltext += applBlock[i] + "\n";
    }
  }
  cbArg.call(appltext,cbArg);
}

function putApplTextDataToProgram(progName, callback, cbArg) {
  // load program file to append APPL text.
  var progFile = addProgramExtension(progName);
  var copiedArg = $.extend(true, {}, cbArg);
  copiedArg.progName = progName;
  copiedArg.call = callback;
  loadFile(progFile, loadForPutApplTextCallback, copiedArg);
}
/*
 * cbArg.progName : Program name. (With * if editing)
 *      .call : Callback function. (Call when completed)
 */
function loadForPutApplTextCallback(status, fileName, progLines, numLines, cbArg) {
  if (status != IO_SUCCESS) {
    if (cbArg.call != undefined) {
      dispOffWaiting();
      top.openCmpConfirm(webPage, window, 'applsaveerrdlg', resources['dlgMsgApplErr'], {btnData :{btn1:top.irpDlgBtnOC.btn1}}, true);
      return;
    }
  }
  // Convert program text lines
  initConvertLines();
  convertLSData(progLines, numLines, setConvertLines); // common api.
  var callbackArg = { fileName: fileName, cbArg: cbArg };
  waitCnvTextComplete(loadForPutApplTextCnvCallback, callbackArg);
}
function loadForPutApplTextCnvCallback(callbackArg) {
  var cbArg = callbackArg.cbArg;
  var progTextLines = getConvertLines();
  // Search target keyword applKey
  var posTargetAppl = -1;
  var posTargetTerm = -1;
  var posMnBlock = -1;
  var detectTargetAppl = false;
  var appltext = "";

  for (var line_num = 0; line_num < progTextLines.length; line_num++) {
    var textLine = progTextLines[line_num];
    if (textLine.length == 0) {
      continue;
    }
    if (textLine.indexOf("/APPL") >= 0) {
      posTargetAppl = line_num;
      detectTargetAppl = true;
      break;
    }
  }
  for (var secondLine = progTextLines.length - 1; posTargetAppl < progTextLines.length; secondLine--) {
    var applLine = progTextLines[secondLine];
    if (applLine.length == 0) {
      continue;
    }
    if (applLine.indexOf("/MN") >= 0) {
      posTargetTerm = secondLine;
      posMnBlock = secondLine;
      break;
    }
  }
  // Make APPL array from text
  var applTextArray = cbArg.applText.split(/\r\n|\n/);
  // Remove target appl block if exist.
  if (detectTargetAppl) {
    var cntApplLines = posTargetTerm - posTargetAppl;
    progTextLines.splice(posTargetAppl, cntApplLines);
    posMnBlock -= cntApplLines;
  } else {
    for (var num = 0; num < progTextLines.length; num++) {
      if (progTextLines[num].indexOf("/MN") >= 0) {
        posMnBlock = num;
      }
    }
  }
  // Appl text inert before /MN
  Array.prototype.splice.apply(progTextLines, [posMnBlock, 0].concat(applTextArray));
  // change Program to empty.
  cbArg.text = progTextLines;
  cbArg.file = callbackArg.fileName;
  cbArg.func = chgApplEmptyCallback;
  chgProg('', waitChgProgComplete, cbArg);

}
/*==========================================
 * Read/Write Each System variable.
 */
/*
 * Get Current Cartesian Frame Kind
 */
function getCartFrameKind(grp, callback) {
  top.rpcmc_setVar(top.SYSNAME_C, '$JCR.$JOG_GP', grp);
  top.rpcmc_getVar(top.SYSNAME_C, '$JCR_GRP[grp].$JOG_COORD', callback);
}

// Get variable name for frame name get/set
function getFrameVariableName(frameIndex, grp) {
  if (grp == undefined) grp = 1;
  var varName = '';
  switch (frameIndex) {
    case FRMVAL_USER:
      varName = '$MNUFRAMENUM[' + grp + ']';
      break;
    case FRMVAL_TOOL:
      varName = '$MNUTOOLNUM[' + grp + ']';
      break;
    case FRMVAL_JOG:
      varName = 'JOGFRAMNUM[' + grp + ']';
      break;
  }
  return varName;
}
// Get variable name for fram max number.
function getFrameMaxNumName(frameIndex) {
  var varName = '';
  switch (frameIndex) {
    case FRMVAL_USER:
      varName = '$SCR.$MAXNUMUFRAM';
      break;
    case FRMVAL_TOOL:
      varName = '$SCR.$MAXNUMUTOOL';
      break;
    default:
      debug(DBGWARN, 'Illegal Frame index:' + frameIndex);
      break;
  }
  return varName;
}
/*
 * Get specified Cartesian Frame Number
 */
function getCartFrameNumber(frameIndex, grp, callback) {
  var progName = (frameIndex == FRMVAL_JOG) ? top.TPFDEF_C : top.SYSNAME_C;
  var varName = getFrameVariableName(frameIndex, grp);
  top.rpcmc_getVar(progName, varName, callback, frameIndex);
}
/*
 * Set Frame coordinate
 *
 * grp : Group number
 * selFrame : Frame coordinate (0=Joint/1=Jog/2=World/3=Tool/4=User)
 * frameNum : Frame number (if World, number is no need.)
 */
function setFrameCoordinate(grp, frameIndex, frameNum) {
  sendJogTypeCart(grp, frameIndex);
  if (frameIndex != FRMVAL_WORLD) {
    var progName = (frameIndex == FRMVAL_JOG) ? top.TPFDEF_C : top.SYSNAME_C;
    var varName = getFrameVariableName(frameIndex, grp);
    top.rpcmc_setVar(progName, varName, frameNum);
  }
}
/*
 * Get specified Cartesian Frame Number of MAX
 */
function getCartFrameMaxNumber(frameIndex, callback) {
  var progName = top.SYSNAME_C;
  var varName = getFrameMaxNumName(frameIndex);
  top.rpcmc_getVar(progName, varName, callback, frameIndex);
}
/*
 * Get Position Register Max Number
 */
function getPosRegMaxNumber(callback) {
  top.rpcmc_getVar(top.POSREG_C, '$MAXPREGNUM', callback, null);
}

/*
 * Switch joint axes
 * (IN) grp : Group number
 * (IN) axes : JOGJOINT_RBT to Robot
 *             JOGJOINT_EXT to Exetension
 * (OUT) false : Illegal argument failure.
 */
function switchJogJointAxes(grp, axes) {
  if ((axes != JOGJOINT_RBT) && (axes != JOGJOINT_EXT)) {
    return false;
  }
  top.rpcmc_setVar(top.SYSNAME_C, '$JCR.$JOG_GP', grp);
  top.rpcmc_setVar(top.SYSNAME_C, '$JCR_GRP[grp].$JOG_SUBGRP', axes);
  return true;
}
/*
 * Get current selected axes
 * (IN) grp : Group number
 * (IN) callback : A callback function to get current selected axes
 *          arg1 : SYSNAME_C
 *          arg2 : $JCR_GRP[grp].$JOG_SUBGRP
 *          arg3 : Axes 0=Robot, 1=Extention.
 */
function getCurrentSelAxes(grp, callback) {
  top.rpcmc_setVar(top.SYSNAME_C, '$JCR.$JOG_GP', grp);
  top.rpcmc_getVar(top.SYSNAME_C, '$JCR_GRP[grp].$JOG_SUBGRP', callback);
}

/*
 * Get recent top program name.
 * (IN) callback : A callback function to get program name list.
 *          arg1 : SYSNAME_C
 *          arg2 : $TP_DEFPROG
 *          arg3 : no use
 *          arg4 : Defined program name
 */
function getRecentTopProgram(callback) {
  top.rpcmc_getVar(top.SYSNAME_C, '$TP_DEFPROG', callback);
}

/*
 * Get override value.
 * (IN) callback : A callback function
 *          arg1 : SYSNAME_C
 *          arg2 : $MCR.$GENOVERRIDE
 */
function getOverrideValue(callback) {
  top.rpcmc_getVar(top.SYSNAME_C, '$MCR.$GENOVERRIDE', callback);
}

/*
 * Set override value.
 * (IN) value: override value
 */
function setOverrideValue(value) {
  if (value == 'FINE') {
    top.rpcmc_setVar(top.SYSNAME_C, '$MCR.$GENOVERRIDE', 1);
    top.rpcmc_setVar(top.SYSNAME_C, '$JCR_GRP[1].$JOG_V_FINE', 'FALSE');
    top.rpcmc_setVar(top.SYSNAME_C, '$JCR_GRP[1].$JOG_FINE_MD', 'TRUE');
  } else if (value == 'VFINE') {
    top.rpcmc_setVar(top.SYSNAME_C, '$MCR.$GENOVERRIDE', 1);
    top.rpcmc_setVar(top.SYSNAME_C, '$JCR_GRP[1].$JOG_FINE_MD', 'TRUE');
    top.rpcmc_setVar(top.SYSNAME_C, '$JCR_GRP[1].$JOG_V_FINE', 'TRUE');
  } else { // value is 1 to 100
    top.rpcmc_setVar(top.SYSNAME_C, '$MCR.$GENOVERRIDE', value);
  }
}

/*==========================================
 * Execute program etc...
 */

/*
 * Reset Alarm status.
 */
var isResetAlarm = false;
function resetAlarmStatus() {
  isResetAlarm = true;
  top.sendKey("Reset", 1);
  top.sendKey("Reset", 0);
  setTimeout(function () { }, 500);
  isResetAlarm = false;
}

/*
 * change frame type.
 */
function sendJogTypeCart(grp, frm) {
  top.rpcmc_setVar(top.SYSNAME_C, '$JCR.$JOG_GP', grp);
  top.rpcmc_setVar(top.SYSNAME_C, '$JCR_GRP[grp].$JOG_COORD', frm);
}
function sendJogTypeJoint(grp) {
  top.rpcmc_setVar(top.SYSNAME_C, '$JCR_GRP[grp].$JOG_COORD', FRMVAL_JOINT);
}

function sendShiftKey(value) {
  top.sendKey("R-shift", value);
  top.sendKey("L-shift", value);
}

/*
 * Change Step Mode
 */
function exchangeStepMode() {
  top.sendKey('Step', 1);
  top.sendKey('Step', 0);
}

/*****
 watch Alarm status
 ******/
function watchAlarmstatus() {
  if (!isResetAlarm) {
    setTimeout(function () {
      top.rpcmc_iovalrd(top.tpout_type_c, 1, callbackAlarmStatus, 0, 0);
    }, 250);
  }
}
function callbackAlarmStatus(type, mode, status) {
  //alarmstatus = status;
  if (status == 1) {
    startAlarmBlink();
  } else {
    setAlarmStatus(false); // clear alarm status.(toolbar.js)
    $('#resetbutton').css({
      'background-color': '',
      'color': ''
    });
    $('#resetbtn').css({
      'background-color': '',
      'color': ''
    });
  }
  //watchAlarmstatus();
}

/*****
 watch Execution status
 ******/
var execProgHold = false;
function setExecProgHold(condition) {
  execProgHold = condition;
}
function isExecProgHold() {
  return execProgHold;
}

var execOffCallback = null;  // Call when exec Off.
function startExecStatus(callback) {
  execOffCallback = callback;
  setWatchExecValue(1); // main.js
  setTimeout(function () {
    top.rpcmc_iovalrd(top.tpout_type_c, 5, callbackExecstatus, 0, 0);
  }, 200);
}
function callbackExecstatus(type, mode, status) {
  debug(DBGDUMP, 'startExecStatus callback: watchExec_value=' + status);
  setWatchExecValue(status); // set Initial value main.js
  // --- If the execution stops before the status changes,
  // --- return to the state before execution.
  if (status == 0) {
    enabelEditWindow();
    if (top.dlg_shift_close != undefined) {
      top.dlg_shift_close(); // close 'Program is Running' popup...
    }
  }
}
function startMovetoStatus(callback) {
  execOffCallback = callback;
}

function enabelEditWindow() {
  setExecProgHold(false); // Add for cancel limitation.
  setProgramExec(false); // enable edit window
  if (statusProgramInfoTrans.getCurrentProgramSI().stat == WATCHEXEC_ABORTED || statusProgramInfoTrans.getCurrentProgramSI().prog != omitExtension(movementProgramName)) {
    setMoveToOnProgram(false); // Just in case...
  }
  if (isMyIFrameIdPrim()) {
    top.dlg_shift_close(); // close 'Program is Running' popup...
  }
  if(!progLoadError) removeOverlayScreen('exec'); // Operations such as editing will be enabled.
  if ((checkEditInvalid(false)) && (isScrModePcEditor()) &&
    (isMyIFrameIdPrim()) && (getCurrentProgram() != "")) { // program protect editting in editor 
    protOverlayManager(true);
  }
}

function watchExecStatus(watchExecValue) {
  if (watchExecValue == 0) {
    sendShiftKey(0);
    // resetWatchStatus(); no need watch status
    // When execution is stopped,
    // the limitation is canceled unless a temporary stop or alarm occurs.
    // ---> Even when paused, cancel the limitation.
    //if ((!execProgHold) && (!isAlarmOn())) {
    enabelEditWindow();
    //}
    if (execOffCallback != null) {
      execOffCallback();
    }
  }
}

function saveLocalRegs(progName, callback) {
  var sendObj = {
    applText: "", applKey: "",
    localRegsData: "0,0,0;", localRegsKey: localRegsText[getFileIOLang()] + "\t=",
    localRegCB: callback,
  };
  var localRegsArr = ProgramApplManager.getEditApplLocalRegisters();
  sendObj.localRegsData = localRegsArr["LOCAL_REGISTER"] + "," +
                          localRegsArr["LOCAL_POS_REGISTER"] + "," +
                          localRegsArr["LOCAL_STR_REGISTER"] + ";";
  putApplDataToProgram(progName, callbackSaveLocalRegs, sendObj);
}
function callbackSaveLocalRegs(status, cbArg) {
  if (cbArg.sedStat != IO_SUCCESS) {
    top.openCmpConfirm(webPage, window, 'applsaveerrdlg', resources['dlgMsgApplErr'], {btnData :{btn1:top.irpDlgBtnOC.btn1}}, true);
    return;
  }
  if (typeof cbArg.localRegCB === "function") {
    cbArg.localRegCB(status, cbArg.progName);
  }
}
// edit attribute dialog save APPL process
function saveAppl(prgName) {
  var sendObj = {
    applText: "/APPL\n", applKey: "",
  };
  if (top.g_order.r792) {
    sendObj.applKey = "AUTO_SINGULARITY_HEADER";
    sendObj.applText += createSingularityString();
    if (ProgramApplManager.isLoadLineTrack()) {
      sendObj.applText += createLinTrackString();
    }
    if (top.g_order.wnsp) {
      sendObj.applText += createPltzModeString();
    }
  } else if (ProgramApplManager.isLoadLineTrack()) {
    sendObj.applKey = "LINE_TRACK";
    sendObj.applText += createLinTrackString();
    if (top.g_order.wnsp) {
      sendObj.applText += createPltzModeString();
    }
  } else if (top.g_order.wnsp) {
    sendObj.applKey = "PLTZ_MODE_HEADER";
    sendObj.applText += createPltzModeString();
  }
  var progName = prgName;
  if (isExistEditProgramFile(getTempProgName(progName))) {
    progName = getTempProgName(progName);
  } else {
    progName = getProdProgName(progName); // No *Prog, Product Prog name.
  }
  putApplDataToProgram(progName, callBackSaveAppl, sendObj);
}

function callBackSaveAppl(status, cbArg) {
  if (cbArg.sedStat != IO_SUCCESS) {
    top.openCmpConfirm(webPage, window, 'applsaveerrdlg', resources['dlgMsgApplErr'], {btnData :{btn1:top.irpDlgBtnOC.btn1}}, true);
  } else {
    ProgramApplManager.updateLineTrackingConfig(); // fileio
    if (!isScrModeProgAttr()) {
      $('#editattrdlg').hide();
      $('#editattrdlg').remove();
      removeOverlayScreen('editattr');
      refreshPosAreaLock(); // refresh posarea for group mask
    }
    if ((afterSetAttrCall !== undefined) && (afterSetAttrCall !== null)) {
      var progName = getCurrentProgram();
      if (isExistEditProgramFile(getTempProgName(progName))) {
        progName = getTempProgName(progName);
      } else {
        progName = getProdProgName(progName); // No *Prog, Product Prog name.
      }
      afterSetAttrCall(progName);
    } else if (!dispAttrDlgFlag) {
      saveattribute();
    }
  }
}

// line tracking APPL string
function createLinTrackString() {
  var editAppl = ProgramApplManager.getEditApplData(); // fileio
  var text = "LINE_TRACK; \n";
  for (var key in editAppl) {
    if (editAppl.hasOwnProperty(key)) {
      var value = editAppl[key];
      text += key + ":" + value + ";\n";
    }
  }
  return text;
}

// line tracking APPL string
function createSingularityString() {
  var editAppl = ProgramApplManager.getEditApplSingularity(); // fileio
  var text = "AUTO_SINGULARITY_HEADER; \n";
  for (var key in editAppl) {
    if (editAppl.hasOwnProperty(key)) {
      var value = editAppl[key];
      text += key + ":" + value + "\n";
    }
  }
  return text;
}

// PALLETIZING MODE APPL string
function createPltzModeString() {
  var editAppl = ProgramApplManager.getEditApplPltzMode(); // fileio
  var text = "PLTZ_MODE_HEADER; \n";
  for (var key in editAppl) {
    if (editAppl.hasOwnProperty(key)) {
      var value = editAppl[key];
      text += key + ":" + value + ";\n";
    }
  }
  return text;
}

// save modified palletizing APPL object
function savePltAppl(progName, modified_obj) {
  var sendObj = { applText: "/APPL\n", applKey: "" };

  if (ProgramApplManager.isLoadPalletizing()) {
    sendObj.applKey = (getCurrentLanguage() == "jp") ? "ﾊﾟﾚﾀｲｼﾞﾝｸﾞ" : "Palletizing";
    sendObj.applText += getTempAllPltApplString(getCurrentLanguage(), modified_obj);
    sendObj.pltObj = modified_obj;
  }

  if (isExistEditProgramFile(getTempProgName(progName))) {
    progName = getTempProgName(progName);
  } else {
    progName = getProdProgName(progName); // No *Prog, Product Prog name.
  }
  putApplDataToProgram(progName, callBackSavePltAppl, sendObj);
}

// temporary implements
var palletizingModifyInfo = {};
palletizingModifyInfo.command = '';
palletizingModifyInfo.csrPos = {};
function callBackSavePltAppl(status, cbArg) {
  if (cbArg.sedStat != IO_SUCCESS) {
    dispOffWaiting();
    top.openCmpConfirm(webPage, window, 'applsaveerrdlg', resources['dlgMsgApplErr'], {btnData :{btn1:top.irpDlgBtnOC.btn1}}, true);
  } else {
    var obj = JSON.parse(JSON.stringify(cbArg.pltObj));
    var compareMatch = false;
    var compare;
    if (obj.cmdMode == PLTDLGMODE_MODIFY) {
      compare = comparePltProg(obj);
      compareMatch = compare.edit;
    }
    setGlobalPltObj(obj.palletizing_num, obj);

    // get command line
    var buildCmd = getCreateCmdStr(obj, getCurrentLanguage()).split(/\n/);
    // Put to editor window.
    setNewEditProgram(true);
    var csr = getPltProgRange();
    selTarget.startRow = {};
    selTarget.endRow = {};
    selTarget.startRow.line = csr.from.line;
    selTarget.endRow.line = csr.from.line;
    selTarget.startRow.ch = 0;
    selTarget.endRow.ch = 0;
    // Performs a dedicated palletizing process when a command insertion error occurs.
    pltEditCmd.isProcess = true;
    pltEditCmd.startLine = selTarget.startRow.line;
    pltEditCmd.lineNum = 0;
    if (obj.cmdMode == PLTDLGMODE_MODIFY && compareMatch) {
      var selPltTargetLines = csr.to.line - csr.from.line + 1;
      // Delete target selection before paste.
      var cbArg = {};
      cbArg.buildCmd = buildCmd;
      cbArg.csrPos = csr;
      palletizingModifyInfo.command = buildCmd;
      palletizingModifyInfo.csrPos = csr;
      deleteEditLines(getCurrentProgram(), selTarget.startRow.line + 1, selPltTargetLines, cbArg);	// api
      return;
    } else if (obj.cmdMode == PLTDLGMODE_MODIFY && !compareMatch) {
      // focus set to editor
      var editor = getPcEditor();
      editor.focus();
      editor.setCursor({ line: csr.from.line, ch: csr.from.char });
      defineButtonDlg.close('#palletButton');
      closePltDialog();
      dispOffWaiting();
      removeOverlayScreen('applsaveerrdlg');
      return;
    }
    stackCmd = buildCmd;
    stackCsr = csr;
    tempCmd = buildCmd;
    tempFirstSavePltCmd();
  }
}

function putPalettizingCommands(commands,csr) {
  if (!commands) {
    commands = stackCmd;
  }
  multiRowPaste(true, commands);
  // focus set to editor
  if (csr) {
    var csrPos = csr;
  } else {
    var csrPos = getPltProgRange();
  }
  var editor = getPcEditor();
  editor.focus();
  editor.setCursor({ line: csrPos.from.line, ch: csrPos.from.char });
  defineButtonDlg.close('#palletButton');
  closePltDialog();
  dispOffWaiting();
  removeOverlayScreen('applsaveerrdlg');
}
function putEmptyRowToPstPltCmd(csrPos) {
  var editor = getPcEditor();
  editor.setCursor({ line: palletizingModifyInfo.csrPos.from.line, ch: 0 });
  //insertCommandStr('' + CODECRLF); //prgwin
  putPalettizingCommands(palletizingModifyInfo.command, palletizingModifyInfo.csrPos);
}
// call after delete original rows and reload file.
function reloadPltModifyCallback(status, programName, programText, lineCount) {
  putEmptyRowToPstPltCmd(palletizingModifyInfo.csrPos);
}

// temp data
var tempCmd = [];
var stackCmd = "";
var stackCsr = {};
var tempNum = 0;

function tempFirstSavePltCmd() {
  var buildCmd = stackCmd;
  var csr = stackCsr;
  // putPalettizingCommands();
  // return;
  tempCmd = buildCmd;
  var mnNum = 0;
  if (!isExistEditProgramFile(getTempProgName(getCurrentProgram()))) {
    copyProductToEditProg(getProdProgName(getCurrentProgram()));
    mkEditProg_TempPlt(buildCmd, csr);
    return;
  }
  mnNum = getEditorDoc().lastLine() + 1;

  tempNum = 0;
  var lineData = apiEscape(tempCmd[tempNum]) + ";";

  editPrg(getTempProgName(getCurrentProgram()), lineData, mnNum, PRGWRITE_INS, tempSavePltCmd);

}

function tempSavePltCmd(state, prgName) {
  if (state != 0) {// save error
    dispOffWaiting();
    handle_error(state);
    mnNum = getEditorDoc().lastLine() + 1;
    delLine(prgName, mnNum , tempNum + 1);
    defineDialog.open(null, '#pltcmdsaveerr', 'dlgMsgPrgLineErr');
    $("#pltcmdsaveerr").css({ "z-index": "10003" });
    return;
  }
  if (tempNum < tempCmd.length - 1) { // save next line...
    mnNum = getEditorDoc().lastLine() + 1;
    var lineData = apiEscape(tempCmd[tempNum]) + ";";
    // var lineData = tempCmd[tempNum] + ";";
    editPrg(prgName, lineData, mnNum + tempNum, PRGWRITE_ADD, tempSavePltCmd);
    tempNum++;
  } else {
    // compleate
    mnNum = getEditorDoc().lastLine() + 1;

    delLine(prgName, mnNum, tempNum + 1, delayDlete);
    tempCmd = [];
    tempNum = 0;
  }

}

// for Delete lines
function mkEditProg_TempPlt(buildCmd, csr) {
  var wdTimer_delLines = null;
  if (watchStatus == 1) { // Watch status is ongoing.
    wdTimer_delLines = setTimeout(function () {
      mkEditProg_TempPlt(buildCmd, csr);
    }, 100);
  } else {
    clearTimeout(wdTimer_delLines);
    wdTimer_delLines = null;
    tempFirstSavePltCmd(buildCmd, csr);
  }
}

function delayDlete() {
  setTimeout(putPalettizingCommands, 100);
}

function dlgSaveAppl(changeText){
  saveApplText(getCurrentProgram(), changeText);
}

// edit appl dialog save process
function saveApplText(crtProg,applText) {
  var sendObj = { applText: "", applKey: "" };
  sendObj.applKey = "/APPL";
  sendObj.applText += applText;
  putApplTextDataToProgram(decisionAsterisk(crtProg), callBackSaveApplText, sendObj);
}

function callBackSaveApplText(status, cbArg) {
  dispOffWaiting();
  if (cbArg.sedStat != IO_SUCCESS) {
    top.openCmpConfirm(webPage, window, 'applsaveerrdlg', resources['dlgMsgApplErr'], {btnData :{btn1:top.irpDlgBtnOC.btn1}}, true);
  } else {
    readProgramFile(decisionAsterisk(getCurrentProgram()));
    closeDialog('#appleditordlg');
  }
}

function decisionAsterisk(crtProg){
  var progName = "";
  if (isExistEditProgramFile(getTempProgName(crtProg))) {
    progName = getTempProgName(crtProg);
  } else {
    progName = getProdProgName(crtProg); // No *Prog, Product Prog name.
  }
  return progName;
}

function preProcDelete() {
  var pgName = getSelectProgram();
  var cbArg = {};
  cbArg.saveName = pgName;
  if (pgName == getCurrentProgram()) {
    cbArg.func = delBtnProc;
    chgProg('', waitChgProgComplete, cbArg);
  } else {
    delBtnProc(IO_SUCCESS, null, cbArg);
  }
}

/* Callback function to delete program after change prog to empty */
function delBtnProc(status, progName, cbArg) {
  if (status != 0) {
    debug(DBGERROR, 'delBtnProc: progName=' + progName + '; status=' + status);
    handle_error(status);
    top.openCmpConfirm(webPage, window, 'faildeleteprogdlg', resources['dlgMsgFailDelProg'], {btnData: { btn1:top.irpDlgBtnYN.btn1}}, true);
    return;
  }
  tempPgName = getTempProgName(cbArg.saveName); // add *
  if (isExistEditProgramFile(tempPgName)) { // exist temp program
    deletePrg(tempPgName, delBtnProcCB);
    removeEditProgramFile(tempPgName);
  } else { // no temp program
    deletePrg(cbArg.saveName, delBtnProcCB);
  }
}

var delBtnFlg = false; // Determine whether it is a process after delete
function delBtnProcCB(status, progName) {
  debug(DBGDUMP, 'deletePrg: status(' + status + ')');
  if (status != 0) {
    handle_error(status);
    // Since the program is unselected, select it again.
    if (progName == getCurrentProgram()) {
      var cbArg = {};
      cbArg.func = reselectProgramCallback;
      chgProg(getProdProgName(progName), waitChgProgComplete, cbArg);
      // If the list has been changed, restore it.
      restoreProgramList(getProdProgName(progName));
    }
    // It can not be deleted because it is in use elsewhere.
    if (status == IOSTAT_MEMO_044) {
      top.openCmpConfirm(webPage, window, 'savealertdlg', resources['dlgMsgAlreadyUse'], {btnData :{btn1:top.irpDlgBtnOC.btn1}}, true);
    // It can not be deleted because it is protected.
    } else if (status == IOSTAT_MEMO_006) {
      top.openCmpConfirm(webPage, window, 'deleteprotecterr', resources['dlgMsgDelProtectErr'], {btnData:{btn1:top.irpDlgBtnYN.btn1}}, true);
    } else {
      top.openCmpConfirm(webPage, window, 'faildeleteprogdlg', resources['dlgMsgFailDelProg'], {btnData: { btn1:top.irpDlgBtnYN.btn1}}, true);
    }
    return;
  }
  if (isProgramNameTemporary(progName)) { // Processing after delete temp program
    progName = getProdProgName(progName);
    deletePrg(progName, delBtnProcCB);
  } else { // Processing after delete prod program
    $('#openbtn').prop('disabled', true);
    $('#openbtn').addClass('okyesdis');
    $('#deletebtn').prop('disabled', true);
    $('#deletebtn').addClass('okyesdis');
    $('#detailsbtn').prop('disabled', true);
    $('#detailsbtn').addClass('okyesdis');
    if (progName == getCurrentProgram() || getCurrentProgram() == "") {
      // Initialization Attribute
      var initAttr = {COMMENT: "", STACK_SIZE: 500, MTNGRP: 1, PAUSE: 0, PROTECT: PROTECTOFF, SUBTYPE: 0};
      reflectSetAttribute(progName, initAttr);
      ProgramApplManager.initEditApplSingularity(false);
      ProgramApplManager.initEditApplPltzMode(false);
      ProgramApplManager.initEditApplLocalRegisters();
      ProgramApplManager.initTrackingConfig();
      drawAttribute();
      setCurrentProgram('');
      top.statbar.$('#prgName').text('');
      chgDispPrgName('');
    } else {
      selPrgList(null, null, getCurrentProgram());
      chgDispPrgName(getCurrentProgram());
    }
    delBtnFlg = true;
    buildProgramList();
  }
}

function isDispMoveToMoniDlg(chkProgName, callback) {
  top.rpcmc_chkkey(null, top.mor_ss_c, top.SYSNAME_C, '$ALM_IF.$TASK_NUM', getTaskNumCB);
  function getTaskNumCB(io_type, io_index, taskNum, cbArg, chk_status) {
    if (taskNum == 0) {
      callback(taskNum, chkProgName);
    } else if (parseInt(taskNum) >= parseInt(maxTask)) {
      top.openCmpConfirm(webPage, window, 'moveToMonitorDlg', resources['dlgMsgMoveToMonitor'],
                        {btnData : top.irpDlgBtnYNM, btn1Cb : abort_prog, btn3Cb : moveToMonitor}, true);
    } else {
      getMonitorInfo(getMonitorInfoCB);
      function getMonitorInfoCB(status, moniList) { //common_io.js
        for (i = 0; i < moniList.length; i++) {
        	if (moniList[i].prog == chkProgName) {
        		callback(taskNum, moniList[i].task);
            return;
        	}
        }
        if((!validMult && validUOP == null) || (validUOP != null && !validUOP)) {
          top.openCmpConfirm(webPage, window, 'moveToMonitorDlg', resources['dlgMsgMoveToMonitor'],
                            {btnData : top.irpDlgBtnYNM, btn1Cb : abort_prog, btn3Cb : moveToMonitor}, true);
        } else {
          callback(taskNum, chkProgName);
        }
      }
    }
  }
}
function moveToMonitor() {
  if (isScrModePcEditor()) {
    var props = { value: "" };
    top.irprogapi.setDispPrgAttrMoniFlag(true);
    props.value = top.SELECTPROG_ADDRESS;
    top.treemod.nodeOnClick(null, props);
    top.treemod.update_tree_url(props.value);
  } else {
    showProgramMoniotrList(SELECT_MONITOR);
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                        
var g_keyseq = 1;
var isfirst = true;
var sendkeycomplete = true;
var g_urlprefix; 

var httc_port = parseInt('4080');
if (!httc_port) {
  httc_port = 4080;
}
g_urlprefix = location.host;
parts = g_urlprefix.split(':');

g_urlprefix = 'http://' + parts[0] + ':' + httc_port + '/TKEYDO/';



function sendKey(
  key_name, // (in)  predefined key_name
  press,    // (in)  press flag
  callback) {  

  if (g_lock) {
    setTimeout(function() { sendKey(key_name, press); }, 0);
  }
  if (key_name.length > 0) {
    g_lock = 1;
    g_keyseq++;
    top.rpcmc_cross_url(g_urlprefix + 'F_EVENT?key=' + key_name + '&keyseq=' + g_keyseq + '&press=' + press);
    top.rpcmc_rprintf(g_urlprefix + 'F_EVENT?key=' + key_name + ':' + press);
    
    g_lock = 0;
    if ((key_name == 'Deadman-L') && (!press)) {
      setTimeout(function() { sendKey('Enable', 0); }, 500);
    }
    else if ((key_name == 'Enable') && (press)) {
      setTimeout(function() { sendKey('Deadman-L', 1); }, 500);
    }
    if ((key_name != 'Enable') && (key_name != 'Deadman-L') &&
        (key_name != 'L-shift') && (key_name != 'R-shift') &&
        (key_name != 'Icon')) {
      if (press) {
        g_keycount++;
      }
      else if (g_keycount) {
        g_keycount--;
      }
    }
    if (g_wdog_enable) {
      if (!g_curr_timer) {
        // Start watchdog first time
        sendSync();
      }
      else if ((g_keycount) && (g_curr_timer === g_wdog_slow)) {
        // Keys pressed
        // Cancel slow watchdog and restart with fast watchdog
        cancelSync();
        g_curr_timer = g_wdog_fast;
        g_wdog_timer = setTimeout(sendSync, g_curr_timer);
      }
    }
  }
}

// Send watchdog to COMM Web Server.
function sendSync() {
  var cmd;
  if (g_keycount === 0) {
    g_curr_timer = g_wdog_slow;
    cmd = 'F_SYNC0'
  }
  else {
    cmd = 'F_SYNC';
  }

  // setTimeout and setInterval does not work on PanelView while button is pressed
  // Instead ask controller to delay for us.
  // When URL returns send another watchdog.
  if (top.g_msie6) {
    $.ajax({
      url: g_urlprefix + cmd + '?keyseq=' + g_keyseq + '&delay=' + g_curr_timer,
      dataType: 'jsonp',
      success: function() {
        if (!g_stop_cnt) {
          sendSync();
        }
        else {
          g_stop_cnt--;
        }
      },
      error: function() {
        if (!g_stop_cnt) {
          sendSync();
        }
        else {
          g_stop_cnt--;
        }
      }
    });
  }
  else {
    top.rpcmc_cross_url(g_urlprefix + cmd + '?keyseq=' + g_keyseq);
    g_wdog_timer = setTimeout(sendSync, g_curr_timer);
  }
} // sendSync

// Cancel watchdog.
function cancelSync() {
  if (top.g_msie6) {
    g_stop_cnt++;
  }
  else {
    if (g_wdog_timer) {
      clearTimeout(g_wdog_timer);
      g_wdog_timer = null;
    }
  }
} // cancelSync




/*
// not use 

function sendKey(key,value,callback) {
	var result = 0;
	// Insert code here.
	//sendjogtype(key,value);
	sendkeycomplete = false;
	if(isfirst || value ==1 || jogkeystatus==1){
		//g_keyseq = 1;
		//sendjogtype(key,value);
		isfirst = false;
		//sendenablekey(key,value);
		if(key != 'Reset' && key != 'Step'){
			sendshiftkeyon(key,value);
		}
		rpcmc_cross_url(g_urlprefix + 'F_EVENT?key=' + key + '&keyseq=' + g_keyseq + '&press=' + value)	;
		rpcmc_cross_url(g_urlprefix + 'F_SYNC?keyseq=' + g_keyseq )	;
		g_keyseq++;	
  		//setTimeout(sendjogkey(key), 1000);
	} else {
		rpcmc_cross_url(g_urlprefix + 'F_EVENT?key=' + key + '&keyseq=' + g_keyseq + '&press=' + value)	;	
		rpcmc_cross_url(g_urlprefix + 'F_SYNC?keyseq=' + g_keyseq )	;
		g_keyseq++;
		if (key != 'Reset' && key != 'Step'){
			sendshiftkeyoff(key,value);
		}
		//sendspecifiedkey(key,value);
	}
	return result;
}
*/                                                                                                                                                                                                                         /**********************************************************************
 * PC Editor script
 * for toolbar.
 * Created: 2017/04/20
 * Modified: 2017/08/21 Omit status area...
 */

/* === Generate Toolber === */
/* param targetId = Generate target. */
function generateToolbar() {
	$('#vertinner').addClass('crntlayoutbtn');
}

/* --- alarm status --- */
var alarmStatus = false;
function setAlarmStatus(stat) {
	alarmStatus = stat;
}
function isAlarmOn() {
	return (alarmStatus);
}

/* --- TP Enable status --- */
var enableStatus = false;	// true = ENABLE button pressed.
function setEnableStatus(stat) {
	enableStatus = stat;
}
function isEnableOn() {
	return (enableStatus);
}

// Set / Reset Alarm button.
function startAlarmBlink() {
	$('#resetbutton').css({ 'background-color': '#ff0000', 'color': '#ffffff' });
	alarmStatus = true;
}
function stopAlarmBlink() {
	//$('#resetbutton').css({'background-color': '#67727E', 'color': '#ababab'});
	resetAlarmStatus();
	//watchAlarmstatus();
}

/*****
  Toolbar's event functions
 *****/
$(function () {
	/** Layout button **/
	$('#vertinner').on('mouseover', function (event) {
		$('#imgvert').css('opacity', '0.5');
	});
	$('#vertinner').on('mouseout', function (event) {
		$('#imgvert').css('opacity', '1.0');
	});
	$('#horzinner').on('mouseover', function (event) {
		$('#imghoriz').css('opacity', '0.5');
	});
	$('#horzinner').on('mouseout', function (event) {
		$('#imghoriz').css('opacity', '1.0');
	});
	$('#vertinner').on('click touchend', function (event) {
		if(event.type.indexOf('touch') >= 0){
			event.preventDefault();
		}
		if (!isMyIFrameIdPrim()) {
			mwOverlayCleanUp();
		} else if (checkEditInvalid(false)) {
		    protOverlayCleanUp();
		}
		generateLayout(LAYOUTVERTICAL);
		var layoutH = $('#layoutarea').height();
		var layoutW = $('#layoutarea').width();
		layoutH -= $('#resizehorzv').height();	// Prg+Cmd + Pos+Jog
		layoutW -= $('#resizevertv').width();	// Pos + Jog
		// Window layout reset to Vertical-layout
		initVertWindow(layoutH * WINRATEUPPER, layoutH * WINRATELOWER, layoutW, layoutW);
		$('#horzinner').removeClass('crntlayoutbtn');
		$('#vertinner').addClass('crntlayoutbtn');
		$('#selpostbllist').css({ 'font-size': '12px' });
		var posctrlW = document.getElementById('posctrl').clientWidth;
		$('#posdata').width(posctrlW);
		posResizeRefresh(true);	// poswin
		if (!isMyIFrameIdPrim()) {
      		mwOverlaySetting();
		} else if (getCurrentProgram() == '') {
			npOverlaySetting();
		} else if (checkEditInvalid(false)) {
      		protOverlaySetting();
		}
	});
	$('#horzinner').on('click touchend', function (event) {
		if(event.type.indexOf('touch') >= 0){
			event.preventDefault();
		}
		if (!isMyIFrameIdPrim()) {
			mwOverlayCleanUp();
		} else if (checkEditInvalid(false)) {
		    protOverlayCleanUp();
		}
		generateLayout(LAYOUTHORIZONTAL);
		var layoutH = $('#layoutarea').height();
		var layoutW = $('#layoutarea').width();
		layoutH -= $('#resizehorzh').height();	// Pos + Jog
		layoutW -= $('#resizeverth').width();	// Prg+Cmd + Pos+Jog
		// Window layout reset to Horizontal-layout
		initHorzWindow(layoutW * WINRATELEFTH, layoutW * WINRATERIGHTH, layoutH, layoutH);
		$('#vertinner').removeClass('crntlayoutbtn');
		$('#horzinner').addClass('crntlayoutbtn');
		$('#selpostbllist').css({ 'font-size': '10px' });
		var posctrlW = document.getElementById('posctrl').clientWidth;
		$('#posdata').width(posctrlW);
		posResizeRefresh(true);	// poswin
		if (!isMyIFrameIdPrim()) {
      		mwOverlaySetting();
    	} else if (getCurrentProgram() == '') {
			npOverlaySetting();
		} else if (checkEditInvalid(false)) {
      		protOverlaySetting();
    	}
	});
	/** Hold button **/
	$('#playpause').on('click', function (event) {
		debug(DBGINFO, 'Pause(Hold) button click!');
    holdProgram();	// prgwin
	});
	/** Stop button **/
	$('#playstop').on('click', function (event) {
		debug(DBGINFO, 'Stop button click!');
		stopProgram();	// prgwin
    var progMain = ProgramInfoManager.getMainProgInfo();
    abortProgram(progMain.getProgName(), playStopCallback);	// io
	});
	/** Reset button **/
	$('#resetbutton').on('click', function (event) {
		if ($('#resetbutton')[0].tagName.toLowerCase() == 'button') {
			$('#resetbutton').prop("disabled", true);
		} else {
			$('#resetbutton').css({ "pointer-events": "none" });
		}
		stopAlarmBlink();
		$('#infocode').html('');
		$('#infomsg').html('');
		// Prevent resetbutton bashing.
		setTimeout(function () {
			if ($('#resetbutton')[0].tagName.toLowerCase() == 'button') {
				$('#resetbutton').prop("disabled", false);
			} else {
				$('#resetbutton').css({ "pointer-events": "auto" });
			}
		}, 500);
	});
	/**
	 * Click File menu button.
	 */
	$('#filemenu').on('click touchend', function (event) {
		if(event.type.indexOf('touch') >= 0){
			event.preventDefault();
		}
		var pupLeng = $('#selectfile').length;
    turnoffPopup();
		if (pupLeng == 0) {	// If it does not already exist, display popup.
			popupDialog.selection('selectfile');
		}
		return false;
	});
	/**
	 * Click Run dropdown button.
	 */
	$('#selexec').on('click', function (event) {
		var pupLeng = $('#toggleexec').length;
		turnoffPopup();
		if (pupLeng == 0) {	// If it does not already exist, display popup.
			popupDialog.selection('toggleexec');
		}
		return false;
	});
	/**
	 * Click outside program button.
	 */
	$('#othermenu').on('click', function (event) {
		var pupLeng = $('#launchext').length;
		turnoffPopup();
		if (pupLeng == 0) {	// If it does not already exist, display popup.
			popupDialog.selection('launchext');
		}
		return false;
	});
});
                                                                                                                                                                                                                                                                                                                                                                              PCEDI~20JS    MjXX  MjXY*  BS I N F O  . J S     P C E D I  T O R _ T R   A N PCEDI~21JS    MjXX  MjX
  BS . J S      P C E D I  T O R _ U T   I L PCEDI~22JS    MjXX  MjXط  BI S T . J  S     P C E D T  D E F _ C M   D L PCEDTD~1JS    MjXX  MjX*:  BN G . J S  v    P C E D I  vT O R _ P A   G I PCEDI~23JS    MjXX  MjX8ج  BE G . J S  V    P C E D I  VT O R _ P O   S R PCEDI~24JS    MjXX  MjXGةu  /**********************************************************************
 * Robot Program Editor script
 * Tooltip script
 * Created: 2017/04/26 FSI
 *
 */

/**********
  Tooltip.
**********/
/**
 * Tooltip definition
 * tableId: Definition table ID
 * targetId: Tooltip base target ID
 * messageId: Message output destination ID.
 * resourceId: Message resource ID.
 * getPosition: Function of get tooltip display position(top).
 */
var tooltipDefTable = [
  {
    tableId: 'prgform',
    targetId: 'prgform',
    messageId: 'emptyName',
    resourceId: 'dlgMsgEmptyName',
    arrowDir: 'under',
    getPosition: getPrgFormPos
  },
  {
    tableId: 'prgform',
    targetId: 'prgform',
    messageId: 'ilgName',
    resourceId: 'dlgMsgIlgName',
    arrowDir: 'under',
    getPosition: getPrgFormPos
  },
  {
    tableId: 'programarea',
    targetId: 'programarea',
    messageId: 'dontmove',
    resourceId: 'dlgMsgDontMove',
    arrowDir: 'under',
    getPosition: getSaveErrPos
  },
  {
    tableId: 'attrIptCmnt',
    targetId: 'attrIptCmnt',
    messageId: 'tipByteOver',
    resourceId: 'tipByteOver',
    arrowDir: 'under',
    getPosition: getCmntFormPos
  },
  {
    tableId: 'attrIptStack',
    targetId: 'attrIptStack',
    messageId: 'tipNumvalOver',
    resourceId: 'tipNumvalOver',
    arrowDir: 'under',
    getPosition: getStackFormPos
  },
  {
    tableId: 'iptframehead',
    targetId: 'iptframehead',
    messageId: 'maxFrameNum',
    resourceId: 'tipMaxFrameNum',
    arrowDir: 'over',
    getPosition: getJogNumPos
  },
  {
    tableId: 'iptframehead',
    targetId: 'iptframehead',
    messageId: 'emptyFrameNum',
    resourceId: 'tipEmptyNum',
    arrowDir: 'over',
    getPosition: getJogNumPos
  },
  {
    tableId: 'iptframeheadTab',
    targetId: 'iptframehead',
    messageId: 'maxFrameNum',
    resourceId: 'tipMaxFrameNum',
    arrowDir: 'overleft',
    getPosition: getJogNumPosTab
  },
  {
    tableId: 'iptframeheadTab',
    targetId: 'iptframehead',
    messageId: 'emptyFrameNum',
    resourceId: 'tipEmptyNum',
    arrowDir: 'overleft',
    getPosition: getJogNumPosTab
  },
  {
    tableId: 'listAttrIptCmnt',
    targetId: 'listAttrIptCmnt',
    messageId: 'tipByteOver',
    resourceId: 'tipByteOver',
    arrowDir: 'under',
    getPosition: getListCmntFormPos
  },
  {
    tableId: 'listAttrIptStack',
    targetId: 'listAttrIptStack',
    messageId: 'tipNumvalOver',
    resourceId: 'tipNumvalOver',
    arrowDir: 'under',
    getPosition: getListStackFormPos
  },
  {
    tableId: 'divapplLineSch',
    targetId: 'divapplLineSch',
    messageId: 'tipScheduleOvar',
    resourceId: 'tipScheduleOvar',
    arrowDir: 'under',
    getPosition: getdialogScheduleFormPos
  },
  {
    tableId: 'divapplLineBound',
    targetId: 'divapplLineBound',
    messageId: 'tipBoundryOvar',
    resourceId: 'tipBoundryOvar',
    arrowDir: 'under',
    getPosition: getdialogBoundryFormPos
  },
  {
    tableId: 'listapplLineSch',
    targetId: 'listdivapplLineSch',
    messageId: 'tipScheduleOvar',
    resourceId: 'tipScheduleOvar',
    arrowDir: 'under',
    getPosition: getListScheduleFormPos
  },
  {
    tableId: 'listapplLineBound',
    targetId: 'listdivapplLineBound',
    messageId: 'tipBoundryOvar',
    resourceId: 'tipBoundryOvar',
    arrowDir: 'under',
    getPosition: getListBoundryFormPos
  },
  {
    tableId: 'listAttrIptLocalNumReg',
    targetId: 'listAttrIptLocalNumReg',
    messageId: 'tipLocalNumRegValOver',
    resourceId: 'tipLocalNumRegValOver',
    arrowDir: 'under',
    getPosition: getLocalNumRegFormPos
  },
  {
    tableId: 'listAttrIptLocalPosReg',
    targetId: 'listAttrIptLocalPosReg',
    messageId: 'tipLocalPosRegValOver',
    resourceId: 'tipLocalPosRegValOver',
    arrowDir: 'under',
    getPosition: getLocalPosRegFormPos
  },
  {
    tableId: 'listAttrIptLocalStrReg',
    targetId: 'listAttrIptLocalStrReg',
    messageId: 'tipLocalStrRegValOver',
    resourceId: 'tipLocalStrRegValOver',
    arrowDir: 'under',
    getPosition: getLocalStrRegFormPos
  }
];

/*
 * Search tooltip id from tooltie definition table.
 */
function searchTooltipTable(id, msg) {
  for (var i = 0; i < tooltipDefTable.length; i++) {
    var def = tooltipDefTable[i];
    if ((def.tableId == id) && (def.messageId == msg)) {
      return def;
    }
  }
  return null;
}

/*
 * Tooltip turn on.
 */
function tooltipOn(tableId, messageId) {	// Tooltip message on
  tooltipDisp(tableId, messageId, null);
}
function tooltipDisp(tableId, messageId, phList) {	// Tooltip message on
  var defTable = searchTooltipTable(tableId, messageId);
  if ($('#tooltipbody').length != 0) {
    return;
  }
  var tips = resources[defTable.resourceId];
  if ((phList !== null) && (phList.length > 0)) {	// Place holder list is exist.
    for (var i = 0; i < phList.length; i++) {
      tips = tips.replace(phList[i].phStr, phList[i].repStr);
    }
  }
  var idStr = "#" + defTable.targetId;
  var tipClass = (defTable.arrowDir == 'over') ? 'tooltipbelow' :
    (defTable.arrowDir == 'overleft') ? 'tooltipupleft' : 'tooltipbody';
  $(idStr).append('<div id="tooltipbody" class="tooltipbase ' + tipClass + '" style="display: none;">' + tips + '</div>');
  $('#tooltipbody').show();
  var ttPos = defTable.getPosition();
  $('#tooltipbody').css('top', ttPos);
}

/*
 * Tooltip turn off.
 */
function tooltipOff(targetId) {
  //var idStr = "#" + targetId;
  //$(idStr).find('.tooltipbody').remove();
  $('#tooltipbody').remove();
}

/*
 * Get Tooltip top position.
 */
// Program form
var tiparrowH = 8;
function getPrgFormPos() {
  var targetPos = $('.dlginputtext').position();
  var targetTop = targetPos.top;
  var targetMarginH = $('#prgform').height() - $('.dlginputtext').height();
  var tipH = $('#tooltipbody')[0].offsetHeight;
  return targetTop + targetMarginH - (tipH + tiparrowH);
}
// comment form
function getCmntFormPos() {
  var targetPos = $('#attrIptCmnt').position();
  var targetTop = targetPos.top;
  var tipH = $('#tooltipbody')[0].offsetHeight;
  var setTop = targetTop - (tipH + tiparrowH);
  if(isScrModeProgAttr()) {
    var targetH = $('#attrIptCmnt').height();
    $('.tooltipbody').addClass('tiparrowlt');
    setTop = targetH + tiparrowH;
  }
  return setTop;
}
// stacksize form
function getStackFormPos() {
  var targetPos = $('#attrIptStack').position();
  var targetTop = targetPos.top;
  var tipH = $('#tooltipbody')[0].offsetHeight;
  return targetTop - (tipH + tiparrowH);
}
// Save error row
function getSaveErrPos() {
  return $('#tooltipbody').height();
}
// Jog coordinate number
function getJogNumPos() {
  var targetHeight = $('#iptframehead').height();
  var tipW = $('#tooltipbody').width();
  var tipH = $('#tooltipbody').height();
  var ttSize = { 'width': tipW, 'height': tipH };
  return (18 + targetHeight);
}
// Jog coordinate number for Tablet mode.
function getJogNumPosTab() {
  var targetHeight = $('#iptframehead').height();
  var tipW = $('#tooltipbody').width();
  var tipH = $('#tooltipbody').height();
  var ttSize = { 'width': tipW, 'height': tipH };
  return (targetHeight);
}
// comment form
function getListCmntFormPos() {
  var targetPos = $('#listAttrIptCmnt').position();
  var targetTop = targetPos.top;
  var tipH = $('#tooltipbody')[0].offsetHeight;
  return targetTop - (tipH + tiparrowH);
}
// stacksize form
function getListStackFormPos() {
  var targetPos = $('#listAttrIptStack').position();
  var targetTop = targetPos.top;
  var tipH = $('#tooltipbody')[0].offsetHeight;
  return targetTop - (tipH + tiparrowH);
}
// LINE_TRACK_SCHEDULE_NUMBER form
function getdialogScheduleFormPos() {
  var targetPos = $('#divapplLineSch').position();
  var targetTop = targetPos.top;
  if(isScrModeProgAttr()) {
    $('#tooltipbody').css({ left: targetPos.left - $('#tooltipbody').width() });
    $('.tooltipbody').addClass('tiparrowrb');
  }
  var tipH = $('#tooltipbody')[0].offsetHeight;
  return targetTop - (tipH + tiparrowH);
}
// LINE_TRACK_BOUNDARY_NUMBER form
function getdialogBoundryFormPos() {
  var targetPos = $('#divapplLineBound').position();
  var targetTop = targetPos.top;
  if(isScrModeProgAttr()) {
    $('#tooltipbody').css({ left: targetPos.left - $('#tooltipbody').width() });
    $('.tooltipbody').addClass('tiparrowrb');
  }
  var tipH = $('#tooltipbody')[0].offsetHeight;
  return targetTop - (tipH + tiparrowH);
}
// LINE_TRACK_SCHEDULE_NUMBER form
function getListScheduleFormPos() {
  var targetPos = $('#listdivapplLineSch').position();
  var targetTop = targetPos.top;
  var tipH = $('#tooltipbody')[0].offsetHeight;
  return targetTop - (tipH + tiparrowH);
}
// LINE_TRACK_BOUNDARY_NUMBER form
function getListBoundryFormPos() {
  var targetPos = $('#listdivapplLineBound').position();
  var targetTop = targetPos.top;
  var tipH = $('#tooltipbody')[0].offsetHeight;
  return targetTop - (tipH + tiparrowH);
}

// local Register
function getLocalNumRegFormPos() {
  var targetPos = $('#listAttrIptLocalNumReg').position();
  var targetTop = targetPos.top;
  var tipH = $('#tooltipbody')[0].offsetHeight;
  return targetTop - (tipH + tiparrowH);
}
function getLocalPosRegFormPos() {
  var targetPos = $('#listAttrIptLocalPosReg').position();
  var targetTop = targetPos.top;
  var tipH = $('#tooltipbody')[0].offsetHeight;
  return targetTop - (tipH + tiparrowH);
}
function getLocalStrRegFormPos() {
  var targetPos = $('#listAttrIptLocalStrReg').position();
  var targetTop = targetPos.top;
  var tipH = $('#tooltipbody')[0].offsetHeight;
  return targetTop - (tipH + tiparrowH);
}

/*
 * Setting toolTip for progattr dialog.
 */
function attrDlgTooltipOn(tableId, messageId, $targetElem) {
  var tooltip = document.createElement('div');
  var defTable = searchTooltipTable(tableId, messageId);

  // Setting tooltip.
  tooltip.id = 'dlgTooltip';
  tooltip.innerHTML = resources[defTable.resourceId];
  $targetElem[0].parentNode.insertBefore(tooltip, $targetElem[0].nextSibling);

  // Setting tooltip position.
  var targetOffTop = $targetElem.offset().top;  // document
  var inputH = $targetElem[0].offsetHeight;
  var inputParTop = $targetElem.position().top; // parent
  var tooltipH = tooltip.offsetHeight + 8;
  var tooltipPos = 0;

  if(targetOffTop < tooltipH) {
    tooltipPos = inputH + 8;
    tooltip.className = 'tooltipArrowLt';
  } else {
    tooltipPos = inputParTop - tooltipH;
    tooltip.className = 'tooltipArrowLb';
  }
  tooltip.style.top = tooltipPos + 'px';
}

function attrDlgTooltipOff($tooltip) {
  $tooltip.remove();
}
                                                                                                                                                                                                                                                                                                                                                                                                                                       /**********************************************************************
 * PC Editor script
 * for Transmit various informations.
 * Created: 2018/10/01
 */

/**
 * Class for transmitting information.
 *
 * Definition for program informations.
 * Usage: var transinfo = new TransProgramInfo();
 *
 * Definition for editor area information.
 * Usage: var editArea = new TransEdtAreaInfo('frame');
 */

 // Program informations.
function TransProgramInfo() {
	var mProgName = '';
	var mAfterProc = '';
	var mModifyTime = false;
	var mDialogId = '';
	Object.defineProperty(this, "progName", {
		get: function() {
			return mProgName;
		},
		set: function(name) {
			mProgName = name;
		},
	});
	Object.defineProperty(this, "afterProc", {
		get: function() {
			return mAfterProc;
		},
		set: function(after) {
			mAfterProc = after;
		},
	});
	Object.defineProperty(this, "modifyTime", {
		get: function() {
			return mModifyTime;
		},
		set: function(modify) {
			mModifyTime = modify;
		}
	});
	Object.defineProperty(this, "dialogId", {
		get: function() {
			return mDialogId;
		},
		set: function(id) {
			mDialogId = id;
		}
	});
}

 // Editor Area informations.
 function TransEditAreaInfo(frameId) {
	var mFrameId = frameId;
	var mEditor = null;	// Editor object (Codemirror)
	var mTol = 1;	// Top of line
	var mEol = 1;	// End of line
	var mViewLines = 1;	// Display Line count
	var mScrollTop = 0;	// Scroll Top pixel
	var mTextHeight = 16;	// Text Line Height
	Object.defineProperty(this, 'frameId', {
		get: function() {
			return mFrameId;
		},
		set: function(id) {
			mFrameId = id;
		},
	});
	Object.defineProperty(this, 'editor', {
		get: function() {
			return mEditor;
		},
		set: function(editor) {
			mEditor = editor;
		},
	});
	Object.defineProperty(this, 'tol', {
		get: function() {
			return mTol;
		},
		set: function(line) {
			mTol = line;
		},
	});
	Object.defineProperty(this, 'eol', {
		get: function() {
			return mEol;
		},
		set: function(line) {
			mEol = line;
		}
	});
	Object.defineProperty(this, 'viewLines', {
		get: function() {
			return mViewLines;
		},
		set: function(line) {
			mViewLines = line;
		}
	});
	Object.defineProperty(this, 'scrollTop', {
		get: function() {
			return mScrollTop;
		},
		set: function(px) {
			mScrollTop = px;
		}
	});
	Object.defineProperty(this, 'textHeight', {
		get: function() {
			return mTextHeight;
		},
		set: function(height) {
			mTextHeight = height;
		}
	});
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /**********************************************************************
 * Robot Program Editor script
 * Utilities
 * Created: 2017/06/19 FSI
 *
 */

/** Debug function **/
var DBGFATAL = 1;
var DBGERROR = 2;
var DBGWARN = 3;
var DBGINFO = 4;
var DBGDUMP = 5;
var DBGTRACE = 6;
var debugLevel = DBGINFO;	// Debug level. (Default level is INFO)
var debugDateOn = true;		// Datetime add to message
var levelHead = ['', 'FATAL', 'ERROR', 'WARN ', 'INFO ', 'DUMP ', 'TRACE'];
function debug(level, message) {
	if (level <= debugLevel) {
		var dbgDttm = (debugDateOn) ? formatDateTime() : '';
		var dbgmsg = levelHead[level] + ':' + message;
		console.log(dbgDttm + dbgmsg);
	}
}
function formatDateTime() {
	var dtObj = new Date();
	var yStr = dtObj.getFullYear();
	var mStr = ('00' + (dtObj.getMonth() + 1)).slice(-2);
	var dStr = ('00' + dtObj.getDate()).slice(-2);
	var hStr = ('00' + dtObj.getHours()).slice(-2);
	var nStr = ('00' + dtObj.getMinutes()).slice(-2);
	var sStr = ('00' + dtObj.getSeconds()).slice(-2);
	var fmtStr = '[' + yStr + '/' + mStr + '/' + dStr + ' ' +
		hStr + ':' + nStr + ':' + sStr + ']';
	return fmtStr;
}

/***** ----- for Tablet debug ----- *****
 *     Dump data display to textarea    *
 *                                      */
var tabletDbgOn = false;
function tabletDebug(mode, message) {
	if ((isTablet) && (tabletDbgOn)) {
		if ($('#tabDebInfo').length == 0) {	   // If not exist info area, append one.
			var $tabDeb = $('<div>', { 'id': 'tabDebInfo' });
			$tabDeb.css({ 'position': 'absolute', 'top': '320px', 'left': '200px', 'background-color': 'white' });
			$('#pceditor').append($tabDeb);
		}
		switch (mode) {
			case 'dump':
				$('#tabDebInfo').html(message);
				break;
			case 'trace':
				var currentText = $('#tabDebInfo').html();
				message += ('<br/>' + currentText);
				$('#tabDebInfo').html(message);
				break;
			case 'end':
				$('#tabDebInfo').remove();
				break;
			default:
				$('#tabDebInfo').html('Illegal mode:(' + mode + ')');
				break;
		}
	}
}

/** ===
 * Definition of methods that iPad clientX/Y convert.
 **/
function getEventClient(event) {
	var evClient = { x: 0, y: 0 };
  if (event.changedTouches == undefined) {	// Maybe event is click.
    evClient.x = event.clientX;
    evClient.y = event.clientY;
  } else {	// Maybe event is mouse event.
    var touchObject = event.changedTouches[0];
    evClient.x = touchObject.pageX;
    evClient.y = touchObject.pageY;
  }
	return evClient;
}

/** ===
 * Definition of methods that may not be supported.
 **/

/* trim() is supported in the ES5.1 */
if (!String.prototype.trim) {
	String.prototype.trim = function () {
		return this.replace(/^\s+|\s+$/g, '');
	};
}

/* startsWith() is supported in the ES6 */
if (!String.prototype.startsWith) {
	String.prototype.startsWith = function (searchString, position) {
		position = position || 0;
		return this.substr(position, searchString.length) === searchString;
	};
}

/* sjisBytes() is the process for calculating the number of bytes in Shift-JIS */
String.prototype.sjisBytes = function () {
	var length = 0;
	for (var i = 0; i < this.length; i++) {
		var c = this.charCodeAt(i);
		if ((c >= 0x0 && c < 0x81) || (c === 0xf8f0) || (c >= 0xff61 && c < 0xffa0) || (c >= 0xf8f1 && c < 0xf8f4)) {
			length += 1;
		} else {
			length += 2;
		}
	}
	return length;
};

/* cutOutBytes () is the process of cutting out the specified number of bytes from a string. */
String.prototype.cutOutBytes = function (byteCount) {
	var length = 0;
	var cutOutStr = "";
	for (var i = 0; i < this.length; i++) {
		var c = this.charCodeAt(i);
		if ((c >= 0x0 && c < 0x81) || (c === 0xf8f0) || (c >= 0xff61 && c < 0xffa0) || (c >= 0xf8f1 && c < 0xf8f4)) {
			length += 1;
		} else {
			length += 2;
		}
		cutOutStr += this[i];
		if (length >= byteCount) {
			break;
		}
	}
	return cutOutStr;
}

/* bytes() is the process of get bytes count */
String.prototype.bytes = function () {
	return(encodeURIComponent(this).replace(/%../g, "x").length);
  }

/* Date.now() is supported in the ES5.1 */
if (!Date.now) {
	Date.now = function now() {
		return new Date().getTime();
	};
}

/** ===
 * Definition of methods that each convert data.
 **/

/* except semicolon */
function exceptEndEmp(prgData) {
	var i = prgData.length - 1;
	for (; i >= 0; i--) {
		if (prgData[i] != ' ') {
			break;
		}
	}
	prgData = prgData.substr(0, i + 1);
	return prgData;
}

/* Quotation escape */
function escapeQuote(orgStr) {
    if (typeof orgStr != 'string') {
        orgStr = '' + orgStr;
    }
    return orgStr.replace(/\\/g, '\\\\')
                 .replace(/""/g, '\"\"');	// Escape continuous double quotes.
}

/* Convert SJIS data to Unicode */
function convertSjistoUcd(sJisText) {
	// Shift_JIS to Unicode convert
	var sjisArray = [];
	for (var convIdx = 0; convIdx < sJisText.length; convIdx++) {
		var tempCharCode = sJisText.charCodeAt(convIdx);
		if (tempCharCode > 0x00) { // Not null character
			sjisArray[convIdx] = tempCharCode;
		}
	}
	var ucdArray = Encoding.convert(sjisArray, 'Unicode', 'SJIS');
	var ucd8Str = Encoding.codeToString(ucdArray);
	return ucd8Str;
}
                                                                                                                                                                                                                                                                                                                                         /**********************************************************************
 * Robot Program Editor script
 * Commad List Definition table
 * Created: 2017/07/04 FSI
 *
 */

/* === definition command parts of dialog control === */
var commandParts = {
	'eg': {
		"txtMotionJ": "J",
		"txtMotionL": "L",
		"txtMotionA": "A",
		"txtMotionC": "C",
		"txtCnt": "CNT",
		"txtFine": "FINE",
		"selRegP": "P",
		"selRegPR": "PR",
		"selRegPRAx": "PR[i,j]",
		"selRegR": "R",
		"selRegAR": "AR",
		"selRegSR": "SR",
		"selRegDO": "DO",
		"selRegRO": "RO",
		"selRegAO": "AO",
		"selRegGO": "GO",
		"selRegF": "F",
		"selSelect": "SELECT",
		"selSelCase": "(SELECT)=",
		"selSelElse": "(SELECT)ELSE",
		"selCmdIf": "IF",
		"selCmdWait": "WAIT",
		"selCmdWaitErr": "WAIT ERR_NUM",
		"selCmdCall": "CALL",
		"selCmdRun": "RUN",
		"selCmdTimer": "TIMER",
		"selCmdLbl": "LBL",
		"selJmpLbl": "JMP LBL",
		"selCmdPayld": "PAYLOAD",
		"selCmdMsg": "MESSAGE",
		"selCmdUalm": "UALM",
		"selCmdOffsetCond": "OFFSET CONDITION",
		"selCmdToolOfstCnd": "TOOL_OFFSET CONDITION",
		"selCmdSkipCond": "SKIP CONDITION",
		"selCmdSkipErr": "SKIP CONDITION ERR_NUM",
		"selCmdUFrame": "UFRAME",
		"selCmdUTool":  "UTOOL",
		"selCmdUFNum": "UFRAME_NUM",
		"selCmdUTNum": "UTOOL_NUM",
		"selCmdDiag": "DIAG_REC",
		"selCmdDiagSec": "DIAG_REC_SEC",
		"selCmdRsr": "RSR",
		"selCmdOvrride": "OVERRIDE",
		"selCmdJntMax": "JOINT_MAX_SPEED",
		"selCmdLnrMax": "LINEAR_MAX_SPEED",
		"selAddAcc": "ACC",
		"selAddSimEV": "EV",
		"selAddIndEV": "Ind.EV",
		"selAddSkpLb": "Skip,LBL",
		"selAddOffPr": "Offset,PR ",
		"selAddToolPr": "Tool_Offset,PR",
		"selAddTB": "TB",
		"selAddTA": "TA",
		"selAddDB": "DB",
		"selAddTBC": "TB",
		"selAddTBS": "TB",
		"selAddTBP": "TB",
		"selAddTAC": "TA",
		"selAddTAS": "TA",
		"selAddTAP": "TA",
		"selAddDBC": "DB",
		"selAddDBS": "DB",
		"selAddDBP": "DB",
		"selAddPntLogic": "POINT_LOGIC",
		"selTmoutlbl": "TIMEOUT,LBL",
		"valRegP": "P[]",
		"valRegPR": "PR[]",
		"valRegPRAx": "PR[,]",
		"valRegR": "R[]",
		"valRegAR": "AR[]",
		"valRegSR": "SR[]",
		"valRegDO": "DO[]",
		"valRegRO": "RO[]",
		"valRegAO": "AO[]",
		"valRegGO": "GO[]",
		"valRegSO": "SO[]",
		"valRegUO": "UO[]",
		"valRegDI": "DI[]",
		"valRegRI": "RI[]",
		"valRegAI": "AI[]",
		"valRegGI": "GI[]",
		"valRegSI": "SI[]",
		"valRegUI": "UI[]",
		"valEnable": "ENABLE",
		"valDisable": "DISABLE",
		"valStart": "START",
		"valStop": "STOP",
		"valReset": "RESET",
		"valSelElse": "ELSE",
		"valAnd": " AND ",
		"valOr": " OR ",
		"valOn": "On",
		"valOff": "Off",
		"valPulse": "Pulse",
		"valTimer": "TIMER[]",
		"valTmovf": "TIMER_OVERFLOW[]",
		"valStrlen": "STRLEN",
		"valFindstr": "FINDSTR",
		"valLpos": "Lpos",
		"valJpos": "Jpos",
		"valUframe": "UFRAME[]",
		"valUtool": "UTOOL[]",
		"valSubstr": "SUBSTR",
		"valOnP": "On+",
		"valOffM": "Off-"
	},
	'jp': {
		"txtMotionJ": "ｶｸｼﾞｸ",
		"txtMotionL": "ﾁｮｸｾﾝ",
		"txtMotionA": "Cｴﾝｺ",
		"txtMotionC": "ｴﾝｺ",
		"txtCnt": "ﾅﾒﾗｶ",
		"txtFine": "ｲﾁｷﾞﾒ",
		"selRegP": "ｲﾁ",
		"selRegPR": "ｲﾁﾚｼﾞ",
		"selRegPRAx": "ｲﾁﾚｼﾞ[i,j]",
		"selRegR": "ﾚｼﾞ",
		"selRegAR": "ﾋｷｽｳ",
		"selRegSR": "ﾓｼﾞﾚｼﾞ",
		"selRegDO": "DO",
		"selRegRO": "RO",
		"selRegAO": "AO",
		"selRegGO": "GO",
		"selRegF": "F",
		"selSelect": "ｾﾝﾀｸ",
		"selSelCase": "(ｾﾝﾀｸ)=",
		"selSelElse": "(ｾﾝﾀｸ)ｿﾉﾀ",
		"selCmdIf": "ﾓｼ",
		"selCmdWait": "ﾀｲｷ",
		"selCmdWaitErr": "ﾀｲｷ ｴﾗｰﾊﾞﾝｺﾞｳ",
		"selCmdCall": "ﾖﾋﾞﾀﾞｼ",
		"selCmdRun": "ｼﾞｯｺｳ",
		"selCmdTimer": "ﾀｲﾏ",
		"selCmdLbl": "ﾗﾍﾞﾙ",
		"selJmpLbl": "ｼﾞｬﾝﾌﾟ ﾗﾍﾞﾙ",
		"selCmdMsg": "ﾒｯｾｰｼﾞ",
		"selCmdPayld": "ﾌｶｾｯﾃｲ",
		"selCmdUalm": "ﾕｰｻﾞｱﾗｰﾑ",
		"selCmdOffsetCond": "ｲﾁﾎｾｲ ｼﾞｮｳｹﾝ",
		"selCmdToolOfstCnd": "ﾂｰﾙﾎｾｲ ｼﾞｮｳｹﾝ",
		"selCmdSkipErr": "ｽｷｯﾌﾟ ｼﾞｮｳｹﾝ ｴﾗｰﾊﾞﾝｺﾞｳ",
		"selCmdSkipCond": "ｽｷｯﾌﾟ ｼﾞｮｳｹﾝ",
		"selCmdUFrame": "ﾕｰｻﾞｻﾞﾋｮｳ",
		"selCmdUTool":  "ﾂｰﾙｻﾞﾋｮｳ",
		"selCmdUFNum": "ﾕｰｻﾞｻﾞﾋｮｳﾊﾞﾝｺﾞｳ",
		"selCmdUTNum": "ﾂｰﾙｻﾞﾋｮｳﾊﾞﾝｺﾞｳ",
		"selCmdDiag": "ｼﾝﾀﾞﾝ_ｷﾛｸ",
		"selCmdDiagSec": "ｼﾝﾀﾞﾝ_ｷﾛｸ_ﾋﾞｮｳ",
		"selCmdRsr": "RSR",
		"selCmdOvrride": "ｵｰﾊﾞﾗｲﾄﾞ",
		"selCmdJntMax": "ｶｸｼﾞｸ ｻｲｺｳ ｿｸﾄﾞ",
		"selCmdLnrMax": "ﾁｮｸｾﾝ ｻｲｺｳ ｿｸﾄﾞ",
		"selAddAcc": "ｶｿｸﾄﾞ",
		"selAddSimEV": "ﾄﾞｳｷﾌｶｿｸﾄﾞ",
		"selAddIndEV": "ﾋﾄﾞｳｷﾌｶｿｸﾄﾞ",
		"selAddSkpLb": "ｽｷｯﾌﾟ,ﾗﾍﾞﾙ",
		"selAddOffPr": "ｲﾁﾎｾｲ,ｲﾁﾚｼﾞ",
		"selAddToolPr": "ﾂｰﾙﾎｾｲ,ｲﾁﾚｼﾞ",
		"selAddTB": "ｻｷｼﾞｯｺｳ",
		"selAddTA": "ｱﾄｼﾞｯｺｳ",
		"selAddDB": "ｻｷｼﾞｯｺｳ(ｷｮﾘ)",
		"selAddTBC": "ｻｷｼﾞｯｺｳ",
		"selAddTBS": "ｻｷｼﾞｯｺｳ",
		"selAddTBP": "ｻｷｼﾞｯｺｳ",
		"selAddTAC": "ｱﾄｼﾞｯｺｳ",
		"selAddTAS": "ｱﾄｼﾞｯｺｳ",
		"selAddTAP": "ｱﾄｼﾞｯｺｳ",
		"selAddDBC": "ｻｷｼﾞｯｺｳ",
		"selAddDBS": "ｻｷｼﾞｯｺｳ",
		"selAddDBP": "ｻｷｼﾞｯｺｳ",
		"selAddPntLogic": 'ﾎﾟｲﾝﾄﾛｼﾞｯｸ',
		"selTmoutlbl": "ｼﾞｶﾝｷﾞﾚ,ﾗﾍﾞﾙ",
		"valRegP": "ｲﾁ[]",
		"valRegPR": "ｲﾁﾚｼﾞ[]",
		"valRegPRAx": "ｲﾁﾚｼﾞ[,]",
		"valRegR": "ﾚｼﾞ[]",
		"valRegAR": "ﾋｷｽｳ[]",
		"valRegSR": "ﾓｼﾞﾚｼﾞ[]",
		"valRegDO": "DO[]",
		"valRegRO": "RO[]",
		"valRegAO": "AO[]",
		"valRegGO": "GO[]",
		"valRegSO": "SO[]",
		"valRegUO": "UO[]",
		"valRegDI": "DI[]",
		"valRegRI": "RI[]",
		"valRegAI": "AI[]",
		"valRegGI": "GI[]",
		"valRegSI": "SI[]",
		"valRegUI": "UI[]",
		"valEnable": "ﾕｳｺｳ",
		"valDisable": "ﾑｺｳ",
		"valStart": "ｽﾀｰﾄ",
		"valStop": "ｽﾄｯﾌﾟ",
		"valReset": "ﾘｾｯﾄ",
		"valSelElse": "ｿﾉﾀ",
		"valAnd": " ｶﾂ ",
		"valOr": " ﾏﾀﾊ ",
		"valOn": "ｵﾝ",
		"valOff": "ｵﾌ",
		"valPulse": "ﾊﾟﾙｽ",
		"valTimer": "ﾀｲﾏ[]",
		"valTmovf": "ﾀｲﾏ ｵｰﾊﾞﾌﾛｰ[]",
		"valStrlen": "ﾓｼﾞ_ﾅｶﾞｻ",
		"valFindstr": "ﾓｼﾞ_ｹﾝｻｸ",
		"valLpos": "ﾁｮｯｺｳｲﾁ",
		"valJpos": "ｶｸｼﾞｸｲﾁ",
		"valUframe": "ﾕｰｻﾞｻﾞﾋｮｳ[]",
		"valUtool": "ﾂｰﾙｻﾞﾋｮｳ[]",
		"valSubstr": "ﾓｼﾞ_ﾄﾘﾀﾞｼ",
		"valOnP": "ﾀﾁｱｶﾞﾘ",
		"valOffM": "ﾀﾁｻｶﾞﾘ"
	}
};
                                                                                                                                                                                                      /**********************************************************************
 * Page control script
 * Created: 2018/11/13 FSI (porting from treemenu common)
 */

// Use jQuery
/*
 * jQuery JavaScript Library
 * https://jquery.com/
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 */

var pagingMaxItemNum = 100;
var pagingStartItemNum = 1;
var pagingEndItemNum = 20;
var pagingMaxPageNum = 5;
var pagingCurrentPage = 1;
var pagingRowPerPage = 20;

/*
 * Set Page Layout
 */
function setPageLayout(obj) {
	var divarea = $('<div>', { id: 'page_left_area', class: 'page_left_area' });
	divarea.html('<button id="page_prevbtn" class="page_prevbtn page_prevoff"></button>' +
		'<div id="page_num" class="page_num" name="page_num" tabindex="2">' +
		'<div id="page_btn" class="page_btn">' +
		'<img id="pageimg" class="pageimg" src="../common/images/select_icon.png">' +
		'</div>' +
		'</div>' +
		'<div id="page_slash" class="page_slash"></div>' +
		'<div id="page_max" class= "page_max"></div>' +
		'<div id="page_unit" class="page_unit">/</div>' +
		'<button id="page_nextbtn" class="page_nextbtn page_nextoff"></button>');
	obj.append(divarea);
	divarea = $('<div>', { id: 'page_right_area', class: 'page_right_area' });
	divarea.html('<div id="page_right_block" class="page_right_block">' +
		'<div id="page_item_num" class= "page_item_num"></div>' +
		'<div id="page_item_unit" class= "page_item_unit">/&nbsp;</div>' +
		'<div id="page_item_max" class= "page_item_max"></div>' +
		'<div id="page_item_max_unit" class= "page_item_max_unit"></div></div>');
	obj.append(divarea);
}

/*
 * Correct Page Layout(safari or eg)
 */
function correctPageLayout() {
	var lang = getCurrentLanguage();
	if ((lang == 'jp')
		|| (lang == 'ch')) {
		var userAgent = window.navigator.userAgent.toLowerCase();
		if ((userAgent.indexOf('chrome') == -1)
			&& (userAgent.indexOf('safari') != -1)) {
			$('#page_unit').css('margin-top', '1px');
			$('#page_item_unit').css('margin-top', '-3px');
			$('#page_item_max_unit').css('margin-top', '-3px');
		}
	} else {
		$('#page_slash').css('margin-top', '2px');
		$('#page_unit').css('margin-top', '6px');
		$('#page_max').css('margin-top', '6px');
	}
}
/*
 * Initialize Page Area Data
 */
function initPageArea(item_max, rowPerPage) {
	pagingRowPerPage = rowPerPage;
	// set variable and css
	pagingMaxItemNum = item_max;
	pagingStartItemNum = 1;
	if (pagingMaxItemNum >= pagingRowPerPage) {
		pagingEndItemNum = pagingStartItemNum + (pagingRowPerPage - 1);
	} else {
		pagingEndItemNum = pagingMaxItemNum;
	}

	pagingMaxPageNum = Math.floor(pagingMaxItemNum / pagingRowPerPage);
	var math = pagingMaxItemNum % pagingRowPerPage;
	if (math != 0) {
		pagingMaxPageNum = pagingMaxPageNum + 1;
	}
	pagingCurrentPage = 1;
	updatePageButton();
	// Set a time interval to correctly set the page number for IE
	setTimeout(function () { setPageAreaHtml(); }, 10);
}

/*
 * Set Page Area html
 */
function setPageAreaHtml() {
	var sel_btn = $('#page_btn');
	$('#page_num').text(pagingCurrentPage);
	$('#page_num').append(sel_btn);
	$('#page_max').html(pagingMaxPageNum);

	$('#page_item_num').html(pagingStartItemNum + "-" + pagingEndItemNum);
	$('#page_item_max').html(pagingMaxItemNum);
}

/*
 * Set page area event
 */
function setPageAreaEvent(entryFunc) {
	$("#page_prevbtn").on('click touchend', function (event) {
		if(event.type.indexOf('touch') >= 0){
			event.preventDefault();
		}
		if (pagingCurrentPage <= 1) {
			return;
		}
		var sel_btn = $('#page_btn');
		pagingCurrentPage = pagingCurrentPage - 1;
		$('#page_num').text(pagingCurrentPage);
		$('#page_num').append(sel_btn);

		updatePageButton();
		calcItemNum();
		$("#page_prevbtn").blur();
		setTimeout(function () {
			entryFunc(pagingStartItemNum, pagingEndItemNum);
		}, 0);
	});
	$("#page_nextbtn").on('click touchend', function (event) {
		if(event.type.indexOf('touch') >= 0){
			event.preventDefault();
		}
		if (pagingCurrentPage >= pagingMaxPageNum) {
			return;
		}
		var sel_btn = $('#page_btn');
		pagingCurrentPage = pagingCurrentPage + 1;
		$('#page_num').text(pagingCurrentPage);
		$('#page_num').append(sel_btn);

		updatePageButton();
		calcItemNum();
		$("#page_nextbtn").blur();
		setTimeout(function () {
			entryFunc(pagingStartItemNum, pagingEndItemNum);
		}, 0);
	});
	$("#page_num").on('click', function (event) {
		if (pagingMaxPageNum == 1) {
			return;
		}

		var sel_menu = $('.page_frame');

		if (sel_menu.length) {
			var target = $(event.target);
			$('.page_frame').remove();
			$('#pageimg').attr('src', '../common/images/select_icon.png');

			if (target.hasClass('page_sel')) {
				var sel_btn = $('#page_btn');
				pagingCurrentPage = Number(target.text());
				$('#page_num').text(pagingCurrentPage);
				$('#page_num').append(sel_btn);
				updatePageButton();
				calcItemNum();
				setTimeout(function () {
					entryFunc(pagingStartItemNum, pagingEndItemNum);
				}, 0);
			}
			return;
		} else {
			$('#pageimg').attr('src', '../common/images/select_icon_open.png');

			var menu_frame = $('<div></div>', {
				addClass: "page_frame"
			});

			for (var i = 1; i <= pagingMaxPageNum; i++) {
				var menu_sel = $('<div></div>', {
					addClass: "page_sel"
				});

				menu_sel.text(i);

				if (i == pagingCurrentPage) {
					menu_sel.addClass('page_select');
				}
				if (i == pagingMaxPageNum) {
					menu_sel.addClass('page_end');
				}

				menu_frame.append(menu_sel);
			}

			$(this).append(menu_frame);
			return;
		}
	});
	$("#page_num").on('blur', function (event) {
		var sel_menu = $('.page_frame');
		if (sel_menu.length) {
			$('#pageimg').attr('src', '../common/images/select_icon.png');
			$('.page_frame').remove();
		}
		return;
	});
}

/*
 * Set color change in page button
 */
function updatePageButton() {
	if (pagingCurrentPage > 1) {
		if (pagingMaxPageNum == 1) { // just in case
			$('#page_prevbtn').removeAttr("tabindex");
			$('#page_prevbtn').removeClass('page_prevon');
			$('#page_prevbtn').addClass('page_prevoff');
		} else {
			$('#page_prevbtn').attr('tabindex', '1');
			$('#page_prevbtn').removeClass('page_prevoff');
			$('#page_prevbtn').addClass('page_prevon');
		}
	} else {
		$('#page_prevbtn').removeAttr("tabindex");
		$('#page_prevbtn').removeClass('page_prevon');
		$('#page_prevbtn').addClass('page_prevoff');
	}

	if (pagingCurrentPage == pagingMaxPageNum) {
		$('#page_nextbtn').removeAttr("tabindex");
		$('#page_nextbtn').removeClass('page_nexton');
		$('#page_nextbtn').addClass('page_nextoff');
	} else {
		$('#page_nextbtn').attr('tabindex', '3');
		$('#page_nextbtn').removeClass('page_nextoff');
		$('#page_nextbtn').addClass('page_nexton');
	}
}

/*
 * Calculate Display Item
 */
function calcItemNum() {
	pagingStartItemNum = pagingRowPerPage * (pagingCurrentPage - 1) + 1;
	if (pagingStartItemNum + (pagingRowPerPage - 1) <= pagingMaxItemNum) {
		pagingEndItemNum = pagingCurrentPage * pagingRowPerPage;
	} else {
		pagingEndItemNum = pagingMaxItemNum;
	}
	$("#page_item_num").html(pagingStartItemNum + "-" + pagingEndItemNum);
}

function getCurrentItemStart() {
	return pagingStartItemNum;
}

function getCurrentItemEnd() {
	return pagingEndItemNum;
}

/*
 * Remove focus of select box when page is chosen for IE.
 */
function removePageFocus() {
	$('#page_num').blur();
}
                                                                                    /**********************************************************************
 * Robot Program Editor script
 * for Position register procedure.
 * Created: 2018/11/12
 * Modified:2018/11/22 [FSI 201811]
 */
// Use w2ui.
/* w2ui 1.5.rc1 (nightly) (c) http://w2ui.com, vitmalina@gmail.com */
/* Code licensed under the MIT License. */
/* https://github.com/vitmalina/w2ui/blob/master/license.txt */

/**
 * Definition for Position data window.
 */

// - Variable definition of Position Register Table -
var captionPosRegTbl = [];
captionPosRegTbl = captionPosRegTbl.concat(posDatHead).concat(entrykeysJoint).concat(entrykeysCart).concat(entrykeysExt).concat(entrykeysForm);

// - Definition for Position Register -
var POSREG_INTERVAL_TIME = 3000;	// Interval Time for get Position register value. original is 1000
var gridArrayCart = [];
gridArrayCart = gridArrayCart.concat(entrykeysCart).concat(entrykeysConf);
var columnsArrayCart = [];
var columnsArrayJoint = [];
var columnsArrayExt = [];
var isConvPosReg = false;
var isTchUpPosReg = false;
// POSFIELDARRAY is defined in poswin

// Current Config String
var currentConfigStr = '';
function getCurrentConfig() {
  return currentConfigStr;
}
function setCurrentConfig(str) {
  currentConfigStr = str;
}

/* --- position register modify flag --- */
var posRegModified = false;
function isPosRegModified() {
  return posRegModified;
}
function setPosRegModified(modify) {
  posRegModified = modify;
}

// Variables for Paging
var posRegStartNum = 1;
var posRegEndNum = 20;
var currentPosRegPage = 1;
var posRegRecParPage = 20;
var maxPosRegCount = 100;
function getCurrentPosRegPage() {
  return currentPosRegPage;
}
function setCurrentPosRegPage(startNum) {
  currentPosRegPage = (startNum / posRegRecParPage) + 1;
}
function getPosRegStartNum() {
  return posRegStartNum;
}
function setPosRegStartNum(num) {
  posRegStartNum = num;
}
function getPosRegEndNum() {
  return posRegEndNum;
}
function setPosRegEndNum(num) {
  posRegEndNum = num;
}

// Variable for PosReg process
var posRegMaxNum = null;
var selectGridRow = [];	// Select Row array

// Variable for continuing data update.
var continuousUpdate = false;	// true= on update
function isContinuousUpdate() {
  return continuousUpdate;
}
function setContinuousUpdate(cont) {
  continuousUpdate = cont;
}
// Position Register polling timer
var timerIdPosReg = null;
var enablePolling = false;
function isEnablePolling() {
  return enablePolling;
}
function stopGetPosRegPolling() {
  debug(DBGDUMP, 'stopGetPosRegPolling');
  if (timerIdPosReg != null) {
    clearTimeout(timerIdPosReg);
  }
  timerIdPosReg = null;
  enablePolling = false;
}
function startGetPosRegPolling() {
  debug(DBGDUMP, 'startGetPosRegPolling');
  enablePolling = true;
  if (timerIdPosReg != null) {
    clearTimeout(timerIdPosReg);
  }
  timerIdPosReg = setTimeout(function () { readPosRegRecord(); }, POSREG_INTERVAL_TIME);
}
// Timer variable to reset enablePolling to false.
var timerIdSendKeepData = null;
var keepPosRegData = false;	// The flag to switch whether to keep data or not.
function isKeepPosRegData() {
  return keepPosRegData;
}
function setKeepPosRegData(keep) {
  keepPosRegData = keep;
}

/*
 * Check specified index column is display on.
 */
function showSpcifiedColumn(index) {	// if specifed column display on, return true.
  return (!w2ui[POSREGSTBL].getColumn(POSFIELDARRAY[index]).hidden);
}

/*
 * Initialize Position Register Data
 */
function initPositionRegister(startRec, endRec) {
  stopGetPosRegPolling();
  var cbArg = {};
  cbArg.tblKind = POSTBLKIND_REGS;
  var posRec = createPosRegRow();
  cbArg.rec = posRec;
  // get config string
  get_curpos(top.KXYZWPR, top.TXML_TP_REC_TYPE, getCurrentGroupNum(), getCurrentConfigCallback, cbArg);	// common_io
  setTimeout(function () {
    drawPosRegData(startRec, endRec);
  }, 0);
}
/*
 * Draw Position Register Data
 */
function drawPosRegData(startRec, endRec) {
  clearTimeout(timerIdPosReg);
  setPosRegStartNum(startRec);
  setPosRegEndNum(endRec);
  var linebuff = [];
  w2ui[POSREGSTBL].clear();
  var crntGrpNum = getCurrentGroupNum();
  for (var i = startRec; i <= endRec; i++) {
    var newline = createPosRegRow();
    newline.GP = crntGrpNum;
    newline.recid = linebuff.length + 1;
    //newline.rowno = resources["PosRegName"] + "[" + i + "]";
    newline.rowno = i;
    newline.id = i;
    newline.rep = POS_REP_NONE;
    linebuff.push(newline);
  }
  if (linebuff.length != 0) {
    w2ui[POSREGSTBL].add(linebuff);
  }
  w2ui[POSREGSTBL].refresh();
  if (selectGridRow != null) {
    w2ui[POSREGSTBL].select(selectGridRow[0]);
  }
  isDrawFinish = false;
  setFileName("edposreg");
  getPosRegValue(getCurrentGroupNum(), getPosRegStartNum(), posRegRecParPage, posRegValueCallback); // api
}
/*
 * Change page. (call from paging.js)
 */
var isDrawFinish = false;
var timerIdWatchDraw = null;
function changePosRegPage(startRec, endRec) {
  isTchUpPosReg = false;
  removePageFocus();
  if (isKeepPosRegData()) {
    setAllCurrentPagePosReg();
  }
  stopGetPosRegPolling();
  drawPosRegData(startRec, endRec);
  timerIdWatchDraw = setTimeout(function () { watchFinishDraw(); }, 20);
}
function watchFinishDraw() {
  if (!isDrawFinish) {
    clearTimeout(timerIdWatchDraw);
    timerIdWatchDraw = setTimeout(function () { watchFinishDraw(); }, 20);
    return;
  }
  clearTimeout(timerIdWatchDraw);
  timerIdWatchDraw = null;
  w2ui[POSREGSTBL].refresh();
  var focusTargetId = (crntGridSelType == SELGRID_CELL) ? '#grid_posregstbl_data_0_1' : '#grid_posregstbl_rec_1';
  //$(focusTargetId).click();
  $(focusTargetId).focus();
  debug(DBGDUMP, 'watchFinishDraw: start polling.');
  startGetPosRegPolling();
}
/*
 * Callback of Get Position Register Value.
 */
function setRecordPosRegValue(grp, data, record) {
  switch (Number(data.rep)) {
    case POS_REP_CART:
    case POS_REP_BOTH:
      record.GP = grp;
      record.rep = Number(data.rep);
      record.Comment = data.Comment;
      record.Config = data.Config;
      record.X = Number(data.X);
      record.Y = Number(data.Y);
      record.Z = Number(data.Z);
      record.W = Number(data.W);
      record.P = Number(data.P);
      record.R = Number(data.R);
      record.UT = POS_REG_UT_VAL;
      record.UF = POS_REG_UF_VAL;
      record.axes = data.axes;
      for (var i = POSFIELDARRAY.indexOf('J1'); i <= POSFIELDARRAY.indexOf('J6'); i++) {
        record[POSFIELDARRAY[i]] = "";
      }
      for (var i = POSFIELDARRAY.indexOf('EXT1'); i <= POSFIELDARRAY.indexOf('EXT3'); i++) {
        var up_str = POSFIELDARRAY[i];
        record[up_str] = (data[up_str]) ? Number(data[up_str].data) : "";
      }
      record.frame = COORDINATECART;
      break;
    case POS_REP_JOINT:
      record.GP = grp;
      record.rep = POS_REP_JOINT;
      record.Comment = data.Comment;
      record.Config = data.Config;
      record.X = "";
      record.Y = "";
      record.Z = "";
      record.W = "";
      record.P = "";
      record.R = "";
      for (var i = POSFIELDARRAY.indexOf('J1'); i <= POSFIELDARRAY.indexOf('J6'); i++) {
        var up_str = POSFIELDARRAY[i];
        record[up_str] = (data[up_str]) ? Number(data[up_str].data) : "";
      }
      for (var i = POSFIELDARRAY.indexOf('EXT1'); i <= POSFIELDARRAY.indexOf('EXT3'); i++) {
        var up_str = POSFIELDARRAY[i];
        record[up_str] = (data[up_str]) ? Number(data[up_str].data) : "";
      }
      record.UT = POS_REG_UT_VAL;
      record.UF = POS_REG_UF_VAL;
      record.axes = data.axes;
      record.frame = COORDINATEJOINT;
      break;
  }
}
function posRegValueCallback(data_arr) {
  if ((getXmlErrorData().flg) && (getXmlErrorData().init)) {
    setXmlErrorData();
  }
  if ((data_arr == null) || 	// no data
    (Object.keys(data_arr).length == 0) ||
    (isConvPosReg) ||	// on convert
    (isTchUpPosReg) ||
    (isContinuousUpdate())) {
    return;	// NOP
  }
  var rowno = Object.keys(data_arr)[0].toString();
  var grp = Number(rowno.slice(0, 1));
  if (grp != getCurrentGroupNum()) {
    return;
  }
  var chg_data = w2ui[POSREGSTBL].getChanges();
  if (chg_data.length != 0) {
    w2ui[POSREGSTBL].save();
  }
  for (key in data_arr) {
    var id = key.toString().slice(2);
    var recid = w2ui[POSREGSTBL].find({ id: id });
    var record = w2ui[POSREGSTBL].records[recid[0] - 1];
    var data = data_arr[key];
    if ((id < getPosRegStartNum()) || (id > getPosRegEndNum())) {	// rec id is out of range...
      break;	//return;
    }
    if (data.rep) {
      setRecordPosRegValue(grp, data, record);
    } else {
      record.GP = grp;
      record.rep = POS_REP_NONE;
      record.Comment = data.Comment;
      record.Config = "";
      record.axes = "";
      for (var i = POSFIELDARRAY.indexOf('J1'); i <= POSFIELDARRAY.indexOf('UT'); i++) {
        record[POSFIELDARRAY[i]] = "";
      }
      record.frame = COORDINATEUNKOWN;
    }
    // FSI 20181122 Delete to add a line selection color
    //setPosRegColor(record);
    w2ui[POSREGSTBL].refreshRow(recid[0]);
  }
  paintMaskingCell();

  if (typeof getJointUnitGroup(getCurrentGroupNum()) !== 'undefined') {
    makeDisplayRepPos(w2ui[POSREGSTBL].records, POSTBLKIND_REGS);
  } else {
    setTimeout(function () {
      makeDisplayRepPos(w2ui[POSREGSTBL].records, POSTBLKIND_REGS);
    }, POSREG_INTERVAL_TIME);
  }
  isDrawFinish = true;	// finish draw.
}

/*
 * Update values
 */
function readPosRegRecord() {
  if ((!isConvPosReg) && (!isTchUpPosReg)) {
    if (!isContinuousUpdate()) {	// Continuous data update not in progress.
      debug(DBGDUMP, 'Polling Get Pos Reg Value. (from:' + getPosRegStartNum() + ' rec=' + posRegRecParPage + ')');
      getPosRegValue(getCurrentGroupNum(), getPosRegStartNum(), posRegRecParPage, posRegValueCallback); // api
    }
  } else {
    isConvPosReg = false;
    isTchUpPosReg = false;
  }
  debug(DBGDUMP, 'readPosRegRecord: start polling.');
  startGetPosRegPolling();
}

/*
 * It is called one second after the last data transmission.
 (Porting from posregister_main)
 */
function savePosRegAfterSend() {
  setContinuousUpdate(false);	// to send ok
  if (isKeepPosRegData()) {
    setAllCurrentPagePosReg();
  }
}

/*
 * Callback of Get Position Register Max Number.
 * (Call from common api) (Setting by poswin)
 */
function posRegMaxNumCallback(progname, varname, typecode, value, cbarg1, cbarg2) {
  posRegMaxNum = value.slice(0);
  initPageArea(posRegMaxNum, 20);
}

// Make posreg column information. (call from poswin)
function setPosRegColumnsData() {
  // Set Columns Data(Cartesian, Joint)
  var coldata = w2ui[POSREGSTBL].columns;
  for (var i = 0; i < coldata.length; i++) {
    if (gridArrayCart.indexOf(coldata[i].field) != -1) { // Cartesian Col
      columnsArrayCart.push(i);
    }
    if (entrykeysJoint.indexOf(coldata[i].field) != -1) { // Joint Col
      columnsArrayJoint.push(i);
    }
    if (entrykeysExt.indexOf(coldata[i].field) != -1) {	// Ext. Col
      columnsArrayExt.push(i);
    }
  }
}

/*
 * PosReg Color Setting(Cartesian, Joint)
 * It is not used in the PC editor, and set it aside just in case.
 */
function setPosRegColor(record) {
  switch (record.rep) {
    case POS_REP_NONE:
      for (var i = 0; i < columnsArrayCart.length; i++) {
        record.w2ui.style[columnsArrayCart[i]] = "background-color: transparent;";
      }
      for (var i = 0; i < columnsArrayJoint.length; i++) {
        record.w2ui.style[columnsArrayJoint[i]] = "background-color: transparent;";
      }
      //for (var i = 0; i < columnsArrayExt.length; i++) {
      //	record.w2ui.style[columnsArrayExt[i]] = "background-color: #ffffff;";
      //}
      break;
    case POS_REP_CART:
      for (var i = 0; i < columnsArrayCart.length; i++) {
        record.w2ui.style[columnsArrayCart[i]] = "background-color: transparent;";
      }
      for (var i = 0; i < columnsArrayJoint.length; i++) {
        record.w2ui.style[columnsArrayJoint[i]] = "background-color: #c7ced7;";
      }
      //for (var i = 0; i < columnsArrayExt.length; i++) {
      //	record.w2ui.style[columnsArrayExt[i]] = "background-color: #ffffff;";
      //}
      break;
    case POS_REP_BOTH:
      if (getCurrentFrameType() == COORDINATECART) {
        for (var i = 0; i < columnsArrayJoint.length; i++) {
          record.w2ui.style[columnsArrayJoint[i]] = "background-color: #c7ced7;";
        }
        for (var i = 0; i < columnsArrayCart.length; i++) {
          record.w2ui.style[columnsArrayCart[i]] = "background-color: transparent;";
        }
      } else {
        for (var i = 0; i < columnsArrayCart.length; i++) {
          record.w2ui.style[columnsArrayCart[i]] = "background-color: transparent;";
        }
        for (var i = 0; i < columnsArrayJoint.length; i++) {
          record.w2ui.style[columnsArrayJoint[i]] = "background-color: #c7ced7;";
        }
        for (var i = 0; i < columnsArrayExt.length; i++) {
          record[columnsArrayExt[i]] = "";
        }
      }
      //for (var i = 0; i < columnsArrayExt.length; i++) {
      //	record.w2ui.style[columnsArrayExt[i]] = "background-color: #ffffff;";
      //}
      break;
    case POS_REP_JOINT:
      if (getCurrentFrameType() == COORDINATEJOINT) {
        for (var i = 0; i < columnsArrayCart.length; i++) {
          record.w2ui.style[columnsArrayCart[i]] = "background-color: #c7ced7;";
        }
        for (var i = 0; i < columnsArrayJoint.length; i++) {
          record.w2ui.style[columnsArrayJoint[i]] = "background-color: transparent;";
        }
      } else {
        for (var i = 0; i < columnsArrayJoint.length; i++) {
          record.w2ui.style[columnsArrayJoint[i]] = "background-color: transparent;";
        }
        for (var i = 0; i < columnsArrayCart.length; i++) {
          record.w2ui.style[columnsArrayCart[i]] = "background-color: #c7ced7;";
        }
        for (var i = 0; i < columnsArrayExt.length; i++) {
          record[columnsArrayExt[i]] = "";
        }
      }
      //for (var i = 0; i < columnsArrayExt.length; i++) {
      //	record.w2ui.style[columnsArrayExt[i]] = "background-color: #ffffff;";
      //}
      break;
    default:
      for (var i = 0; i < columnsArrayCart.length; i++) {
        record.w2ui.style[columnsArrayCart[i]] = "background-color: #c7ced7;";
      }
      for (var i = 0; i < columnsArrayJoint.length; i++) {
        record.w2ui.style[columnsArrayJoint[i]] = "background-color: #c7ced7;";
      }
      //for (var i = 0; i < columnsArrayExt.length; i++) {
      //	record.w2ui.style[columnsArrayExt[i]] = "background-color: #c7ced7;";
      //}
      break;
  }
  w2ui[POSREGSTBL].refreshRow(record.recid);
}

/**
 * Delete specified position.
 */
var delPosRegArray = [];
function deletePosRegRecord() {
  var writeDataArray = [];
  setContinuousUpdate(false);	// make write data array
  for (var regidx = 0; regidx < delPosRegArray.length; regidx++) {
    var record = w2ui[POSREGSTBL].records[delPosRegArray[regidx] - 1];
    record.rep = POS_REP_NONE;
    record.Comment = "";
    record.Config = "";
    record.axes = "";
    record.force = true;
    // Data clear
    for (var i = POSFIELDARRAY.indexOf('J1'); i <= POSFIELDARRAY.indexOf('UT'); i++) {
      record[POSFIELDARRAY[i]] = "";
    }
    w2ui[POSREGSTBL].set(record.recid, record);
    w2ui[POSREGSTBL].save();
    cmtUpdateFlg[record.recid] = true;
    var recData = { clm: COLTBLOFS_CMNT, num: 2 };
    recordPosRegValue(record, recData, writeDataArray, true);
  }
  // Refrect (multi) row delete
  setPosRegValue(getCurrentGroupNum(), writeDataArray, setPosRegCallback);	// common_api
  cmtUpdateFlg = {};
  paintMaskingCell();
  setFocusAfterPosCtrl('#posctrldel');	// poswin
}
// Delete Position Register row... (Porting from posregister_main)
function deletePosRegister(delArray) {	// call from poswin (via dialog)
  stopGetPosRegPolling();
  delPosRegArray = delArray;
  deletePosRegRecord();
  deleteDisplayRepPos(w2ui[getSelPosTblName()].get(delArray[0]).rowno, delArray.length, getSelPosTblKind());
}

/*
 * Record Position Register Value
 * record: target record / column: target column / delete_flag: true=delete
 */
var cmtUpdateFlg = {};
function recordPosRegValue(record, recData, writeData, delete_flag) {
  stopGetPosRegPolling();
  switch (record.rep) {
    case POS_REP_CART:
    case POS_REP_BOTH:
    case POS_REP_JOINT:
      break;
    case POS_REP_NONE:
      if (((recData.clm == COLTBLOFS_CMNT) && (recData.num == 1)) || (delete_flag)) { 
      }else{
        var grpNum = getCurrentGroupNum();
        switch (getCurrentFrameType()) {	// poswin
          case COORDINATECART:
            record.rep = (getExtendAxesCount(grpNum) > 0) ? POS_REP_BOTH : POS_REP_CART;
            record.axes = getExtendAxesCount(grpNum);	// poswin
            record.UT = POS_REG_UT_VAL;
            record.UF = POS_REG_UF_VAL;
            record.frame = COORDINATECART;
            // When config and other than comments are entered.
            for (var i = POSFIELDARRAY.indexOf('X'); i <= POSFIELDARRAY.indexOf('R'); i++) {
              if (record[POSFIELDARRAY[i]] === "") {
                record[POSFIELDARRAY[i]] = 0;
              }
            }
            for (var i = POSFIELDARRAY.indexOf('EXT1'); i <= POSFIELDARRAY.indexOf('EXT3'); i++) {
              if (showSpcifiedColumn(i)) {
                if (record[POSFIELDARRAY[i]] === "") {
                  record[POSFIELDARRAY[i]] = 0;
                }
              }
            }
            // If anything other than config is entered in the initial data, we get the config of the current position.
            if (recData.clm != COLTBLOFS_CONF) {
              record.Config = getCurrentConfig();
            }
            break;
          case COORDINATEJOINT:
            record.force = true;
            record.rep = POS_REP_JOINT;
            record.axes = getAxesCount(grpNum);	// api
            record.UT = POS_REG_UT_VAL;
            record.UF = POS_REG_UF_VAL;
            record.frame = COORDINATEJOINT;
            for (var i = POSFIELDARRAY.indexOf('J1'); i <= POSFIELDARRAY.indexOf('J6'); i++) {
              if (showSpcifiedColumn(i)) {
                if (record[POSFIELDARRAY[i]] === "") {
                  record[POSFIELDARRAY[i]] = 0;
                }
              }
            }
            for (var i = POSFIELDARRAY.indexOf('EXT1'); i <= POSFIELDARRAY.indexOf('EXT3'); i++) {
              if (showSpcifiedColumn(i)) {
                if (record[POSFIELDARRAY[i]] === "") {
                  record[POSFIELDARRAY[i]] = 0;
                }
              }
            }
            break;
          default:
            break;
        }
      }
      break;
    default:
      debug(DBGERROR, 'recordPosRegValue: Unknown rep.(' + record.rep + ')');
      break;
  }
  //setPosRegColor(record);	// reset color [1/17/2019] No need to set the color.
  w2ui[POSREGSTBL].refreshRow(record.recid);	// [1/17/2019] Process in place of the above
  paintMaskingCell();	// [1/17/2019] Process in place of the above

  if (recData.clm == COLTBLOFS_CMNT) {
    cmtUpdateFlg[record.id] = true;
  } else if (cmtUpdateFlg[record.id] != true) {
    cmtUpdateFlg[record.id] = false;
  }
  if (isContinuousUpdate()) {	// If continuous input is in progress.
    setKeepPosRegData(true);
    clearTimeout(timerIdSendKeepData);
    timerIdSendKeepData = setTimeout(function () {
      savePosRegAfterSend();
    }, POSREG_INTERVAL_TIME);
  } else {	// If it was a single input. or delete
    writeData.push(createPosRegWriteData(record));
    //    setPosRegValue(getCurrentGroupNum(), writeData, setPosRegCallback);	// common_api
    //	setKeepPosRegData(false);
    //	setContinuousUpdate(true);	// update is continue
    //    timerIdSendKeepData = setTimeout(function () {
    //		savePosRegAfterSend();
    //	}, POSREG_INTERVAL_TIME);
    //    record.force = false;
  }
  return writeData;
}

/*
 * Set All Current Page Position Register Value
 */
function setAllCurrentPagePosReg() {
  var writeDataArray = [];
  for (var i = getPosRegStartNum(); i <= getPosRegEndNum(); i++) {
    var recid = w2ui[POSREGSTBL].find({ id: i });
    var record = w2ui[POSREGSTBL].records[recid[0] - 1];
    //record.force = false;
    var write_data = createPosRegWriteData(record);
    writeDataArray.push(write_data);
  }
  setPosRegValue(getCurrentGroupNum(), writeDataArray, setPosRegCallback);	// common_api
  cmtUpdateFlg = {};
  setKeepPosRegData(false);	// keep data nothing
  setContinuousUpdate(false);	// update is continue
}

// Callback for acquire the current location's config when you put values in the initial data.
function getCurrentConfigCallback(pos_rep, pos_type, grp_num, str, cbArg) {
  var posJson = analyzeCartesianPosition(str, cbArg);
  setCurrentConfig(posJson.Config);
}

// create empty row
function createPosRegRow() {
  var empty = {};
  empty.recid = "";
  empty.rowno = "";
  for (var i = 1; i < captionPosTbl.length; i++) {
    empty[captionPosTbl[i]] = "";
  }
  empty.GP = getCurrentGroupNum();
  empty.frame = COORDINATEUNKOWN;	//getCurrentFrameType();
  //empty.save = false;
  empty.error = 0;
  empty.trgtTbl = POSTBLKIND_REGS;
  empty.rep = POS_REP_NONE;
  empty.axes = getAxesCount(empty.GP);
  empty.id = "";
  empty.force = false;
  empty.config_flag = false;
  empty.w2ui = {};
  empty.w2ui.style = {};
  return empty;
}

/*
 * Set to w2ui record directry.
 */
function setPosRegRecord(chgRec) {
  var posRegRow = w2ui[POSREGSTBL].records[chgRec.recid - 1];
  // make record data
  posRegRow.Config = chgRec.Config;
  posRegRow.rep = chgRec.rep;
  posRegRow.frame = chgRec.frame;
  posRegRow.force = true;
  if (chgRec.frame == COORDINATECART) {
    posRegRow.X = chgRec.X;
    posRegRow.Y = chgRec.Y;
    posRegRow.Z = chgRec.Z;
    posRegRow.W = chgRec.W;
    posRegRow.P = chgRec.P;
    posRegRow.R = chgRec.R;
    for (var l = POSFIELDARRAY.indexOf('J1'); l <= POSFIELDARRAY.indexOf('J6'); l++) {
      posRegRow[POSFIELDARRAY[l]] = "";
    }
  } else if (chgRec.frame == COORDINATEJOINT) {
    posRegRow.X = "";
    posRegRow.Y = "";
    posRegRow.Z = "";
    posRegRow.W = "";
    posRegRow.P = "";
    posRegRow.R = "";
    for (var l = POSFIELDARRAY.indexOf('J1'); l <= POSFIELDARRAY.indexOf('J6'); l++) {
      posRegRow[POSFIELDARRAY[l]] = chgRec[POSFIELDARRAY[l]];
    }
  } else {
    return;
  }
  for (var l = POSFIELDARRAY.indexOf('EXT1'); l <= POSFIELDARRAY.indexOf('EXT3'); l++) {
    posRegRow[POSFIELDARRAY[l]] = chgRec[POSFIELDARRAY[l]];
  }
  //w2ui[POSREGSTBL].save();
  w2ui[POSREGSTBL].refreshRow(chgRec.recid);
  paintMaskingCell();
}

/*
 * Check position register data and Put row data to system.
 * (Call from poswin)(Porting from poswin)
 * recid : Target record id.
 * reflect: Target record reflect flag. 1=Waiting, 0=Not Waiting
 */
function checkAndPutPosRegister(recid, reflect) {
  if (recid == undefined) {
    return COORDINATEUNKOWN;
  }
  stopGetPosRegPolling();
  var posLine = w2ui[POSREGSTBL].records[recid - 1];
  // Do not save if any one is not set.
  var rowInfo = getPositionStateRow(posLine);	// poswin
  var grpNum = getCurrentGroupNum();
  if (cmtUpdateFlg[recid] != true) {
    cmtUpdateFlg[recid] = false;
  }
  // All data input, update position data.
  if (rowInfo.posMode == COORDINATECART) {
    posLine.rep = (getExtendAxesCount(grpNum) > 0) ? POS_REP_BOTH : POS_REP_CART;
    posLine.axes = getExtendAxesCount(grpNum);	// api
  } else if (rowInfo.posMode == COORDINATEJOINT) {
    posLine.rep = POS_REP_JOINT;
    posLine.axes = getAxesCount(grpNum);	// api
    posLine.rob_axes = getJointRobotAxes(grpNum);
  }
  if (reflect == POSREG_NOTWAIT) {
    // Put Position Register Value !!!
    // Construct Position Register Write Data
    var writePRData = [];
    writePRData.push(createPosRegWriteData(posLine));
    // Put Position Register Data
    setPosRegValue(grpNum, writePRData, setPosRegCallback);	// common_api
    cmtUpdateFlg = {};
    posLine.force = false;
  } else {
    setKeepPosRegData(true);
    clearTimeout(timerIdSendKeepData);
    timerIdSendKeepData = setTimeout(function () {
      savePosRegAfterSend();
    }, POSREG_INTERVAL_TIME);
  }
}

/*
 * Set Position Register Callback (call from common_api)
 */
function setPosRegCallback(status) {
  debug(DBGINFO, 'setPosRegCallback: Write Pos Reg Data.(' + status + ')');
  debug(DBGDUMP, 'setPosRegCallback: start polling.');
  startGetPosRegPolling();
}

/*
 * Create Positio Register write data
 * (porting from postegister_main.js)
 */
function createPosRegWriteData(record) {
  var grpNum = getCurrentGroupNum();
  var writePRData = {};
  writePRData.id = record.id;
  writePRData.gnum = grpNum;
  writePRData.comment = (record.Comment == undefined) ? "" : record.Comment;
  writePRData.force = record.force;
  writePRData.only_cmt_flag = false;
  if (typeof cmtUpdateFlg[record.id] != 'undefined') {
    writePRData.only_pos_flag = ((cmtUpdateFlg[record.id]) ? false : true);
  } else {
    writePRData.only_pos_flag = true;
  }
  switch (record.rep) {
    case POS_REP_CART:
    case POS_REP_BOTH:
      writePRData.rep = record.rep;
      writePRData.axes = getExtendAxesCount(grpNum);
      writePRData.Config = record.Config;
      writePRData.X = record.X;
      writePRData.Y = record.Y;
      writePRData.Z = record.Z;
      writePRData.W = record.W;
      writePRData.P = record.P;
      writePRData.R = record.R;
      var axesCount = 6;
      for (var i = POSFIELDARRAY.indexOf('EXT1'); i <= POSFIELDARRAY.indexOf('EXT3'); i++) {
        if (showSpcifiedColumn(i)) {
          var up_str = POSFIELDARRAY[i];
          if (record[up_str] !== "") {
            writePRData[up_str] = {};
            writePRData[up_str].data = record[up_str];
            writePRData[up_str].unit = getJointUnitStr(grpNum, axesCount);
            axesCount++;
          }
        }
      }
      break;
    case POS_REP_JOINT:
      writePRData.rep = record.rep;
      writePRData.axes = getAxesCount(grpNum);
      writePRData.rob_axes = getJointRobotAxes(grpNum);
      writePRData.Config = record.Config;
      var axesCount = 0;
      for (var i = POSFIELDARRAY.indexOf('J1'); i <= POSFIELDARRAY.indexOf('J6'); i++) {
        var up_str = POSFIELDARRAY[i];
        if (record[up_str] !== "") {
          writePRData[up_str] = {};
          writePRData[up_str].data = record[up_str];
          writePRData[up_str].unit = getJointUnitStr(grpNum, axesCount);
          axesCount++;
        }
      }
      for (var i = POSFIELDARRAY.indexOf('EXT1'); i <= POSFIELDARRAY.indexOf('EXT3'); i++) {
        var up_str = POSFIELDARRAY[i];
        if (record[up_str] !== "") {
          writePRData[up_str] = {};
          writePRData[up_str].data = record[up_str];
          writePRData[up_str].unit = getJointUnitStr(grpNum, axesCount);
          axesCount++;
        }
      }
      break;
    case POS_REP_NONE:
      writePRData.only_cmt_flag = true;
      break;
  }
  return writePRData;
}

// call from convertXVRCallback(common api)
function analyzePosRegData(data) {
  var rtn_value = {};
  // PosReg data analyze.
  var target_key = '';    // Target Key
  var target_value = '';  // Target Value
  var value_temp = '';    // Value Temp(Next Key)
  for (var index = 0; index < data.length; index++) {
    switch (data[index]) {
      case '\'':  // Comment
        if ("Comment" in rtn_value) {
          rtn_value[target_key] = target_value;
          target_key = "";
          target_value = "";
        } else {
          target_value = "";
          target_key = "Comment";
          rtn_value[target_key] = "";
        }
        break;
      case ':':  // Delimiter
      case '=':  // Delimiter(Axis)
        if (target_key == "Comment") {
          target_value = target_value + data[index];
        } else {
          if (target_key != "") {
            rtn_value[target_key] = target_value.trim();
          }
          target_key = value_temp.trim();
          target_value = "";
          value_temp = "";
        }
        break;
      case '\n':  // Enter
        if (target_key != "") {
          rtn_value[target_key] = (target_value + value_temp).trim();
          target_key = "";
          target_value = "";
          value_temp = "";
        }
        break;
      default:   // Character and Space
        if (target_key == "Comment") {
          target_value = target_value + data[index];
        } else {
          if ((data[index] != ' ') && (value_temp.slice(-1) == ' ')) {
            target_value = target_value + value_temp;
            value_temp = "";
          }
          value_temp = value_temp + data[index];
        }
        break;
    }
  }
  if (target_key != "") {
    rtn_value[target_key] = (target_value + value_temp).trim();
  }
  // Axis Data => {data:000.000, unit:"deg"}
  for (var key in rtn_value) {
    if (key.match(/J\d/) || key.match(/EXT\d/)) {
      var value = rtn_value[key].split(' ');
      rtn_value[key] = { data: value[0], unit: value[1] };
    }
  }
  return rtn_value;
}

/*
 * Windows Before Unload Event
 */
$(window).on('beforeunload', function (evt) {
  debug(DBGINFO, 'Window before unload event(posreg):' + evt.type);
  stopGetPosRegPolling();
  // If there is any change data, send it all before switching.
  if (isKeepPosRegData()) {
    setAllCurrentPagePosReg();
  }
});
                                                                                       BO N . J S      P R O G A  T T R _ B U   T T PROGAT~1JS    MjXX  MjX؊8  B. J S      P R O G A  T T R _ L A   N G PROGAT~2JS    MjXX  MjX"  BU T . J S      P R O G A  T T R _ L A   Y O PROGAT~3JS    MjXX  MjX<{  B. J S    y  P R O G A  yT T R _ M A   I N PROGAT~4JS    MjXX  MjX93  BY P E . J  YS     P R O G A  YT T R _ S U   B T PROGAT~5JS    MjXX  MjX
(  BS    "  // Use jQuery
/*
* jQuery JavaScript Library
* https://jquery.com/
* Copyright JS Foundation and other contributors
* Released under the MIT license
* https://jquery.org/license
*/

var buttonName = '';
var selectProgName = '';

function setSelectProgram(prgName) {
  selectProgName = prgName;
}
function getSelectProgram() {
  return selectProgName;
}

// click new program button.
$('#newbtn').on('click touchend', function (event) {
  if(event.type.indexOf('touch') >= 0){
    event.preventDefault();
  }
  isDispMoveToMoniDlg('', undispDlg);
  function undispDlg() {
    buttonName = 'newProg';
    isJmpEdit = true;
    checkRunStat();
  }
});

// click open program button.
$('#openbtn').on('click touchend', function (event) {
  if(event.type.indexOf('touch') >= 0){
    event.preventDefault();
  }
  buttonName = 'openProg';
  isJmpEdit = true;
  var selProgName = (curTabType == SELECT_PROGLIST) ? getSelectProgram() : getSelectedMonitorSubName();
  isDispMoveToMoniDlg(selProgName, programOpen);
  return false;
});
function programOpen(taskNum, mainProg) {
  var selProgName = (curTabType == SELECT_PROGLIST) ? getSelectProgram() : getSelectedMonitorName();
  if (taskNum == 0 && selProgName != getCurrentProgram()) {
    getProgramText(selProgName, GETPROG_TEMP, readEditPrgCallback);	// robotapi  
    return false;
  } else {
    chgProg(mainProg, jmpEditPage);
  }
}

// click delete program button.
$('#deletebtn').on('click touchend', function (event) {
  if(event.type.indexOf('touch') >= 0){
    event.preventDefault();
  }
  buttonName = 'deleteProg';
  prgbuttonSelectProc();
  return false;
});

// click save attrbute button
$('#savebtn').on('click touchend', function (event) {
  if(event.type.indexOf('touch') >= 0){
    event.preventDefault();
  }
  buttonName = 'saveTab';
  if (getSelectProgram() == '') {
    return false;
  }
  shiftCurrentProg();
  getProgramText(getCurrentProgram(), GETPROG_TEMP, readEditPrgCallback);	// robotapi
});

// click saveas button.
$('#saveasbtn').on('click touchend', function (event) {
  if(event.type.indexOf('touch') >= 0){
    event.preventDefault();
  }
  isDispMoveToMoniDlg('', unDispDlg);
  function unDispDlg() {
  	buttonName = 'saveAstab';
    checkRunStat();
  }
  return false;
});

// click rename button
$('#renamebtn').on('click touchend', function (event) {
  if(event.type.indexOf('touch') >= 0){
    event.preventDefault();
  }
  isDispMoveToMoniDlg('', unDispDlg);

  function unDispDlg() {
  	buttonName = 'renametab';
  	shiftCurrentProg();
  	getProgramText(getCurrentProgram(), GETPROG_TEMP, readEditPrgCallback);	// robotapi
  }
  return false;
});

// click details button
var isJmpEdit = true;
var callEditAttrDlgFnc = undefined;
$('#detailsbtn').on('click touchend', function (event) {
  if(event.type.indexOf('touch') >= 0){
    event.preventDefault();
  }
  $('#detailsbtn').css('pointer-events', 'none');
  buttonName = 'detailstab';
  callEditAttrDlgFnc = callEditAttrDlg;
  getProgramText(getSelectProgram(), GETPROG_TEMP, readEditPrgCallback);  // robotapi
});

$('#pauseBtn').on('click touched', function (event) {
  if(event.type.indexOf('touch') >= 0){
    event.preventDefault();
  }
  var progName = getSelectedMonitorName();
  if (progName) {
    top.pauseSelProgram(progName);
  }
});

$('#stopBtn').on('click touched', function (event) {
  if(event.type.indexOf('touch') >= 0){
    event.preventDefault();
  }
  var progName = getSelectedMonitorName();
  if (progName) {
    abortProgram(progName);
  }
});

function callEditAttrDlg() {
  top.openCmpPupAppendFrm(window, '/frh/jcgtp/editattrdlg.stm', 'detailsbtn', resources['toolBtnAttribute'], true, { width: "650px", height: "600px"}, initFlag);
}

function initFlag() {
  // For details button
  callEditAttrDlgFnc = undefined;
  $('#detailsbtn').css('pointer-events', '');
}

// click applicationdata button
$('#applbtn').on('click touchend', function (event) {
  if(event.type.indexOf('touch') >= 0){
    event.preventDefault();
  }
  buttonName = 'applicationdatatab';
  shiftCurrentProg();
  getProgramText(getCurrentProgram(), GETPROG_TEMP, readEditPrgCallback);	// robotapi
  return false;
});

// click add filters button
$('#addFilterBtn').on('click', function (event) {
  $('#addFilterBtn').css('pointer-events', 'none');
  top.openCmpPupAppendFrm(window, '/frh/jcgtp/prgfilterdlg.stm', null, null, true, { width: "650px", height: "600px"}, openPrgFilterPopCB);

  function openPrgFilterPopCB() {
    $('#addFilterBtn').css('pointer-events', '');
  }
});

$('#filterSlctOvlBtn').on('click', function (event) {
  $('#filterSlctOvlBtn').css('pointer-events', 'none');
  var pgimp_cvr = '<?xml version="1.0" encoding="UTF-8"?>\r<XMLCFG>\r<PROG name="*SYSTEM*">\r';
  pgimp_cvr = pgimp_cvr + '<VAR name="$PGINP_TYPE" />\r';
  pgimp_cvr = pgimp_cvr + '</PROG>\r</XMLCFG>';

  // Create pgimpInfo.cvr
  var file_cvr = new Blob([pgimp_cvr], { type: "text/plain" });
  top.getXHR("pgimpInfo.cvr", file_cvr, showSlctList);

  function showSlctList(status, getText) {
    if (status != top.IO_SUCCESS) {
      console.log("getXHR error");
    } else {
      var strXml = getText;
      var xmlObj = null;
      var domParser = new DOMParser();
      try {
        xmlObj = domParser.parseFromString(strXml, 'text/xml');
      } catch (e) {
        xmlObj == null;
        var btnObj = {
          btnData :{ btn1 : top.irpDlgBtnOC.btn1 },
        };
        top.openCmpConfirm(webPage, window, 'alreadydelerrdlg', resources['dlgMsgLoadError'], btnObj, true);
        top.irprogapi.inner.apiErrorLog(e);
      }
      if ((xmlObj == null) || (xmlObj.getElementsByTagName('parsererror').length)) {
        // failure Get XML Data.
        top.irprogapi.inner.apiErrorLog('showSlctList: xml error.');
      } else {
        // Analyze XML Data.
        if (xmlObj.getElementsByTagName("ARRAY").length != 0) {
          var array_elem = xmlObj.getElementsByTagName('ARRAY');
          var filterSlctObj = [resources['filterAll']];
          for (var j = 0; j < array_elem.length; j++) {
            // Check empty case
            if ((array_elem[j].childNodes.length > 0) && (array_elem[j].childNodes[0].data.length > 0) && (array_elem[j].childNodes[0].data != '********') && (array_elem[j].childNodes[0].data !== '')) {
              filterSlctObj.push(array_elem[j].childNodes[0].data);
            }
          }
          document.getElementById('filterSlct').refresh(filterSlctObj, document.getElementById('filterSlct').getValue(), null, false);
          document.getElementById('filterSlct').click();
        }
      }
    }
    $('#filterSlctOvlBtn').css('pointer-events', '');
  }
});

// go to make new file page
function jmpEditPage(state) {
  // The specified program does not exist.
  if (state == IOSTAT_MEMO_073) {
    var btnObj = {
      btnData :{ btn1 : top.irpDlgBtnOC.btn1 },
      btn1Cb : refleshProgList
    };
    top.openCmpConfirm(webPage, window, 'alreadydelerrdlg', resources['dlgMsgAlreadyDelError'], btnObj, true);
    return;
  }
  if (!isJmpEdit) {
    isJmpEdit = true;
    buildProgramList();
    return;
  }

  var props = { value: "" };
  var jumpPage = 0;
  top.irprogapi.setPauseConfDlgFlag(getCurrentProgram());  // set old progname
  setCurrentProgram(getSelectProgram());
  props.value = top.IHMI_EDITOR_ADDRESS;

  if (isMyIFrameIdPrim()) {
    top.treemod.nodeOnClick(null, props);
    top.treemod.update_tree_url(props.value);
  } else {
    var frameId = getMyIFrameIdName();
    var rootFrame = top.document.getElementById("mainfrm");
    var targetFrame = rootFrame.contentDocument.getElementById(frameId + "stat");
    var targetTag = targetFrame.contentDocument.getElementsByTagName("body");
    var bgColor = window.getComputedStyle(targetTag[0]).getPropertyValue('background-color');
    if (bgColor == "rgb(58, 59, 59)") {
      top.rpcmc_setVar(top.SYSNAME_C, '$IRPROG_CFG.$CURR_URL', props.value);
      sessionStorage.setItem('selectProg', getSelectProgram());
      top.treemod.nodeOnClick(null, props);
      top.treemod.update_tree_url(props.value);
    }
  }
};

function showAttrDlg(status, progName) {
  chgDispPrgName(progName);
  sortProgramList();
  readProgramFile(progName);
  attrBtnEnable();
  drawProgramList();
  revertCurrentProg();
  // Get program attribute
  if (dispAttrDlgFlag) {
  top.openCmpPupAppendFrm(window, '/frh/jcgtp/editattrdlg.stm', null, resources['toolBtnAttribute'], true, { width: "650px", height: "600px"});
  }
  if ((top.g_order.r792) || (ProgramApplManager.isLoadLineTrack()) || (top.g_order.wnsp)) {
    waitCnvTextComplete(callSaveAppl, progName);
  }
  function callSaveAppl(progName) {
    saveAppl(progName);
  }
}

function btnSaveattribute() {

  actionAfterSaving = '';
  var crntAttr = {};
  crntAttr.COMMENT = pgAttrComment;
  crntAttr.STACK_SIZE = pgAttrStackSize;
  crntAttr.SUBTYPE = pgSubType;
  crntAttr.PAUSE = pgPause;
  crntAttr.PROTECT = pgProtect;
  crntAttr.MTNGRP = pgMotionGroup;
  saveProgramAttribute(getSelectProgram(), crntAttr, stackInputFlag);
}

var modifiAster = false;
function readEditPrgCallback(status, programName, programText, lineCount) {
  programName = omitExtension(programName);
  // If status is error, no modified program.
  if (status != IO_SUCCESS) {
    modifiAster = false;
    if (buttonName == 'newProg') {
      defineDialog.open('#filenew', '#getprogdlg', '');	// Get program name
    } else if (buttonName == 'openProg') {
      if (isMyIFrameIdPrim()) {
        checkRunStat();
      } else {
        jmpEditPage();
      }
    } else if (buttonName == 'saveTab' && !(modifiAster)) {
      $("#savebtn").blur();
    } else {
      prgbuttonSelectProc();
    }
    return;
  }
  modifiAster = true;
  prgbuttonSelectProc();
}

function prgbuttonSelectProc() {
  if ((buttonName == 'openProg') || (buttonName == 'newProg') || (modifiAster && (buttonName == 'detailstab'))) {
    // open button / new button
    var btnObj = {
      btnData : {
        btn1: top.irpDlgBtnYN.btn1,
        btn2: top.irpDlgBtnYN.btn2,
        btn3: top.irpDlgBtnOC.btn2,
      },
      btn1Cb      : progAttrSaveProgram,
      btn1CbArg   : { saveParam: { aftersave: buttonName } },
      btn2Cb      : callOpenSelectProgram,
      btn2CbArg   : { saveParam: { aftersave: buttonName, selprog: '' } },
      btn3Cb      : initFlag
    };
    top.openCmpConfirm(webPage, window, 'progattrselchangedlg', resources['dlgMsgPgModified'], btnObj, true);
  } else if (buttonName == 'deleteProg') {  // delete button
    var btnObj = { btnData : top.irpDlgBtnOC, btn1Cb  : preProcDelete };
    top.openCmpConfirm(webPage, window, 'deleteprogdlg', resources['dlgMsgDelProg'], btnObj, true);
  } else if (buttonName == 'saveAttrtab') {
    var btnObj = {
      btnData : top.irpDlgBtnOC,
      btn1Cb      : saveBeforAttribute,
      btn1CbArg   : { saveParam: { aftersave: buttonName }},
      btn2Cb      : undoAttribute,
    };
    // Confirm save modified
    top.openCmpConfirm(webPage, window, 'confsaveatterdlg', resources['dlgMsgSavePg'], btnObj, true);
  } else if (buttonName == 'renametab') {
    defineDialog.open('#filerename', '#getrenameprogdlg', 'dlgMsgIptPgRename');		// Get
  } else if (buttonName == 'saveAstab') {
    defineDialog.open('#filesaveas', '#getsvasprogdlg', 'dlgMsgIptPgSaveAs');		// Get
  } else if (buttonName == 'saveTab') {
    // save button
    var btnObj = {
      btnData : top.irpDlgBtnOC,
      btn1Cb      : progAttrSaveProgram,
      btn1CbArg   : { saveParam: { aftersave: buttonName } },
      btn2Cb      : progAttrAsterFlg,
    };
    top.openCmpConfirm(webPage, window, 'progattrsavedlg', resources['dlgMsgSavePg'], btnObj, true);
  } else if (buttonName == 'applicationdatatab') {
    defineDialog.open(buttonName, '#appleditordlg', '');
  } else if (buttonName == 'detailstab') {
    isJmpEdit = false;
    readProgramFile(getSelectProgram());
  }
}

function callOpenSelectProgram(btnId, cbArg) {
  var saveParam = cbArg.saveParam;
  var pgName = getSelectProgram();
  saveParam['selprog'] = pgName;
  openSelectProgram(saveParam);
}

function chgSaveBtnCallback(status, programName, programText, lineCount) {
  if (status == null) {
    if (programName.match(/^\*/)) {
      if ($('#savebtn').prop('disabled') && $('#savebtn').hasClass('btndesable')) {
        $('#savebtn').removeClass('btndesable');
        $('#savebtn').prop('disabled', false);
      }
      return;
    }
  } else if (status == IO_SUCCESS) {
    programName = omitExtension(programName).replace(/^\*/, '');

    if ($('#savebtn').prop('disabled') && $('#savebtn').hasClass('btndesable')) {
      $('#savebtn').removeClass('btndesable');
      $('#savebtn').prop('disabled', false);
    }
    return;
  }

  if (!$('#savebtn').prop('disabled') && !$('#savebtn').hasClass('btndesable')) {
    $('#savebtn').addClass('btndesable');
    $('#savebtn').prop('disabled', true);
  }
}

function checkRunStat() {
  if (buttonName == 'newProg') { //filenew button
    getProgramText(getCurrentProgram(), GETPROG_TEMP, readEditPrgCallback);	// robotapi
  } else if (buttonName == 'saveAstab') {
    shiftCurrentProg();
    getProgramText(getCurrentProgram(), GETPROG_TEMP, readEditPrgCallback);	// robotapi    
  } else { // open button
    var selProgName = (curTabType == SELECT_PROGLIST) ? getSelectProgram() : getSelectedMonitorSubName();
    chgProg(selProgName, jmpEditPage);
  }
}

var abortNum = 0;
function procAfterAbort(status, prgName) {
  if (status !== IO_SUCCESS) {
    if (abortNum < 10) {
      setTimeout(function() {
        abortProgram(prgName, procAfterAbort);
      }, 100);
      abortNum++;
      return;
    } else {
      abortNum = 0;
    }
  }
  abortNum = 0;
  if (buttonName == 'newProg') { //filenew button
    getProgramText(getCurrentProgram(), GETPROG_TEMP, readEditPrgCallback);	// robotapi
  } else if (buttonName == 'saveAstab') {
    shiftCurrentProg();
    getProgramText(getCurrentProgram(), GETPROG_TEMP, readEditPrgCallback);	// robotapi
  } else { // open button
    chgProg(getSelectProgram(), jmpEditPage);
  }
}                                                                                                                                                                                                                                                                                                                                                                                      // Use jQuery
/*
 * jQuery JavaScript Library
 * https://jquery.com/
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
*/

var resources = [];
function initResource(callback) {
  var lang = getCurrentLanguage();
  $.getJSON('lang/' + lang + '.jsn')
    .done(function (data, status, xhr) {
      debug(DBGINFO, 'Read language resource file.(' + lang + '):status[' + status + ']');
      resources = data;
      initToolbarResource();
      initEachWindowResource();
      initTabResource(callback);
      debug(DBGINFO, 'Finish language resource.');
    })
    .fail(function (xhr, textStatus, errorThrown) {
      if (lang != LANG_EG) {
        currentLang = LANG_EG;
        initResource(callback);
        debug(DBGFATAL, 'Get Lang data failed.(' + textStatus + ')');
        console.log("change Language :" + lang + " > " + currentLang);
      }
    });
}

function initTabResource(callback) {
  var lang = getCurrentLanguage();
  $.getJSON('lang/tab_' + lang + '.jsn')
    .done(function (data, status, xhr) {
      debug(DBGINFO, 'Read Visual language resource file.(' + lang + '):status[' + status + ']');
      Object.keys(data).forEach(function (val) {
        resources[val] = this[val];
      }, data);
      initTabletResource();
      initPrgFilter();
      callback();
      debug(DBGINFO, 'Finish Visual language resource.');
    })
    .fail(function (xhr, textStatus, errorThrown) {
      if (lang != LANG_EG) {
        currentLang = LANG_EG;
        initTabResource(callback);
        debug(DBGFATAL, 'Get Visual Lang data failed.(' + textStatus + ')');
        console.log("change Language :" + lang + " > " + currentLang);
      }
    });
}

/* === Resource matching table (for fixed contents) === */
/* (Generate contents resource are defined in each place.) */
var resourceToolbarTable = [
  // Toolbar button resource.
  { 'id': 'filemenu', 'append': 'after', 'resId': 'toolTabProgram' },
  { 'id': 'createprog', 'append': 'after', 'resId': 'toolBtnNewProg' },
  { 'id': 'saveprog', 'append': 'after', 'resId': 'toolBtnSaveProg' },
  { 'id': 'playrun', 'append': 'after', 'resId': 'toolBtnPlayRun' },
  { 'id': 'playpause', 'append': 'after', 'resId': 'toolBtnPlayPause' },
  { 'id': 'playstop', 'append': 'after', 'resId': 'toolBtnPlayStop' },
  { 'id': 'playstep', 'append': 'after', 'resId': 'toolBtnPlayStep' },
  { 'id': 'playcont', 'append': 'after', 'resId': 'toolBtnPlayCont' },
  // each button
  { 'id': 'ovrridbtn', 'append': 'after', 'resId': 'overrideBtn' },
  { 'id': 'resetbutton', 'append': 'after', 'resId': 'resetButton' },
  { 'id': 'othermenu', 'append': 'after', 'resId': 'otherMenu' },
  // file menu
  { 'id': 'filenewtext', 'append': 'after', 'resId': 'toolBtnNewProg' },
  { 'id': 'filesavetext', 'append': 'after', 'resId': 'toolBtnSaveProg' },
  // Dummy
  { 'id': 'dummy', 'append': 'no', 'resId': 'dummy' }
];
var resourceEachWindowTable = [
  // JOG button resource.
  { 'id': 'jogctrlcrt', 'append': 'no', 'resId': 'posTableCrt' },
  { 'id': 'jogctrljnt', 'append': 'no', 'resId': 'posTableJnt' },
  // JOG window resource.
  //{'id': 'crsbtnuptxt', 'append': 'no', 'resId': 'lblCartPos'},
  //{'id': 'crsbtndntxt', 'append': 'no', 'resId': 'lblCartAtt'},
  //{'id': 'grphdrframe', 'append': 'no', 'resId': 'hdrGrpFrame'},
  { 'id': 'hdrframelabel', 'append': 'no', 'resId': 'hdrFrameLbl' },
  { 'id': 'lblframeuser', 'append': 'no', 'resId': 'lblFrameUser' },
  { 'id': 'lblframetool', 'append': 'no', 'resId': 'lblFrameTool' },
  { 'id': 'lblframewrld', 'append': 'no', 'resId': 'lblFrameWorld' },
  { 'id': 'lblframejog', 'append': 'no', 'resId': 'lblFrameJog' },
  { 'id': 'lblframejoint', 'append': 'no', 'resId': 'lblFrameJoint' },
  { 'id': 'hdrframenum', 'append': 'no', 'resId': 'hdrFrameNum' },
  // Position table control resource.
  { 'id': 'posctrldel', 'append': 'no', 'resId': 'posTableDel' },
  //{ 'id': 'posctrlmov', 'append': 'after', 'resId': 'posTableMov' },
  //{ 'id': 'posctrltup', 'append': 'no', 'resId': 'posTableTup' },
  { 'id': 'posctrlcpy', 'append': 'no', 'resId': 'posTableCpy' },
  { 'id': 'posctrlpst', 'append': 'no', 'resId': 'posTablePst' },
  { 'id': 'posctrljnt', 'append': 'no', 'resId': 'posTableJnt' },
  { 'id': 'posctrlcrt', 'append': 'no', 'resId': 'posTableCrt' },
  // Dummy
  { 'id': 'dummy', 'append': 'no', 'resId': 'dummy' }
];

var resourceTabletTable = [
  /* Progattr screen(Program list,Edit attributes) */
  // Program list
  { 'id': 'tabProgList', 'append': 'no', 'resId': 'ttlProgList' },
  { 'id': 'tabMonitor', 'append': 'no', 'resId': 'ttlMonitor' },
  { 'id': 'filtertext', 'append': 'no', 'resId': 'filterText' },
  { 'id': 'proglisthdr-nbr', 'append': 'no', 'resId': 'hdrNum' },
  { 'id': 'proglisthdr-ttl', 'append': 'no', 'resId': 'hdrProgname' },
  { 'id': 'proglisthdr-typ', 'append': 'no', 'resId': 'hdrSubtype' },
  { 'id': 'noMonitorTextArea', 'append': 'no', 'resId': 'dlgNoMonitorProgram' },
  // Button
  { 'id': 'addFilterBtn', 'append': 'after', 'resId': 'addFilterButton' },
  { 'id': 'openbtnttext', 'append': 'after', 'resId': 'openButton' },
  { 'id': 'newbtnttext', 'append': 'after', 'resId': 'newButton' },
  { 'id': 'deletebtnttext', 'append': 'after', 'resId': 'deleteButton' },
  { 'id': 'savebtntext', 'append': 'after', 'resId': 'saveButton' },
  { 'id': 'saveasbtntext', 'append': 'after', 'resId': 'saveasButton' },
  { 'id': 'renamebtntext', 'append': 'after', 'resId': 'renameButton' },
  { 'id': 'detailsbtntext', 'append': 'after', 'resId': 'detailsButton' },
  { 'id': 'applbtn', 'append': 'after', 'resId': 'applicationdataButton' },
  { 'id': 'pauseBtnText', 'append': 'after', 'resId': 'pauseButton' },
  { 'id': 'stopBtnText', 'append': 'after', 'resId': 'stopButton' },
  // Edit attributes
  { 'id': 'editatt_title', 'append': 'no', 'resId': 'ttlEditAtt' },
  { 'id': 'subProgNameTitle', 'append': 'no', 'resId': 'subTtlEditAtt' },
  { 'id': 'att_com', 'append': 'no', 'resId': 'attComment' },
  { 'id': 'att_stack', 'append': 'no', 'resId': 'attStack' },
  { 'id': 'att_subtype', 'append': 'no', 'resId': 'attSubtype' },
  { 'id': 'att_mtnGrp', 'append': 'no', 'resId': 'attMtnGrp' },
  { 'id': 'att_pause', 'append': 'no', 'resId': 'attPause' },
  { 'id': 'att_protect', 'append': 'no', 'resId': 'attProtect' },
  { 'id': 'att_local_Reg', 'append': 'no', 'resId': 'attLocalNumReg' },
  { 'id': 'att_local_Pos_Reg', 'append': 'no', 'resId': 'attLocalPosReg' },
  { 'id': 'att_local_Str_Reg', 'append': 'no', 'resId': 'attLocalStrReg' },
  { 'id': 'singularity_avd', 'append': 'no', 'resId': 'singularityAvd' }
];

// Toolbar Language Resource Initialize.
function initToolbarResource() {
  debug(DBGDUMP, 'Init toolbar resource.');
  for (var i = 0; i < resourceToolbarTable.length; i++) {
    var rmt = resourceToolbarTable[i];
    var idStr = '#' + rmt.id;
    var resourceText = resources[rmt.resId];
    if (rmt.append == 'before') {	// Message append to already existed text.
      resourceText = resourceText + $(idStr).html();	//	append text
    } else if (rmt.append == 'after') {
      resourceText = $(idStr).html() + resourceText;	//	append text
    }
    $(idStr).html(resourceText);
  }
}

// Language Resource Initialize. (except toolbar)
function initEachWindowResource() {
  debug(DBGDUMP, 'Init window resource.');
  for (var i = 0; i < resourceEachWindowTable.length; i++) {
    var rmt = resourceEachWindowTable[i];
    var idStr = '#' + rmt.id;
    var resourceText = resources[rmt.resId];
    if (rmt.append == 'before') {	// Message append to already existed text.
      resourceText = resourceText + $(idStr).html();	//	append text
    } else if (rmt.append == 'after') {
      resourceText = $(idStr).html() + resourceText;	//	append text
    }
    $(idStr).html(resourceText);
  }
  debug(DBGDUMP, 'Finish windows resource.');
};

function initTabletResource() {
  debug(DBGDUMP, 'Init Visual Programming resource.');
  for (var i = 0; i < resourceTabletTable.length; i++) {
    var rmt = resourceTabletTable[i];
    var idStr = '#' + rmt.id;
    var resourceText = resources[rmt.resId];
    if (rmt.append == 'before') {	// Append text before element
      $(idStr).prepend(resourceText);
    } else if (rmt.append == 'inter') { // Append text between two elements
      idStr = '#dammy_sprite';
      $(idStr).after(resourceText);
    } else if (rmt.append == 'after') { // Append text after element
      $(idStr).append(resourceText);
    } else {
      $(idStr).html(resourceText);
    }
  }
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /**********************************************************************
 * Visual programming script
 * Layout generator
 * Created: 2018/09/19 FSI
 *
 */
// Use jQuery
/*
* jQuery JavaScript Library
* https://jquery.com/
* Copyright JS Foundation and other contributors
* Released under the MIT license
* https://jquery.org/license
*/

// Require : pceditor_fileio.js : Use ProgramApplManager object.

/**
 * Sub Type definition
 */
var editValueList = ['attrSubNone', 'attrSubMacro', 'attrSubCond'];
var selEditValue = 'none';
var subtypeList = {
  0: "attrSubNone",
  3: "attrSubMacro",
  4: "attrSubCond"
};

function drawProgramList() {
  // Do not display the program name starting with "IPL_"
  var allProgram = getProgramFileList();
  var countDispProg = 0;
  var progList = [];
  var progNameList = [];
  for (var i = 0; i < allProgram.length; i++) {
    var progName = allProgram[i].name;
    if (!progName.match(/^IPL_.*/)) {
      var filterSlcted = sessionStorage.getItem('progattrFilter_' + window.frameElement.id);
      if ((isScrModeProgAttr()) && (filterSlcted !== null) && (filterSlcted != resources['filterAll'])) {
        var reg = new RegExp("^" + filterSlcted + ".*");
        if (!progName.match(reg)) {
          continue;
        }
      }
      progNameList[countDispProg] = progName;
      progList[countDispProg] = allProgram[i];
      countDispProg++;
    }
  }
  var list = {
    head: [
      {
        cells: [
          { text: 'No.', className: 'progattrlisthdr-nbr'},
          { text: resources['hdrProgName'], className: 'progattrlisthdr-ttl'},
          { text: resources['dlgAttrSubtype'], className: 'progattrlisthdr-typ'}
        ]
      }
    ],
    body: []
  };
  $(progList).each(function (i) {
    var name = progList[i].name;
    if ((name != getCurrentProgram()) || (isScrModeProgAttr())) {
      var selElem = {
        className: "",
        value: name,
        cells: [
          { text: '' + (i + 1), className: 'progattrlistbody-nbr'},
          { text: name, className: 'progattrlistbody-ttl'},
          { text: progList[i].type, className: 'progattrlistbody-typ'}
        ]
      };
      list.body.push(selElem);
    }
  });
  var selIdx = progNameList.indexOf($('#progNameText').text()) + 1;
  var selList = (selIdx > 0) ? $('#progNameText').text() : null;
  document.getElementById('proglistview').refresh(list, selList);
  document.getElementById('proglistview').scrollTo(selIdx);
  // When list is selected, enable OK button.
  if (getSelectProgram() != '') {
    $('#openbtn').prop('disabled', false);
    $('#openbtn').removeClass('okyesdis');
    $('#deletebtn').prop('disabled', false);
    $('#deletebtn').removeClass('okyesdis');
    $('#detailsbtn').prop('disabled', false);
    $('#detailsbtn').removeClass('okyesdis');
  }
};

var timerId = 0; //use with onTimer
function programMonitorTabsClick(id, operation, value) {
  $('#listArea').removeClass('hide');
  $('#noMonitorTextArea').addClass('hide');
  if (value == SELECT_PROGLIST) {
    if (timerId != 0) {
      clearInterval(timerId);
    }
    curTabType = SELECT_PROGLIST;
    showProgList();
    hideMonitorList();
    //change program name when switching monitor list from program list.
    var selProgName = $('#proglistview')[0].getSelectedValue();
    chgDispPrgName(selProgName, '');
  } else if (value == SELECT_MONITOR) {
    curTabType = SELECT_MONITOR;
    hideProgList();
    showMonitorList();
    getMonitorInfo(getMonitorInfoCallback);
  }
  function showProgList() {
    $('#prgFilter').removeClass('hide');
    $('#prglistform').removeClass('hide');
    $('#progBtnArea').removeClass('hide');
  }
  function hideProgList() {
    $('#prgFilter').addClass('hide');
    $('#prglistform').addClass('hide');
    $('#progBtnArea').addClass('hide');
  }
  function showMonitorList() {
    $('#monitorListArea').removeClass('hide');
    $('#monitorBtnArea').removeClass('hide');
    $('#subProgArea').removeClass('hide');
  }
  function hideMonitorList() {
    $('#monitorListArea').addClass('hide');
    $('#monitorBtnArea').addClass('hide');
    $('#subProgArea').addClass('hide');
  }
}
function getMonitorInfoCallback(status, list, cbArg) {
  if (timerId != 0) { //Only when there is monitor info
    clearInterval(timerId);
    timerId = 0;
  }
  if (list.length == 0) {
    $('#listArea').addClass('hide');
    $('#noMonitorTextArea').removeClass('hide');
    chgDispPrgName('', '');
  } else if (status == top.IO_SUCCESS) {
    $('#listArea').removeClass('hide');
    $('#noMonitorTextArea').addClass('hide');
    var prevMonitorList = monitorFileList;
    var listCell = setListCell(list);
    //If moniotr info changed
    if (JSON.stringify(prevMonitorList) != JSON.stringify(monitorFileList)) {
      preMoniValue = 0;
      var isChkFirstExeRow = false;
      for (var i = 0; i < monitorFileList.length; i++) {
        var row = monitorFileList[i];
        //first index in exe row.
        if (!isChkFirstExeRow && (monitorFileList[i].stat == 0)) {
          preMoniValue = i;
          isChkFirstExeRow = true;
        }
        //selecting row.
        if (row.prog == preMoniProgName) {  //Is there a selected program?
          preMoniValue = i;
          break;
        }
      }
      preMoniProgName = monitorFileList[preMoniValue].prog;
      $("#monitorList")[0].refresh(listCell, preMoniValue.toString(), false);
      //Change program name and sub program name at the bottom of the screen
      chgDispPrgName(monitorFileList[preMoniValue].task, monitorFileList[preMoniValue].prog);
    } else {  //change program name and sub program name when switching display from program list to monitor list
      chgDispPrgName(monitorFileList[preMoniValue].task, monitorFileList[preMoniValue].prog);
    }
  }
  onTimer();
  function onTimer() {
    timerId = setInterval(function () {
      getMonitorInfo(getMonitorInfoCallback);
    }, 500);
  }
  function setListCell(list) {
    return {
      head: [
        {
          cells: [
            { text: 'No.', className: 'progattrlisthdr-nbr'},
            { text: resources['hdrProgName'], className: 'progattrlisthdr-ttl'},
            { text: resources['hdrSubProgName'], className: 'progattrlisthdr-ttl'},
            { text: resources['hdrStatus'], className: 'progattrlisthdr-typ'}
          ]
        }
      ],
      body: createMonitorList(list)
    };
    function createMonitorList(monitorList) {
      var bodyList = [];
      monitorFileList = [];
      for (var i = 0; i < monitorList.length; i++) {
        var listRow = monitorList[i];
        var stat = "";
        if (listRow.stat == 0) {
          stat = resources['statusRunning'];
        } else if (listRow.stat == 1) {
          stat = resources['statusPausing'];
        }
        var cellList = [
          {text: (i + 1), className: 'progattrlistbody-nbr'},
          {text: listRow.task, className: 'progattrlistbody-ttl'},
          {text: listRow.prog, className: 'progattrlistbody-ttl'},
          {text: stat, className: 'progattrlistbody-typ'}
        ];

        monitorFileList.push({
          task: listRow.task,
          prog: listRow.prog,
          stat: listRow.stat
        });
        bodyList.push({
          className: '',
          value: i,
          cells: cellList
        })
      }
      return bodyList;
    }
  }
}

function drawAttribute() {
  //var currentAttr = getEditAttribute();
  var progInfo = ProgramInfoManager.getSpecifiedProgInfo(getSelectProgram());
  var currentAttr = progInfo.getEditAttrValue();

  $('#listAttrcomment').val(currentAttr.COMMENT);
  pgAttrComment = currentAttr.COMMENT;
 
  var currentStack = currentAttr.STACK_SIZE == 0 ? 500 : currentAttr.STACK_SIZE;
  $('#listAttrstacksize').val(currentStack);
  pgAttrStackSize = Number(currentStack);

  if (currentAttr.SUBTYPE == undefined) {
    currentAttr.SUBTYPE = 0;
  }
  $('#seleditlist').html(resources[subtypeList[currentAttr.SUBTYPE]] + ' <div id="seleditbtn" class="selframebtn">' +
    '<img id="selbtnimg" class="selbtnimg" src="images/select_icon_large.png">' +
    '</div>');
  setSelEditListVal(subtypeList[currentAttr.SUBTYPE]);
  pgSubType = getSelEditListVal();

  generateMtnGrpCheckBox(progInfo);  // Add argument
  generateIgnPause(currentAttr);  // Add argument
  generateProtectBtn(progInfo);  // Add argument
  generateLocalRegisters();
  if (top.g_order.r792) {
    generateSingularityAvd();
  }
  if (ProgramApplManager.isLoadLineTrack()) {
    generateLineTrackAppl();
  }
  dispOffWaiting();
  if (typeof callEditAttrDlgFnc === 'function') callEditAttrDlg();
};

function generateLocalRegisters() {
  var editAppl = ProgramApplManager.getEditApplLocalRegisters(); // fileio
  $('#listAttrlocalNumReg').val(editAppl["LOCAL_REGISTER"]);
  $('#listAttrlocalPosReg').val(editAppl["LOCAL_POS_REGISTER"]);
  $('#listAttrlocalStrReg').val(editAppl["LOCAL_STR_REGISTER"]);
}

function generateMtnGrpCheckBox(progInfo) {
  //var currentAttr = getEditAttribute();
  var currentAttr = progInfo.getEditAttrValue();
  pgMotionGroup = currentAttr.MTNGRP;
  var attrTd = $(document.getElementById('listAtt_mtnGrpCB'));
  attrTd.html('');
  maxGroupCount = getGroupCount();	// Limit on the number of groups.
  var grpChecked = false;
  var grpMasked = false;
  var grpChkCnt = getGroupCheckCount();
  var chkBoxArea1 = $('<div>', { 'id': 'chkBoxArea1'});
  attrTd.append(chkBoxArea1);
  var attrChkBoxArea = $(document.getElementById('chkBoxArea1'));
  for (var i = 0; i < maxGroupCount; i++) {
    if(i == 4){
      var chkBoxArea2 = $('<div>', { 'id': 'chkBoxArea2'});
      attrTd.append(chkBoxArea2);
      attrChkBoxArea = $(document.getElementById('chkBoxArea2'));
    }
    var attrGrp = $('<input>', {
      'type': 'checkbox', 'id': 'listAttrGrp' + (i + 1), 'name': 'listAttrmtngrp',
      'class': 'chkboxbk', 'value': 'grp' + (i + 1)
    });
    if ((pgMotionGroup & (1 << i)) != 0) {
      attrGrp.attr({ 'checked': 'checked' });
      grpChecked = true;
    }
    var attrLbl = $('<label>', { 'for': 'listAttrGrp' + (i + 1), 'id': 'listlblGrp' + (i + 1), 'class': 'chkboxlg' });
    attrLbl.html('' + (i + 1));
    if ((currentAttr.PROTECT == PROTECTON) || 	// Protection on -> Disable  or
      (progInfo.isExistProgPosition()) || // Position data is exist and checked group -> Disable or
      ((currentAttr.SUBTYPE == top.MM_SUB_COND_C))) { // Subtype is Condition -> Disable
      attrGrp.prop('disabled', true);
      attrLbl.prop('disabled', true);
      attrLbl.css({ 'opacity': '0.5' });
      grpMasked = true;
    }
    attrChkBoxArea.append(attrGrp);
    attrChkBoxArea.append(attrLbl);
  }
}

function generateIgnPause(currentAttr) {  // Add argument
  //var currentAttr = getEditAttribute();
  //Editattribute Pause
  var attrTd = $(document.getElementById('listAtt_pause_btn'));
  attrTd.html('');
  var attrPouseOn = 'pousebtnoff attrleftbtn';
  var attrPouseOff = 'pousebtnon attrrightbtn';
  if ((currentAttr.PAUSE & MASK_IGNRPAUS) == PAUSEON) {
    attrPouseOn = 'pousebtnon attrleftbtn';
    attrPouseOff = 'pousebtnoff attrrightbtn';
    pgPause = PAUSEON;
  } else {
    pgPause = 0;
  }
  var attrButton = $('<button>');
  attrButton.attr({ 'type': 'button', 'id': 'listAttrpauseon', 'class': attrPouseOn, 'tabindex': 4 });
  attrButton.html(resources['attrBtnOn']);
  if (currentAttr.PROTECT == PROTECTON) {
    attrButton.prop('disabled', true);
    attrButton.addClass('attrdisable');
  }
  attrTd.append(attrButton);
  attrButton = $('<button>');
  attrButton.attr({ 'type': 'button', 'id': 'listAttrpauseoff', 'class': attrPouseOff, 'tabindex': 5 });
  attrButton.html(resources['attrBtnOff']);
  if (currentAttr.PROTECT == PROTECTON) {
    attrButton.prop('disabled', true);
    attrButton.addClass('attrdisable');
  }
  attrTd.append(attrButton);
}

function generateProtectBtn(progInfo) { // Add argument
  //var currentAttr = getEditAttribute();
  var currentAttr = progInfo.getEditAttrValue();
  var attrTd = $(document.getElementById('listAttr_protect_btn'));
  attrTd.html('');
  //Editattribute Protect
  var attrProtectOn = 'protectbtnoff attrleftbtn';
  var attrProtectOff = 'protectbtnon attrrightbtn';
  if (currentAttr.PROTECT == PROTECTON) {
    attrProtectOn = 'protectbtnon attrleftbtn';
    attrProtectOff = 'protectbtnoff attrrightbtn';

    $('#listAttrpauseon').prop('disabled', true);
    $('#listAttrpauseon').addClass('attrdisable');
    $('#listAttrpauseoff').prop('disabled', true);
    $('#listAttrpauseoff').addClass('attrdisable');
    $('#listApplSingularityAvdOn').prop('disabled', true);
    $('#listApplSingularityAvdOn').addClass('attrdisable');
    $('#listApplSingularityAvdOff').prop('disabled', true);
    $('#listApplSingularityAvdOff').addClass('attrdisable');
    $('.iptcombox').prop('disabled', true);
    $('#listAttrstacksize').prop('disabled', true);
    $('#listAttrlocalNumReg').prop('disabled', true);
    $('#listAttrlocalPosReg').prop('disabled', true);
    $('#listAttrlocalStrReg').prop('disabled', true);
    $('#seleditlist').addClass('attrseldisable');
    $('.chkboxbk').prop('disabled', true);
    $('.chkboxlg').prop('disabled', true);
    $('.chkboxlg').css({ 'opacity': '0.5' });
    pgProtect = PROTECTON;
  } else {
    $('#listAttrpauseon').prop('disabled', false);
    $('#listAttrpauseon').removeClass('attrdisable');
    $('#listAttrpauseoff').prop('disabled', false);
    $('#listAttrpauseoff').removeClass('attrdisable');
    $('#listApplSingularityAvdOn').prop('disabled', false);
    $('#listApplSingularityAvdOn').removeClass('attrdisable');
    $('#listApplSingularityAvdOff').prop('disabled', false);
    $('#listApplSingularityAvdOff').removeClass('attrdisable');
    $('.iptcombox').prop('disabled', false);
    $('#listAttrstacksize').prop('disabled', false);
    $('#listAttrlocalNumReg').prop('disabled', false);
    $('#listAttrlocalPosReg').prop('disabled', false);
    $('#listAttrlocalStrReg').prop('disabled', false);
    $('#seleditlist').removeClass('attrseldisable');
    if ((!progInfo.isExistProgPosition()) && (posRecordCount == 0) &&
    (currentAttr.SUBTYPE != top.MM_SUB_COND_C)) {
      $('.chkboxbk').prop('disabled', false);
      $('.chkboxlg').prop('disabled', false);
      $('.chkboxlg').css({ 'opacity': '1.0' });
    }
    pgProtect = PROTECTOFF;
  }
  attrButton = $('<button>');
  attrButton.attr({ 'type': 'button', 'id': 'listAttrprotecton', 'class': attrProtectOn, 'tabindex': 6 });
  attrButton.html(resources['attrBtnOn']);
  attrTd.append(attrButton);
  attrButton = $('<button>');
  attrButton.attr({ 'type': 'button', 'id': 'listAttrprotectoff', 'class': attrProtectOff, 'tabindex': 7 });
  attrButton.html(resources['attrBtnOff']);
  attrTd.append(attrButton);
}

function generateSingularityAvd() {  // Add argument
  $("#appltitle").html("<b>" + convertHanZenkaku(resources["applTitle"]) + "</b>");
  var applTd = $(document.getElementById('singularity_avd_btn'));
  applTd.html('');
  var applSingularityAvdOn = 'singularityAvdOff applleftbtn';
  var applSingularityAvdOff = 'singularityAvdOn applrightbtn';
  var editAppl = ProgramApplManager.getEditApplSingularity(); // fileio
  if (editAppl.hasOwnProperty('ENABLE_SINGULARITY_AVOIDANCE')) {
    if (editAppl['ENABLE_SINGULARITY_AVOIDANCE'].indexOf('TRUE') >= 0) {
      applSingularityAvdOn = 'singularityAvdOn applleftbtn';
      applSingularityAvdOff = 'singularityAvdOff applrightbtn';
    }
  } else {
    ProgramApplManager.initEditApplSingularity(false);         // fileio
  }
  var applButton = $('<button>');
  applButton.attr({ 'type': 'button', 'id': 'listApplSingularityAvdOn', 'class': applSingularityAvdOn});
  applButton.html(resources['attrBtnOn']);
  if (pgProtect == PROTECTON) {
    applButton.prop('disabled', true);
    applButton.addClass('attrdisable');
  }
  applTd.append(applButton);
  applButton = $('<button>');
  applButton.attr({ 'type': 'button', 'id': 'listApplSingularityAvdOff', 'class': applSingularityAvdOff});
  applButton.html(resources['attrBtnOff']);
  if (pgProtect == PROTECTON) {
    applButton.prop('disabled', true);
    applButton.addClass('attrdisable');
  }
  applTd.append(applButton);
  
  // $("#applArea").show();
  // $(".singularityAvdAPPL").show();

}

function generateLineTrackAppl() {

  $("#appltitle").html("<b>" + convertHanZenkaku(resources["applTitle"]) + "</b>");
  $("#line_schedule").html(convertHanZenkaku(resources["lineschedule"]));
  $("#listApplschedule").val(ProgramApplManager.getLineTrackingConfig("lineschedule"));
  $("#line_boundary").html(convertHanZenkaku(resources["lineboundary"]));
  $("#listApplboundary").val(ProgramApplManager.getLineTrackingConfig("lineboundary"));
  $("#line_end").html(convertHanZenkaku(resources["lineend"]));

  var attrTd = $(document.getElementById('listApplIptend'));
  attrTd.html('');
  var attrGrp = $('<input>', {
    'type': 'checkbox', 'id': 'listApplLineEnd', 'name': 'listLineEnd',
    'class': 'chkboxbk', 'value': 'listLineEnd1'
  });
  if (ProgramApplManager.getLineTrackingConfig("lineend") == "TRUE") {
    attrGrp.attr({ 'checked': 'checked' });
  }
  var attrLbl = $('<label>', { 'for': 'listApplLineEnd', 'id': 'listLineEnd1', 'class': 'chkboxlg' });
  attrLbl.html('');
  attrTd.append(attrGrp);
  attrTd.append(attrLbl);
  if (pgProtect == PROTECTON) {
    $('#listApplLineEnd').prop('disabled', true);
    $('#listLineEnd1').prop('disabled', true);
    $('#listLineEnd1').css({ 'opacity': '0.5' });
  } else {
    $('#listApplLineEnd').prop('disabled', false);
    $('#listLineEnd1').prop('disabled', false);
    $('#listLineEnd1').css({ 'opacity': '1.0' });
  }

  // $("#applArea").show();
  // $(".lineTrackAPPL").show();

  if ($('#bottom_screen').length && addHeightCount == 0) {
    addScreenHeight();
  }
}

var addHeightCount = 0;

function addScreenHeight() {
  var cur_height = $('#bottom_screen').height();
  var add_height = $('#applArea').height();
  $('#bottom_screen').css('height', cur_height + add_height);
  addHeightCount++;
}

// select program list
var selProgFlag = false;
var clickCount = 0;
var prevalue = null;
var DBL_timer;

// Define an event handler for the program list.
function selPrgList(id, operation, value) {
  ProgramApplManager.initEditApplSingularity(true);         // fileio
  ProgramApplManager.initEditApplPltzMode(true);         // fileio
  if (prevalue != value) { // When the first time and the second time are different.
    clickCount = 0;
  }
  prevalue = value;
  // single click
  if (!clickCount) {
    ++clickCount;
    DBL_timer = setTimeout(function () {
      updateSelProg(value);
    }, 200);
    // double click(open program)
  } else {
    clearTimeout(DBL_timer);
    updateSelProg(value);
    buttonName = 'openProg';
    isDispMoveToMoniDlg(getSelectProgram(), programOpen);
    clickCount = 0;
  }
  function updateSelProg(value) {
    selProgFlag = true;
    chgDispPrgName(value);
    // When list is selected, enable OK button.
    if (getSelectProgram() != '') {
      $('#openbtn').prop('disabled', false);
      $('#openbtn').removeClass('okyesdis');
      $('#deletebtn').prop('disabled', false);
      $('#deletebtn').removeClass('okyesdis');
      $('#detailsbtn').prop('disabled', false);
      $('#detailsbtn').removeClass('okyesdis');
    }
    tooltipOff();
    attrBtnEnable();
    readProgramFile(value);
    clickCount = 0;
  }
}
var selMonitorRow = [];
var preMoniValue = 0;
var preMoniProgName = ""; //for reselection
function selMonitorList(id, operation, value) {
  if (preMoniValue != value) { // When the first time and the second time are different.
    clickCount = 0;
  }
  preMoniValue = value;
  selMonitorRow = monitorFileList[value];
  var taskName = selMonitorRow.task;
  var progName = selMonitorRow.prog;
  preMoniProgName = progName;
  // single click
  if (!clickCount) {
    ++clickCount;
    DBL_timer = setTimeout(function () {
      updateSelMonitor(taskName, progName);
    }, 200);
    // double click(open program)
  } else {
    clearTimeout(DBL_timer);
    updateSelMonitor(taskName, progName);
    buttonName = 'openProg';
    isDispMoveToMoniDlg(getSelectedMonitorSubName(), programOpen);
    clickCount = 0;
  }
  function updateSelMonitor(taskName, progName) {
    chgDispPrgName(taskName, progName);
    clickCount = 0;
  }
}

$('#listAttrcomment').on('input', function (event) {
  tooltipOff('attrIptCmnt');
});
$('#listAttrcomment').on('change', function (event) {
  tooltipOff('attrIptCmnt');
  var attrComment = $('#listAttrcomment');
  pgAttrComment = attrComment.val();
  if (attrComment.val().length > 0) {	// input comment (not empty)
    var valid = checkByte(attrComment, COMMENTMAX);
    if (!valid) { // Illegal program comment error.
      tooltipOn('listAttrIptCmnt', 'tipByteOver');
      $('#btneditattrok').blur();
      attrComment.select().focus();
      return false;
    }
  }
  if (ProgramApplManager.isLoadLineTrack()) {
    if (!setEditApplData()) {
      return false;
    }
  }
  saveAttr();
  $('#listAttrcomment').blur();
});

$('#listAttrstacksize').on('input', function (event) {
  stackInputFlag = true;
  tooltipOff('attrIptStack');
  var inputNum = $('#listAttrstacksize').val();
  inputNum = inputNum.replace(/[^0-9]+/i, '');	// number only
  $('#listAttrstacksize').val(inputNum);
});
$('#listAttrstacksize').on('change', function (event) {
  tooltipOff('attrIptStack');
  var attrStackSize = $('#listAttrstacksize');
  pgAttrStackSize = Number(attrStackSize.val());
  var valid = true;
  if (attrStackSize.val().length == 0) {	// input stacksize (not empty)
    valid = false;
  } else {
    if ((pgAttrStackSize < STACKSIZEMIN) || (pgAttrStackSize > STACKSIZEMAX)) {	// Illegal program comment error.
      valid = false;
    }
  }
  if (!valid) {
    tooltipOn('listAttrIptStack', 'tipNumvalOver');
    $('#btneditattrok').blur();
    attrStackSize.select().focus();
    return false;
  }
  if (ProgramApplManager.isLoadLineTrack()) {
    if (!setEditApplData()) {
      return false;
    }
  }
  saveAttr();
  $('#listAttrstacksize').blur();
});

$('.localRegs').on('input', function (event) {
  tooltipOff();
  var chgId = event.target.id;
  var inputNum = $('#' + chgId).val();
  inputNum = inputNum.replace(/[^0-9]+/i, '');	// number only
  $('#' + chgId).val(inputNum);
});
$('.localRegs').on('change', function (event) {
  tooltipOff();
  var validChk = true;
  var inputId = event.target.id;
  var chgValue = $('#' + inputId).val();
  if (chgValue == "") {
    var oldValue = ProgramApplManager.getEditApplLocalRegisters();  // fileio
    $('#' + inputId).val(oldValue[localRegTable[inputId].valueId]);
    return;
  }
  // validation check
  if (chgValue < 0 || chgValue > localRegTable[inputId].maxValue) {
    validChk = false;
  }
  if (validChk) {
    if (ProgramApplManager.isLoadLineTrack()) {
      if (!setEditApplData()) {
        return false;
      }
    }
    ProgramApplManager.setEditApplLocalRegisters(chgValue, localRegTable[inputId].valueId);  // fileio
    saveLocalRegs(getSelectProgram());
    $('.localRegs').blur();
  } else {
    tooltipOn(localRegTable[inputId].trgtId, localRegTable[inputId].tooltipId);
    $('#btneditattrok').blur();
    $("#" + inputId).select().focus();
  }
});

$('#listAtt_mtnGrpCB').on('change', 'input[name="listAttrmtngrp"]', function (evt) {
  pgMotionGroup = 0;
  $('input[name="listAttrmtngrp"]:checked').each(function (i) {
    var chkValStr = $(this).val();
    var chkValue = parseInt(chkValStr.substr('grp'.length));
    pgMotionGroup |= 1 << (chkValue - 1);
  });
  // if position data is exist and check group is last 1... to disable
  var grpNum = 1;
  var grpCheck = pgMotionGroup;
  var grpChkCnt = getGroupCheckCount();
  var progInfo = ProgramInfoManager.getSpecifiedProgInfo(getSelectProgram());
  for (var grpNum = 0; grpNum < maxGroupCount; grpNum++) {
    var checkStat = false;
    var checkOpcty = '1.0';
    if (((grpCheck >> grpNum) & 0x1) == 1) {	// check on
      if ((progInfo.isExistProgPosition())) {	// Position data is exist.
        checkStat = true;
        checkOpcty = '0.5';
      }
    }
    $('#listAttrGrp' + (grpNum + 1)).prop('disabled', checkStat);
    $('#listlblGrp' + (grpNum + 1)).prop('disabled', checkStat);
    $('#listlblGrp' + (grpNum + 1)).css({ 'opacity': checkOpcty });
  }
  /*
  if (pgMotionGroup > 0) {	// Either group is checked.
    $('#attrpauseon').prop('disabled', true);
    $('#attrpauseon').addClass('attrdisable');
    $('#attrpauseoff').prop('disabled', true);
    $('#attrpauseoff').addClass('attrdisable');
  } else {*/
  $('#listAttrpauseon').prop('disabled', false);
  $('#listAttrpauseon').removeClass('attrdisable');
  $('#listAttrpauseoff').prop('disabled', false);
  $('#listAttrpauseoff').removeClass('attrdisable');
  $('#listApplSingularityAvdOn').prop('disabled', false);
  $('#listApplSingularityAvdOn').removeClass('attrdisable');
  $('#listApplSingularityAvdOff').prop('disabled', false);
  $('#listApplSingularityAvdOff').removeClass('attrdisable');
  //}
  if (ProgramApplManager.isLoadLineTrack()) {
    if (!setEditApplData()) {
      return false;
    }
  }
  saveAttr();
  $("#listAtt_mtnGrpCB").css({ "pointer-events": "none" });
  setTimeout(function () {
    $("#listAtt_mtnGrpCB").css({ "pointer-events": "auto" });
  }, 400);
});

function setApplEvent() {
  $('#listApplschedule').on('input', function (event) {
    tooltipOff("listapplLineSch");
    var inputNum = $('#listApplschedule').val();
    inputNum = inputNum.replace(/[^0-9]/i, '');	// number only
    $('#listApplschedule').val(inputNum);
  });
  $('#listApplschedule').on('change', function (event) {
    if (setEditApplData()) {
      saveAppl(getSelectProgram());
      $('#listApplschedule').blur();
    }
  });

  $('#listApplboundary').on('input', function (event) {
    tooltipOff("listapplLineBound");
    var inputNum = $('#listApplboundary').val();
    inputNum = inputNum.replace(/[^0-9]/i, '');	// number only
    $('#listApplboundary').val(inputNum);
  });
  $('#listApplboundary').on('change',function (event) {
    if (setEditApplData()) {
      saveAppl(getSelectProgram());
      $('#listApplboundary').blur();
    }
  });

  $('#listApplend').focusout(function (event) {
    if (setEditApplData()) {
      saveAppl(getSelectProgram());
    }
  });
  $('#listApplend').on('keydown', function (event) {
    if (event.keyCode == KEYCODE_ENTER) {
      // saveAppl();
      $('#listApplend').blur();
    }
  });

  $('#listApplIptend').on('change', 'input[name="listLineEnd"]', function (evt) {
    setEditApplData();
    saveAttr();
    $("#listApplIptend").css({ "pointer-events": "none" });
    setTimeout(function () {
      $("#listApplIptend").css({ "pointer-events": "auto" });
    }, 400);
  });

}

function setEditApplData() {
  var wkEditApplData = {};
  // LINE_TRACK_SCHEDULE_NUMBER
  wkEditApplData[resources["lineschedule"]] = $('#listApplschedule').val();
  var applSch = $('#listApplschedule');
  if ((wkEditApplData[resources["lineschedule"]] < 0) || (wkEditApplData[resources["lineschedule"]] > 8)) {
    tooltipOn('listapplLineSch', 'tipScheduleOvar');
    $('#btneditattrok').blur();
    applSch.select().focus();
    return false;
  }
  // LINE_TRACK_BOUNDARY_NUMBER
  wkEditApplData[resources["lineboundary"]] = $('#listApplboundary').val();
  var applBoun = $('#listApplboundary');
  if ((wkEditApplData[resources["lineboundary"]] < 0) || (wkEditApplData[resources["lineboundary"]] > 10)) {
    tooltipOn('listapplLineBound', 'tipBoundryOvar');
    $('#btneditattrok').blur();
    applBoun.select().focus();
    return false;
  }
  var endCheck = "FALSE";
  if ($('#listApplLineEnd').prop('checked')) {
    endCheck = "TRUE";
  }
  wkEditApplData[resources["lineend"]] = endCheck;
  ProgramApplManager.initEditApplData();
  ProgramApplManager.setEditApplData(wkEditApplData);
  return true;
}

function chgDispPrgName(progName, subProgName) {
  $('#progNameText').text(progName);
  $('#subProgNameText').text(subProgName);
  setSelectProgram(progName);
}

function saveAttr() {
  buttonName = 'saveAttrtab';
  getProgramText(getSelectProgram(), GETPROG_TEMP, readEditPrgAttrCallback);	// robotapi
}

// file attribute reg exp checker
function checkByte(inputCom, byteNumber) {
  if (inputCom.val().sjisBytes() > byteNumber) {
    return false;
  } else {
    return true;
  }
}

function readEditPrgAttrCallback(status, programName, programText, lineCount) {
  programName = omitExtension(programName);
  // If status is error, no modified program.
  if (status != IO_SUCCESS) {
    btnSaveattribute(); // There is no * file, save the attribute as it is.
    return;
  }
  //  There is a * file, give a save confirmation dialog.
  var btnObj = {
    btnData : top.irpDlgBtnOC,
    btn1Cb      : saveBeforAttribute,
    btn1CbArg   : { saveParam: { aftersave: buttonName }},
    btn2Cb      : undoAttribute,
  };
  // Confirm save modified
  top.openCmpConfirm(webPage, window, 'confsaveatterdlg', resources['dlgMsgSavePg'], btnObj, true);
}

function attrBtnDisable() {
  $('#savebtn').addClass('btndesable');
  $('#saveasbtn').addClass('btndesable');
  $('#renamebtn').addClass('btndesable');
  $('#applbtn').addClass('btndesable');
  $('#savebtn').prop('disabled', true);
  $('#saveasbtn').prop('disabled', true);
  $('#renamebtn').prop('disabled', true);
  $('#applbtn').prop('disabled', true);

  $('#listAttrprotecton').addClass('btndesable');
  $('#listAttrprotecton').prop('disabled', true);
  $('#listAttrprotectoff').addClass('btndesable');
  $('#listAttrprotectoff').prop('disabled', true);
  $('#listAttrpauseon').prop('disabled', true);
  $('#listAttrpauseon').addClass('attrdisable');
  $('#listAttrpauseoff').prop('disabled', true);
  $('#listAttrpauseoff').addClass('attrdisable');
  $('#listApplSingularityAvdOn').prop('disabled', true);
  $('#listApplSingularityAvdOn').addClass('attrdisable');
  $('#listApplSingularityAvdOff').prop('disabled', true);
  $('#listApplSingularityAvdOff').addClass('attrdisable');
  $('.iptcombox').prop('disabled', true);
  $('#listAttrstacksize').prop('disabled', true);
  $('#listAttrlocalNumReg').prop('disabled', true);
  $('#listAttrlocalPosReg').prop('disabled', true);
  $('#listAttrlocalStrReg').prop('disabled', true);
  $('#seleditlist').addClass('attrseldisable');
  $('.chkboxbk').prop('disabled', true);
  $('.chkboxlg').prop('disabled', true);
  $('.chkboxlg').css({ 'opacity': '0.5' });
}
function attrBtnEnable() {
  $('#saveasbtn').removeClass('btndesable');
  $('#renamebtn').removeClass('btndesable');
  $('#applbtn').removeClass('btndesable');
  $('#saveasbtn').prop('disabled', false);
  $('#renamebtn').prop('disabled', false);
  $('#applbtn').prop('disabled', false);
}                                                                                                                                                                                                    /**********************************************************************
 * PC Editor script
 * for JOG Window.
 * Created: 2018/08/29 FSI
 */

// Use jQuery
/*
 * jQuery JavaScript Library
 * https://jquery.com/
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
*/

/*
  Robot Program Editor initialyze.
*/

var langTimerId = null;
var langGetCount = 0;	// for retry (not use know)

var progAttr_LoadFlg = false;

var watchExec_value = 0;
function getWatchExecValue() {
  return watchExec_value;
}

/* --- Set tablet flag for iOS(iPad), Android, Windows tablet --- */
var navUA = navigator.userAgent.toLowerCase();
console.log("[[User Agent]]=>(" + navigator.userAgent + ")");
var isiPad = (navUA.indexOf('ipad') >= 0);
var isAndroid = (navUA.indexOf('android') >= 0) && (navUA.indexOf('mobile') < 0);
var isTablet = (isiPad || isAndroid ||
  ((navUA.indexOf('windows') >= 0) && (navUA.indexOf('touch') >= 0)) ||
  (navUA.indexOf('kindle') > 0));

//========================================================================

/* Check the frame where the editor exists. */
function isMyIFrameIdPrim() {
  return (window.frameElement.id == IFRAMEID_PRIM);
}

/* Check the frame where the editor exists. */
function getMyIFrameIdName() {
  return window.frameElement.id;
}

// Initialize Editor screen get language kind.
function initEditorScreen() {
  initResource(initLayoutArea);
}
// Initialize layout area after get resource data.
function initLayoutArea() {  
  if (top.irprogapi.getDispPrgAttrMoniFlag()) {
    curTabType = SELECT_MONITOR;
    top.irprogapi.setDispPrgAttrMoniFlag(false);
  }
  showProgramMoniotrList(curTabType);
  $('#programMonitorTabs')[0].setCallback(programMonitorTabsClick);
  buildProgramList();
  $("#proglistview")[0].setCallback(selPrgList);
  $("#monitorList")[0].setCallback(selMonitorList);

  $('img').attr('ondragstart', 'return false;');
  $('body').css({ 'font-family' : resources.progAttrFont});
  // Fix the width of '#prgFilter'. for IE.
  if(top.g_msie) {
    // Separate display for element-by-element calculations.
    $('#prgFilter').css('display','block');
    var text = document.getElementById('filtertext').offsetWidth;
    var box = document.getElementById('filterSlctBox').offsetWidth;
    var btn = document.getElementById('addFilterBtn').offsetWidth;
    var fixWidth = text + box +  btn;
    $('#prgFilter').css('flex','0 0 ' + fixWidth + 'px');
    $('#prgFilter').css('display','');
  }
  if (!isMyIFrameIdPrim()) { // for other than prim
    putSubFrameOverlay();
  }
  setApplEvent();
}

// In order to make the operation possible, remove the screen.
function removeOverlayScreen(additionalID) {
  $('#screenoverlay-' + additionalID).hide();
  $('#screenoverlay-' + additionalID).remove();
}
// In order to make operation impossible, the screen is put up.
function putOverlayScreen(additionalID, targetScr) {
  var overlayCls = 'screenoverlay ' + targetScr;
  var overlayId = 'screenoverlay-' + additionalID;
  if ($('#' + overlayId).length == 0) {    // If it does not already exist, display overlay.
    $('body').append('<div id="' + overlayId + '" class="' + overlayCls + '"></div>');
    $('#' + overlayId).show();
  }
}

function putSubFrameOverlay() {
  // attribute area screen
  var topHeight = $('.top_area').height();
  var screenHeight = $('.contents_area').height() - topHeight;
  var overlayDiv = document.createElement('div');
  overlayDiv.id = "bottom_screen";
  overlayDiv.className = "screenoverlay";
  $('.bottom_area').append(overlayDiv);
  $('#bottom_screen').css({
    "position": "absolute",
    "top": topHeight,
    "height": screenHeight,
    "z-index": 2
  });
  $('#bottom_screen').show();

  // new button aerea screen
  var overlay = document.createElement("div");
  overlay.className = "screenoverlay";
  overlay.id = "top_button_screen";
  $('.right_area').append(overlay);
  $('#top_button_screen').css({
    "height": topHeight,
    "width": "100%",
    "position": "absolute"
  });
  $('#top_button_screen').show();
  $('#openbtn').css("z-index", 9999);
}

$(function () {
  $('#listAtt_pause_btn').on('click touchend', '#listAttrpauseon', function (event) {
    if(event.type.indexOf('touch') >= 0){
      event.preventDefault();
    }
    if (pgPause == 0) {
      // When list is selected, enable OK button.
      $('#listAttrpauseon').css({ 'background-color': attrBtnOnColor });
      $('#listAttrpauseoff').css({ 'background-color': attrBtnOffColor });
      pgPause = PAUSEON;
      if (ProgramApplManager.isLoadLineTrack()) {
        if (!setEditApplData()) {
          return false;
        }
      }
      saveAttr();
    }
  });
  $('#listAtt_pause_btn').on('click touchend', '#listAttrpauseoff', function (event) {
    if(event.type.indexOf('touch') >= 0){
      event.preventDefault();
    }
    if (pgPause == PAUSEON) {
      // When list is selected, enable OK button.
      $('#listAttrpauseoff').css({ 'background-color': attrBtnOnColor });
      $('#listAttrpauseon').css({ 'background-color': attrBtnOffColor });
      pgPause = 0;
      if (ProgramApplManager.isLoadLineTrack()) {
        if (!setEditApplData()) {
          return false;
        }
      }
      saveAttr();
    }
  });
  $('#listAttr_protect_btn').on('click touchend', '#listAttrprotecton', function (event) {
    if(event.type.indexOf('touch') >= 0){
      event.preventDefault();
    }
    if (pgProtect == PROTECTOFF) {
      // When list is selected, enable OK button.
      $('#listAttrprotecton').css({ 'background-color': attrBtnOnColor });
      $('#listAttrprotectoff').css({ 'background-color': attrBtnOffColor });
      $('#listAttrpauseon').prop('disabled', true);
      $('#listAttrpauseon').addClass('attrdisable');
      $('#listAttrpauseoff').prop('disabled', true);
      $('#listAttrpauseoff').addClass('attrdisable');
      $('#listApplSingularityAvdOn').prop('disabled', true);
      $('#listApplSingularityAvdOn').addClass('attrdisable');
      $('#listApplSingularityAvdOff').prop('disabled', true);
      $('#listApplSingularityAvdOff').addClass('attrdisable');
      $('.iptcombox').prop('disabled', true);
      $('#listAttrstacksize').prop('disabled', true);
      $('#listAttrlocalNumReg').prop('disabled', true);
      $('#listAttrlocalPosReg').prop('disabled', true);
      $('#listAttrlocalStrReg').prop('disabled', true);
      $('#seleditlist').addClass('attrseldisable');
      $('.chkboxbk').prop('disabled', true);
      $('.chkboxlg').prop('disabled', true);
      $('.chkboxlg').css({ 'opacity': '0.5' });
      pgProtect = PROTECTON;
      if (ProgramApplManager.isLoadLineTrack()) {
        if (!setEditApplData()) {
          return false;
        }
      }
      saveAttr();
    }
  });
  $('#listAttr_protect_btn').on('click touchend', '#listAttrprotectoff', function (event) {
    if(event.type.indexOf('touch') >= 0){
      event.preventDefault();
    }
    if (pgProtect == PROTECTON) {
      // When list is selected, enable OK button.
      $('#listAttrprotectoff').css({ 'background-color': attrBtnOnColor });
      $('#listAttrprotecton').css({ 'background-color': attrBtnOffColor });
      $('#listAttrpauseon').prop('disabled', false);
      $('#listAttrpauseon').removeClass('attrdisable');
      $('#listAttrpauseoff').prop('disabled', false);
      $('#listAttrpauseoff').removeClass('attrdisable');
      $('#listApplSingularityAvdOn').prop('disabled', false);
      $('#listApplSingularityAvdOn').removeClass('attrdisable');
      $('#listApplSingularityAvdOff').prop('disabled', false);
      $('#listApplSingularityAvdOff').removeClass('attrdisable');
      $('.iptcombox').prop('disabled', false);
      $('#listAttrstacksize').prop('disabled', false);
      $('#listAttrlocalNumReg').prop('disabled', false);
      $('#listAttrlocalPosReg').prop('disabled', false);
      $('#listAttrlocalStrReg').prop('disabled', false);
      $('#seleditlist').removeClass('attrseldisable');
      var progInfo = ProgramInfoManager.getSpecifiedProgInfo(getSelectProgram());
      if ((!progInfo.isExistProgPosition()) && (posRecordCount == 0) &&
        ($('#seleditlist').text().trim() != resources['attrSubCond'])) {
        $('.chkboxbk').prop('disabled', false);
        $('.chkboxlg').prop('disabled', false);
        $('.chkboxlg').css({ 'opacity': '1.0' });
      }
      $('#listApplLineEnd').prop('disabled', false); // Checkbox for Line track is enable,
      $('#listLineEnd1').prop('disabled', false); // when Position data is exist.
      $('#listLineEnd1').css({ 'opacity': '1.0' });
      pgProtect = PROTECTOFF;
      if (ProgramApplManager.isLoadLineTrack()) {
        if (!setEditApplData()) {
          return false;
        }
      }
      saveAttr();
    }
  });
  $('#singularity_avd_btn').on('click touchend', '#listApplSingularityAvdOn', function (event) {
    if(event.type.indexOf('touch') >= 0){
      event.preventDefault();
    }
    // When list is selected, enable OK button.
    $('#listApplSingularityAvdOn').css({ 'background-color': attrBtnOnColor });
    $('#listApplSingularityAvdOff').css({ 'background-color': attrBtnOffColor });
    var editSingularity= {};
    editSingularity["ENABLE_SINGULARITY_AVOIDANCE"] = 'TRUE;';
    ProgramApplManager.setEditApplSingularity(editSingularity);  // fileio
    if (ProgramApplManager.isLoadLineTrack()) {
      if (!setEditApplData()) {
        return false;
      }
    }
    saveAttr();
  });
  $('#singularity_avd_btn').on('click touchend', '#listApplSingularityAvdOff', function (event) {
    if(event.type.indexOf('touch') >= 0){
      event.preventDefault();
    }
    // When list is selected, enable OK button.
    $('#listApplSingularityAvdOff').css({ 'background-color': attrBtnOnColor });
    $('#listApplSingularityAvdOn').css({ 'background-color': attrBtnOffColor });
    var editSingularity= {};
    editSingularity["ENABLE_SINGULARITY_AVOIDANCE"] = 'FALSE;';
    ProgramApplManager.setEditApplSingularity(editSingularity);  // fileio
    if (ProgramApplManager.isLoadLineTrack()) {
      if (!setEditApplData()) {
        return false;
      }
    }
    saveAttr();
  });
});

// (IN) pgName: Program name after switching.
function chgProgramCB(pgName) {
  setCurrentProgram(pgName);
  var progInfo = parseProgramFile(getProdProgName(pgName), getConvertLines()); // api.
  ProgramInfoManager.chgMainProgInfo(progInfo); // Set program info to top.
}

function initPrgFilter() {
  var slctH = document.getElementById('filterSlct').clientHeight;
  var slctW = document.getElementById('filterSlct').clientWidth;
  document.getElementById('filterSlctBox').style.width = slctW + 'px';
  document.getElementById('filterSlctOvlBtn').style.height = slctH + 'px';
  document.getElementById('filterSlctOvlBtn').style.width = slctW + 'px';
  document.getElementById('filterSlctOvl').style.left = '-' + slctW + 'px';
  document.getElementById('filterSlct').setCallback(setPrgFilter);
  var filterSlcted = sessionStorage.getItem('progattrFilter_' + window.frameElement.id);
  var filterSlctObj = [resources['filterAll']];
  if ((filterSlcted === null) || (filterSlcted == resources['filterAll'])) {
    filterSlcted = resources['filterAll'];
  } else {
    filterSlctObj.push(filterSlcted);
  }
  document.getElementById('filterSlct').refresh(filterSlctObj, filterSlcted, null, false);
}
function setPrgFilter(id, type, value) {
  sessionStorage.setItem('progattrFilter_' + window.frameElement.id, value);
  drawProgramList();
}

//========================================================================
var SELECT_PROGLIST = 0;
var SELECT_MONITOR = 1;
var loadFlag = false;
var curTabType = SELECT_PROGLIST;
/*
 * Windows OnLoad Event
 */
$(window).on('load', function () {
  loadFlag = true;

  setScrMode();

  // If I have not acquired the language type yet, I will go get it.
  if (getCurrentLanguage() === null) {
    setCurrentLanguage(initEditorScreen);
  }

  if (isMyIFrameIdPrim()) {
    // Callback for program switching on the status bar.
    top.setChgPrgCB(chgProgramCB);
  }


  top.rpcmc_chkkey(null, top.mor_ss_c, top.SYSNAME_C, '$PG_CFG.$NUM_TASKS', setNumTasks);
  top.rpcmc_chkkey(null, top.mor_ss_c, top.SYSNAME_C, '$SCR.$MULSELENB', setMulSelEnb);
  getMltEnable();
});

var TAB_NUM = 2;
function showProgramMoniotrList(listType) {
  $('#programMonitorTabs')[0].refresh(null, TAB_NUM, listType.toString(), false, null);
  programMonitorTabsClick('', 'change', listType);
}

function getSelectedMonitorName() {
  var val = $('#monitorList')[0].getSelectedValue();
  return val == "" ? null : monitorFileList[val].task;
}

function getSelectedMonitorSubName() {
  var val = $('#monitorList')[0].getSelectedValue();
  return val == "" ? null : monitorFileList[val].prog;
}                                                                                                                                                                                                       /**********************************************************************
 * PC Editor Tablet script
 * for program attribute subtype.
 * Created: 2018/09/13 FSI
 *
 */
// Use jQuery
/*
* jQuery JavaScript Library
* https://jquery.com/
* Copyright JS Foundation and other contributors
* Released under the MIT license
* https://jquery.org/license
*/

// Require : pceditor_fileio.js : Use ProgramApplManager object.

var openSelEditList = false;
function isOpenSelEditList() {
  return openSelEditList;
}
function setOpenSelEditList(status) {
  openSelEditList = status;
}
function closeSelEditList() {
  $('#seleditopt').remove();
  setOpenSelEditList(false);
  if (ProgramApplManager.isLoadLineTrack()) {
    if (!setEditApplData()) {
      return false;
    }
  }
  if (pgSubType != getSelEditListVal()) {
    saveAttr();
  }
  pgSubType = getSelEditListVal();
}

function getSelEditListVal() {
  return selEditValue;
}

function setSelEditListVal(editVal) {
  // convert subtype name to number
  var result = null;
  var keys = Object.keys(subtypeList);
  for (var i = 0; i < keys.length; i++) {
    if (subtypeList[keys[i]] === editVal) {
      result = keys[i];
    }
  }
  selEditValue = result[0];
}

$(function () {
  // Click on select list
  $('#seleditlist').on('click touchend', function (evt) {
    if(evt.type.indexOf('touch') >= 0){
      evt.preventDefault();
    }
    if (openSelEditList) {
      $('#selbtnimg').removeClass('selbtndisabled');
      selectEditListProc(evt);
      closeSelEditList();
    } else {
      // Make Edit-list HTML.
      var $editoptbox = $('<div>', { 'id': 'seleditopt', 'class': 'selframebox'});
      var progdata = ProgramInfoManager.getSpecifiedProgInfo(getSelectProgram());
      if (progdata.getMnemonicLineCount() > 0) { // Program line is exist -> Disable(Condition)
        editValueList = ['attrSubNone', 'attrSubMacro']; // 
      }
      for (var editidx = 0; editidx < (editValueList.length); editidx++) {
        var $frmoptitem = $('<div>', { 'id': editValueList[editidx], 'class': 'selframeopt' });
        $frmoptitem.html(resources[editValueList[editidx]]);
        if (editValueList[editidx] == subtypeList[getSelEditListVal()]) {
          $frmoptitem.css({ 'background-color': '#0E6EB8', 'color': '#ffffff' });
        }
        if (editidx == 0) { 	// start of item
          $frmoptitem.addClass('selframeopttop');
        }
        if (editidx == editValueList.length - 1) {
          $frmoptitem.addClass('selframeoptend');
        }
        $editoptbox.append($frmoptitem);
      }
      editValueList = ['attrSubNone', 'attrSubMacro', 'attrSubCond'];
      $('#seleditlist').append($editoptbox);
      setOpenSelEditList(true);
    }
    evt.preventDefault();
    evt.stopPropagation();
    return false;
  });

  // Procedure for edit list selection.
  function selectEditListProc(evt) {
    var seleditVal = evt.target.id;
    var selIndex = $.inArray(seleditVal, editValueList);
    if (selIndex < 0) {
      return;
    }
    setCheckStatPL(resources[seleditVal]);
    setSelEditListVal(seleditVal);
    // refrect to edit name box
    $('#seleditlist').html(resources[seleditVal] + ' <div id="seleditbtn" class="selframebtn">' +
    '<img id="selbtnimg" class="selbtnimg" src="images/select_icon_large.png">' +
      '</div>');
  }

  function setCheckStatPL(currentSelect) {
    var progInfo = ProgramInfoManager.getCurrentProgInfo();
    var checkStat = false;
    var checkOpcty = '1.0';

    if (currentSelect == resources['attrSubCond']) {
      checkStat = true;
      checkOpcty = '0.5';
      pgMotionGroup = 0;
    } else {
      if (progInfo.isExistProgPosition()) {
        checkStat = true; // Position data is exist -> Disable
        checkOpcty = '0.5';
      }
    }
    for (var grpNum = 0; grpNum < maxGroupCount; grpNum++) {
      $('#listAttrGrp' + (grpNum + 1)).prop('disabled', checkStat);
      $('#listlblGrp' + (grpNum + 1)).prop('disabled', checkStat);
      $('#listlblGrp' + (grpNum + 1)).css({ 'opacity': checkOpcty });

      if (currentSelect == resources['attrSubCond']) {
        var checkbox = document.getElementById('listAttrGrp' + (grpNum + 1));
        checkbox.checked = false; // Subtype is Condition -> Checked clear
      }
    }
  }
});                                                                                                                                                                                                                        P A L L E  "T I Z I N G   . J PALLET~1JS    MjXX  MjX  BL G . J S  6    P C E D I  6T O R _ P L   T D PCEDI~25JS    MjXX  MjXU BO S . J S      P C E D I  T O R _ P L   T P PCEDI~26JS    MjXX  MjX-  BI N F O .  J S     P C E D I  T O R _ P R   O G PCEDI~27JS    MjXX  MjXp9  BC H . J S      P C E D I  T O R _ S E   A R PCEDI~28JS    MjXX  MjXڑ;  BM P . J S      P C E D I  T O R _ A T   C O /**********************************************************************
 * Robot Program Editor script
 * 
 * Created: 2019/04/16
 *
 */

// palletizing global object
var palletizing = {};

function initGPlt() {
  palletizing = {};
}

var defaltVoidPosDataModel = {
  "groupNumber": "", "ufVal": "", "utVal": "", "configStr": "",
  "poskey": { "X": "", "Y": "", "Z": "", "W": "", "P": "", "R": "" }
}

var defaltBottomPosObj = {
  "posNumber": "",
  "posData": [{
    "groupNumber": "", "ufVal": "", "utVal": "", "configStr": "",
    "poskey": { "X": "", "Y": "", "Z": "", "W": "", "P": "", "R": "" }
  }]
};

var jpObjKana = {
  "ﾂﾐｱｹﾞﾙ": "積上", "ﾂﾐｵﾛｽ": "積下",
  "ｷﾞﾚﾀﾞ": "行列段", "ﾚﾀﾞｷﾞ": "列段行", "ﾀﾞｷﾞﾚ": "段行列", "ｷﾞﾀﾞﾚ": "行段列", "ﾚｷﾞﾀﾞ": "列行段", "ﾀﾞﾚｷﾞ": "段列行",
  "2ﾃﾝ": "2点", "ｾﾞﾝﾃﾝ": "全点", "ｺﾃｲ": "固定", "ﾌﾞﾝｶﾂ": "分割"
};

var jpKanji2Kana = {
  "積上": "ﾂﾐｱｹﾞﾙ", "積下": "ﾂﾐｵﾛｽ",
  "行列段": "ｷﾞﾚﾀﾞ", "列段行": "ﾚﾀﾞｷﾞ", "段行列": "ﾀﾞｷﾞﾚ", "行段列": "ｷﾞﾀﾞﾚ", "列行段": "ﾚｷﾞﾀﾞ", "段列行": "ﾀﾞﾚｷﾞ",
  "2点": "2ﾃﾝ", "全点": "ｾﾞﾝﾃﾝ",
  "固定": "ｺﾃｲ", "分割": "ﾌﾞﾝｶﾂ"
};

var chLib = {
  "pltpallet": "PALLET",
  "pltdepallet": "DEPALLET",
  "pltauxno": "NO",
  "pltauxyes": "YES",
  "pltmethodline": "LINE",
  "pltmethodfree": "FREE",
  "pltattitudefix": "FIX",
  "pltattitudeint": "INTER"
}

// create new palletizing object
function generatePltObj(category, pltNum) {
  var geneObj = {
    "category": category,
    "palletizing_num": pltNum
  }
  geneObj.config = generateConfigObj(category);
  geneObj.bottom = generateBottomArry();

  if (category.indexOf("X") >= 0) {
    geneObj.pattern = generatePatternArry();
  }

  geneObj.route = generateRouteObj(getCurrentLanguage());

  return geneObj;
}

// default pattern for B
var defalteConfigObj = {
  "name": "",
  "type": "pltpallet",
  "incr": 1,
  "pal_reg": 1,
  "order": "pltrcl",
  "rows": [1],
  "columns": [1],
  "layers": [1],
  "aux_pos": ["pltauxno"],
  "appr": 1,
  "rtrt": 1,
  "pattern": 1
}

function generateConfigObj(category) {
  var obj = JSON.parse(JSON.stringify(defalteConfigObj));
  var appendRCArray = ["pltmethodline", "pltattitudefix"]; // rows and columns for E/EX
  var appendLArray = ["pltmethodline", "pltattitudefix", 1]; // layers for E/EX
  var appendAuxArray = ["pltattitudefix"];
  switch (category) {
    case "B":

      break;
    case "BX":

      break;
    case "E":
    case "EX":
      obj.rows = obj.rows.concat(appendRCArray);
      obj.columns = obj.columns.concat(appendRCArray);
      obj.layers = obj.layers.concat(appendLArray);
      obj.aux_pos = obj.aux_pos.concat(appendAuxArray);
      break;
    default:
      break;
  }

  return obj;
}

function generateBottomArry() {
  var defaultRoutearray = [
    {
      "posNumber": "P [1,1,1]", "posData": [{
        "groupNumber": "", "ufVal": "", "utVal": "", "configStr": "",
        "poskey": { "X": "", "Y": "", "Z": "", "W": "", "P": "", "R": "" }
      }]
    }
  ];
  return defaultRoutearray;
}

function generatePatternArry() {
  var defaultPatternArry = [["*", "*", "*"]];
  return defaultPatternArry;
}

var defaultRouteProg = [
  { "motion": "pltmotionj", "speed": "30", "unit": "%", "kind": "pltmotionfine", "kind_num": 0 },
  { "motion": "pltmotionj", "speed": "30", "unit": "%", "kind": "pltmotionfine", "kind_num": 0 },
  { "motion": "pltmotionj", "speed": "30", "unit": "%", "kind": "pltmotionfine", "kind_num": 0 }
];

function generateRouteObj(lang) {
  var geneRoute = { "pattern": { "1": [] }, "prog": [] };
  var posArry = [];
  var pos_str = { "jp": ["ｲﾁ[ｾ_1]", "ｲﾁ[ﾂﾐﾃﾝ]", "ｲﾁ[ﾆ_1]"], "eg": ["P [A_1]", "P [BTM]", "P [R_1]"] };

  if (lang != "jp") lang = "eg";
  var str = pos_str[lang];

  for (var i = 0; i < 3; i++) {
    posArry[i] = {
      "posNumber": "",
      "posData": [{
        "groupNumber": "", "ufVal": "", "utVal": "", "configStr": "",
        "poskey": { "X": "", "Y": "", "Z": "", "W": "", "P": "", "R": "" }
      }]
    }
    posArry[i].posNumber = str[i];
  }

  geneRoute.pattern["1"] = posArry;
  geneRoute.prog = JSON.parse(JSON.stringify(defaultRouteProg));

  return geneRoute;
}

//==================================
// initialize palletizing object

// initialize palletizing_B defalt object  (load LS File)
function initPalletB(pallet_num) {
  palletizing[String(pallet_num)] = JSON.parse(JSON.stringify(generatePltObj("B", pallet_num)));
  return palletizing[String(pallet_num)];
}
// initialize palletizing_BX defalt object  (load LS File)
function initPalletBX(pallet_num) {
  palletizing[String(pallet_num)] = JSON.parse(JSON.stringify(generatePltObj("BX", pallet_num)));
  return palletizing[String(pallet_num)];
}
// initialize palletizing_E defalt object  (load LS File)
function initPalletE(pallet_num) {
  palletizing[String(pallet_num)] = JSON.parse(JSON.stringify(generatePltObj("E", pallet_num)));
  return palletizing[String(pallet_num)];
}
// initialize palletizing_EX defalt object  (load LS File)
function initPalletEX(pallet_num) {
  palletizing[String(pallet_num)] = JSON.parse(JSON.stringify(generatePltObj("EX", pallet_num)));
  return palletizing[String(pallet_num)];
}
// genelate initialize palletizing object
function getInitPltObj(plt_categoly, pltNum) {
  var result = false;
  switch (plt_categoly) {
    case "B":
      result = initPalletB(pltNum);
      break;
    case "BX":
      result = initPalletBX(pltNum);
      break;
    case "E":
      result = initPalletE(pltNum);
      break;
    case "EX":
      result = initPalletEX(pltNum);
      break;
    default:
      result = false;
      break;
  }
  return result;
}

//==================================
// get temporary palletizing object

// get temp palletizing_B default object  (crate New palletizing)
function getTempPalletB(pallet_num) {
  var blank = JSON.parse(JSON.stringify(generatePltObj("B", pallet_num)));
  blank.palletizing_num = pallet_num;
  return blank;
}
// get temp palletizing_BX default object  (crate New palletizing)
function getTempPalletBX(pallet_num) {
  var blank = JSON.parse(JSON.stringify(generatePltObj("BX", pallet_num)));
  blank.palletizing_num = pallet_num;
  return blank;
}
// get temp palletizing_E default object  (crate New palletizing)
function getTempPalletE(pallet_num) {
  var blank = JSON.parse(JSON.stringify(generatePltObj("E", pallet_num)));
  blank.palletizing_num = pallet_num;
  return blank;
}
// get temp palletizing_EX default object  (crate New palletizing)
function getTempPalletEX(pallet_num) {
  var blank = JSON.parse(JSON.stringify(generatePltObj("EX", pallet_num)));
  blank.palletizing_num = pallet_num;
  return blank;
}


// delete unused palletizing number
function deleteUnusedPltNum(pltNum_array) {
  var obj_keys = Object.keys(palletizing);
  for (var i = 0; i < pltNum_array.length; i++) {
    for (var j = 0; j < obj_keys.length; j++) {
      if (pltNum_array[i] == obj_keys[j]) {
        obj_keys.splice(j, 1);
      }
    }
  }
  if (obj_keys.length > 0) {
    for (index in obj_keys) {
      delete palletizing[obj_keys[index]];
    }
  }
}

// search unused pallet number 
function searchUnusedPltNum() {
  var num = 1;
  for (num; num <= 16; num++) {
    if (palletizing[num] == undefined) {
      return num;
    }
  }
}

// genelate new palletizing object
function getNewPltObj(plt_categoly) {
  var num = searchUnusedPltNum();
  if (num == undefined) { return false; }
  var result = false;
  switch (plt_categoly) {
    case "B":
      result = getTempPalletB(num);
      break;
    case "BX":
      result = getTempPalletBX(num);
      break;
    case "E":
      result = getTempPalletE(num);
      break;
    case "EX":
      result = getTempPalletEX(num);
      break;
    default:
      result = false;
      break;
  }
  return result;
}

// set local pallet object for global palletizing object
function setGlobalPltObj(pallet_num, pallet_obj) {
  palletizing[String(pallet_num)] = JSON.parse(JSON.stringify(pallet_obj));
}

// get global palletizing object
function getGlobalPltObj(pallet_num) {
  return JSON.parse(JSON.stringify(palletizing[String(pallet_num)]));
}

// Update an object based on the value of config
function updatePltObj(pallet_obj) {
  var update = {};
  update = updateBottom(pallet_obj, getCurrentLanguage());
  update = updateRoute(update, getCurrentLanguage());
  update = updatePattern(update);
  return update;
}

// Bottom update
function updateBottom(pallet_obj, lang) {
  var row = pallet_obj.config.rows[0];
  var colum = pallet_obj.config.columns[0];
  var layers = pallet_obj.config.layers;
  var aux = pallet_obj.config.aux_pos[0];
  var pos_lib = { jp: "ｲﾁ", eg: "P ", ch: "P ", gr: "P ", fr: "P ", it: "P", tw: "P" };
  var pos_str = pos_lib[lang];
  var bottom_array = [];

  var patNum = 1;
  do {  // create bottom point
    bottom_array.push({
      "posNumber": pos_str + "[1,1," + patNum + "]", "posData": [{
        "groupNumber": "", "ufVal": "", "utVal": "", "configStr": "",
        "poskey": { "X": "", "Y": "", "Z": "", "W": "", "P": "", "R": "" }
      }]
    });
    if (row != 1) {
      bottom_array = createRowObj(pallet_obj, bottom_array, pos_str, patNum);
    }
    if (colum != 1) {
      bottom_array = createColumObj(pallet_obj, bottom_array, pos_str, patNum);
    }
    if (aux == "pltauxyes" && row != 1 && colum != 1) {
      bottom_array = createAuxObj(pallet_obj, bottom_array, pos_str, patNum)
    } else if (aux == "pltauxyes" && (row == 1 || colum == 1)) {
      pallet_obj.config.aux_pos[0] = "pltauxno";
    }
    if (layers[0] != 1) {
      bottom_array = createLayerObj(pallet_obj, bottom_array, pos_str, patNum);
    }
    patNum++;
  } while ((patNum <= layers[3]) && (layers.length == 4));

  // copy position data
  for (var lnum = 0; lnum < bottom_array.length; lnum++) {
    for (var onum = 0; onum < pallet_obj.bottom.length; onum++) {
      if (bottom_array[lnum].posNumber == pallet_obj.bottom[onum].posNumber) {
        bottom_array[lnum].posData = pallet_obj.bottom[onum].posData
      }
    }
  }

  pallet_obj.bottom = {};
  pallet_obj.bottom = bottom_array;

  return pallet_obj;
}

function createRowObj(pallet_obj, bottom_array, pos_str, patNum) {
  var rows = pallet_obj.config.rows;
  var tempObj = JSON.parse(JSON.stringify(defaltBottomPosObj));

  if (rows[1] === "pltmethodfree") { // all point teaching
    for (var i = 2; i <= rows[0]; i++){
      tempObj.posNumber = pos_str + "[" + i + ",1," + patNum + "]";
      bottom_array.push(JSON.parse(JSON.stringify(tempObj)));
    }
  } else { // other 
    tempObj.posNumber = pos_str + "[" + rows[0] + ",1," + patNum + "]";
    bottom_array.push(JSON.parse(JSON.stringify(tempObj)));
  }

  return bottom_array;
}

function createColumObj(pallet_obj, bottom_array, pos_str, patNum) {
  var columns = pallet_obj.config.columns;
  var tempObj = JSON.parse(JSON.stringify(defaltBottomPosObj));

  if (columns[1] === "pltmethodfree") { // all point teaching
    for (var i = 2; i <= columns[0]; i++) {
      tempObj.posNumber = pos_str + "[1," + i + "," + patNum + "]";
      bottom_array.push(JSON.parse(JSON.stringify(tempObj)));
    }
  } else { // other 
    tempObj.posNumber = pos_str + "[1," + columns[0] + "," + patNum + "]";
    bottom_array.push(JSON.parse(JSON.stringify(tempObj)));
  }

  return bottom_array;
}

function createLayerObj(pallet_obj, bottom_array, pos_str, patNum) {
  var layers = pallet_obj.config.layers;
  var tempObj = JSON.parse(JSON.stringify(defaltBottomPosObj));

  if (layers[3] != 1 && pallet_obj.category.indexOf("E") >= 0) { return bottom_array;}

  if (layers[1] === "pltmethodfree") { // all point teaching
    for (var i = 2; i <= layers[0]; i++) {
      tempObj.posNumber = pos_str + "[1,1," + i + "]";
      bottom_array.push(JSON.parse(JSON.stringify(tempObj)));
    }
  } else { // other 
    tempObj.posNumber = pos_str + "[1,1," + layers[0] + "]";
    bottom_array.push(JSON.parse(JSON.stringify(tempObj)));
  }

  return bottom_array;
}

function createAuxObj(pallet_obj, bottom_array, pos_str, patNum) {
  var colum = pallet_obj.config.columns[0];
  var row = pallet_obj.config.rows[0];
  var tempObj = JSON.parse(JSON.stringify(defaltBottomPosObj));

  tempObj.posNumber = pos_str + "[" + row + "," + colum + "," + patNum + "]";
  bottom_array.push(tempObj);

  return bottom_array;
}

// Route update
function updateRoute(pallet_obj, lang) {
  var appr = pallet_obj.config.appr;
  var rtrt = pallet_obj.config.rtrt;
  var appr_text = { jp: "ｾ", eg: "A", ch: "A", gr: "A", fr: "A", it: "A", tw: "A" };
  var rtrt_text = { jp: "ﾆ", eg: "R", ch: "R", gr: "R", fr: "R", it:"R", tw: "R" };
  var pos_text = { jp: "ｲﾁ", eg: "P ", ch: "P ", gr: "P", fr: "P", it: "P", tw: "P" };
  var target_text = { jp: "ﾂﾐﾃﾝ", eg: "BTM", ch: "BTM", gr: "BTM", fr: "BTM", it: "BTM", tw: "BTM" };

  // crate defalt data
  var posdata_array = [];
  var prog_array = [];
  var putPosdataVal = {
    posNumber: "", posData: [{
      "groupNumber": "", "ufVal": "", "utVal": "", "configStr": "",
      "poskey": { "X": "", "Y": "", "Z": "", "W": "", "P": "", "R": "" }
    }]
  };
  var putProgVal = { motion: "pltmotionj", speed: "30", unit: "%", kind: "pltmotionfine", "kind_num": 0 }

  // create route pattern positiondata
  // approach position data
  for (var appr_num = appr; appr_num > 0; appr_num--) {
    var putData = JSON.parse(JSON.stringify(putPosdataVal));
    putData.posNumber = pos_text[lang] + "[" + appr_text[lang] + "_" + appr_num + "]"; // crate value
    posdata_array.push(putData);
    prog_array.push(putProgVal);
  }
  // BTM position data
  var putData = JSON.parse(JSON.stringify(putPosdataVal));
  putData.posNumber = pos_text[lang] + "[" + target_text[lang] + "]"; // crate value
  posdata_array.push(putData);
  prog_array.push(putProgVal);
  // rtrt position data
  for (var rtrt_num = 1; rtrt_num <= rtrt; rtrt_num++) {
    var putData = JSON.parse(JSON.stringify(putPosdataVal));
    putData.posNumber = pos_text[lang] + "[" + rtrt_text[lang] + "_" + rtrt_num + "]"; // crate value
    posdata_array.push(putData);
    prog_array.push(putProgVal);
  }

  var posdataObj = {};
  for (var pat = 1; pat <= pallet_obj.config.pattern; pat++) {
    var routePattern = pallet_obj.route.pattern[String(pat)];    

    // create pattern positions
    posdataObj[String(pat)] = JSON.parse(JSON.stringify(posdata_array));

    var genPos = posdataObj[String(pat)];

    if (routePattern == undefined) continue;

    // copy posdata config data
    for (var lnum = 0; lnum < routePattern.length; lnum++) {
      for (var onum = 0; onum < genPos.length; onum++) {
        if (genPos[onum].posNumber == routePattern[lnum].posNumber) {
          genPos[onum].posData = routePattern[lnum].posData;
        }
      }
    }
  }

  if (prog_array.length == pallet_obj.route.prog.length) {
    prog_array = pallet_obj.route.prog;
  }

  pallet_obj.route.pattern = posdataObj;
  pallet_obj.route.prog = prog_array;

  return pallet_obj;
}

// Pattern update
function updatePattern(pallet_obj) {
  if (pallet_obj.category.indexOf("X") > 0) {
    var patNum = pallet_obj.config.pattern;
    var patObj = [];
    var comObj = pallet_obj.pattern;

    for (var i = 0; i < patNum; i++) {
      patObj[i] = ["*", "*", "*"];
    }
    for (var j = 0; j < patObj.length; j++) {
      if (j >= comObj.length) { break; }
      patObj[j] = comObj[j];
    }
    pallet_obj.pattern = patObj;
  }
  return pallet_obj;
}

// check object value exist
function checkObjExist(obj, target_key, val) {
  var result = obj.filter(function (item, index) {
    if (item[target_key] == val) return true;
  });
  return result;
}

// set program text data
// pallet_num : target pallet number
// command_num : target command number
// input_obj : input program data
// ex.)        {
//                "motion": "J",
//                "speed": "30",
//                "unit": "%",
//                "kind": "FINE",
//                "kind_num": 0
//              }
function setProgData(pallet_num, command_num, input_obj) {

  // if (!evalProgDataObj(input_obj)) return false; // Object integrity check.  no need?

  for (key in input_obj) {
    input_obj[key] = serchPltResource(resources, input_obj[key]);
  }

  var target_data = palletizing[String(pallet_num)].route;
  target_data.prog[command_num] = input_obj;

  return true;
}

function evalProgDataObj(progDataObj) {
  var keyList = ["motion", "speed", "unit", "kind", "kind_num"];

  if (Object.keys(progDataObj) != keyList.length) {
    return false;
  }

  for (var i = 0; i < keyList.length; i++) {
    var key = keyList[i];
    if (progDataObj[key] == undefined) {
      return false;
    }
  }
  return true;
}

function getVoidPosDataModel() {
  var obj = JSON.parse(JSON.stringify(defaltVoidPosDataModel));
  return obj;
}

function serchPltResource(obj, val) {
  var result = val;
  var keys = Object.keys(obj);

  if (getCurrentLanguage() == "ch") {
    var chKey = Object.keys(chLib)
    for (var i = 0; i < chKey.length; i++) {
      if (chLib[chKey[i]] === String(val)) {
        result = chKey[i];
      }
    }
  }

  if (getCurrentLanguage() == "jp") {
    var hennkann = jpObjKana[val];
    if (hennkann != undefined) {
      val = hennkann;
    }
  }

  for (var i = 0; i < keys.length; i++) {
    if (obj[keys[i]] === String(val)) {
      result = keys[i];
    }
  }
  return result;
}

function getAllPltApplString(lang) {
  var outputString = "";//"/APPL\n";
  var title_str = { jp: "ﾊﾟﾚﾀｲｼﾞﾝｸﾞ", eg: "Palletizing", ch: "Palletizing", gr: "Palletizing", fr: "Palletizing", it: "Palletizing", tw: "Palletizing" };
  for (key in palletizing) {

    var outputObj = getGlobalPltObj(key);
    // Palletizing[*];
    outputString += title_str[lang] + "[" + key + "];\n";
    // CONFIG
    outputString += createConfString(outputObj, lang);
    // BOTTOM
    outputString += createBottomString(outputObj, lang);
    // PATTERN
    if (/X$/.test(outputObj.category)) {
      outputString += createPatternString(outputObj, lang);
    }
    // ROUTE
    outputString += crateRouteString(outputObj, lang);
  }
  return outputString;
}

function getTempAllPltApplString(lang, mod_obj) {
  var outputString = "";//"/APPL\n";
  var title_str = { jp: "ﾊﾟﾚﾀｲｼﾞﾝｸﾞ", eg: "Palletizing", ch: "Palletizing", gr: "Palletizing", fr: "Palletizing", it: "Palletizing", tw: "Palletizing" };
  var tempPltObj = JSON.parse(JSON.stringify(palletizing));
  tempPltObj[String(mod_obj.palletizing_num)] = mod_obj;
  for (key in tempPltObj) {

    var outputObj = tempPltObj[key];
    // Palletizing[*];
    outputString += title_str[lang] + "[" + key + "];\n";
    // CONFIG
    outputString += createConfString(outputObj, lang);
    // BOTTOM
    outputString += createBottomString(outputObj, lang);
    // PATTERN
    if (/X$/.test(outputObj.category)) {
      outputString += createPatternString(outputObj, lang);
    }
    // ROUTE
    outputString += crateRouteString(outputObj, lang);
  }
  return outputString;
}

function getThisPltObjStr(pltObj, lang) {
  var outputString = "";//"/APPL\n";
  var modObj = JSON.parse(JSON.stringify(pltObj));
  var title_str = { jp: "ﾊﾟﾚﾀｲｼﾞﾝｸﾞ", eg: "Palletizing", ch: "Palletizing", gr: "Palletizing", fr: "Palletizing", it: "Palletizing", tw: "Palletizing" };
  for (key in palletizing) {
    if (String(modObj.palletizing_num) != key) {
      var outputObj = getGlobalPltObj(key);
      // Palletizing[*];
      outputString += title_str[lang] + "[" + key + "];\n";
      // CONFIG
      outputString += createConfString(outputObj, lang);
      // BOTTOM
      outputString += createBottomString(outputObj, lang);
      // PATTERN
      if (/X$/.test(outputObj.category)) {
        outputString += createPatternString(outputObj, lang);
      }
      // ROUTE
      outputString += crateRouteString(outputObj, lang);
    } else {
      // Palletizing[*];
      outputString += title_str[lang] + "[" + key + "];\n";
      // CONFIG
      outputString += createConfString(modObj, lang);
      // BOTTOM
      outputString += createBottomString(modObj, lang);
      // PATTERN
      if (/X$/.test(outputObj.category)) {
        outputString += createPatternString(outputObj, lang);
      }
      // ROUTE
      outputString += crateRouteString(modObj, lang);
    }
  }

  return outputString;
}

function createConfString(outputObj, lang) {
  var confString = "";
  var configString = { jp: "ｼｮｷﾃﾞｰﾀ", eg: "CONFIG", ch: "CONFIG", gr: "CONFIG", fr: "CONFIG", it: "CONFIG", tw: "CONFIG" };
  var type_str = { jp: "ｼｭﾙｲ", eg: "TYPE", ch: "TYPE", gr: "TYPE", fr: "TYPE", it: "TYPE", tw: "TYPE" };
  var incr_str = { jp: "ｿﾞｳｶ", eg: "INCR", ch: "INCR", gr: "INCR", fr: "INCR", it: "INCR", tw: "INCR" };
  var palReg_str = { jp: "ﾊﾟﾚｯﾄ ﾚｼﾞｽﾀ", eg: "PAL REG", ch: "PAL REG", gr: "PAL REG", fr: "PAL REG", it: "PAL REG", tw: "PAL REG" };
  var order_str = { jp: "ｼﾞｭﾝｼﾞｮ", eg: "ORDER", ch: "ORDER", gr: "ORDER", fr: "ORDER", it: "ORDER", tw: "ORDER" };
  var row_str = { jp: "ｷﾞｮｳ", eg: "ROWS", ch: "ROWS", gr: "ROWS", fr: "ROWS", it: "ROWS", tw: "ROWS" };
  var col_str = { jp: "ﾚﾂ", eg: "COLUMNS", ch: "COLUMNS", gr: "COLUMNS", fr: "COLUMNS", it: "COLUMNS", tw: "COLUMNS" };
  var lay_str = { jp: "ﾀﾞﾝ", eg: "LAYERS", ch: "LAYERS", gr: "LAYERS", fr: "LAYERS", it: "LAYERS", tw: "LAYERS" };
  var aux_str = { jp: "ﾎｼﾞｮﾃﾝ", eg: "AUXILIARY POS", ch: "AUXILIARY POS", gr: "AUXILIARY POS", fr: "AUXILIARY POS", it: "AUXILIARY POS", tw: "AUXILIARY POS" };
  var appr_str = { jp: "ｾｯｷﾝﾃﾝ", eg: "APPR", ch: "APPR", gr: "APPR", fr: "APPR", it: "APPR", tw: "APPR" };
  var rtrt_str = { jp: "ﾆｹﾞﾃﾝ", eg: "RTRT", ch: "RTRT", gr: "RTRT", fr: "RTRT", it: "RTRT", tw: "RTRT" };
  var pattern_str = { jp: "ﾊﾟﾀｰﾝ ", eg: "PATTERN", ch: "PATTERN", gr: "PATTERN", fr: "PATTERN", it: "PATTERN", tw: "PATTERN" };
  var confObj = outputObj.config;
  // 	CONFIG:
  confString += configString[lang] + ":\n";
  // PALLETIZING-B_1 "" ;
  if (lang == "jp") {
    confString += resources["palletStr"] + " " + outputObj.category + "_" + outputObj.palletizing_num + " " + '"' + confObj.name + '" ;\n';
  } else {
    confString += resources["palletStr"] + "-" + outputObj.category + "_" + outputObj.palletizing_num + " " + '"' + confObj.name + '" ;\n';
  }
  // TYPE = 	PALLET   ;
  if (lang == "jp") {
    confString += type_str[lang] + " = \t" + jpKanji2Kana[resources[confObj.type]] + "   ;\n";
  } else {
    confString += type_str[lang] + " = \t" + chLib[confObj.type] + " ;\n";
  }
  // 		INCR = 	1 ;
  confString += incr_str[lang] + " = \t" + confObj.incr + " ;\n";
  //		PAL REG   = 	1 ;
  confString += palReg_str[lang] + " = \t" + confObj.pal_reg + " ;\n";
  //		ORDER  = 	RCL ;
  if (lang == "jp") {
    confString += order_str[lang] + " = \t" + jpKanji2Kana[resources[confObj.order]] + " ;\n";
  } else {
    confString += order_str[lang] + " = \t" + resources[confObj.order] + " ;\n";
  }
  //		ROWS    = 	[1] ;
  confString += row_str[lang] + " = \t" + convArrayString(confObj.rows, lang) + " ;\n";
  //		COLUMNS = 	[1] ;
  confString += col_str[lang] + " = \t" + convArrayString(confObj.columns, lang) + " ;\n";
  //		LAYERS  = 	[1] ;
  confString += lay_str[lang] + " = \t" + convArrayString(confObj.layers, lang) + " ;\n";
  //		AUXILIARY POS = [NO ] ;
  confString += aux_str[lang] + " = " + convArrayString(confObj.aux_pos, lang) + " ;\n";
  //		APPR = 1 ;
  confString += appr_str[lang] + " = " + JSON.stringify(confObj.appr) + " ;\n";
  //		RTRT = 1 ;
  confString += rtrt_str[lang] + " = " + JSON.stringify(confObj.rtrt) + " ;\n";
  //		PATTERN= 1 ; for BX/EX
  if (/X$/.test(outputObj.category)) {
    confString += pattern_str[lang] + "= " + JSON.stringify(confObj.pattern) + " ;\n";
  }

  return confString;
}

function createBottomString(outputObj, lang) {
  var bottom_str = { jp: "ﾂﾐﾃﾝ", eg: "BOTTOM", ch: "BOTTOM", gr: "BOTTOM", fr: "BOTTOM", it: "BOTTOM", tw: "BOTTOM" };
  var bottomArray = outputObj.bottom;
  var bottomString = "";
  bottomString += bottom_str[lang] + ":\n";
  bottomString += createPosdataString(bottomArray, lang);

  return bottomString;
}

function createPosdataString(posDataArray, lang) {
  var posdata_str = "";
  var config_str = { jp: "ｹｲﾀｲ", eg: "CONFIG", ch: "CONFIG", gr: "CONFIG", fr: "CONFIG", it: "CONFIG", tw: "CONFIG" };

  for (var i = 0; i < posDataArray.length; i++) {
    var posObj = posDataArray[i];
    var Posdata = posObj.posData[0];
    // 		P [1,1,1]{
    posdata_str += posObj.posNumber + "{\n";
    //		     GP1:
    posdata_str += "     GP" + Posdata.groupNumber + ":\n";
    // UF
    var uf_val = (Posdata.ufVal === "") ? "F" : Posdata.ufVal;
    posdata_str += " UF : " + uf_val + ", ";
    // UT
    var ut_val = (Posdata.utVal === "") ? "F" : Posdata.utVal;
    posdata_str += "UT : " + ut_val + ",    ";
    // CONFIG
    var conf_val = (Posdata.configStr === "") ? getPosConf() : Posdata.configStr;
    posdata_str += config_str[lang] + " : '" + conf_val + "',\n";
    // X
    var xpos = '';
    if (Posdata.poskey.X === "") {
      xpos = "********";
    } else {
      if (isNaN(Posdata.poskey.X)) {
        xpos = Posdata.poskey.X;
      } else {
        xpos = Number(Posdata.poskey.X).toFixed(3);
      }
    }
    posdata_str += " X = " + xpos + "  mm,  ";
    // Y
    var ypos = '';
    if (Posdata.poskey.Y === "") {
      ypos = "********";
    } else {
      if (isNaN(Posdata.poskey.Y)) {
        ypos = Posdata.poskey.Y;
      } else {
        ypos = Number(Posdata.poskey.Y).toFixed(3);
      }
    }
    posdata_str += "Y = " + ypos + "  mm,  ";
    // Z
    var zpos = '';
    if (Posdata.poskey.Z === "") {
      zpos = "********";
    } else {
      if (isNaN(Posdata.poskey.Z)) {
        zpos = Posdata.poskey.Z;
      } else {
        zpos = Number(Posdata.poskey.Z).toFixed(3);
      }
    }
    posdata_str += "Z = " + zpos + "  mm,\n";
    // W
    var wang = '';
    if (Posdata.poskey.W === "") {
      wang = "********";
    } else {
      if (isNaN(Posdata.poskey.W)) {
        wang = Posdata.poskey.W;
      } else {
        wang = Number(Posdata.poskey.W).toFixed(3);
      }
    }
    posdata_str += " W = " + wang + " deg,  ";
    // P
    var pang = '';
    if (Posdata.poskey.P === "") {
      pang = "********";
    } else {
      if (isNaN(Posdata.poskey.P)) {
        pang = Posdata.poskey.P;
      } else {
        pang = Number(Posdata.poskey.P).toFixed(3);
      }
    }
    posdata_str += "P = " + pang + " deg,  ";
    // R
    var rang = '';
    if (Posdata.poskey.R === "") {
      rang = "********";
    } else {
      if (isNaN(Posdata.poskey.R)) {
        rang = Posdata.poskey.R;
      } else {
        rang = Number(Posdata.poskey.R).toFixed(3);
      }
    }
    posdata_str += "R = " + rang + " deg\n";
    // };
    posdata_str += "};\n";
  }
  return posdata_str;
}

function crateRouteString(outputObj, lang) {
  var route_str = { jp: "ｹｲﾛﾊﾟﾀｰﾝ", eg: "ROUTE", ch: "ROUTE", gr: "ROUTE", fr: "ROUTE", it: "ROUTE", tw: "ROUTE" };
  var routString = "";
  var routeArray = [];
  var routeObj = outputObj.route.pattern;

  //	ROUTE:
  routString += route_str[lang] + ":\n";

  // posdata
  if (/^[B|E]$/.test(outputObj.category)) {
    routeArray = routeObj["1"];
    routString += createPosdataString(routeArray, lang);
  } else {// BX/EX
    for (var j = 1; j <= 16; j++) {
      routeArray = routeObj[String(j)];
      if (routeArray != undefined) {
        routString += route_str[lang] + "[" + j + "]{\n";
        routString += createPosdataString(routeArray, lang);
        routString += "};\n";
      }
    }
  }

  return routString;
}

function createPatternString(outputObj, lang) {
  var patStr = { "jp": "ｹｲﾛｼﾞｮｳｹﾝ", "eg": "PATTERN", "ch": "PATTERN", "gr": "PATTERN", "fr": "PATTERN", "it": "PATTERN", "tw": "PATTERN" };
  var patItemStr = { "jp": "ﾊﾟﾀｰﾝ", "eg": "PTN ", "ch": "PTN ", "gr": "PTN ", "fr": "PTN ", "it": "PTN", "tw": "PTN" };
  var patternArry = outputObj.pattern;
  var returnStr = "";

  //	PATTERN:
  returnStr = patStr[lang] + ":\n";
  //PTN [1] = [1, *, *] ;
  for (var i = 0; i < patternArry.length; i++) {
    returnStr += patItemStr[lang] + "[" + (i + 1) + "] = " + JSON.stringify(patternArry[i]).replace(/"/g, "") + ";\n";
  }

  return returnStr;
}

function convArrayString(array, lang) {
  var str = "[";
  for (var i = 0; i < array.length; i++) {
    if (isNaN(Number(array[i]))) {
      if (lang == "jp") {
        var lbl = jpKanji2Kana.hasOwnProperty(resources[array[i]]) ? jpKanji2Kana[resources[array[i]]] : resources[array[i]];
        str += lbl + ", ";
      } else {
        str += chLib[array[i]] + ", ";
      }
    } else {
      str += array[i] + ", ";
    }
  }
  var coma = str.lastIndexOf(",");
  str = str.slice(0, coma);
  str += " ]"
  return str;
}

function getCreateCmdStr(pltObj, lang) {
  var prg_array = pltObj.route.prog;
  var pos_array = pltObj.route.pattern["1"];
  var pos_str = { jp: "ｲﾁ_", eg: "PAL_", ch: "PAL_", gr: "PAL_", fr: "PAL_", it: "PAL_", tw: "PAL_" };

  var pal_num = pos_str[lang] + pltObj.palletizing_num;
  var cmd_str = "";

  if (lang == "jp") {
    cmd_str += resources["palletStr"] + " " + pltObj.category + "_" + pltObj.palletizing_num + "\n";
  } else {
    cmd_str += resources["palletStr"] + "-" + pltObj.category + "_" + pltObj.palletizing_num + "\n";
  }
  for (var i = 0; i < prg_array.length; i++) {
    var prg_obj = prg_array[i];
    var pos_kkako = pos_array[i].posNumber.match(/\[.+\]/);
    var kindstr = resources[prg_obj.kind] == "CNT" ? resources[prg_obj.kind] + prg_obj.kind_num : resources[prg_obj.kind];
    cmd_str += resources[prg_obj.motion] + " " + pal_num + pos_kkako[0] + " " + prg_obj.speed + prg_obj.unit + " " + kindstr + "\n";
  }
  cmd_str += resources["palletEndStr"] + pltObj.palletizing_num;

  return cmd_str;
}

function comparePltProg(plt_obj) {
  var editProg = plt_obj.route.prog;
  var originProg = getGlobalPltObj(plt_obj.palletizing_num).route.prog;
  var editFlg = [];
  var returnObj = { edit: false, allReplace: false, editLines: [] };

  if (editProg.length != originProg.length) {
    returnObj.allReplace = true;
    returnObj.edit = true;
    return returnObj; //ALL replace
  }

  for (var i = 0; i < originProg.length; i++) {
    var compA = originProg[i];
    var compB = editProg[i];
    for (key in compA) {
      if (compA[key] != compB[key]) {
        editFlg[i] = true;
        returnObj.edit = true;
        break;
      } else {
        editFlg[i] = false;
      }
    }
  }
  returnObj.editLines = editFlg;
  return returnObj; // diff line replace
}

// Return true on error
function checkBottomPosData(btmObj) {
  for (index in btmObj){
    var btm = btmObj[index];
    if (confPosdata(btm.posData[0])) {
      return true; // return error
    }
  }
  return false; // return not error
}

// Return true on error
function checkRoutePosData(routeObj) {
  var patObj = routeObj.pattern;
  for (index in patObj) {
    var pattern = patObj[index];
    for (i in pattern){
      var target = pattern[i];
      if (confPosdata(target.posData[0])) {
        return true; // return error
      }
    }
  }
  return false; // return not error
}

// confirm position data
function confPosdata(posdata) {// Return true on error
  // posdata error flg
  for (index in posdata) {
    var data = posdata[index];
    if (index === "poskey") {
      for (i in data){
        if (data[i] === "") {
          return true; // return error
        }
      }
    }
    if (data === "") {
      return true; // return error
    }
  }
  return false; // return not error
}                                                                                                                                                                                                                                                         /**********************************************************************
 * PC Editor script
 * for Palletizing dialog.
 * Created: 2019/4/18	Copied from pceditor_dialog
 *
 */

/*
 * Palletizing Dialog Main Process.
 */
function pltDialogMainProcess(plt_categoly) {
  // check and delete editor text palletizing number
  checkAllPltNum();
  // for test
  plt_categoly = plt_categoly.replace("PLT", "");
  //

  var pltObj = getNewPltObj(plt_categoly);
  if (!pltObj) {
    defineDialog.open(null, '#pltmaxvalerr', 'dlgMsgPltNumErr');
    return "err";
  }
  var result = pltDialog.open(PLTDLGMODE_INSERT);
  if (result) {
    pltDialog.process('initData', pltObj);
  }
  return result;
}

// Palletizing config Modified process
function pltDialogModifiedProcess(plt_num) {
  try {
    var pltObj = getGlobalPltObj(plt_num);
    var result = pltDialog.open(PLTDLGMODE_MODIFY);
    // check and delete editor text palletizing number
    checkAllPltNum();
    if (result) {
      pltDialog.process('initData', pltObj);
    }
    return result;
  } catch (e) {
    console.log("The specified palletizing object was not found.");
  }
}

/*
 * Configuration of Palletizing Main Frame Dialog.
 */
function configPalletMainDialog() {
  // Make dialog frame
  var $dlgFrame = $('<div>', { 'id': 'pltmainfrmdlg', 'class': 'pltmaindlg' });
  // Dialog title header
  var $dlgTitle = $('<div>', { 'id': 'pltdlgtitle', 'class': 'dlgtitlebar' });
  var $dlgTitleText = $('<span>', { 'id': 'pltdlgttltxt' });
  // Title header string
  $dlgTitleText.html(resources['pltdlgmainttl']);
  $dlgTitle.append($dlgTitleText);
  $dlgFrame.append($dlgTitle);

  // Make contents area
  var $dlgTblFlm = $('<div>', { 'id': 'pltdlgcontent', 'class': 'dlgtblflm' });
  $dlgTblFlm.css('width', '93%');
  var $pltDlgTbl = $('<div>', { 'id': 'pltdlgtable', 'class': 'pltdlgtbl' });
  $dlgTblFlm.append($pltDlgTbl);
  $dlgFrame.append($dlgTblFlm);

  // Make button area
  var $dlgBtnArea = $('<div>', { 'id': 'pltdlgbtnarea', 'class': 'pltbtnarea', 'align': 'center' });
  $dlgBtnArea.css({ 'clear': 'both' });
  // 'Back(Prev)' button (None on the initial data screen)
  var $blgBtnDiv = $('<div>', { 'id': 'pltprevframe', 'class': 'pltprevframe' });
  var $blgBtnPrev = $('<button>', { 'id': 'pltdlgbtnprev', 'class': 'pltdlgbutton pltbtnprev' });
  $blgBtnPrev.html(resources['dlgBtnPrev']);
  $blgBtnDiv.append($blgBtnPrev);
  $dlgBtnArea.append($blgBtnDiv);
  // Cancel button
  $blgBtnDiv = $('<div>', { 'id': 'pltcancelframe', 'class': 'pltcancelframe' });
  var $blgBtnCancel = $('<button>', { 'id': 'pltdlgbtncancel', 'class': 'pltdlgbutton pltbtncancel' });
  $blgBtnCancel.html(resources['dlgBtnCancel']);
  $blgBtnDiv.append($blgBtnCancel);
  $dlgBtnArea.append($blgBtnDiv);
  // Next button (or Finish button)
  $blgBtnDiv = $('<div>', { 'id': 'pltnextframe', 'class': 'pltnextframe' });
  var $blgBtnNext = $('<button>', { 'id': 'pltdlgbtnnext', 'class': 'pltdlgbutton pltbtnnext' });
  $blgBtnNext.html(resources['dlgBtnNext']);
  $blgBtnDiv.append($blgBtnNext);
  $dlgBtnArea.append($blgBtnDiv);
  // Append to dialog main frame
  $dlgFrame.append($dlgBtnArea);
  $('body').append($dlgFrame);
}

/*
 * Initialize Content Area of Dialog
 */
function initContentArea(subTitleId) {
  // Change title
  $('#pltdlgttltxt').html(resources['pltdlgmainttl'] + resources[subTitleId]);
  // pick content area element
  var $pltDlgTbl = $('#pltdlgtable');
  // initialize element
  $pltDlgTbl.empty();
  var $cutDlgBtn = $('#pltdlgbtnarea').remove();
  return $cutDlgBtn;
}
/*
 * Finalize Content Area of Dialog
 */
function finalContentArea(appendObj, dlgBtnObj) {
  var $dlgTblFlm = $('#pltdlgcontent');
  $dlgTblFlm.append(appendObj);
  var $dlgFrame = $('#pltmainfrmdlg');
  $dlgFrame.append($dlgTblFlm);
  $dlgFrame.append(dlgBtnObj);
}

/*
 *  Configuration of Palletizing Initial Data Dialog.
 */
function configPalletInitData(pltObj) {
  var $cutDlgBtn = initContentArea('pltdlgttlinit');
  var $pltDlgTbl = $('#pltdlgtable');

  // Row 1
  var $pltTblRow = $('<div>', { 'class': 'plttblrow' });
  // Palletizing name
  $pltTblRow.html(resources['pltname'] + pltObj.palletizing_num);
  var $pltNumIpt = $('<input>', { 'id': 'pltNumIpt', 'class': 'pltnum' });
  $pltNumIpt.val(pltObj.config.name);
  $pltTblRow.append($pltNumIpt);
  $pltDlgTbl.append($pltTblRow);

  // Row 2 - Col 1
  $pltTblRow = $('<div>', { 'class': 'plttblrow' });
  var $pltTblCol = $('<div>', { 'class': 'plttblcol' });
  // Kind
  $pltTblCol.html(resources['plttype']);
  $pltTblRow.append($pltTblCol);

  // Row 2 - Col 2
  $pltTblCol = $('<div>', { 'class': 'plttblcol' });
  var $typeSelBox = $('<div>', { 'id': 'typeSelBox', 'class': 'pltselbox', 'tabindex': '1' });
  var $typeSelText = $('<span>');
  $typeSelText.html(resources[pltObj.config.type]);
  $typeSelBox.append($typeSelText);

  var $typeSelBtn = $('<div>', { 'id': 'typeSelBtn', 'class': 'dlgselbtn' });
  var $typeSelImg = $('<img>', { 'id': 'typeSelImg', 'class': 'dlgselimg', 'src': 'images/select_icon.png' });
  $typeSelBtn.append($typeSelImg);
  $typeSelBox.append($typeSelBtn);
  $pltTblCol.append($typeSelBox);
  $pltTblRow.append($pltTblCol);

  // Row 2 - Col 3
  $pltTblCol = $('<div>', { 'class': 'plttblcol' });
  $pltTblRow.append($pltTblCol);

  // Row 2 - Col 4
  $pltTblCol = $('<div>', { 'class': 'plttblcol' });
  // Incr
  $pltTblCol.html(resources['pltinc']);
  $pltTblRow.append($pltTblCol);

  // Row 2 - Col 5
  $pltTblCol = $('<div>', { 'class': 'plttblcol' });
  var $pltIncIpt = $('<input>', { 'id': 'pltIncIpt', 'class': 'pltinput', 'maxlength': '3' });
  $pltIncIpt.val(pltObj.config.incr);
  $pltTblCol.append($pltIncIpt);
  $pltTblRow.append($pltTblCol);

  // Row 2 combine
  $pltDlgTbl.append($pltTblRow);

  // R 3 - C 1
  $pltTblRow = $('<div>', { 'class': 'plttblrow' });
  $pltTblCol = $('<div>', { 'class': 'plttblcol' });
  // Pallet register
  $pltTblCol.html(resources['pltprg']);
  $pltTblRow.append($pltTblCol);

  // R 3 - C 2
  $pltTblCol = $('<div>', { 'class': 'plttblcol' });
  var $pltPrgIpt = $('<input>', { 'id': 'pltPrgIpt', 'class': 'pltinput', 'maxlength': '3' });
  $pltPrgIpt.val(pltObj.config.pal_reg);
  $pltTblCol.append($pltPrgIpt);
  $pltTblRow.append($pltTblCol);

  // R 3 - C 3
  $pltTblCol = $('<div>', { 'class': 'plttblcol' });
  $pltTblRow.append($pltTblCol);

  // R 3 - C 4
  $pltTblCol = $('<div>', { 'class': 'plttblcol' });
  // Order
  $pltTblCol.html(resources['pltorder']);
  $pltTblRow.append($pltTblCol);

  // R 3 - C 5
  $pltTblCol = $('<div>', { 'class': 'plttblcol' });
  var $ordSelBox = $('<div>', { 'id': 'ordSelBox', 'class': 'pltselbox', 'tabindex': '1' });
  var $ordSelText = $('<span>');
  $ordSelText.html(resources[pltObj.config.order]);
  $ordSelBox.append($ordSelText);

  var $ordSelBtn = $('<div>', { 'id': 'ordSelBtn', 'class': 'dlgselbtn' });
  var $ordSelImg = $('<img>', { 'id': 'ordSelImg', 'class': 'dlgselimg', 'src': 'images/select_icon.png' });
  $ordSelBtn.append($ordSelImg);
  $ordSelBox.append($ordSelBtn);
  $pltTblCol.append($ordSelBox);
  $pltTblRow.append($pltTblCol);

  // R 3 combine
  $pltDlgTbl.append($pltTblRow);

  // R 4
  $pltTblRow = $('<div>', { 'class': 'plttblrow' });
  $pltTblCol = $('<div>', { 'class': 'plttblcol' });
  $pltTblRow.append($pltTblCol);
  $pltDlgTbl.append($pltTblRow);

  // R 4 combine
  $pltDlgTbl.append($pltTblRow);

  // R 5 - C 1
  $pltTblRow = $('<div>', { 'class': 'plttblrow' });
  $pltTblCol = $('<div>', { 'class': 'plttblcol' });
  // Line
  $pltTblCol.html(resources['pltrow']);
  $pltTblRow.append($pltTblCol);

  // R 5 - C 2
  $pltTblCol = $('<div>', { 'class': 'plttblcol' });
  var $pltRowIpt = $('<input>', { 'id': 'pltRowIpt', 'class': 'pltinput', 'maxlength': '3' });
  $pltRowIpt.val(pltObj.config.rows[0]);
  $pltTblCol.append($pltRowIpt);
  $pltTblRow.append($pltTblCol);

  if ((pltObj.category == 'E') || (pltObj.category == 'EX')) {
    // R 5 - C 3
    $pltTblCol = $('<div>', { 'class': 'plttblcol' });
    var $rowFstSelBox = $('<div>', { 'id': 'rowFstSelBox', 'class': 'pltselbox', 'tabindex': '1' });
    var $rowFstSelTextBox = $('<input>', { 'id': 'rowFstCombBox', 'class': 'pltcombbox', 'maxlength': '4' });
    var rowTxt = "";
    if (pltObj.config.rows[1] in resources) {
      rowTxt = resources[pltObj.config.rows[1]];
    } else {
      rowTxt = pltObj.config.rows[1];
    }
    $rowFstSelTextBox.val(rowTxt);
    $rowFstSelBox.append($rowFstSelTextBox);

    var $rowFstSelBtn = $('<div>', { 'id': 'rowFstSelBtn', 'class': 'dlgselbtn' });
    var $rowFstSelImg = $('<img>', { 'id': 'rowFstSelImg', 'class': 'dlgselimg', 'src': 'images/select_icon.png' });
    $rowFstSelBtn.append($rowFstSelImg);
    $rowFstSelBox.append($rowFstSelBtn);
    $pltTblCol.append($rowFstSelBox);
    $pltTblRow.append($pltTblCol);

    // R 5 - C 4
    $pltTblCol = $('<div>', { 'class': 'plttblcol' });
    var $rowSndSelBox = $('<div>', { 'id': 'rowSndSelBox', 'class': 'pltselbox', 'tabindex': '1' });
    var $rowSndSelText = $('<span>');
    $rowSndSelText.html(resources[pltObj.config.rows[2]]);
    $rowSndSelBox.append($rowSndSelText);

    var $rowSndSelBtn = $('<div>', { 'id': 'rowSndSelBtn', 'class': 'dlgselbtn' });
    var $rowSndSelImg = $('<img>', { 'id': 'rowSndSelImg', 'class': 'dlgselimg', 'src': 'images/select_icon.png' });
    $rowSndSelBtn.append($rowSndSelImg);
    $rowSndSelBox.append($rowSndSelBtn);
    $pltTblCol.append($rowSndSelBox);
    $pltTblRow.append($pltTblCol);
  }

  // R 5 combine
  $pltDlgTbl.append($pltTblRow);

  // R 6 - C 1
  $pltTblRow = $('<div>', { 'class': 'plttblrow' });
  $pltTblCol = $('<div>', { 'class': 'plttblcol' });
  // Column
  $pltTblCol.html(resources['pltcol']);
  $pltTblRow.append($pltTblCol);

  // R 6 - C 2
  $pltTblCol = $('<div>', { 'class': 'plttblcol' });
  var $pltColIpt = $('<input>', { 'id': 'pltColIpt', 'class': 'pltinput', 'maxlength': '3' });
  $pltColIpt.val(pltObj.config.columns[0]);
  $pltTblCol.append($pltColIpt);
  $pltTblRow.append($pltTblCol);

  if ((pltObj.category == 'E') || (pltObj.category == 'EX')) {
    // R 6 - C 3
    $pltTblCol = $('<div>', { 'class': 'plttblcol' });
    var $colFstSelBox = $('<div>', { 'id': 'colFstSelBox', 'class': 'pltselbox', 'tabindex': '1' });
    var $colFstSelTextBox = $('<input>', { 'id': 'colFstCombBox', 'class': 'pltcombbox', 'maxlength': '4' });
    var clumnTxt = "";
    if (pltObj.config.columns[1] in resources) {
      clumnTxt = resources[pltObj.config.columns[1]];
    } else {
      clumnTxt = pltObj.config.columns[1];
    }
    $colFstSelTextBox.val(clumnTxt);
    $colFstSelBox.append($colFstSelTextBox);

    var $colFstSelBtn = $('<div>', { 'id': 'colFstSelBtn', 'class': 'dlgselbtn' });
    var $colFstSelImg = $('<img>', { 'id': 'colFstSelImg', 'class': 'dlgselimg', 'src': 'images/select_icon.png' });
    $colFstSelBtn.append($colFstSelImg);
    $colFstSelBox.append($colFstSelBtn);
    $pltTblCol.append($colFstSelBox);
    $pltTblRow.append($pltTblCol);

    // R 6 - C 4
    $pltTblCol = $('<div>', { 'class': 'plttblcol' });
    var $colSndSelBox = $('<div>', { 'id': 'colSndSelBox', 'class': 'pltselbox', 'tabindex': '1' });
    var $colSndSelText = $('<span>');
    $colSndSelText.html(resources[pltObj.config.columns[2]]);
    $colSndSelBox.append($colSndSelText);

    var $colSndSelBtn = $('<div>', { 'id': 'colSndSelBtn', 'class': 'dlgselbtn' });
    var $colSndSelImg = $('<img>', { 'id': 'colSndSelImg', 'class': 'dlgselimg', 'src': 'images/select_icon.png' });
    $colSndSelBtn.append($colSndSelImg);
    $colSndSelBox.append($colSndSelBtn);
    $pltTblCol.append($colSndSelBox);
    $pltTblRow.append($pltTblCol);
  }

  // R 6 combine
  $pltDlgTbl.append($pltTblRow);

  // R 7 - C 1
  $pltTblRow = $('<div>', { 'class': 'plttblrow' });
  $pltTblCol = $('<div>', { 'class': 'plttblcol' });
  // Layer
  $pltTblCol.html(resources['pltlay']);
  $pltTblRow.append($pltTblCol);

  // R 7 - C 2
  $pltTblCol = $('<div>', { 'class': 'plttblcol' });
  var $pltLayIpt = $('<input>', { 'id': 'pltLayIpt', 'class': 'pltinput', 'maxlength': '3' });
  $pltLayIpt.val(pltObj.config.layers[0]);
  $pltTblCol.append($pltLayIpt);
  $pltTblRow.append($pltTblCol);

  if ((pltObj.category == 'E') || (pltObj.category == 'EX')) {
    // R 7 - C 3
    $pltTblCol = $('<div>', { 'class': 'plttblcol' });
    var $layFstSelBox = $('<div>', { 'id': 'layFstSelBox', 'class': 'pltselbox', 'tabindex': '1' });
    var $layFstSelTextBox = $('<input>', { 'id': 'layFstCombBox', 'class': 'pltcombbox', 'maxlength': '4' });
    var layerTxt = "";
    if (pltObj.config.layers[1] in resources) {
      layerTxt = resources[pltObj.config.layers[1]];
    } else {
      layerTxt = pltObj.config.layers[1];
    }
    $layFstSelTextBox.val(layerTxt);
    $layFstSelBox.append($layFstSelTextBox);

    var $layFstSelBtn = $('<div>', { 'id': 'layFstSelBtn', 'class': 'dlgselbtn' });
    var $layFstSelImg = $('<img>', { 'id': 'layFstSelImg', 'class': 'dlgselimg', 'src': 'images/select_icon.png' });
    $layFstSelBtn.append($layFstSelImg);
    $layFstSelBox.append($layFstSelBtn);
    $pltTblCol.append($layFstSelBox);
    $pltTblRow.append($pltTblCol);

    // R 7 - C 4
    $pltTblCol = $('<div>', { 'class': 'plttblcol' });
    var $laySndSelBox = $('<div>', { 'id': 'laySndSelBox', 'class': 'pltselbox', 'tabindex': '1' });
    var $laySndSelText = $('<span>');
    $laySndSelText.html(resources[pltObj.config.layers[2]]);
    $laySndSelBox.append($laySndSelText);

    var $laySndSelBtn = $('<div>', { 'id': 'laySndSelBtn', 'class': 'dlgselbtn' });
    var $laySndSelImg = $('<img>', { 'id': 'laySndSelImg', 'class': 'dlgselimg', 'src': 'images/select_icon.png' });
    $laySndSelBtn.append($laySndSelImg);
    $laySndSelBox.append($laySndSelBtn);
    $pltTblCol.append($laySndSelBox);
    $pltTblRow.append($pltTblCol);

    // R7 - C 5
    $pltTblCol = $('<div>', { 'class': 'plttblcol' });
    var $pltLayIptSnd = $('<input>', { 'id': 'pltLayIptSnd', 'class': 'pltinput', 'maxlength': '2' });

    if (pltObj.config.layers[1] == 'pltmethodfree') {
      $pltLayIptSnd.attr('readonly');
      $pltLayIptSnd.val(1);
    } else {
      $pltLayIptSnd.val(pltObj.config.layers[3]);
    }

    $pltTblCol.append($pltLayIptSnd);
    $pltTblRow.append($pltTblCol);
  }

  // R 7combine
  $pltDlgTbl.append($pltTblRow);

  // R 8 - C 1
  $pltTblRow = $('<div>', { 'class': 'plttblrow' });
  $pltTblCol = $('<div>', { 'class': 'plttblcol' });
  // Aux position
  $pltTblCol.html(resources['pltaux']);
  $pltTblRow.append($pltTblCol);

  // R 8 -C 2
  $pltTblCol = $('<div>', { 'class': 'plttblcol' });
  var $auxSelBox = $('<div>', { 'id': 'auxSelBox', 'class': 'pltselbox', 'tabindex': '1' });
  var $auxSelText = $('<span>');
  $auxSelText.html(resources[pltObj.config.aux_pos[0]]);
  $auxSelBox.append($auxSelText);

  var $auxSelBtn = $('<div>', { 'id': 'auxSelBtn', 'class': 'dlgselbtn' });
  var $auxSelImg = $('<img>', { 'id': 'auxSelImg', 'class': 'dlgselimg', 'src': 'images/select_icon.png' });
  $auxSelBtn.append($auxSelImg);
  $auxSelBox.append($auxSelBtn);
  $pltTblCol.append($auxSelBox);
  $pltTblRow.append($pltTblCol);

  if ((pltObj.category == 'E') || (pltObj.category == 'EX')) {
    // R 8 - C 3
    $pltTblCol = $('<div>', { 'class': 'plttblcol' });
    $pltTblRow.append($pltTblCol);

    // R 8 - C 4
    $pltTblCol = $('<div>', { 'class': 'plttblcol' });
    var $auxSndSelBox = $('<div>', { 'id': 'auxSndSelBox', 'class': 'pltselbox', 'tabindex': '1' });
    var $auxSndSelText = $('<span>');
    $auxSndSelText.html(resources[pltObj.config.aux_pos[1]]);
    $auxSndSelBox.append($auxSndSelText);

    var $auxSndSelBtn = $('<div>', { 'id': 'auxSndSelBtn', 'class': 'dlgselbtn' });
    var $auxSndSelImg = $('<img>', { 'id': 'auxSndSelImg', 'class': 'dlgselimg', 'src': 'images/select_icon.png' });
    $auxSndSelBtn.append($auxSndSelImg);
    $auxSndSelBox.append($auxSndSelBtn);
    $pltTblCol.append($auxSndSelBox);
    $pltTblRow.append($pltTblCol);
  }

  // R 8 combine
  $pltDlgTbl.append($pltTblRow);

  // R 9 - C 1
  $pltTblRow = $('<div>', { 'class': 'plttblrow' });
  $pltTblCol = $('<div>', { 'class': 'plttblcol' });
  // approach
  $pltTblCol.html(resources['pltapp']);
  $pltTblRow.append($pltTblCol);

  // R 9 - C 2
  $pltTblCol = $('<div>', { 'class': 'plttblcol' });
  var $pltAppIpt = $('<input>', { 'id': 'pltAppIpt', 'class': 'pltinput', 'maxlength': '1' });
  $pltAppIpt.val(pltObj.config.appr);
  $pltTblCol.append($pltAppIpt);
  $pltTblRow.append($pltTblCol);

  // R 9 - C 3
  $pltTblCol = $('<div>', { 'class': 'plttblcol' });
  $pltTblRow.append($pltTblCol);

  // R 9 - C 4
  $pltTblCol = $('<div>', { 'class': 'plttblcol' });
  // retreat
  $pltTblCol.html(resources['pltrtrt']);
  $pltTblRow.append($pltTblCol);

  // R 9 - C 5
  $pltTblCol = $('<div>', { 'class': 'plttblcol' });
  var $pltPtnIpt = $('<input>', { 'id': 'pltPtnIpt', 'class': 'pltinput', 'maxlength': '1' });
  $pltPtnIpt.val(pltObj.config.rtrt);
  $pltTblCol.append($pltPtnIpt);
  $pltTblRow.append($pltTblCol);

  // R 9 combine
  $pltDlgTbl.append($pltTblRow);

  if ((pltObj.category == 'BX') || (pltObj.category == 'EX')) {
    // R 10 - C 1
    $pltTblRow = $('<div>', { 'class': 'plttblrow' });
    $pltTblCol = $('<div>', { 'class': 'plttblcol' });
    // pattern
    $pltTblCol.html(resources['pltptrn']);
    $pltTblRow.append($pltTblCol);

    // R 10 - C 2
    $pltTblCol = $('<div>', { 'class': 'plttblcol' });
    var $pltPtrnIpt = $('<input>', { 'id': 'pltPtrnIpt', 'class': 'pltinput', 'maxlength': '2' });
    $pltPtrnIpt.val(pltObj.config.pattern);
    $pltTblCol.append($pltPtrnIpt);
    $pltTblRow.append($pltTblCol);
  } else {
    // R 10
    $pltTblCol = $('<div>', { 'class': 'plttblcol' });
    $pltTblRow.append($pltTblCol);
  }

  // R 10 combine
  $pltDlgTbl.append($pltTblRow);

  // Append to parent frame
  finalContentArea($pltDlgTbl, $cutDlgBtn);
  // disable 'Prev' button
  $('#pltdlgbtnprev').removeClass('pltbtnprev');
  $('#pltdlgbtnprev').addClass('pltbtndisable');
}

/*
 *  Configuration of Palletizing Bottom Point Dialog.
 */
function configPalletBtmPoint(pltObj) {
  // pick content area element
  var $cutDlgBtn = initContentArea('pltdlgttlbtm');
  var $pltDlgTbl = $('#pltdlgtable');

  // Configuration code here
  var $pltBtmTUpBtn = $('<button>', { id: 'pltBtmTUpBtn', class: 'plttupbtn' });
  $pltBtmTUpBtn.html(resources['posTableTup']);
  var $pltBtmPos = $('<div>', { id: 'pltBtmPos', class: 'pltpos' });
  $pltDlgTbl.append($pltBtmTUpBtn);
  $pltDlgTbl.append($pltBtmPos);

  // Append to parent frame
  finalContentArea($pltDlgTbl, $cutDlgBtn);

  // enable 'Prev' button
  $('#pltdlgbtnprev').removeClass('pltbtndisable');
  $('#pltdlgbtnprev').addClass('pltbtnprev');
  $('#pltdlgbtnnext').html(resources['dlgBtnNext']);

  // Put the position data grid.
  putPltPosGrid('pltBtmPos', 'pltBtmTUpBtn', pltObj);

  // Enable the reset button, jog window, resize bar, and layout button.
  setPltPosOverlay();
}

/*
 *  Configuration of Palletizing Route Condition Dialog.
 */
function configPalletRouteCnd(pltObj) {
  var pltPtnArray = pltObj.pattern;

  // pick content area element
  var $cutDlgBtn = initContentArea('pltdlgttlcond');
  var $pltDlgTbl = $('#pltdlgtable');

  // Configuration code here
  $(".pltdlgtbl").css({
    "padding-top": "10px",
    "height": "480px"
  });
  var $ptnInptArea = $("<div>", { "id": "pltPtnArea" });

  for (var i = 1; i <= pltObj.config.pattern; i++) {
    var ptnArray = pltPtnArray[i - 1];
    var $ptnLine = $('<div>', { 'id': 'pltPtnLin' + i, "class": "pltRouteCond" }); // 行項目を作成

    var $ptnNum = $('<div>', { 'id': 'pltPtnLin' + i + '-1' });
    $ptnNum.css({ "display": "inline-block" });
    $ptnNum.html(resources["pltptn"] + "[" + i + "] = [&nbsp;");
    $ptnLine.append($ptnNum);

    var $ptnInput = $("<input>", { 'id': 'pltPtnIpt1', 'class': 'pltinput' });
    $ptnInput.val(ptnArray[0]);
    $ptnLine.append($ptnInput);

    var $ptncom = $("<div>");
    $ptncom.css({ "display": "inline-block" });
    $ptncom.html("&nbsp;,&nbsp;");
    $ptnLine.append($ptncom);

    var $ptnInput = $("<input>", { 'id': 'pltPtnIpt2', 'class': 'pltinput' });
    $ptnInput.val(ptnArray[1]);
    $ptnLine.append($ptnInput);

    var $ptncom = $("<div>");
    $ptncom.css({ "display": "inline-block" });
    $ptncom.html("&nbsp;,&nbsp;");
    $ptnLine.append($ptncom);

    var $ptnInput = $("<input>", { 'id': 'pltPtnIpt3', 'class': 'pltinput' });
    $ptnInput.val(ptnArray[2]);
    $ptnLine.append($ptnInput);

    var $ptnclose = $("<div>");
    $ptnclose.css({ "display": "inline-block" });
    $ptnclose.html("&nbsp;]");
    $ptnLine.append($ptnclose);

    $ptnInptArea.append($ptnLine);
  }

  $pltDlgTbl.append($ptnInptArea);

  // Append to parent frame
  finalContentArea($pltDlgTbl, $cutDlgBtn);
  // Change button face to NEXT
  $('#pltdlgbtnnext').html(resources['dlgBtnNext']);
}

function updatePltRoutePtnObj(routeObj) {
  var rows = $('.pltrouterow').length;

  for (var route_num = 1; route_num <= rows; route_num++) {
    var prog_obj = {};

    // Motion
    var motion_j = resources['pltmotionj'];
    var prog_motion = $('#motionselframe_' + route_num).find('span').text();
    prog_obj.motion = (prog_motion == motion_j) ? 'pltmotionj' : 'pltmotionl';

    // Speed
    var speed_val = $('#speedcombinput_' + route_num).val();
    var sel_reg = resources['pltslctreg'];
    if (speed_val == sel_reg) { // if select 'R[]'
      // add '[num]'
      var speed_reg_num = $('#speedregiinput_' + route_num).val();
      speed_val += '[' + speed_reg_num + ']';
    }
    prog_obj.speed = speed_val;
    prog_obj.unit = $('#speedselframe_' + route_num).find('span').text();

    // Termination type
    var kind_fine = resources['pltmotionfine'];
    var prog_kind = $('#pathselframe_' + route_num).find('span').text();

    if (prog_kind == kind_fine) {
      prog_obj.kind = 'pltmotionfine';
      prog_obj.kind_num = 0;
    } else {
      prog_obj.kind = 'pltmotioncnt';
      var cnt_val = $('#pathcombinput_' + route_num).val();
      if (cnt_val == sel_reg) { // id select 'R[]'
        // add '[num]'
        var cnt_reg_num = $('#pathregiinput_' + route_num).val();
        cnt_val += '[' + cnt_reg_num + ']';
      }
      prog_obj.kind_num = cnt_val;
    }

    routeObj.prog[route_num - 1] = $.extend({}, prog_obj);
  }
}

function blurPltSlctBox(event) {
  var $cur_target = $(event.currentTarget);

  if ($('#slcmenulist').length) {
    $cur_target.find('img').attr('src', 'images/select_icon.png');
    $('#slcmenulist').remove();
  }
}

function changePltSlctBox(event) {
  var MOTION_SELECT_LIST = [resources['pltmotionj'], resources['pltmotionl']];
  var REG_SELECT_LIST = ['', resources['pltslctregbracket']];
  var J_SELECT_LIST = ['%', 'sec', 'msec'];
  var L_SELECT_LIST = ['mm/sec', 'cm/min', 'inch/min', 'deg/sec', 'sec', 'msec'];
  var PATH_SELECT_LIST = [resources['pltmotionfine'], resources['pltmotioncnt']];
  var $event_target = $(event.target);
  var $cur_target = $(event.currentTarget);
  var slct_type = $cur_target.attr('id').replace(/\_\d+$/, '');
  var route_num = $cur_target.attr('id').replace(slct_type + '_', '');
  var slct_list;
  var custom_class;
  var comb_input_type;

  switch (slct_type) {
    case 'motionselframe':
      slct_list = MOTION_SELECT_LIST;
      custom_class = 'motion';
      break;
    case 'speedcombframe':
      slct_list = REG_SELECT_LIST;
      custom_class = 'combo';
      comb_input_type = 'speedcombinput';
      break;
    case 'speedselframe':
      if ($('#motionselframe_' + route_num).find('span').text() == resources['pltmotionj']) {
        slct_list = J_SELECT_LIST;
      } else {
        slct_list = L_SELECT_LIST;
      }
      custom_class = 'speed';
      break;
    case 'pathselframe':
      slct_list = PATH_SELECT_LIST;
      custom_class = 'path';
      break;
    case 'pathcombframe':
      slct_list = REG_SELECT_LIST;
      custom_class = 'combo';
      comb_input_type = 'pathcombinput';
      break;
    default:
      return false;
  }

  if ($('#slcmenulist').length) {
    $cur_target.find('img').attr('src', 'images/select_icon.png');
    $('#slcmenulist').remove();

    if ($event_target.hasClass('slcmenu')) {
      if ($cur_target.find('span').length) {
        if (slct_type == 'motionselframe' && $event_target.text() != $cur_target.find('span').text()) {
          if ($event_target.text() == resources['pltmotionj']) {
            $('#speedselframe_' + route_num).find('span').text('%');
          } else if ($event_target.text() == resources['pltmotionl']) {
            $('#speedselframe_' + route_num).find('span').text('mm/sec');
          }
        }
        if (slct_type == 'pathselframe' && $event_target.text() != $cur_target.find('span').text()) {
          if ($event_target.text() == resources['pltmotionfine']) {
            $('#pathcombframe_' + route_num).css('display', 'none');
            $('#pathregiframe_' + route_num).css('display', 'none');
          } else if ($event_target.text() == resources['pltmotioncnt']) {
            $('#pathcombframe_' + route_num).css('display', 'block');
            if ($('#pathcombinput_' + route_num).val() == resources['pltslctreg']) {
              $('#pathregiframe_' + route_num).css('display', 'block');
            }
          }
        }

        $cur_target.find('span').text($event_target.text());
      } else {
        var $comb_input = $('#' + comb_input_type + '_' + route_num);
        var $interlock_frame;

        if (slct_type == 'speedcombframe') {
          $interlock_frame = $('#speedregiframe_' + route_num);
        } else if (slct_type == 'pathcombframe') {
          $interlock_frame = $('#pathregiframe_' + route_num);
        }

        if ($event_target.text().replace('[]', '') != $comb_input.val()) {
          if ($event_target.text() == resources['pltslctregbracket']) {
            $comb_input.val(resources['pltslctreg']);
            $interlock_frame.css('display', 'block');
          } else {
            if (!$comb_input.val().match(/^\d+$/)) {
              $comb_input.val('');
            }
            $interlock_frame.css('display', 'none');
          }
        }
      }
    }
  } else {
    var $list_frame = $('<div>', { 'id': 'slcmenulist', 'class': 'slcmenulist' });
    var $list_cell;
    var cur_select;

    if ($event_target.get(0).tagName == 'INPUT') {
      return false;
    }

    if ($cur_target.find('span').length) {
      cur_select = $cur_target.find('span').text();
    } else {
      cur_select = $('#' + comb_input_type + '_' + route_num).val();
    }

    $list_frame.addClass(custom_class);
    $cur_target.find('img').attr('src', 'images/select_icon_open.png');

    for (var i = 0; i < slct_list.length; i++) {
      $list_cell = $('<div>', { 'class': 'slcmenu' });
      $list_cell.addClass(custom_class);
      $list_cell.text(slct_list[i]);

      if (slct_list[i].replace('[]', '') == cur_select || (slct_list[i] == '' && cur_select.match(/^\d+$/))) {
        $list_cell.css({ 'background-color': 'rgb(14, 110, 184)', 'color': 'rgb(255, 255, 255)' });
      }
      if (i == 0) {
        $list_cell.addClass('selcmenutop');
      }
      $list_frame.append($list_cell);
    }
    $cur_target.append($list_frame);
  }
  return false;
}

// Edit program content row data.
function buildRoutePointTr(routeNum, posStr, routeProg) {
  var speedData = String(routeProg.speed);
  var speed_regi = null;
  var speed_num = null;

  if (speedData.indexOf('[') > -1) {
    speed_regi = speedData.substring(0, speedData.indexOf('['));
    speed_num = speedData.substring(speedData.indexOf('[') + 1, speedData.lastIndexOf(']'));
  } else {
    speed_num = speedData;
  }

  var kindData = String(routeProg.kind_num);
  var kind_regi = null;
  var kind_num = null;

  if (kindData.indexOf('[') > -1) {
    kind_regi = kindData.substring(0, kindData.indexOf('['));
    kind_num = kindData.substring(kindData.indexOf('[') + 1, kindData.lastIndexOf(']'));
  } else {
    kind_num = kindData;
  }

  // Table frame
  var $pltRouteRow = $('<div>', { 'id': 'pltrouterow_' + routeNum, 'class': 'pltrouterow' });

  // No.
  var $routeRowNo = $('<div>', { 'id': 'pltrouteno_' + routeNum, 'class': 'pltroutecell no' });
  $routeRowNo.text(routeNum);

  // Motion
  var $routeRowMotion = $('<div>', { 'id': 'pltroutemotion_' + routeNum, 'class': 'pltroutecell motion' });
  var $motionSelFrame = $('<div>', { 'id': 'motionselframe_' + routeNum, 'class': 'pltrouteselbox motion', 'tabindex': '1' });
  var $motionSelVal = $('<span>');
  $motionSelVal.text(resources[routeProg.motion]);
  var $motionSelBtn = $('<div>', { 'id': 'motionselbtn_' + routeNum, 'class': 'pltrouteselbtn motion' });
  var $motionSelImg = $('<img>', { 'src': 'images/select_icon.png', 'class': 'pltrouteselimg motion' });
  $motionSelBtn.append($motionSelImg);
  $motionSelFrame.append($motionSelVal);
  $motionSelFrame.append($motionSelBtn);
  $routeRowMotion.append($motionSelFrame);

  // Position
  var $routeRowPos = $('<div>', { 'id': 'pltroutepos_' + routeNum, 'class': 'pltroutecell pos' });
  $routeRowPos.text(posStr);

  // Speed
  var $routeRowSpeed = $('<div>', { 'id': 'pltroutespeed_' + routeNum, 'class': 'pltroutecell speed' });
  var $speedCombFrame = $('<div>', { 'id': 'speedcombframe_' + routeNum, 'class': 'pltroutecombbox speed', 'tabindex': '1' });
  var $speedCombInput = $('<input>', { 'id': 'speedcombinput_' + routeNum, 'class': 'pltroutecombinput speed' });

  if (isiPad) {
    $speedCombInput.css('height', '22px');
    $speedCombInput.css('width', '35px');
  }

  if (speed_regi) {
    $speedCombInput.val(speed_regi);
  } else {
    $speedCombInput.val(speed_num);
  }

  var $speedCombBtn = $('<div>', { 'id': 'speedcombbtn_' + routeNum, 'class': 'pltroutecombbtn speed' });
  var $speedCombImg = $('<img>', { 'src': 'images/select_icon.png', 'class': 'pltrouteselimg speed' });

  $speedCombBtn.append($speedCombImg);
  $speedCombFrame.append($speedCombInput);
  $speedCombFrame.append($speedCombBtn);
  $routeRowSpeed.append($speedCombFrame);

  $speedRegiFrame = $('<div>', { 'id': 'speedregiframe_' + routeNum, 'class': 'pltroutecombregi speed' });
  $speedRegiInput = $('<input>', { 'id': 'speedregiinput_' + routeNum, 'class': 'pltrouteregiinput speed' });

  if (isiPad) {
    $speedRegiInput.css('height', '22px');
    $speedRegiInput.css('width', '30px');
  }

  if (speed_regi) {
    $speedRegiInput.val(speed_num);
  } else {
    $speedRegiFrame.css('display', 'none');
  }

  $speedRegiFrame.append('[');
  $speedRegiFrame.append($speedRegiInput);
  $speedRegiFrame.append(']');
  $routeRowSpeed.append($speedRegiFrame);

  var $speedSelFrame = $('<div>', { 'id': 'speedselframe_' + routeNum, 'class': 'pltrouteselbox speed', 'tabindex': '1' });
  var $speedSelVal = $('<span>');
  $speedSelVal.text(routeProg.unit);
  var $speedSelBtn = $('<div>', { 'id': 'speedselbtn_' + routeNum, 'class': 'pltrouteselbtn speed' });
  var $speedSelImg = $('<img>', { 'src': 'images/select_icon.png', 'class': 'pltrouteselimg speed' });
  $speedSelBtn.append($speedSelImg);
  $speedSelFrame.append($speedSelVal);
  $speedSelFrame.append($speedSelBtn);
  $routeRowSpeed.append($speedSelFrame);

  // Termination type
  var $routeRowPath = $('<div>', { 'id': 'pltroutepath_' + routeNum, 'class': 'pltroutecell path' });
  var $pathSelFrame = $('<div>', { 'id': 'pathselframe_' + routeNum, 'class': 'pltrouteselbox path', 'tabindex': '1' });
  var $pathSelVal = $('<span>');
  $pathSelVal.text(resources[routeProg.kind]);
  var $pathSelBtn = $('<div>', { 'id': 'pathselbtn_' + routeNum, 'class': 'pltrouteselbtn path' });
  var $pathSelImg = $('<img>', { 'src': 'images/select_icon.png', 'class': 'pltrouteselimg path' });
  $pathSelBtn.append($pathSelImg);
  $pathSelFrame.append($pathSelVal);
  $pathSelFrame.append($pathSelBtn);
  $routeRowPath.append($pathSelFrame);

  var $pathCombFrame = $('<div>', { 'id': 'pathcombframe_' + routeNum, 'class': 'pltroutecombbox path', 'tabindex': '1' });
  var $pathCombInput = $('<input>', { 'id': 'pathcombinput_' + routeNum, 'class': 'pltroutecombinput path' });

  if (isiPad) {
    $pathCombInput.css('height', '22px');
    $pathCombInput.css('width', '35px');
  }

  if (kind_regi) {
    $pathCombInput.val(kind_regi);
  } else {
    $pathCombInput.val(kind_num);
  }

  var $pathCombBtn = $('<div>', { 'id': 'pathcombbtn_' + routeNum, 'class': 'pltroutecombbtn path' });
  var $pathCombImg = $('<img>', { 'src': 'images/select_icon.png', 'class': 'pltrouteselimg path' });
  $pathCombBtn.append($pathCombImg);
  $pathCombFrame.append($pathCombInput);
  $pathCombFrame.append($pathCombBtn);
  $routeRowPath.append($pathCombFrame);

  $pathRegiFrame = $('<div>', { 'id': 'pathregiframe_' + routeNum, 'class': 'pltroutecombregi path' });
  $pathRegiInput = $('<input>', { 'id': 'pathregiinput_' + routeNum, 'class': 'pltrouteregiinput path' });

  if (isiPad) {
    $pathRegiInput.css('height', '22px');
    $pathRegiInput.css('width', '30px');
  }

  if (kind_num == '0') {
    kind_num = '';
  }

  $pathRegiInput.val(kind_num);

  $pathRegiFrame.append('[');
  $pathRegiFrame.append($pathRegiInput);
  $pathRegiFrame.append(']');
  $routeRowPath.append($pathRegiFrame);

  if (resources[routeProg.kind] == resources['pltmotionfine']) {
    $pathCombFrame.css('display', 'none');
  }
  if (!kind_regi) {
    $pathRegiFrame.css('display', 'none');
  }

  // Combine
  $pltRouteRow.append($routeRowNo);
  $pltRouteRow.append($routeRowMotion);
  $pltRouteRow.append($routeRowPos);
  $pltRouteRow.append($routeRowSpeed);
  $pltRouteRow.append($routeRowPath);

  // Event listener
  $motionSelFrame.on('click', changePltSlctBox);
  $speedCombFrame.on('click', changePltSlctBox);
  $speedSelFrame.on('click', changePltSlctBox);
  $pathSelFrame.on('click', changePltSlctBox);
  $pathCombFrame.on('click', changePltSlctBox);

  $motionSelFrame.on('blur', blurPltSlctBox);
  $speedCombFrame.on('blur', blurPltSlctBox);
  $speedSelFrame.on('blur', blurPltSlctBox);
  $pathSelFrame.on('blur', blurPltSlctBox);
  $pathCombFrame.on('blur', blurPltSlctBox);

  return $pltRouteRow
}
// -------------------------------
// Route pattern Dialog Appearance
function configPalletRoutePtn(pltObj, pltPtnNumber) {
  var $cutDlgBtn = initContentArea('pltdlgttlroute');
  var $pltDlgTbl = $('#pltdlgtable');

  // Configuration code here
  var $dlgRoutePtnFrame = $('<div>', { 'id': 'ptndlgrouteptn', 'class': 'ptndlgrouteblick' });
  var $dlgRoutePtnHead = $('<div>', { 'id': 'ptndlgpltregstr', 'class': 'pltrteposmsg' });
  $dlgRoutePtnHead.css({ 'float': 'left', 'height': '24px', 'padding': '8px 0px 0px 0px' });
  var ptnheadStr = resources['dlgIfPltReg'].replace('$reg$', String(pltObj.config.pal_reg)); // replace pattern number;
  $dlgRoutePtnHead.html(ptnheadStr);
  var $ptnBtnPosDat = $('<div>', { 'id': 'ptnBtnPos', 'class': 'ptnBtnPos' });
  $ptnBtnPosDat.html(resources['hdrPosition']);
  $dlgRoutePtnFrame.append($dlgRoutePtnHead);
  $dlgRoutePtnFrame.append($ptnBtnPosDat);
  // Pattern number (hidden element)
  var $dlgRoutePtnNumber = $('<span>', { 'id': 'ptndlgroutenumber' });
  if (pltPtnNumber != null) {
    $dlgRoutePtnNumber.text(pltPtnNumber);
  }
  $dlgRoutePtnNumber.css('display', 'none');

  //Dara ScrollFrame
  var $pltRouteScroll = $('<div>', { 'id': 'pltRouteScroll', 'class': 'pltRouteScroll' });
  // Data table
  var $pltRouteTable = $('<div>', { 'id': 'pltRouteGrid', 'class': 'pltRouteGrid' });
  var $pltRouteHead = $('<div>', { 'id': 'pltrouteptnhead', 'class': 'pltrouteptnhead' });
  var $pltRouteTitle1 = $('<div>', { 'id': 'pltroutetitle_no', 'class': 'pltroutetitle no' });
  $pltRouteTitle1.html('No.');
  var $pltRouteTitle2 = $('<div>', { 'id': 'pltroutetitle_motion', 'class': 'pltroutetitle motion' });
  $pltRouteTitle2.html(resources['hdrMotion']);
  var $pltRouteTitle3 = $('<div>', { 'id': 'pltroutetitle_pos', 'class': 'pltroutetitle pos' });
  $pltRouteTitle3.html(resources['hdrPosition']);
  var $pltRouteTitle4 = $('<div>', { 'id': 'pltroutetitle_speed', 'class': 'pltroutetitle speed' });
  $pltRouteTitle4.html(resources['hdrFdrate']);
  var $pltRouteTitle5 = $('<div>', { 'id': 'pltroutetitle_path', 'class': 'pltroutetitle path' });
  $pltRouteTitle5.html(resources['hdrPath']);

  $pltRouteHead.append($pltRouteTitle1);
  $pltRouteHead.append($pltRouteTitle2);
  $pltRouteHead.append($pltRouteTitle3);
  $pltRouteHead.append($pltRouteTitle4);
  $pltRouteHead.append($pltRouteTitle5);

  // Data Main Contents
  var $pltRouteMain = $('<div>', { 'id': 'pltrouteptnmain', 'class': 'pltrouteptnmain' });
  var apprPoint = pltObj.config.appr; // Approach point
  var routeNum = 1;
  // Approach point (Sekkinn-tenn)
  for (var apIndex = apprPoint; apIndex > 0; apIndex--) {
    var posStr = resources['pltpositiontxt'] + '[' + resources['pltposapprtxt'] + '_' + apIndex + ']';
    var $pltRouteRow = buildRoutePointTr(routeNum, posStr, pltObj.route.prog[routeNum - 1]);
    routeNum++;
    $pltRouteMain.append($pltRouteRow);
  }
  // Stack point (Tsumi-tenn)
  var posStr = resources['pltpositiontxt'] + '[' + resources['pltposstacktxt'] + ']';
  var $pltRouteRow = buildRoutePointTr(routeNum, posStr, pltObj.route.prog[routeNum - 1]);
  routeNum++;
  $pltRouteMain.append($pltRouteRow);
  // Retreat point (Nige-tenn)
  var rtrtPoint = pltObj.config.rtrt; // Retreat point
  for (var rtIndex = 0; rtIndex < rtrtPoint; rtIndex++) {
    var posStr = resources['pltpositiontxt'] + '[' + resources['pltposrtrttxt'] + '_' + (rtIndex + 1) + ']';
    var $pltRouteRow = buildRoutePointTr(routeNum, posStr, pltObj.route.prog[routeNum - 1]);
    routeNum++;
    $pltRouteMain.append($pltRouteRow);
  }

  $pltRouteTable.append($pltRouteHead);
  $pltRouteTable.append($pltRouteMain);
  $pltRouteScroll.append($pltRouteTable);
  $dlgRoutePtnFrame.append($pltRouteScroll);
  $pltDlgTbl.append($dlgRoutePtnFrame);

  // Append to parent frame
  finalContentArea($pltDlgTbl, $cutDlgBtn);

  // change button face to DONE
  $('#pltdlgbtnnext').html(resources['dlgBtnFinish']);
}

// Close Dialog
function closePltDialog() {
  // In tablet mode, return to the programming tab.
  if (isScrModeEditorTab()) {
    selPosInTablet(false);
  }
  $('#pltmainfrmdlg').hide();
  $('#pltmainfrmdlg').remove();
  removeOverlayScreen('pltdialog');
}

// Close sub dialog
function closeSubPltDialog() {
  $('#pltsubfrmdlg').hide();
  $('#pltsubfrmdlg').remove();
  $('#pltmainfrmdlg').removeClass('hidemaindlg');
}

/*
 *  Convert dialog date to resource id.
 */
function convert_resource(text) {
  var resources_id;

  switch (text) {
    case '積上':
    case 'PALLET':
    case '码垛':
      resources_id = 'pltpallet';
      break;

    case '積下':
    case 'DEPALLET':
    case '拆垛':
      resources_id = 'pltdepallet';
      break;

    case '行列段':
    case 'RCL':
      resources_id = 'pltrcl';
      break;

    case '行段列':
    case 'RLC':
      resources_id = 'pltrlc';
      break;

    case '列行段':
    case 'CRL':
      resources_id = 'pltcrl';
      break;

    case '列段行':
    case 'CLR':
      resources_id = 'pltclr';
      break;

    case '段行列':
    case 'LRC':
      resources_id = 'pltlrc';
      break;

    case '段列行':
    case 'LCR':
      resources_id = 'pltlcr';
      break;

    case '固定':
    case 'FIX':
      resources_id = 'pltattitudefix';
      break;

    case '分割':
    case 'INTER':
    case '内部':
      resources_id = 'pltattitudeint';
      break;

    case '2点':
    case 'LINE':
    case '直线':
      resources_id = 'pltmethodline';
      break;

    case '全点':
    case 'FREE':
    case '自由':
      resources_id = 'pltmethodfree';
      break;

    case 'ｱﾘ':
    case 'YES':
    case '是':
      resources_id = 'pltauxyes';
      break;

    case 'ﾅｼ':
    case 'NO':
    case '否':
      resources_id = 'pltauxno';
      break;

    default:
      resources_id = text;
      break;
  }

  return resources_id;
}

function checkCommentsCount(string) {
  var MAX_COUNT = 17;
  var str_array = string.split("");
  var count = 0;
  var new_string = "";
  var char;

  for (var i = 0; i < str_array.length; i++) {
    char = str_array[i].charCodeAt(0);

    if ((char >= 0x0 && char < 0x81) || (char == 0xf8f0) || (char >= 0xff61 && char < 0xffa0) || (char >= 0xf8f1 && char < 0xf8f4)) {
      count++;
    } else {
      count += 2;
    }

    if (count >= MAX_COUNT) {
      return new_string;
    } else {
      new_string += str_array[i];
    }
  }

  return true;
}

function deleteString(text) {
  var str_array = text.split("");
  var new_str = "";
  var str;

  for (var i = 0; i < str_array.length; i++) {
    str = str_array[i];

    if ((i == 0 && str.match(/^\-$/)) || str.match(/^[0-9]$/)) {
      new_str += str;
    }
  }

  return new_str;
}

function checkLowHighValue($input, min, max) {
  var value = $input.val();

  if (value.match(/\s/)) {
    value = value.replace(/\s/g, '');
  }
  if (value == '' || value == '-') {
    $input.val(value);
    return true;
  }

  value = Number(value);

  if (isNaN(value)) {
    value = deleteString($input.val());
    $input.val(value);
    return;
  }

  if (min > value) {
    // display error tooltip
    $input.val(min);
  } else if (max < value) {
    // display error tooltip
    $input.val(max);
  } else if (String(value) != String($input.val())) {
    $input.val(value);
  }
}

/*
 * Configuration of Palletizing Sub Frame Dialog.
 */
function configPalletSubDialog() {
  // Make dialog frame
  var $dlgFrame = $('<div>', { 'id': 'pltsubfrmdlg', 'class': 'pltmaindlg' });
  // Dialog title header
  var $dlgTitle = $('<div>', { 'id': 'pltsubdlgtitle', 'class': 'dlgtitlebar' });
  var $dlgTitleText = $('<span>', { 'id': 'pltsubdlgttltxt' });
  // Title header string
  $dlgTitleText.html(resources['pltdlgmainttl']);
  $dlgTitle.append($dlgTitleText);
  $dlgFrame.append($dlgTitle);

  // Make contents area
  var $dlgTblFlm = $('<div>', { 'id': 'pltsubdlgcontent', 'class': 'dlgtblflm' });
  $dlgTblFlm.css('width', '93%');
  var $pltDlgTbl = $('<div>', { 'id': 'pltsubdlgtable', 'class': 'pltdlgtbl' });
  $dlgTblFlm.append($pltDlgTbl);
  $dlgFrame.append($dlgTblFlm);

  // Make button area
  var $dlgBtnArea = $('<div>', { 'id': 'pltsubdlgbtnarea', 'class': 'pltbtnarea', 'align': 'center' });
  $dlgBtnArea.css({ 'clear': 'both' });
  // 'Back(Prev)' button (empty)
  var $blgBtnDiv = $('<div>', { 'id': 'pltprevframe', 'class': 'pltprevframe', 'style': 'min-height: 1px;' });
  $dlgBtnArea.append($blgBtnDiv)
  // Cancel button
  var $dlgBtnDiv = $('<div>', { 'id': 'pltsubcancelframe', 'class': 'pltcancelframe' });
  var $dlgBtnCancel = $('<button>', { 'id': 'pltsubdlgbtncancel', 'class': 'pltdlgbutton pltbtncancel' });
  $dlgBtnCancel.html(resources['dlgBtnCancel']);
  $dlgBtnDiv.append($dlgBtnCancel);
  $dlgBtnArea.append($dlgBtnDiv);
  // OK button
  $dlgBtnDiv = $('<div>', { 'id': 'pltsubokframe', 'class': 'pltnextframe' });
  var $dlgBtnOK = $('<button>', { 'id': 'pltsubdlgbtnok', 'class': 'pltdlgbutton pltbtnnext' });
  $dlgBtnOK.html(resources['dlgBtnOk']);
  $dlgBtnDiv.append($dlgBtnOK);
  $dlgBtnArea.append($dlgBtnDiv);
  // Append to dialog main frame
  $dlgFrame.append($dlgBtnArea);
  $('body').append($dlgFrame);
}

/*
 *  Configuration of Palletizing Route Position Dialog.
 *  Open on top of Palletizing Route Pattern Dialog.
 */
function configPalletRoutePos(pltObj, pltArg) {
  var rteObj = pltObj.route.pattern[pltArg.pattern];
  // pick content area element
  var $dlgFrame = $('#pltsubfrmdlg');
  var $dlgTblFlm = $('#pltsubdlgcontent');
  var $pltDlgTbl = $('#pltsubdlgtable');
  // initialize element
  $pltDlgTbl.empty();
  $dlgTblFlm.empty();
  var $cutDlgBtn = $('#pltsubdlgbtnarea').remove();

  // Change title
  $('#pltsubdlgttltxt').html(resources['pltdlgmainttl'] + resources['pltdlgttlroutepos']);

  // Configuration code here
  var $pltRteTUpBtn = $('<button>', { id: 'pltRteTUpBtn', class: 'plttupbtn' });
  $pltRteTUpBtn.html(resources['posTableTup']);
  var $pltRtePosMsg = $('<div>', { id: 'pltRtePosMsg', class: 'pltrteposmsg' });
  $pltRtePosMsg.css({ 'height': '24px', 'padding': '8px 0px 0px 0px' });
  var msg = resources['pltdlgrouteposmsg'] + '[' + String(pltObj.config.pal_reg) + '] = [ ';
  if (pltObj.category.indexOf("X") > 0) {
    var patArray = pltObj.pattern[0];
    msg += patArray.join(',') + ']';
  } else {
    msg += '*, *, * ]';
  }
  
  $pltRtePosMsg.html(msg);
  var $pltRtePos = $('<div>', { id: 'pltRtePos', class: 'pltpos' });
  $pltDlgTbl.append($pltRteTUpBtn);

  if (/X$/.test(pltObj.category)) { // create select box for route pattern
    var $pltPatSelBox = $('<div>', { 'id': 'pltPatSelBox', 'class': 'pltselbox', 'tabindex': '1' });
    $pltPatSelBox.css({ "width": "125px", "margin-top": "7px", "margin-left": "25px" });
    var $typeSelText = $('<span>');
    $typeSelText.html(resources["pltRoutePattern"] + "1");
    $pltPatSelBox.append($typeSelText);

    var $typeSelBtn = $('<div>', { 'id': 'typeSelBtn', 'class': 'dlgselbtn' });
    var $typeSelImg = $('<img>', { 'id': 'typeSelImg', 'class': 'dlgselimg', 'src': 'images/select_icon.png' });
    $typeSelBtn.append($typeSelImg);
    $pltPatSelBox.append($typeSelBtn);
    $pltDlgTbl.append($pltPatSelBox);
  }
  $pltDlgTbl.append($pltRtePosMsg);
  $pltDlgTbl.append($pltRtePos);

  // Append to center content area
  $dlgTblFlm.append($pltDlgTbl);
  // Append to parent frame
  $dlgFrame.append($dlgTblFlm);
  $dlgFrame.append($cutDlgBtn);

  // Put the position data grid.
  putPltPosGrid('pltRtePos', 'pltRteTUpBtn', pltObj);

  // Enable the reset button, jog window, resize bar, and layout button.
  setPltPosOverlay();
}

/*
* Dialog procedure
*/
var pltDlgIdTransTbl = {
  std: ['initData', 'btmpoint', 'routePtn'],
  ext: ['initData', 'btmpoint', 'routeCnd', 'routePtn']
};
var pltCrntDlgIndex = 0;
var pltDialog = {};
var pltDlgOpenMode = PLTDLGMODE_INSERT; // Palletizing dialog open from {command list | editor}.
var pltSubDialog = {};
var newPltObj = {};
var subDlgSelNum = 1;
$(function () {
  pltDialog = {
    open: function (dlgMode) {
      pltDlgOpenMode = dlgMode;
      var scrlLeft = $(window).scrollLeft();
      var scrlTop = $(window).scrollTop();
      configPalletMainDialog();
      putOverlayScreen('pltdialog', 'forpopup');
      centeringDialogWindow('#pltmainfrmdlg', scrlLeft, scrlTop);
      pltCrntDlgIndex = 0;
      // In tablet mode, switch to the position tab. Allow jog operation.
      if (isScrModeEditorTab()) {
        selPosInTablet(true); // poswin
      }
      return true;
    },
    process: function (dlgKind, pltObj, routePtnNum) {
      if (dlgKind == 'initData') {
        configPalletInitData(pltObj);
      } else if (dlgKind == 'btmpoint') {
        configPalletBtmPoint(pltObj);
      } else if (dlgKind == 'routeCnd') {
        configPalletRouteCnd(pltObj);
      } else if (dlgKind == 'routePtn') {
        configPalletRoutePtn(pltObj, routePtnNum);
      }
      // Index used in the route pattern dialog.
      var routePtnNum = 1;
      // Dialog controll button event handler below
      $('#pltdlgbtnprev').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        // Keep Palletizing Data
        // Call prev dialog
        if (pltCrntDlgIndex == 0) {
          $('#pltdlgbtnprev').blur();
          return false;
        }
        if (dlgKind == 'btmpoint') {
          updatePltPosData(newPltObj.bottom);
          DeletePltGrid();
          // Restore the activated element.
          restorePltPosOverlay();
        } else if (dlgKind == 'routePtn') {
          updatePltRoutePtnObj(newPltObj.route);
        } else if (dlgKind == 'routeCnd') {
          var patNum = newPltObj.config.pattern;
          var patArray = newPltObj.pattern;

          for (var ptnlineNum = 0; ptnlineNum < patNum; ptnlineNum++) {
            var target = patArray[ptnlineNum];
            var idStr = "#pltPtnLin" + (ptnlineNum + 1);
            target[0] = $(idStr + " #pltPtnIpt1").val();
            target[1] = $(idStr + " #pltPtnIpt2").val();
            target[2] = $(idStr + " #pltPtnIpt3").val();
          }

        } else {
          newPltObj = updatePltObj(newPltObj);
        }
        pltCrntDlgIndex--;
        // get route pattern number
        var pltdlgTbl = /X$/.test(pltObj.category) ? pltDlgIdTransTbl.ext : pltDlgIdTransTbl.std
        var routePtnElem = $('#ptndlgroutenumber');
        routePtnNum = (routePtnElem.length > 0) ? parseInt(routePtnElem.text()) - 1 : 1;
        pltDialog.process(pltdlgTbl[pltCrntDlgIndex], pltObj, routePtnNum);
      });
      $('#pltdlgbtncancel').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        if (dlgKind == 'btmpoint') {
          DeletePltGrid();
          // Restore the activated element.
          restorePltPosOverlay();
        }
        // Keep Palletizing Data
        // Break from dialog
        closePltDialog();
      });
      $('#pltdlgbtnnext').on('click touchend', function (event) {
        if(event.type.indexOf('touch') >= 0){
          event.preventDefault();
        }
        // update object
        newPltObj = JSON.parse(JSON.stringify(pltObj));

        // Update current object with dialog data
        if (dlgKind == 'initData') {
          newPltObj.config.name = $('#pltNumIpt').val();
          newPltObj.config.type = convert_resource($('#typeSelBox').find('span').text());
          newPltObj.config.incr = Number($('#pltIncIpt').val());
          newPltObj.config.pal_reg = Number($('#pltPrgIpt').val());
          newPltObj.config.order = convert_resource($('#ordSelBox').find('span').text());
          newPltObj.config.rows[0] = Number($('#pltRowIpt').val());
          newPltObj.config.columns[0] = Number($('#pltColIpt').val());
          newPltObj.config.layers[0] = Number($('#pltLayIpt').val());
          newPltObj.config.aux_pos[0] = convert_resource($('#auxSelBox').find('span').text());

          if (newPltObj.category == 'E' || newPltObj.category == 'EX') {
            newPltObj.config.rows[1] = convert_resource($('#rowFstCombBox').val());
            newPltObj.config.rows[2] = convert_resource($('#rowSndSelBox').find('span').text());
            newPltObj.config.columns[1] = convert_resource($('#colFstCombBox').val());
            newPltObj.config.columns[2] = convert_resource($('#colSndSelBox').find('span').text());
            newPltObj.config.layers[1] = convert_resource($('#layFstCombBox').val());
            newPltObj.config.layers[2] = convert_resource($('#laySndSelBox').find('span').text());
            newPltObj.config.layers[3] = Number($('#pltLayIptSnd').val());
            newPltObj.config.aux_pos[1] = convert_resource($('#auxSndSelBox').find('span').text());
          }

          newPltObj.config.appr = Number($('#pltAppIpt').val());
          newPltObj.config.rtrt = Number($('#pltPtnIpt').val());

          if (newPltObj.category == 'BX' || newPltObj.category == 'EX') {
            newPltObj.config.pattern = Number($('#pltPtrnIpt').val());
          }
          newPltObj = updatePltObj(newPltObj);
        } else if (dlgKind == 'btmpoint') {
          updatePltPosData(newPltObj.bottom);
        } else if (dlgKind == 'routePtn') {
          updatePltRoutePtnObj(newPltObj.route);
        } else if (dlgKind == 'routeCnd') {
          var patNum = newPltObj.config.pattern;
          var patArray = newPltObj.pattern;

          for (var ptnlineNum = 0; ptnlineNum < patNum; ptnlineNum++) {
            var target = patArray[ptnlineNum];
            var idStr = "#pltPtnLin" + (ptnlineNum + 1);
            target[0] = $(idStr + " #pltPtnIpt1").val();
            target[1] = $(idStr + " #pltPtnIpt2").val();
            target[2] = $(idStr + " #pltPtnIpt3").val();
          }

        }

        // Check posdata
        var posdataErr = false;
        if (dlgKind === 'btmpoint') {
          posdataErr = checkBottomPosData(newPltObj.bottom);
          if (!posdataErr) {
            DeletePltGrid();
            // Restore the activated element.
            restorePltPosOverlay();
          }
        } else if (dlgKind === 'routePtn') {
          posdataErr = checkRoutePosData(newPltObj.route);
        }
        if (posdataErr) {
          defineDialog.open(null, '#posalertdlg', 'dlgMsgIncompRow');
          $('#posalertdlg').css({ "z-index": "10003" });
          $('#screenoverlay-dialog').css({ "z-index": "10000" });
          return false;
        }
        // Keep Palletizing Data
        // Call next dialog
        // if still exist setting data, route setting continue.
        // check button face is better...
        var pltdlgTbl = /X$/.test(pltObj.category) ? pltDlgIdTransTbl.ext : pltDlgIdTransTbl.std;
        if (pltCrntDlgIndex >= (pltdlgTbl.length - 1)) {
          if (isWriteProtectWin()) {
            closePltDialog();
            var alertStr = ((isScrModePcEditor()) ? 'dlgMsgNotEditableEditor' : 'dlgMsgNotEditableEditorTb');
            defineDialog.open(null, '#confalertdlg', alertStr); // Alert on
            return false;
          }
          // save APPL .....
          putOverlayScreen('applsaveerrdlg', 'forassist');
          $("#applsaveerrdlg").css({ "z-index": "9999" });
          dispOnWaiting();
          $("#waiting").css({
            "left": "48 %",
            "top": "40%",
            "z-index": "9999"
          });
          newPltObj.cmdMode = pltDlgOpenMode; // insert or modify.
          savePltAppl(getCurrentProgram(), newPltObj);
          return false;
        }

        pltCrntDlgIndex++;
        // get route pattern number
        var routePtnElem = $('#ptndlgroutenumber');
        routePtnNum = (routePtnElem.length > 0) ? parseInt(routePtnElem.text()) + 1 : 1;
        pltDialog.process(pltdlgTbl[pltCrntDlgIndex], newPltObj, routePtnNum);
      });
      // Each dialog event handler below
      if (dlgKind == 'initData') {
        $('.pltselbox').on('click', function (event) {
          var TYPE_SELECT_LIST = [resources['pltpallet'], resources['pltdepallet']];
          var ORDER_SELECT_LIST = [resources['pltrcl'], resources['pltrlc'], resources['pltcrl'], resources['pltclr'], resources['pltlrc'], resources['pltlcr']];
          var LINE_SELECT_LIST = [resources['pltmethodline'], resources['pltmethodfree']];
          var ATT_SELECT_LIST = [resources['pltattitudefix'], resources['pltattitudeint']];
          var AUX_SELECT_LIST = ((($('#pltRowIpt').val() == 1) || ($('#pltColIpt').val() == 1)) ? [resources['pltauxno']] : [resources['pltauxno'], resources['pltauxyes']]);
          var $serectBoxFrame = $(event.currentTarget);
          var selectList;

          if ($('#slcmenulist').length) {
            $serectBoxFrame.find('img').attr('src', 'images/select_icon.png');
            $('#slcmenulist').remove();

            if ($(event.target).hasClass('slcmenu')) {
              if ($serectBoxFrame.find('span').length) {

                if ($serectBoxFrame.attr('id') == 'auxSelBox') {
                  if ($('#pltRowIpt').val() == 1 || $('#pltColIpt').val() == 1) {
                    $serectBoxFrame.find('span').text(resources['pltauxno']);
                  } else {
                    $serectBoxFrame.find('span').text($(event.target).text());
                  }
                } else {
                  $serectBoxFrame.find('span').text($(event.target).text());
                }
              } else {
                $serectBoxFrame.find('input').val($(event.target).text());
              }

              if ($serectBoxFrame.attr('id') == 'layFstSelBox') {
                if ($(event.target).text() == resources['pltmethodfree']) {
                  $('#pltLayIptSnd').attr('readonly');
                  $('#pltLayIptSnd').val(1);
                } else if ($(event.target).text() == resources['pltmethodline']) {
                  $('#pltLayIptSnd').removeAttr('readonly');
                }
              }
            }
          } else {
            var currentSelect = $serectBoxFrame.find('span').text();
            var $listFrame = $('<div>', { 'id': 'slcmenulist', 'class': 'slcmenulist palletizing' });
            var $listCell;

            switch ($serectBoxFrame.attr('id')) {
              case 'typeSelBox':
                selectList = TYPE_SELECT_LIST;
                break;
              case 'ordSelBox':
                selectList = ORDER_SELECT_LIST;
                break;
              case 'rowFstSelBox':
              case 'colFstSelBox':
              case 'layFstSelBox':
                selectList = LINE_SELECT_LIST;
                break;
              case 'rowSndSelBox':
              case 'colSndSelBox':
              case 'laySndSelBox':
              case 'auxSndSelBox':
                selectList = ATT_SELECT_LIST;
                break;
              case 'auxSelBox':
                selectList = AUX_SELECT_LIST;
                break;
              default:
                return false;
                break;
            }

            if ($(event.target).get(0).tagName == 'INPUT') {
              return false;
            }

            $serectBoxFrame.find('img').attr('src', 'images/select_icon_open.png');

            for (var i = 0; i < selectList.length; i++) {
              $listCell = $('<div>', { 'class': 'slcmenu' });
              $listCell.text(selectList[i]);

              if (selectList[i] == currentSelect) {
                $listCell.css({ 'background-color': 'rgb(14, 110, 184)', 'color': 'rgb(255, 255, 255)' });
              }
              if (i == 0) {
                $listCell.addClass('selcmenutop');
              }
              $listFrame.append($listCell);
            }

            $serectBoxFrame.append($listFrame);
          }
          return false;
        });
        $('.pltselbox').on('blur', function (event) {
          var $serectBoxFrame = $(event.currentTarget);
          if ($('#slcmenulist').length) {
            $serectBoxFrame.find('img').attr('src', 'images/select_icon.png');
            $('#slcmenulist').remove();
          }
          return false;
        });
        $('#pltNumIpt').on('input', function (event) {
          var comments = $(this).val();
          var result = checkCommentsCount(comments);

          if (result != true) {
            $(this).val(result);
          }
        });
        $('#pltIncIpt').on('input', function (event) {
          var MIN_VAL = -99;
          var MAX_VAL = 99;

          checkLowHighValue($(this), MIN_VAL, MAX_VAL);
        });
        $('#pltPrgIpt, #pltRowIpt, #pltColIpt, #pltLayIpt').on('input', function (event) {
          var MIN_VAL = 1;
          var MAX_VAL = 127;

          checkLowHighValue($(this), MIN_VAL, MAX_VAL);

          if ($(this).attr('id') == 'pltRowIpt' || $(this).attr('id') == 'pltColIpt') {
            if ($(this).val() == 1) {
              $('#auxSelBox').find('span').text(resources['pltauxno']);
            }
          }
        });
        $('#pltLayIptSnd, #pltPtrnIpt').on('input', function (event) {
          var MIN_VAL = 1;
          var MAX_VAL = 16;

          checkLowHighValue($(this), MIN_VAL, MAX_VAL);
        });
        $('#pltAppIpt, #pltPtnIpt').on('input', function (event) {
          var MIN_VAL = 0;
          var MAX_VAL = 8;

          checkLowHighValue($(this), MIN_VAL, MAX_VAL);
        });
        $('#rowFstCombBox, #colFstCombBox, #layFstCombBox').on('input', function (event) {
          var MIN_VAL = 0;
          var MAX_VAL = 3000;

          if ($(this).val().match(/^(\-)*\d+$/)) {
            checkLowHighValue($(this), MIN_VAL, MAX_VAL);
          }
        });
      } else if (dlgKind == 'routePtn') {
        $('#ptnBtnPos').on('click', function (event) {
          var result = pltSubDialog.open();
          var pltArg = {};
          pltArg.pattern = routePtnNum;
          if (result) {
            updatePltRoutePtnObj(newPltObj.route);
            pltSubDialog.process('routePos', newPltObj, pltArg);
          }
        });
      }
    }
  };
  pltSubDialog = {
    open: function () {
      configPalletSubDialog();
      var pltMainDlgId = document.getElementById('pltmainfrmdlg');
      var maindlgLeft = pltMainDlgId.getBoundingClientRect().left + $(window).scrollLeft();
      var maindlgTop = pltMainDlgId.getBoundingClientRect().top + $(window).scrollTop();
      $('#pltmainfrmdlg').addClass('hidemaindlg');
      $('#pltsubfrmdlg').css({ "left": maindlgLeft + "px", "top": maindlgTop + "px" });
      return true;
    },
    process: function (subdlgKind, pltObj, pltArg) {
      if (subdlgKind == 'routePos') {
        // Put the pattern number 'pattern' in 'pltArg'.
        configPalletRoutePos(pltObj, pltArg);
        subDlgSelNum = 1;
      }
      // Dialog controll button event handler below
      $('#pltsubdlgbtnok').on('click', function () {
        if (subdlgKind == 'routePos') {
          var patNum = /X$/.test(newPltObj.category) ? Number($('#pltPatSelBox').text().replace(/[^0-9]/g, "").trim()) : 1;
          updatePltPosData(newPltObj.route.pattern[patNum]);
          DeletePltGrid();
          // Restore the activated element.
          restorePltPosOverlay();
        }
        newPltObj = updatePltObj(newPltObj);
        pltDialog.process("routePtn", newPltObj, 1);
        closeSubPltDialog();
      });
      $('#pltsubdlgbtncancel').on('click', function () {
        if (subdlgKind == 'routePos') {
          DeletePltGrid();
          // Restore the activated element.
          restorePltPosOverlay();
        }
        // Break from dialog
        closeSubPltDialog();
      });
      $('#pltPatSelBox').on('click', function (event) {
        var $serectBoxFrame = $(event.currentTarget);
        var selectList = [];

        if ($('#slcmenulist').length) { // open list
          $serectBoxFrame.find('img').attr('src', 'images/select_icon.png');
          $('#slcmenulist').remove();

          if ($(event.target).hasClass('slcmenu')) {
            if ($serectBoxFrame.find('span').length) {
              var selectedNum = Number($(event.target).text().replace(/[^0-9]/g, "").trim());
              updatePltPosData(newPltObj.route.pattern[subDlgSelNum]);
              subDlgSelNum = selectedNum;
              changeRtePosData(newPltObj, selectedNum);
              updatePltRtePosMsg(newPltObj, selectedNum);
              $serectBoxFrame.find('span').text($(event.target).text());
            } else {
              $serectBoxFrame.find('input').val($(event.target).text());
            }
          }
        } else {
          var currentSelect = $serectBoxFrame.find('span').text();
          var $listFrame = $('<div>', { 'id': 'slcmenulist', 'class': 'slcmenulist palletizing' });
          var $listCell;

          // create list menu text
          for (var selNum = 1; selNum <= pltObj.config.pattern; selNum++) {
            selectList.push(resources["pltRoutePattern"] + selNum);
          }

          if ($(event.target).get(0).tagName == 'INPUT') {
            return false;
          }

          $serectBoxFrame.find('img').attr('src', 'images/select_icon_open.png');

          // create menu div
          for (var i = 0; i < selectList.length; i++) {
            $listCell = $('<div>', { 'class': 'slcmenu' });
            $listCell.text(selectList[i]);

            if (selectList[i] == currentSelect) {
              $listCell.css({ 'background-color': 'rgb(14, 110, 184)', 'color': 'rgb(255, 255, 255)' });
            }
            if (i == 0) {
              $listCell.addClass('selcmenutop');
            }
            $listFrame.append($listCell);
          }

          $serectBoxFrame.append($listFrame);
        }
        return false;
      });
    }
  };
});

function updatePltRtePosMsg(pltObj, selectNum) {
  var msg = resources['pltdlgrouteposmsg'] + '[' + String(pltObj.config.pal_reg) + '] = [ ';
  var patArray = pltObj.pattern[selectNum - 1];
  msg += patArray.join(',') + ']';
  var target = document.getElementById("pltRtePosMsg");
  target.innerText = msg;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /**********************************************************************
 * Robot Program Editor script
 * Position data window for palletizing.
 * Created: 2019/04/17
 */
// Use w2ui.
/* w2ui 1.5.rc1 (nightly) (c) http://w2ui.com, vitmalina@gmail.com */
/* Code licensed under the MIT License. */
/* https://github.com/vitmalina/w2ui/blob/master/license.txt */

var crtPltGrid = null;
var crtPltBtn = null;
var pltBtmDivId = 'pltBtmPos';
var pltRteDivId = 'pltRtePos';
var pltSelGrid = null;
var PLT_GRID_INDEX = 0;
var PLT_GRID_X = 1;
var PLT_GRID_Y = 2;
var PLT_GRID_Z = 3;
var PLT_GRID_W = 4;
var PLT_GRID_P = 5;
var PLT_GRID_R = 6;
var PLT_GRID_UF = 7;
var PLT_GRID_UT = 8;
var PLT_GRID_CONF = 9;

/**
 * Put the position data grid for palletizing.
 * divId:ID of div to put the position grid.
 * btnID:Touch-up button ID.
 * pltObj:Data of palletizing setting dialog (pass by reference).
 */
function putPltPosGrid(divID, btnID, pltObj) {
  crtPltGrid = divID;
  crtPltBtn = btnID;
  dlgSelGrid = null;
  setPltBtnEnb(false);
  definePltGrid();
  // Event handlers are also defined here.
  DefinePltPosEvent();
  // Set initial data in the position data grid.
  initPosData(pltObj);
}

/**
 * Position table for palettizing bottom by w2ui library.
 */
function definePltGrid() {
  var pltIdxTitle = {
    'pltBtmPos': resources['lblCartPos'],
    'pltRtePos': 'No.'
  };
  $('#' + crtPltGrid).w2grid({
    name: crtPltGrid,
    method: 'GET',
    selectType: SELGRID_CELL,
    recordHeight: 28,
    columns: [
      { field: 'Index', caption: pltIdxTitle[crtPltGrid], size: '10px', min: 60, style: 'text-align: center; background-color: rgba(204, 192, 204, 0.8)' },
      { field: 'X', caption: 'X', size: '10%', min: 85, resizable: true, style: 'text-align: center', editable: { type: 'float', min: -99999999, max: 99999999 } },
      { field: 'Y', caption: 'Y', size: '10%', min: 85, resizable: true, style: 'text-align: center', editable: { type: 'float', min: -99999999, max: 99999999 } },
      { field: 'Z', caption: 'Z', size: '10%', min: 85, resizable: true, style: 'text-align: center', editable: { type: 'float', min: -99999999, max: 99999999 } },
      { field: 'W', caption: 'W', size: '10%', min: 85, resizable: true, style: 'text-align: center', editable: { type: 'float', min: -99999999, max: 99999999 } },
      { field: 'P', caption: 'P', size: '10%', min: 85, resizable: true, style: 'text-align: center', editable: { type: 'float', min: -99999999, max: 99999999 } },
      { field: 'R', caption: 'R', size: '10%', min: 85, resizable: true, style: 'text-align: center', editable: { type: 'float', min: -99999999, max: 99999999 } },
      { field: 'UF', caption: 'UF', size: '5%', min: 30, resizable: true, style: 'text-align: center', editable: { type: 'int', min: 0 } },
      { field: 'UT', caption: 'UT', size: '5%', min: 30, resizable: true, style: 'text-align: center', editable: { type: 'int', min: 1 } },
      { field: 'Config', caption: 'Config', size: '20%', min: 120, resizable: true, style: 'text-align: center', editable: { type: 'text' } }
    ]
  });
  var marginH = 40;
  var gridH = $('#pltdlgtable').height() - $('#' + crtPltBtn).height() - marginH;
  $('#' + crtPltGrid).height(gridH);
}

/*
 * Define event handler for the position data grid for palletizing.
 */
function DefinePltPosEvent() {
  // Touch-up button click event.
  // Get the current position and apply it to the selected row.
  $('#' + crtPltBtn).on('click', function (event) {
    if ($('#' + crtPltBtn).hasClass('plttupinact')) {
      return;      
    }
    var record = w2ui[crtPltGrid].records[dlgSelGrid[0].recid];
    var cbArg = {};
    cbArg.tblKind = POSTBLKIND_DATA;
    cbArg.recid = record.recid;
    cbArg.rec = createrow();
    get_curpos(top.KXYZWPR, top.TXML_TP_REC_TYPE, getCurrentGroupNum(), analyzePltPos, cbArg);
  });
  // Grid change event.
  w2ui[crtPltGrid].on('change', function (event) {
    var grid = this;
    // Retrieve the changed record from the event.
    var recid = Number(event.recid);
    var record = w2ui[crtPltGrid].records[recid];
    // Position data from X to R are rounded off to three decimal places.
    if (event.column >= PLT_GRID_X &&
        event.column <= PLT_GRID_R &&
        event.value_new !== "") {
      event.value_new = Number(event.value_new.toFixed(3));
    }
    event.onComplete = function () {
      w2ui[crtPltGrid].save();
    }
  });
  // Grid select event.
  w2ui[crtPltGrid].on('select', function (event) {
    var grid = this;
    event.onComplete = function () {
      dlgSelGrid = grid.getSelection();
      setPltBtnEnb(true);
    }
  });
  // Grid unselect event.
  w2ui[crtPltGrid].on('unselect', function (event) {
    var grid = this;
    event.onComplete = function () {
      dlgSelGrid = null;
      setPltBtnEnb(false);
    }
  });
}

/*
 * Set initial data in the position data grid.
 * pltObj:Data of palletizing setting dialog (pass by reference).
 */
function initPosData(pltObj) {
  w2ui[crtPltGrid].clear();
  // Create records for the position data.
  var linebuff = [];
  if (crtPltGrid == pltBtmDivId) {
    var btmPos = pltObj.bottom
    for (var idx in btmPos) {
      var newline = createrow();
      newline.Index = btmPos[idx].posNumber.slice(3).slice(0, -1);
      newline.X = btmPos[idx].posData[0].poskey.X;
      newline.Y = btmPos[idx].posData[0].poskey.Y;
      newline.Z = btmPos[idx].posData[0].poskey.Z;
      newline.W = btmPos[idx].posData[0].poskey.W;
      newline.P = btmPos[idx].posData[0].poskey.P;
      newline.R = btmPos[idx].posData[0].poskey.R;
      newline.UF = btmPos[idx].posData[0].ufVal;
      newline.UT = btmPos[idx].posData[0].utVal;
      newline.Config = btmPos[idx].posData[0].configStr;
      newline.recid = linebuff.length;
      linebuff.push(newline);
    }
  } else if (crtPltGrid == pltRteDivId) {
    var rtePos = pltObj.route.pattern[1]
    for (var idx in rtePos) {
      var newline = createrow();
      newline.Index = linebuff.length + 1;
      newline.X = rtePos[idx].posData[0].poskey.X;
      newline.Y = rtePos[idx].posData[0].poskey.Y;
      newline.Z = rtePos[idx].posData[0].poskey.Z;
      newline.W = rtePos[idx].posData[0].poskey.W;
      newline.P = rtePos[idx].posData[0].poskey.P;
      newline.R = rtePos[idx].posData[0].poskey.R;
      newline.UF = rtePos[idx].posData[0].ufVal;
      newline.UT = rtePos[idx].posData[0].utVal;
      newline.Config = rtePos[idx].posData[0].configStr;
      newline.recid = linebuff.length;
      linebuff.push(newline);
    }
  }
  if (linebuff.length != 0) {
    w2ui[crtPltGrid].add(linebuff);
  }
  w2ui[crtPltGrid].refresh();
}

function changeRtePosData(pltObj, patNum) {
  var linebuff = [];
  var rtePos = pltObj.route.pattern[patNum];
  for (var idx in rtePos) {
    var newline = createrow();
    newline.Index = linebuff.length + 1;
    newline.X = rtePos[idx].posData[0].poskey.X;
    newline.Y = rtePos[idx].posData[0].poskey.Y;
    newline.Z = rtePos[idx].posData[0].poskey.Z;
    newline.W = rtePos[idx].posData[0].poskey.W;
    newline.P = rtePos[idx].posData[0].poskey.P;
    newline.R = rtePos[idx].posData[0].poskey.R;
    newline.UF = rtePos[idx].posData[0].ufVal;
    newline.UT = rtePos[idx].posData[0].utVal;
    newline.Config = rtePos[idx].posData[0].configStr;
    newline.recid = linebuff.length;
    linebuff.push(newline);
  }
  if (linebuff.length != 0) {
    w2ui[crtPltGrid].clear();
    w2ui[crtPltGrid].add(linebuff);
  }
  w2ui[crtPltGrid].refresh();
}

/*
 * Grid Row Create
 */
function createrow() {
  var empty = {};
  empty.Index = "";
  empty.X = "";
  empty.Y = "";
  empty.Z = "";
  empty.W = "";
  empty.P = "";
  empty.R = "";
  empty.UF = "";
  empty.UT = "";
  empty.Config = "";
  empty.GP = 1; // Necessary when acquiring current position.
  empty.recid = "";
  return empty;
}

/*
 * Convert the received position data into JSON format.
 */
function analyzePltPos(rep, type, grp, str, cbArg) {
  var posJson = analyzeCartesianPosition(str, cbArg);	// common api
  setUFUTbyTableKind(cbArg.tblKind, posJson); // common api
  updatePltPos(posJson, cbArg);
}

/*
 * Set the received position data in the record.
 */
function updatePltPos(posJson, cbArg) {
  var record = w2ui[crtPltGrid].records[cbArg.recid];
  record.X = Number(posJson.X.toFixed(3));
  record.Y = Number(posJson.Y.toFixed(3));
  record.Z = Number(posJson.Z.toFixed(3));
  record.W = Number(posJson.W.toFixed(3));
  record.P = Number(posJson.P.toFixed(3));
  record.R = Number(posJson.R.toFixed(3));
  record.UF = posJson.UF;
  record.UT = posJson.UT;
  record.Config = posJson.Config;
  w2ui[crtPltGrid].refresh();
}

/*
 * Change enable / disable of touch-ip button.
 */
function setPltBtnEnb(bool) {
  var rmvCls = (bool) ? 'plttupinact' : 'plttupactiv';
  var addCls = (bool) ? 'plttupactiv' : 'plttupinact';
  $('#' + crtPltBtn).removeClass(rmvCls);
  $('#' + crtPltBtn).addClass(addCls);
}

/*
 * Update the dialog object passed by reference with the current grid value.
 * dlgObj:Dialog object (pass by reference)
 */
function updatePltPosData(dlgObj) {
  var records = w2ui[crtPltGrid].records;
  for (var index in records) {
    dlgObj[index].posData[0].poskey.X = records[index].X;
    dlgObj[index].posData[0].poskey.Y = records[index].Y;
    dlgObj[index].posData[0].poskey.Z = records[index].Z;
    dlgObj[index].posData[0].poskey.W = records[index].W;
    dlgObj[index].posData[0].poskey.P = records[index].P;
    dlgObj[index].posData[0].poskey.R = records[index].R;
    dlgObj[index].posData[0].ufVal = records[index].UF;
    dlgObj[index].posData[0].utVal = records[index].UT;
    dlgObj[index].posData[0].configStr = records[index].Config;
    dlgObj[index].posData[0].groupNumber = records[index].GP;
  }
}

/*
 * Delete the displayed position grid object.
 */
function DeletePltGrid() {
  if (w2ui[crtPltGrid]) {
    w2ui[crtPltGrid].destroy(); 
  }
}




/*
 * When the position dialog is displayed, enable the reset button, jog window, resize bar, and layout button.
 */
function setPltPosOverlay() {
  if (isScrModePcEditor()) { // In pc mode
    $('.btnreset').css({ 'position': 'relative' });
    $('.btnreset').css({ 'z-index': 9999 });
    $('#jogwindow').css({ 'z-index': 9999 });
    $('#resizeposmarkv').css({ 'position': 'relative' });
    $('#resizeposmarkv').css({ 'z-index': 9999 });
    $('#resizeposmarkh').css({ 'position': 'relative' });
    $('#resizeposmarkh').css({ 'z-index': 9999 });
  } else if (isScrModeEditorTab()) { // In tablet mode
    $('#resetbutton').css({ 'position': 'relative' });
    $('#resetbutton').css({ 'z-index': 9999 });
    $('#pos_data_right').css({ 'position': 'relative' });
    $('#pos_data_right').css({ 'z-index': 9999 });
  }
}

/*
 * Restore the activated element.
 */
function restorePltPosOverlay() {
  if (isScrModePcEditor()) { // In pc mode
    $('.btnreset').css({ 'position': '' });
    $('.btnreset').css({ 'z-index': '' });
    $('#jogwindow').css({ 'z-index': '' });
    $('#resizeposmarkv').css({ 'position': '' });
    $('#resizeposmarkv').css({ 'z-index': '' });
    $('#resizeposmarkh').css({ 'position': '' });
    $('#resizeposmarkh').css({ 'z-index': '' });
  } else if (isScrModeEditorTab()) { // In tablet mode
    $('#resetbutton').css({ 'position': '' });
    $('#resetbutton').css({ 'z-index': '' });
    $('#pos_data_right').css({ 'position': '' });
    $('#pos_data_right').css({ 'z-index': '' });
  }
}                                 /**********************************************************************
 * PC Editor script
 * for Program file information and procedure.
 * Created: 2019/04/16
 */

/*
 * Class for program manager of program file information.
 *
 * Management of program file information object.
 * This class (and method) is static.
 * example) var programInfo = ProgramInfoManager.getCurrentProgInfo();
 *          ProgramInfoManager.pushProgInfo(progInfo);
 */
var ProgramInfoManager = (function () {
  var programInfoObj = [];  // Program information stack
  var progInfoIndex = 0;  // Index of referenced program information
  // for Move to program
  var moveToInfoObj = null;

  function l_initProgInfoManager() {
    programInfoObj.length = 0;
    progInfoIndex = 0;
  }
  function l_resetProgInfoManager() {
  //  var infoLeng = programInfoObj.length - 1;
  //  for (var i = 0; i < infoLeng; i++) {
  //    programInfoObj.pop();
  //  }
    progInfoIndex = 0;
  }
  function l_getProgInfoList() {
    return programInfoObj;
  }
  function l_setProgInfo(progInfo) {
    debug(DBGDUMP, 'setProgInfo: [' + progInfo.getProgName() + ']');
    programInfoObj = [];
    programInfoObj[0] = progInfo;
    progInfoIndex = 0;
  }
  function l_chgMainProgInfo(progInfo) {
    debug(DBGDUMP, 'chgMainProgInfo: [' + progInfo.getProgName() + ']');
    if (programInfoObj.length == 1) {
      programInfoObj[1] = programInfoObj[0];
    }
    programInfoObj[0] = progInfo;
  }
  function l_overwriteProgInfo(progInfo) {
    debug(DBGDUMP, 'overwriteProgInfo: [' + progInfo.getProgName() + ']');
    if (programInfoObj.length < 1) {
      l_setProgInfo(progInfo);
    } else {
      programInfoObj[1] = progInfo;
      progInfoIndex = 1;
    }
    return progInfoIndex; // return index.
  }
  function l_pushProgInfo(progInfo) {
    debug(DBGDUMP, 'pushProgInfo: [' + progInfo.getProgName() + ']');
    programInfoObj[programInfoObj.length] = progInfo;
    progInfoIndex = programInfoObj.length - 1;
    return progInfoIndex; // return index.
  }
  function l_prependProgInfo(progInfo) {
    var prepProgInfo = $.extend(true, {}, progInfo);  // Copy insert-program-info
    programInfoObj.unshift(prepProgInfo);
    progInfoIndex = 0;
  }
  function l_insertProgInfo(insPos, progInfo) {
    var insProgInfo = $.extend(true, {}, progInfo);  // Copy insert-program-info
    programInfoObj[insPos] = insProgInfo;
    progInfoIndex = insPos;
  }
  function l_updateProgInfo(progName, progInfo) {
    debug(DBGDUMP, 'updateProgInfo: [' + progName + ']');
    var updProgInfo = l_getSpecifiedProgInfo(progName);
    updProgInfo = $.extend(true, updProgInfo, progInfo);  // Marge / Update Program info
    return updProgInfo;
  }
  function l_getCurrentProgInfo() {
    return (programInfoObj.length == 0) ? null : programInfoObj[progInfoIndex];
  }
  function l_getSpecifiedProgInfo(progName) {
    var targetProg = getProdProgName(progName);
    if (targetProg == getMoveProgPrim()) {  // specified name is moveto program
      return moveToInfoObj;
    }
    var tempProgInfo = {};
    var idx = 0;
    for ( ; idx < programInfoObj.length; idx++) {
      if (targetProg == programInfoObj[idx].getProgName()) {
        tempProgInfo = programInfoObj[idx];
        break;
      }
    }
    progInfoIndex = idx;
    return tempProgInfo;
  }
  function l_getMainProgInfo() {
    return programInfoObj[0];
  }
  function l_getCurrentInfoIndex() {
    return progInfoIndex;
  }
  function l_setCurrentInfoIndex(index) {
    progInfoIndex = index;
  }
  function l_setMovetoProgInfo(movetoInfo) {
    moveToInfoObj = $.extend(true, {}, movetoInfo);
  }

  return {
    initProgInfoManager: l_initProgInfoManager,
    resetProgInfoManager: l_resetProgInfoManager,
    getProgInfoList: l_getProgInfoList,
    setProgInfo: l_setProgInfo,
    chgMainProgInfo: l_chgMainProgInfo,
    overwriteProgInfo: l_overwriteProgInfo,
    pushProgInfo: l_pushProgInfo,
    prependProgInfo: l_prependProgInfo,
    insertProgInfo: l_insertProgInfo,
    updateProgInfo: l_updateProgInfo,
    getCurrentProgInfo: l_getCurrentProgInfo,
    getSpecifiedProgInfo: l_getSpecifiedProgInfo,
    getMainProgInfo: l_getMainProgInfo,
    getCurrentInfoIndex: l_getCurrentInfoIndex,
    setCurrentInfoIndex: l_setCurrentInfoIndex,
    setMovetoProgInfo: l_setMovetoProgInfo
  }
})();

/*
 * Class for program file information and procedure.
 *
 * Definition for program file informations.
 * Usage: var programInfo = new ProgramFileInfo(); // important!
 *        example)
 *        programInfo.init(progName); // initialize with program name.
 *        var progPos = programInfo.getProgPos(); // get program position.
 */

// ----------------------
// Data table definition
// ----------------------
// === ATTR item table
var defaultAttr = {
  'jp': {
    'ｻｸｾｲｼｬ': 'PCEDITOR;',
    'ｺﾒﾝﾄ': '\"\";',
    'ﾌﾟﾛｸﾞﾗﾑ ｻｲｽﾞ': ';',
    'ｻｸｾｲ': ';',
    'ｼｭｳｾｲ': ';',
    'ﾌｧｲﾙ ﾒｲ': ';',
    'ﾊﾞｰｼﾞｮﾝ': '0;',
    'ｷﾞｮｳｽｳ': ';',
    'ﾒﾓﾘｰ ｻｲｽﾞ': ';',
    'ﾎｺﾞ': 'ﾖﾐｺﾐ ｶｷｺﾐ;',
    'TCD:  ｽﾀｯｸ ｻｲｽﾞ': '0,',
    '      ﾕｳｾﾝﾄﾞ': '50,',
    '      ﾀｲﾑ ｽﾗｲｽ': '0,',
    '      ﾋﾞｼﾞｰ ﾗﾝﾌﾟ ｵﾌ': '0,',
    '      ｷｮｳｾｲｼｭｳﾘｮｳ ﾖｳｷｭｳ': '0,',
    '      ｲﾁｼﾞﾃｲｼ ﾖｳｷｭｳ': '0;',
    'ﾋｮｳｼﾞｭﾝ ｸﾞﾙｰﾌﾟ': '1,*,*,*,*;',
    'ｺﾝﾄﾛｰﾙ ｺｰﾄﾞ': '00000000 00000000;'
  },
  'eg': {
    'OWNER': 'PCEDITOR;',
    'COMMENT': '\"\";',
    'PROG_SIZE': ';',
    'CREATE': ';',
    'MODIFIED': ';',
    'FILE_NAME': ';',
    'VERSION': '0;',
    'LINE_COUNT': ';',
    'MEMORY_SIZE': '1500;',
    'PROTECT': 'READ_WRITE;',
    'TCD:  STACK_SIZE': '0,',
    '      TASK_PRIORITY': '50,',
    '      TIME_SLICE': '0,',
    '      BUSY_LAMP_OFF': '0,',
    '      ABORT_REQUEST': '0,',
    '      PAUSE_REQUEST': '0;',
    'DEFAULT_GROUP': '1,*,*,*,*;',
    'CONTROL_CODE': '00000000 00000000;'
  }
};
var defaultAttrDate = {
  'jp': 'ﾋﾂﾞｹ yy-mm-dd  ｼﾞｺｸ hh:nn:ss;',
  'eg': 'DATE yy-mm-dd  TIME hh:nn:ss'
};
// Attributes to update when saving
var updateAttributeList = {
  'jp': {
    'ｼｭｳｾｲ': 'modified',
    'ｷﾞｮｳｽｳ': 'linecount'
  },
  'eg': {
    'MODIFIED': 'modified',
    'LINE_COUNT': 'linecount'
  }
};

var localRegsText = {
  'jp': 'ﾛｰｶﾙ ﾚｼﾞｽﾀ',
  'eg': 'LOCAL_REGISTERS',
};
var localRegTable = {
  "listAttrlocalNumReg": {
    valueId : "LOCAL_REGISTER",
    trgtId :"listAttrIptLocalNumReg",
    tooltipId :"tipLocalNumRegValOver",
    maxValue : 100
  },
  "listAttrlocalPosReg": {
    valueId : "LOCAL_POS_REGISTER",
    trgtId :"listAttrIptLocalPosReg",
    tooltipId :"tipLocalPosRegValOver",
    maxValue : 30
  },
  "listAttrlocalStrReg": {
    valueId : "LOCAL_STR_REGISTER",
    trgtId :"listAttrIptLocalStrReg",
    tooltipId :"tipLocalStrRegValOver",
    maxValue : 20
  },
};
// ----------------------
// Program file info class
// ----------------------
function ProgramFileInfo(progName) {
  /* Program name */
  var programName = progName;

  /* Attrribute text array object */
  var attribute = [];
  function l_getAttribute() {
    return attribute;
  }
  function l_putAttribute(attrPair) {
    attribute.push(attrPair);
  }
  function l_initAttribute() {
    attribute.length = 0;
  }
  // Default attribute set to attribute object
  function l_setDefaultAttr(progname) {
    var attrList = defaultAttr[getCurrentLanguage()];
    var index = 0;
    for (var key in attrList) {
      var val = attrList[key];
      var attrPair = {};
      switch (index) {
        case 3: // Create time
          var formatStr = defaultAttrDate[getCurrentLanguage()];
          var nowDate = new Date();
          val = l_formatDateStr(nowDate, formatStr);
          break;
        case 5: // File name
          val = progname;
          break;
      }
      attrPair.key = key;
      attrPair.val = val;
      attribute.push(attrPair);
      index++;
    }
  }
  function l_getDefaultAttrDate(lang) {
    return defaultAttrDate[lang];
  }
  // Formatting Date string
  function l_formatDateStr(dtObj, formatStr) {
    var yStr = ('00' + (dtObj.getFullYear() % 100)).slice(-2);
    var mStr = ('00' + (dtObj.getMonth() + 1)).slice(-2);
    var dStr = ('00' + dtObj.getDate()).slice(-2);
    var hStr = ('00' + dtObj.getHours()).slice(-2);
    var nStr = ('00' + dtObj.getMinutes()).slice(-2);
    var sStr = ('00' + dtObj.getSeconds()).slice(-2);
    var fmtStr = formatStr.replace("yy", yStr)
      .replace("mm", mStr)
      .replace("dd", dStr)
      .replace("hh", hStr)
      .replace("nn", nStr)
      .replace("ss", sStr);
    return fmtStr;
  }
  // Is attribute key modify target?
  // returun null = no, any string = modify target key
  function l_getUpdateAttribute(attrkey) {
    var updateAttr = updateAttributeList[getCurrentLanguage()];
    for (var key in updateAttr) {
      if (key == attrkey) { // match!
        return updateAttr[key];
      }
    }
    return null;
  }

  /* Editable Program Attribute */
  var editAttrValue = {};
  function l_getEditAttrValue() {
    return editAttrValue;
  }
  function l_setEditAttrValue(attrVal) {
    editAttrValue = JSON.parse(JSON.stringify(attrVal));
  }
  function l_putEditAttrValue(kind, value) {
    switch (kind) {
      case 'COMMENT':
        editAttrValue.COMMENT = value;
        break;
      case 'STACK_SIZE':
        editAttrValue.STACK_SIZE = value;
        break;
      case 'PAUSE':
        editAttrValue.PAUSE = value;
        break;
      case 'PROTECT':
        editAttrValue.PROTECT = value;
        break;
      case 'MTNGRP':
        editAttrValue.MTNGRP = value;
        break;
      case 'SUBTYPE':
        editAttrValue.SUBTYPE = value;
        break;
      default:
        debug(DBGERROR, "putEditAttrValue: Illegal attribute kind.");
    }
  }
  function l_initEditAttrValue() {
    l_putEditAttrValue('COMMENT', '');
    l_putEditAttrValue('STACK_SIZE', 0);
    l_putEditAttrValue('PAUSE', 0);
    l_putEditAttrValue('PROTECT', PROTECTOFF);
    var groupMax = l_initMtnGroup();
    l_putEditAttrValue('MTNGRP', groupMax);
    l_putEditAttrValue('SUBTYPE', top.MM_SUB_UNDEF_C);
  }
  /*
   * initial motion group .(check all group)
   */
  function l_initMtnGroup() {
    var allCheckGrp = 0;
    var maxGroup = getGroupCount(); // common api
    for (var grpNum = 0; grpNum < maxGroup; grpNum++) {
      allCheckGrp |= (1 << grpNum);
    }
    return allCheckGrp;
  }

  /* Mnemonic data object */
  var mnemonic = [];
  function l_getProgMnemonicStr() {  // return mnemonic string. (Concatenate each rows text.)
    var mnemStr = '';
    for (index in mnemonic) {
      if (index > 0) {
        mnemStr += CODECRLF;
      }
      mnemStr += mnemonic[index];
    }
    return mnemStr;
  }
  function l_initProgMnemonic() { // initialize mnemonic array.
    mnemonic.length = 0;
  }
  function l_getProgMnemonicArray() {
    return mnemonic;
  }
  function l_putProgMnemonicRow(line) {  // mnemonic text put to array.
   mnemonic.push(line);
  }
  function l_setProgMnemonicArray(mnArray) {
    mnemonic = JSON.parse(JSON.stringify(mnArray));
  }
  function l_getMnemonicLineCount() {
    return mnemonic.length;
  }

  /* Position data object */
  var position = [];
  function l_initProgPosition() {
    position.length = 0;
  }
  function l_getProgPositionArray() {
    return position;
  }
  function l_putProgPositionRow(pos) {
    position.push(pos);
  }
  function l_setProgPositionArray(posArray) {
    position = JSON.parse(JSON.stringify(posArray));
  }
  function l_getProgPositionElement(index) {
    return position[index];
  }
  function l_isExistProgPosition() {
    return (position.length > 0);
  }

  // Array of editing mnemonic text and position text.
  var editMnemonicArray = [];
  var editPositionArray = [];
  function l_initEditMnemonicArray() {
    editMnemonicArray.length = 0;
  }
  function l_initEditPositionArray() {
    editPositionArray.length = 0;
  }
  function l_getEditMnemonicArray() {
    return editMnemonicArray;
  }
  function l_getEditPositionArray() {
    return editPositionArray;
  }
  function l_setEditMnemonicArray(mnTextArray) {
    editMnemonicArray = mnTextArray;
  }
  function l_setEditPositionArray(posTextArray) {
    editPositionArray = posTextArray;
  }

  /* ==================================
     Inner functions.
  */
  function l_init(progName) {
    programName = progName;
    l_initAttribute();
    l_initProgMnemonic();
    l_initProgPosition();
  }
  function l_getProgName() {
    return programName;
  }
  function l_changeProgName(progName) {
    programName = progName;
  }

  return {
    init: l_init,
    getProgName: l_getProgName,
    changeProgName: l_changeProgName,
    getAttribute: l_getAttribute,
    putAttribute: l_putAttribute,
    initAttribute: l_initAttribute,
    setDefaultAttr: l_setDefaultAttr,
    getUpdateAttribute: l_getUpdateAttribute,
    getDefaultAttrDate: l_getDefaultAttrDate,
    formatDateStr: l_formatDateStr,
    initEditAttrValue: l_initEditAttrValue,
    getEditAttrValue: l_getEditAttrValue,
    setEditAttrValue: l_setEditAttrValue,
    putEditAttrValue: l_putEditAttrValue,
    getProgMnemonicStr: l_getProgMnemonicStr,
    initProgMnemonic: l_initProgMnemonic,
    getProgMnemonicArray: l_getProgMnemonicArray,
    putProgMnemonicRow: l_putProgMnemonicRow,
    setProgMnemonicArray: l_setProgMnemonicArray,
    getMnemonicLineCount: l_getMnemonicLineCount,
    initProgPosition: l_initProgPosition,
    getProgPositionArray: l_getProgPositionArray,
    putProgPositionRow: l_putProgPositionRow,
    setProgPositionArray: l_setProgPositionArray,
    getProgPositionElement: l_getProgPositionElement,
    isExistProgPosition: l_isExistProgPosition,
    initEditMnemonicArray: l_initEditMnemonicArray,
    getEditMnemonicArray: l_getEditMnemonicArray,
    setEditMnemonicArray: l_setEditMnemonicArray,
    initEditPositionArray: l_initEditPositionArray,
    getEditPositionArray: l_getEditPositionArray,
    setEditPositionArray: l_setEditPositionArray
  };
}
                                                                                                                                                /**********************************************************************
 * PC Editor script
 * for Find(Search)/Replace Dialog.
 * Created: 2019/03/11
 *
 */

var searchDialogId = 'searchDlg';
var repConfDialogId = 'repConfDlg';
var searchWordId = 'searchword';
var textEditorId = 'programtext';

/* === Dialog configure === */
function configSearchDialog(dlgIdStr, query) {
  //var editorZIndex = document.getElementById('#' + textEditorId).style.zIndex;
  var dlgConf = $('<div>', { id: dlgIdStr, 'class': 'modelessdlg' });
  dlgConf.css({ 'width': '535px', 'display': 'block', 'top': '90px', 'left': '450px' });
  var dlgTtl = $('<div>', { id: dlgIdStr + 'Ttl', 'class': 'dlgtitlebar' });
  dlgTtl.html('Find / Replace');
  var ttlCancel = $('<div>', { id: 'dlgTtlCancel', 'class': 'dlgttlbarbtn' });
  var ttlBtn = $('<img>',
    { id: 'ttlCancelBtn', 'src': 'images/closeicon.png', 'class': 'dlgttlbtnimg' });
  ttlCancel.append(ttlBtn);
  dlgTtl.append(ttlCancel);
  dlgConf.append(dlgTtl);
  var dlgMsg = $('<p>');
  var srhTblFlm = $('<div>', { 'class': 'dlgtblflm' });
  var srhRepTable = $('<table>', { rules: 'none', 'id': 'findtable'});
  srhRepTable.css({'height': '40px'});
  // Editattribute Find
  var srhRepTr = $('<tr>', {'id': 'findrow'});
  srhRepTr.css({'height': '50%'});
  var srhRepTd = $('<td>', { 'class': 'dlgattrtitle' });
  var toggleMark = $('<button>', { 'id': 'tglmark', 'type' : 'button', 'class': 'dlgpousebtnoff attrleftbtn' });
  toggleMark.css({'width': '30px', 'height': '28px'});
  toggleMark.html(' &gt; ');
  srhRepTd.append(toggleMark);
  srhRepTr.append(srhRepTd);
  srhRepTd = $('<td>', { 'class': 'dlgattrtitle' });
  srhRepTd.css({'min-width': '52px'});
  srhRepTd.html('Find');
  srhRepTr.append(srhRepTd);
  srhRepTd = $('<td>');
  var inputForm = $('<div>', { 'id': 'iptFindForm' });
  var srhRepInput = $('<input>', { 'type': 'text', 'id': 'iptFindWord', 'class': 'dlgiptcommbox', 'maxlength': 16, 'tabindex': 1 });
  srhRepInput.css({'height': '22px'});
  inputForm.append(srhRepInput);
  srhRepTd.append(inputForm);
  srhRepTr.append(srhRepTd);
  srhRepTd = $('<td>');
  var backBtn = $('<button>', { 'type' : 'button', 'id': 'findPrevBtn', 'class': 'dlgpousebtnoff attrleftbtn' });
  backBtn.css({'width': '60px', 'height': '28px', 'margin-left': '8px'});
  backBtn.html(' < ');
  var nextBtn = $('<button>', { 'type' : 'button', 'id': 'findNextBtn', 'class': 'dlgpousebtnoff attrleftbtn' });
  nextBtn.css({'width': '60px', 'height': '28px'});
  nextBtn.html(' > ');
  srhRepTd.append(backBtn);
  srhRepTr.append(srhRepTd);
  srhRepTd = $('<td>');
  srhRepTd.append(nextBtn);
  srhRepTr.append(srhRepTd);
  srhRepTd = $('<td>');
  var closeBtn = $('<button>', { 'type' : 'button', 'id': 'findCloseBtn', 'class': 'dlgpousebtnoff attrleftbtn' });
  closeBtn.css({'width': '60px', 'height': '28px'});
  closeBtn.html('Close');
  srhRepTd.append(closeBtn);
  srhRepTr.append(srhRepTd);
  srhRepTable.append(srhRepTr);
  //Editattribute Replace
  srhRepTr = $('<tr>', { 'id': 'replacerow'});
  srhRepTr.css({'height': '50%', 'display': 'none'});
  srhRepTd = $('<td>', { 'class': 'dlgattrtitle' });
  toggleMark = $('<div>', { 'id': 'tglmark' });
  toggleMark.css({'width': '30px', 'height': '28px'});
  toggleMark.html(' &nbsp; ');
  srhRepTd.append(toggleMark);
  srhRepTr.append(srhRepTd);
  srhRepTd = $('<td>', { 'class': 'dlgattrtitle' });
  srhRepTd.css({'min-width': '52px'});
  srhRepTd.html('Replace');
  srhRepTr.append(srhRepTd);
  srhRepTd = $('<td>');
  inputForm = $('<div>', { 'id': 'iptRepForm' });
  srhRepInput = $('<input>', { 'type': 'text', 'id': 'iptRepWord', 'class': 'dlgiptcommbox', 'maxlength': 16, 'tabindex': 1 });
  srhRepInput.css({'height': '22px'});
  inputForm.append(srhRepInput);
  srhRepTd.append(inputForm);
  srhRepTr.append(srhRepTd);
  srhRepTd = $('<td>');
  var repOneBtn = $('<button>', { 'type' : 'button', 'id': 'replaceOneBtn', 'class': 'dlgpousebtnoff attrleftbtn' });
  repOneBtn.css({'width': '60px', 'height': '28px', 'margin-left': '8px'});
  repOneBtn.html('Replace');
  var repAllBtn = $('<button>', { 'type' : 'button', 'id': 'replaceAllBtn', 'class': 'dlgpousebtnoff attrleftbtn' });
  repAllBtn.css({'width': '60px', 'height': '28px'});
  repAllBtn.html('All');
  srhRepTd.append(repOneBtn);
  srhRepTr.append(srhRepTd);
  srhRepTd = $('<td>');
  srhRepTd.append(repAllBtn);
  srhRepTr.append(srhRepTd);
  srhRepTd = $('<td>');
  var emptyBtn = $('<div>');
  emptyBtn.html('&nbsp;');
  srhRepTd.append(emptyBtn);
  srhRepTr.append(srhRepTd);
  srhRepTable.append(srhRepTr);
  // all append
  srhTblFlm.append(srhRepTable);
  var srhRepForm = $('<form>', { 'id': 'dlgSrhRepForm' });
  srhRepForm.append(srhTblFlm);
  dlgConf.append(srhRepForm);
  $('body').append(dlgConf);
}
function configRepConfDialog(dlgIdStr) {
  //var editorZIndex = document.getElementById('#' + textEditorId).style.zIndex;
  var dlgConf = $('<div>', { id: dlgIdStr, 'class': 'modaldlg' });
  dlgConf.css({ 'width': '290px', 'display': 'block', 'top': '90px', 'left': '450px' });
  var dlgTtl = $('<div>', { id: dlgIdStr + 'Ttl', 'class': 'dlgtitlebar' });
  dlgTtl.html('Confirm');
  var ttlCancel = $('<div>', { id: 'dlgTtlCancel', 'class': 'dlgttlbarbtn' });
  var ttlBtn = $('<img>',
    { id: 'ttlCancelBtn', 'src': 'images/closeicon.png', 'class': 'dlgttlbtnimg' });
  ttlCancel.append(ttlBtn);
  dlgTtl.append(ttlCancel);
  dlgConf.append(dlgTtl);
  var dlgMsg = $('<p>');
  dlgMsg.attr('id', 'confmsgid');
  dlgMsg.addClass('dlgcontent');
  dlgMsg.html('Replace?');
  dlgConf.append(dlgMsg);
  var dlgBtn = $('<div align="center" style="clear: both;">');
  var btnClass = 'dlgbutton okyes btnok';
  var btnObj = $('<button>', { type: 'button', id: 'repconfok', 'class': btnClass, value: 'yes' });
  btnObj.css({'width': '80px'});
  btnObj.html('Yes');
  dlgBtn.append(btnObj);
  btnClass = "dlgbutton nocancel btnng";
  var btnObj = $('<button>',
    { type: 'button', id: 'repconfng', 'class': btnClass, value: 'ng' });
  btnObj.css({'width': '80px'});
  btnObj.html('No');
  dlgBtn.append(btnObj);
  btnClass = "dlgbutton nocancel btncancel";
  var btnObj = $('<button>',
    { type: 'button', id: 'repconfcancel', 'class': btnClass, value: 'cancel' });
  btnObj.css({'width': '80px'});
  btnObj.html('Cancel');
  dlgBtn.append(btnObj);
  dlgConf.append(dlgBtn);
  $('body').append(dlgConf);
}

// Definition of usage functions.
// matchList : list of search result.
// crntCsrPos : current cursor position.
// srhDirect : direnction of search. (-1=search previous, 1=search next)
// queryLeng : text length of search query.
function searchNextCsrPos(matchList, crntCsrPos, srhDirect, queryLeng) {
  // Copy to next cursor position from current cursor position.
  var findPos = {};
  findPos.from = $.extend({}, crntCsrPos);
  findPos.from.ch += srhDirect;
  findPos.to = $.extend({}, crntCsrPos);
  findPos.to.ch = findPos.from.ch + queryLeng;
  // Loop list length
  var findNextPos = -1;
  for (var listIndex in matchList) {
    // Search current pos and next pos
    var fromPos = matchList[listIndex].from;
    // Compare line pos.
    if (findPos.from.line == fromPos.line) {	// Same line.
      // Compare char pos.
      if (findPos.from.ch < fromPos.ch) {	// forward char.
        findNextPos = listIndex;
        break;
      }
    } else if (findPos.from.line < fromPos.line) {	// forwatd line.
      findNextPos = listIndex;
      break;
    }
  }
  if (srhDirect < 0) {	// direction is previous.
    if (findNextPos == 0) {	// but prev pos is not found.
      findNextPos = matchList.length;	// set end of list.
    }
    findNextPos--;
  } else if (srhDirect > 0) {	// direction is next.
    if (findNextPos == -1) {	// if next pos is not found.
      findNextPos = 0;	// set top of list.
    }
  }
  // Set line/ch to next position
  var nextPos = {};
  nextPos.from = matchList[findNextPos].from;
  nextPos.to = matchList[findNextPos].to;
  return nextPos;
}
// Prev/Next button procedure.
function searchButtonProc(pcEditor, srhDirct, srhOption) {
  var state = pcEditor.state;
  var query = $('#iptFindWord').val();
  if ((state.search == undefined) || (state.search.queryText == undefined) ||
    (state.search.queryText.toUpperCase() != query.toUpperCase())) {
    srhOption.newSearch(pcEditor, srhOption, query);
  } else {
    var matchList = state.search.annotate.matches;
    // get current cursor position
    var crntCsrPos = pcEditor.getCursor();
    // search match position after current position
    var nextCsrPos = searchNextCsrPos(matchList, crntCsrPos, srhDirct, state.search.annotate.query.length);
    // set cursor to match position
    pcEditor.setCursor(nextCsrPos.from);
    pcEditor.setSelection(nextCsrPos.to, nextCsrPos.from);
  }
}
// Replace One/Replace All button procedure.
function replaceButtonProc(pcEditor, isAll, srhOption) {
  var query = $('#iptFindWord').val();
  var reptxt = $('#iptRepWord').val();
  srhOption.repFunc(pcEditor, query, reptxt, isAll, saveRepAllCallback);	// cm.search.js
}
// Save 1-line when Replace all.
function saveRepAllCallback(repArgs) {
  var crntLine = repArgs.cursor.from();
  var csrcopy = $.extend({}, repArgs.cursor);
  if (csrcopy.findNext()) {	// exist next target.
    var nextLine = csrcopy.from();
    if (crntLine.line != nextLine.line) {	// if next pos is same line, no save.
      saveEditReplaceLine(repArgs, crntLine);	// prgwin
    } else {
      repArgs.nextRep(repArgs);
    }
  }
}
// Variables for replace information
var crntReplacePos = {};
// Replace confirm Yes/No/Cancel button procedure.
function replaceConfirmProc(kind, srhOption) {
  crntReplacePos = srhOption.cm.getCursor();
  if (kind == REPLACE_YES) {	// Yes
    srhOption.callback[0]();
    var nextReplacePos = srhOption.cm.getCursor();
    srhOption.cm.save();	// save(reflect) replace result.
    if (crntReplacePos.line != nextReplacePos.line) {
      var repArgs = {};
      saveEditReplaceLine(repArgs, crntReplacePos);	// prgwin
    }
  } else if (kind == REPLACE_NO) {	// No
    srhOption.callback[1]();
  } else if (kind == REPLACE_CLOSE) {	// Cancel(Close)
    srhOption.cancel(srhOption.cm);
    repConfDialog.close();
  }
}

// Dialog main procedure.
$(function () {
  // Dialog process definition.
  searchDialog = {
    isDialogOpen: function () {
      return $('#' + searchDialogId).length > 0;
    },
    setFocus: function () {
      var textBox = $('#' + searchDialogId).find('#' + searchWordId);
      if (textBox.length > 0) {
        $('#' + searchWordId).val("").focus();
      } else {
        $('.btnnext').focus();
      }
    },
    // Open dialog.
    // srhOption: 'text': text, 'callback': f, value: deflt, selectValueOnOpen: true
    open: function (pcEditor, srhOption) {	// srhOption from search.js(Codemirror)
      var dlgId = '#' + searchDialogId;
      configSearchDialog(searchDialogId, srhOption);
      $(dlgId).fadeIn("middle");
      $('#iptFindWord').focus();
      $('.modelessdlg').on('keydown', function (event) {
        if (event.which == KEYCODE_ENTER) {
          var targetId = event.target.id;
          if (targetId == 'iptFindWord') {
            $('#findNextBtn').trigger('click');
          } else if (targetId == 'iptRepWord') {
            $('#replaceOneBtn').trigger('click');
          } else {
            $('#findCloseBtn').click();
          }
          return false;
        } else if (event.which == KEYCODE_TAB) {
          var elem = $('#dlgSrhRepForm')[0];
          var tabLeng = elem.length;
          var nxttabidx = event.target.tabIndex;
          nxttabidx = (event.shiftKey) ? nxttabidx - 1 : nxttabidx + 1;
          if (nxttabidx > tabLeng) {
            nxttabidx = 1;
          } else if (nxttabidx <= 0) {
            nxttabidx = tabLeng;
          }
          elem[nxttabidx - 1].focus();
          return false;
        } else if (event.which == KEYCODE_ESC) {
          $('#findCloseBtn').click();
          return false;
        }
      });
      // Dialog button process
      // Toggle Fine/Replace change button
      $('#tglmark').on('click', function (event) {
        if ($('#replacerow').is(':visible')) {
          $('#replacerow').hide();
          $('#findtable').css({'height': '40px'});
          $('#tglmark').html(' &gt; ');
          $('#iptFindWord').focus();
        } else {
          $('#findtable').css({'height': '80px'});
          $('#replacerow').show();
          $('#tglmark').html(' v ');
          $('#iptRepWord').focus();
        }
      });
      // Close button
      $('#findCloseBtn').on('click', function (event) {
        $('#' + searchDialogId).hide();
        $('#' + searchDialogId).remove();
        CodeMirror.commands.clearSearch(pcEditor);	// Clear search effect.
        if (!isScrModeProgAttr()) {
          var csrLine = pcEditor.getCursor().line;
          var csrChar = pcEditor.getCursor().ch;
          var scrlLeft = $(window).scrollLeft();
          var scrlTop = $(window).scrollTop();
          pcEditor.focus();
          // Return the scroll position to its before position.
          window.scrollTo(scrlLeft, scrlTop);
          pcEditor.setCursor({ line: csrLine, ch: csrChar });
        }
        return false;
      });
      // Title Cancel button
      $('#dlgTtlCancel').on('click', function (event) {
        $('#findCloseBtn').click();
      });
      // Find Next button
      $('#findNextBtn').on('click', function (event) {
        searchButtonProc(pcEditor, SEARCH_FIND_NEXT, srhOption);
      });
      // Find Prev button
      $('#findPrevBtn').on('click', function (event) {
        searchButtonProc(pcEditor, SEARCH_FIND_PREV, srhOption);
      });
      // Replace One button
      $('#replaceOneBtn').on('click', function (event) {
        replaceButtonProc(pcEditor, false, srhOption);
      });
      // Replace All button
      $('#replaceAllBtn').on('click', function (event) {
        replaceButtonProc(pcEditor, true, srhOption);
      });
    }
  },
  repConfDialog = {
    open: function (pcEditor, srhOption) {	// srhOption from search.js(Codemirror)
      var dlgId = '#' + repConfDialogId;
      if ($(dlgId).length > 0) {
        $(dlgId).focus();
        return;
      }
      configRepConfDialog(repConfDialogId, srhOption);
      $(dlgId).fadeIn("middle");
      // Confirm YES
      $('#repconfok').on('click', function (event) {
        replaceConfirmProc(REPLACE_YES, srhOption);
      });
      // Confirm NO
      $('#repconfng').on('click', function (event) {
        replaceConfirmProc(REPLACE_NO, srhOption);
      });
      // Confirm Cnacel
      $('#repconfcancel').on('click', function (event) {
        replaceConfirmProc(REPLACE_CLOSE, srhOption);
      });
    },
    close: function () {
      $('#' + repConfDialogId).hide();
      $('#' + repConfDialogId).remove();
      $('#findCloseBtn').click();
    }
  }
});                                                                                                               PCEDI~29JS    MjXX  MjX*!A  BS      V I S I O  N _ C M D S   . J VISION~1JS    MjXX  MjXK.                                                                                                                                                                                                                                                                                                                                                                                                  /**********************************************************************
 * Robot Program Editor script
 * auto complete command script
 * Created: 2019/10/11 FSI
 */

// Auto Complete Text Table
var allCmdList = []; // comand(all)
var calcPrmList = []; // paramerter(in calc)
var cmdTable = []; // comand(Retention param list)
var prmTable = {}; // paramerter(Retention analysis method)

// List of parameters not yet analyzed
var restParam = [];

/********************************************
 * Initialyze Autocomplete text list
 ********************************************/
function initAutoComp(paramList) {

  // Construct Auto Complete Command Table
  var autoCompItem = paramList;
  var buildCmdList = [];
  
  for (j = 0; j < autoCompItem.length; j++) {
    var compItem = autoCompItem[j];

    if (compItem.type == "ORDERTABLE") { // for cmdTable
      var proc = ((compItem.value.indexOf("]=") != -1) ? "LEFT_IND" : "NO_PROC");
      var cmdLeaf = { "head": compItem.value, "proc": proc, "param": compItem.param };
      cmdTable.push(cmdLeaf);
      buildCmdList.push(compItem.value);

    } else if (compItem.type == "PARAM") { // for prmTable
      prmTable[compItem.value] = compItem.search;
      if (compItem.calc == "true") {
        calcPrmList.push(compItem.value);
      }

    } else if (compItem.type == "ORDER") { // for allCmdList
      var setItemVal = $('<div />').html(compItem.value).text(); // decode quote (&#39 --> ')
      buildCmdList.push(setItemVal);
    }
  }

  // Escape regular expressions and prevents double registration.
  allCmdList = buildCmdList.filter(function (x, i, self) {
    if ((self.indexOf(x) === i) && (!checkReg(x))) {
      return true;
    } else {
      return false;
    }
  });

}


/********************************************
 * Return Autocomplete text list
 * Call main process or extra process
 ********************************************/
function getAutoCompList(text, ch) {

  // The list for autocomplete
  var atCmpTable = [[], ""];
  // The character string before the cursor
  var bfText = text.slice(0, ch); 
  // Identify the next action from the argument.
  var parseFunc = getParseFunc(bfText);
  // Clear List remains a list of parameters.
  restParam = [];

  switch (parseFunc) {
    case 'CMD_CALC': // Show exclusive suggestions
      atCmpTable = [calcPrmList, bfText];
      break;
		case 'CMD_INDIRECT': // Don 't show suggestions
    case 'CMD_COMMENT':
      break;
    case 'CMD_NORMAL': // Search and show suggestions
      atCmpTable = autoCompCtrlProc(bfText, null, null, 0);
      parseFunc = ((atCmpTable[1] == bfText) ? 'CMD_COMAND' : parseFunc);
      break;
    default:
      break;
  }
  atCmpTable.push(parseFunc);
  return atCmpTable;

}

/********************************************
 * Identify the next action from the argument
 ********************************************/
function getParseFunc(bfText) {

  var startCalcCnt = ((bfText.match(/\(/g) == null) ? 0 : bfText.match(/\(/g).length);
  var endCalcCnt = ((bfText.match(/\)/g) == null) ? 0 : bfText.match(/\)/g).length);
  var startIndCnt = ((bfText.match(/\[/g) == null) ? 0 : bfText.match(/\[/g).length);
  var endIndCnt = ((bfText.match(/\]/g) == null) ? 0 : bfText.match(/\]/g).length);

  // Entering comments
  if (bfText.indexOf("!") !== -1) {
    return 'CMD_COMMENT';
  }
  // Entering an equation
  if (startCalcCnt > endCalcCnt) {
    return 'CMD_CALC';
  }
  // Entering Indirect designation
  if (startIndCnt > endIndCnt) {
    return 'CMD_INDIRECT';
  }
  // other
  return 'CMD_NORMAL';

}

/********************************************
 * Complements instructions that are no longer displayed
 *  due to instruction identification.
 ********************************************/
function getSuppCmdList(str, upStr) {
  var cmdStr = [];
  var trgtStr = str.replace(/^\s+/g, '');

  //  Stores the instruction that matches the string in the array
  for (i = 0; i < allCmdList.length; i++) {
    var resultStr = allCmdList[i].indexOf(trgtStr);
    if ((resultStr === 0) && (allCmdList[i] != trgtStr)) {
      cmdStr.push(allCmdList[i].slice(trgtStr.length - upStr.length));
    }
  }

  return cmdStr;
}

/********************************************
 * Main Process
 * = str : String to search for
 * = res : Previous analysis results
 * = cmd : Identified instruction
 * = num : Number of analyzes
 ********************************************/
function autoCompCtrlProc(str, res, cmd, num) {
  // Remove leading white space
  var trgtStr = str.replace(/^\s+/g, '');
  var nextParam = "pal" + num;

  var result = {
    "str": null,  // String to search for next
    "res": [],    // Autocomplete list returned at the end of recursion
    "cmd": null,  // Identified instruction
    "num": null,  // Number of analyzes next
    "stat": false // Whether to continue recursion
  };
  // --- (1) If the command is unspecified, specify it.
  if (cmd == null) {
    result = searchCmd(trgtStr);

  // --- (2) When the search target is empty, return next parameter.
  } else if (trgtStr == "") { 
    var returnArr = getSpecdPrmList(cmd, nextParam);
    result["res"] = returnArr;

  // --- (3) The paramlist is exhausted, the search is terminated.
  } else if (Object.keys(cmd[0]["param"]).length < num) { 
    
    // If you have more than one command, continue processing.
    if (cmd.length != 1) {
      // Remove the first command and re-enter the function.
      var nextCmd = cmd;
      nextCmd.shift();
      result = setResult(str, res, nextCmd, num, true);
    }

  // --- (4) Identify the parameters.   
  } else {
    result = searchPrm(trgtStr, cmd, num);
  }

  // --- (5) Proceed to the next recursion based on the analysis result.
  if (result["stat"]) {
    return autoCompCtrlProc(result["str"], result["res"], result["cmd"], result["num"]);

  } else {
    var restPal = checkRestParam(str, result["str"], res, result["res"]);

    // --- (5) Proceed to the next recursion based on the analysis result.
    if ((restPal["stat"]) && (result["res"].length == 0)) {
      return autoCompCtrlProc(restPal["str"], restPal["res"], restPal["cmd"], restPal["num"]);

    // --- (*) end of recursion and return result.
    } else {
      return [result["res"], str];
    }
  }
}

/********************************************
 * Search for command Process
 * = str : String to search for
 ********************************************/
function searchCmd(str) {
  var cmdStr = [];
  var trgtStr = str;

  //  Stores the instruction that matches the string in the array
  for (i = 0; i < cmdTable.length; i++) {
    var header = cmdTable[i]["head"];
    trgtStr = str;
    
    // Remove indirect contents
    if ((str.indexOf("[") != -1) && (str.indexOf("]") != -1)) {
      trgtStr = removeInd(trgtStr, cmdTable[i]["proc"]);
    }

    var resultStr = ((checkReg(header)) ? matchStr(trgtStr, header, false) : trgtStr.indexOf(header));
    if (resultStr === 0) {
      var compCmdLen = getCmdLenDiff(trgtStr, header, cmdStr);
      if (compCmdLen > 0) { // Initialize the array if it matches longer command
        cmdStr = [];      
      }
      // If it is not shorter than the command in the cmdStr, store it in the array
      if (compCmdLen > -1) {
        cmdStr.push(cmdTable[i]);
      }
    }
  }
  // Returns a command list if there is no matching instruction
  if (cmdStr.length == 0) {
    return setResult(null, allCmdList, null, null, false);
  } else {
    // Cut the header of the command from the string and start analyzing Parameters
    var cmdHead = cmdStr[0]["head"];
    var slicePos = ((checkReg(cmdHead)) ? matchStr(str, cmdHead, true) : cmdHead.length);
    var nextStr = trgtStr.slice(slicePos);
    return setResult(nextStr, null, cmdStr, 1, true);
  }
}

/********************************************
 * Search for parameters Process
 * = str : String to search for
 * = cmd : Identified instruction
 * = num : Number of parameter to search
 ********************************************/
function searchPrm(str, cmd, num) {
  var trgtStr = str; // Operation string
  var sendPrmList = null;
  var sendCmdList = cmd.concat();
  var paramNum = "pal" + num;
  var cmdStr = [];

  for (i = 0; i < cmd.length; i++){
    var trgtPrm = cmd[i]["param"][paramNum];
    var prmStr = null;

    // if trgtPrm is nothing, skip search
    if (typeof trgtPrm === 'undefined') {
      continue;
    }

    for (k = 0; k < trgtPrm.length; k++) {
      if (typeof prmTable[trgtPrm[k]] === 'undefined') {
        // Prepare to re-enter instruction completion
        cmdStr = cmdStr.concat(searchPrmCmd(trgtStr, trgtPrm[k]));
        continue;
      }      
      if (matchStr(trgtStr, prmTable[trgtPrm[k]], false) == 0) {
        prmStr = trgtPrm[k];
      }
    }
    // Insert specified instruction
    if (prmStr != null) {
      sendPrmList = prmStr;

    } else if (sendCmdList.length != 1) {
      var delCmdCnt = cmd.length - sendCmdList.length;
      sendCmdList.splice(i - delCmdCnt, 1);
    }
  }

  if (cmdStr.length > 0) {
    // Cut the header of the command from the string and start analyzing Parameters
    var cmdHead = cmdStr[0]["head"];
    var slicePos = ((checkReg(cmdHead)) ? matchStr(str, cmdHead, true) : cmdHead.length);
    // Remove indirect contents
    if ((str.indexOf("[") != -1) && (str.indexOf("]") != -1)) {
      trgtStr = removeInd(trgtStr, cmdStr[0]["proc"]);
    }
    var nextStr = trgtStr.slice(slicePos);
    restParam.push({ "cmd": cmd, "num": num + 1 });
    return setResult(nextStr, null, cmdStr, 1, true);

  } else if (sendPrmList == null) {
    // Remove duplicate parameters.
    var returnArr = getSpecdPrmList(cmd, paramNum);
    return setResult(null, returnArr, null, null, false);

  } else {
    var nextStr = trgtStr.slice(matchStr(trgtStr, prmTable[sendPrmList], true));
    return setResult(nextStr, sendPrmList, sendCmdList, num + 1, true);

  }
}

/********************************************
 * Search for commands from the set parameters
 * = str : String to search for
 * = cmd : Search word(forward match)
 ********************************************/
function searchPrmCmd(str, cmd) {
  var cmdStr = [];
  var trgtStr = str;

  // search cmd in cmdTable
  var trgtCmdNum = [];
  for (j = 0; j < cmdTable.length; j++){
    if (cmdTable[j]["head"] == cmd) {
      trgtCmdNum.push(j);
    }
  }
  // not registered
  if (trgtCmdNum.length == 0) {
    return cmdStr;
  }
  // Remove indirect contents
  if ((str.indexOf("[") != -1) && (str.indexOf("]") != -1)) {
    trgtStr = removeInd(trgtStr, cmdTable[trgtCmdNum[0]]["proc"]);
  }
  var header = cmdTable[trgtCmdNum[0]]["head"];
  var resultStr = ((checkReg(header)) ? matchStr(trgtStr, header, false) : trgtStr.indexOf(header));
  
  if (resultStr === 0) {
    for (i = 0; i < trgtCmdNum.length; i++) {
      cmdStr.push(cmdTable[trgtCmdNum[i]]);
    }
  }
  return cmdStr;

}

/********************************************
 * Remove indirect contents (Only once)
 ********************************************/
function removeInd(str, proc) {
  var trgtStr = str; // Operation string
  var startInd = str.indexOf("[");
  var endIndStr = ((proc == "LEFT_IND") ? "]=" : "]");
  var endInd = str.indexOf(endIndStr);

  // If the string structure is wrong(][), the process will be stopped.
  if (startInd > endInd) {
    return str;
  }

  // If indirect is inside, resetting the deletion position.
  var count = (str.slice(startInd + 1, endInd).match(/\[/g) || []).length;
  if (count > 0) {
    while (0 < count) {
      trgtStr = trgtStr.replace(/\]/, "[");
      count--;
    }
    endInd = trgtStr.indexOf(endIndStr);
  }

  // If the resetting is successful, 
  // the character string with the indirect specification deleted is returned.
  if (endInd != -1) {
    trgtStr = str.slice(0, startInd + 1) + str.slice(endInd);
    trgtStr = addComma(str.slice(startInd, endInd), trgtStr);
    return trgtStr;

  } else {
    return str;
  }

}

/********************************************
 * Compare the length of the latest command and stock command
 ********************************************/
function getCmdLenDiff(str, cmd, cmdList) {
  var diffCmdLen = 0;
  var cmdLength = cmd.length;

  // Returns true if there is no command stock in the cmdList
  if (cmdList.length == 0) {
    return diffCmdLen;
  }
  var stkCmdLength = cmdList[0]["head"].length;

  // If command is written in regular expression, recount the number of characters
  if (checkReg(cmd)) {
    cmdLength = matchStr(str, cmd, true);
  }
  if (checkReg(cmdList[0]["head"])) {
    stkCmdLength = matchStr(str, cmdList[0]["head"], true);
  }
  // Compare the length of the latest command and stock command
  diffCmdLen = cmdLength - stkCmdLength;
  return diffCmdLen;
}

/********************************************
 * Add deleted commas
 ********************************************/
function addComma(cutstr, str) {
  var replaceStr = "[";
  var addCmm = "";
  var commaCount = cutstr.match(/,/g);

  if (commaCount == null) {
  } else if (commaCount[0].length > 1) {
    addCmm = " , , ";
  } else if (commaCount[0].length == 1) {
    addCmm = ",";
  }
  replaceStr += addCmm + "]";
  var trgtStr = str.replace("[]", replaceStr);

  return trgtStr;
}

/********************************************
 * Get parameter list for a specified command
 ********************************************/
function getSpecdPrmList(cmd, num) {
  var prmArr = [];

  // Returns parameters that can be entered at this position.
  for (i = 0; i < cmd.length; i++) {
    if (typeof cmd[i]["param"][num] !== 'undefined') {
      prmArr = prmArr.concat(cmd[i]["param"][num]);
    }
  }
  // Remove duplicate parameters and regular expressions.
  var returnArr = prmArr.filter(function (x, i, self) {
    if ((self.indexOf(x) === i) && (!checkReg(x))) {
      return true;
    } else {
      return false;
    }
  });
  return returnArr;
}

/********************************************
 * Determine if string is regular expression
 ********************************************/
function checkReg(str) {
  return str.indexOf("/") === 0;
}

/********************************************
 * Set data in array form to result
 ********************************************/
function setResult(str, res, cmd, num, stat) {
  return { "str": str, "res": res, "cmd": cmd, "num": num, "stat": stat };
}

/********************************************
 * Return whether there remains a list of parameters that have not yet been analyzed.
 ********************************************/
function checkRestParam(str, resultStr, res, resultRes) {
  var nextObj = {
    "str": ((resultStr == null) ? str : resultStr),
    "res": ((resultRes == null) ? res : resultRes),
    "cmd": null,
    "num": 0,
    "stat": false
  }

  // If there is a parameter that has not been searched yet, it will be processed.
  if (restParam.length > 0) {
    nextObj["cmd"] = restParam[restParam.length - 1]["cmd"];
    nextObj["num"] = restParam[restParam.length - 1]["num"];
    restParam.pop();
  }

  // Check if the parameter actually exists.
  if (nextObj["cmd"] != null) {
    var sendCmdList = nextObj["cmd"].concat();
    var nextNum = "pal" + nextObj["num"]

    for (i = 0; i < nextObj["cmd"].length; i++) {
      if (typeof nextObj["cmd"][i]["param"][nextNum] === 'undefined') {
        var delCmdCnt = nextObj["cmd"].length - sendCmdList.length;
        sendCmdList.splice(i - delCmdCnt, 1);
      }
    }
    nextObj["cmd"] = sendCmdList.concat();

    //  If there is at least one parameter to search, flag "success" to recurse.
    if (nextObj["cmd"].length != 0) {
      nextObj["stat"] = true;
    }
  }

  return nextObj;
}

/********************************************
 * Return match result or length of matched string
 ********************************************/
function matchStr(str, header, len) {
  var result = str.match(header.slice(1).slice(0, -1));

  if (result == null) { // failure
    return -1;  
  } else if (len) { // return length of match string
    return result[0].length;
  } else {
    return 0; // return "0", which is the same value as determined by indexOf(heads match)
  }
}                                                                                                                                                                                                                               /**********************************************************************
 * Robot Program Editor script
 * Command List Definition table for Vision
 * Created: 2018/10/30
 *
 */

/* === definition Vision command list === */
var visCommandTree = {
    'eg': [{
        'data': {
            'addParam': '{"cmdId":"GRPVISION"}', 'text': 'Vision', 'value': '', className: 'tree-select-closed'
        },
        'children': [
            {
                'data': {
                    'text': 'RUN_FIND', 'value': '', 'addParam': '{"cmdId":"GRPRUN_FIND"}', className: 'tree-select-closed'
                }, 'children': [{
                    'data': {
                        'addParam': '{"cmdId":"CMDRUNFIND", "tblId":"TBLRUNFIND", "parent":"GRPVISION"}', 'text': 'RUN_FIND ...', 'value': 'VISION RUN_FIND \'...\''
                    }, 'children': []
                },
                {
                    'data': {
                        'addParam': '{"cmdId":"CMDRUNFIND", "tblId":"TBLRUNFIND", "parent":"GRPVISION"}', 'text': 'RUN_FIND ... VIEW', 'value': 'VISION RUN_FIND \'...\' CAMERA_VIEW[...]'
                    }, 'children': []
                },
                {
                    'data': {
                        'addParam': '{"cmdId":"CMDRUNFIND", "tblId":"TBLRUNFIND", "parent":"GRPVISION"}', 'text': 'RUN_FIND SR', 'value': 'VISION RUN_FIND SR[...]'
                    }, 'children': []
                },
                {
                    'data': {
                        'addParam': '{"cmdId":"CMDRUNFIND", "tblId":"TBLRUNFIND", "parent":"GRPVISION"}', 'text': 'RUN_FIND SR VIEW', 'value': 'VISION RUN_FIND SR[...] CAMERA_VIEW[...]'
                    }, 'children': []
                }
                ]
            },
            {
                'data': {
                    'text': 'GET_NFOUND', 'value': '', 'addParam': '{"cmdId":"GRPGET_NFOUND"}', className: 'tree-select-closed'
                }, 'children': [{
                    'data': {
                        'addParam': '{"cmdId":"CMDNFOUND", "tblId":"TBLNFOUND", "parent":"GRPVISION"}', 'text': 'GET_NFOUND ...', 'value': 'VISION GET_NFOUND \'...\' R[...]'
                    }, 'children': []
                },
                {
                    'data': {
                        'addParam': '{"cmdId":"CMDNFOUND", "tblId":"TBLNFOUND", "parent":"GRPVISION"}', 'text': 'GET_NFOUND ... VIEW', 'value': 'VISION GET_NFOUND \'...\' R[...] CAMERA_VIEW[...]'
                    }, 'children': []
                },
                {
                    'data': {
                        'addParam': '{"cmdId":"CMDNFOUND", "tblId":"TBLNFOUND", "parent":"GRPVISION"}', 'text': 'GET_NFOUND SR', 'value': 'VISION GET_NFOUND SR[...] R[...]'
                    }, 'children': []
                },
                {
                    'data': {
                        'addParam': '{"cmdId":"CMDNFOUND", "tblId":"TBLNFOUND", "parent":"GRPVISION"}', 'text': 'GET_NFOUND SR VIEW', 'value': 'VISION GET_NFOUND SR[...] R[...] CAMERA_VIEW[...]'
                    }, 'children': []
                }
                ]
            },
            {
                'data': {
                    'text': 'GET_OFFSET', 'value': '', 'addParam': '{"cmdId":"GRPGET_OFFSET"}', className: 'tree-select-closed'
                }, 'children': [{
                    'data': {
                        'addParam': '{"cmdId":"CMDGETOFF", "tblId":"TBLGETOFF", "parent":"GRPVISION"}', 'text': 'GET_OFFSET ...', 'value': 'VISION GET_OFFSET \'...\' VR[...] JMP LBL [...]'
                    }, 'children': []
                },
                {
                    'data': {
                        'addParam': '{"cmdId":"CMDGETOFF", "tblId":"TBLGETOFF", "parent":"GRPVISION"}', 'text': 'GET_OFFSET SR', 'value': 'VISION GET_OFFSET SR[...] VR[...] JMP LBL [...]'
                    }, 'children': []
                }
                ]
            },
            {
                'data': {
                    'text': 'OVERRIDE', 'value': '', 'addParam': '{"cmdId":"GRPOVERRIDE"}', className: 'tree-select-closed'
                }, 'children': [{
                    'data': {
                        'addParam': '{"cmdId":"CMDOVERRIDE", "tblId":"TBLOVERRIDE", "parent":"GRPVISION"}', 'text': 'OVERRIDE ...', 'value': 'VISION OVERRIDE \'...\' 0.0'
                    }, 'children': []
                },
                {
                    'data': {
                        'addParam': '{"cmdId":"CMDOVERRIDE", "tblId":"TBLOVERRIDE", "parent":"GRPVISION"}', 'text': 'OVERRIDE SR', 'value': 'VISION OVERRIDE SR[...] 0.0'
                    }, 'children': []
                }
                ]
            },
            {
                'data': {
                    'addParam': '{"cmdId":"CMDIRVFIND", "tblId":"TBLIRVFIND", "parent":"GRPVISION"}', 'text': 'IRVFIND ...', 'value': 'CALL IRVFIND(&#34;Vision Process&#34;=\'...\',&#34;Camera View&#34;=1,&#34;Image Reg.&#34;=1)'
                }, 'children': []
            },
            {
                'data': {
                    'addParam': '{"cmdId":"CMDIRVSNAP", "tblId":"TBLIRVSNAP", "parent":"GRPVISION"}', 'text': 'IRVSNAP ...', 'value': 'CALL IRVSNAP(&#34;Vision Process&#34;=\'...\',&#34;Camera View&#34;=1,&#34;Image Reg.&#34;=1)'
                }, 'children': []
            }
        ]
    }],
    'jp': [{
        'data': {
            'addParam': '{"cmdId":"GRPVISION"}', 'text': 'ビジョン', 'value': '', className: 'tree-select-closed'
        },
        'children': [
            {
                'data': {
                    'text': '検出', 'value': '', 'addParam': '{"cmdId":"GRPRUN_FIND"}', className: 'tree-select-closed'
                }, 'children': [{
                    'data': {
                        'addParam': '{"cmdId":"CMDRUNFIND", "tblId":"TBLRUNFIND", "parent":"GRPVISION"}', 'text': '検出 ...', 'value': 'ﾋﾞｼﾞｮﾝ ｹﾝｼｭﾂ \'...\''
                    }, 'children': []
                },
                {
                    'data': {
                        'addParam': '{"cmdId":"CMDRUNFIND", "tblId":"TBLRUNFIND", "parent":"GRPVISION"}', 'text': '検出 ... カメラビュー', 'value': 'ﾋﾞｼﾞｮﾝ ｹﾝｼｭﾂ \'...\' ｶﾒﾗﾋﾞｭｰ[...]'
                    }, 'children': []
                },
                {
                    'data': {
                        'addParam': '{"cmdId":"CMDRUNFIND", "tblId":"TBLRUNFIND", "parent":"GRPVISION"}', 'text': '検出 文字レジ', 'value': 'ﾋﾞｼﾞｮﾝ ｹﾝｼｭﾂ ﾓｼﾞﾚｼﾞ[...]'
                    }, 'children': []
                },
                {
                    'data': {
                        'addParam': '{"cmdId":"CMDRUNFIND", "tblId":"TBLRUNFIND", "parent":"GRPVISION"}', 'text': '検出 文字レジ カメラビュー', 'value': 'ﾋﾞｼﾞｮﾝ ｹﾝｼｭﾂ ﾓｼﾞﾚｼﾞ[...] ｶﾒﾗﾋﾞｭｰ[...]'
                    }, 'children': []
                }
                ]
            },
            {
                'data': {
                    'text': '検出数取得', 'value': '', 'addParam': '{"cmdId":"GRPGET_NFOUND"}', className: 'tree-select-closed'
                }, 'children': [{
                    'data': {
                        'addParam': '{"cmdId":"CMDNFOUND", "tblId":"TBLNFOUND", "parent":"GRPVISION"}', 'text': '検出数取得 ...', 'value': 'ﾋﾞｼﾞｮﾝ ｹﾝｼｭﾂｽｳｼｭﾄｸ \'...\' ﾚｼﾞ[...]'
                    }, 'children': []
                },
                {
                    'data': {
                        'addParam': '{"cmdId":"CMDNFOUND", "tblId":"TBLNFOUND", "parent":"GRPVISION"}', 'text': '検出数取得 ... カメラビュー', 'value': 'ﾋﾞｼﾞｮﾝ ｹﾝｼｭﾂｽｳｼｭﾄｸ \'...\' ﾚｼﾞ[...] ｶﾒﾗﾋﾞｭｰ[...]'
                    }, 'children': []
                },
                {
                    'data': {
                        'addParam': '{"cmdId":"CMDNFOUND", "tblId":"TBLNFOUND", "parent":"GRPVISION"}', 'text': '検出数取得 文字レジ', 'value': 'ﾋﾞｼﾞｮﾝ ｹﾝｼｭﾂｽｳｼｭﾄｸ ﾓｼﾞﾚｼﾞ[...] ﾚｼﾞ[...]'
                    }, 'children': []
                },
                {
                    'data': {
                        'addParam': '{"cmdId":"CMDNFOUND", "tblId":"TBLNFOUND", "parent":"GRPVISION"}', 'text': '検出数取得 文字レジ カメラビュー', 'value': 'ﾋﾞｼﾞｮﾝ ｹﾝｼｭﾂｽｳｼｭﾄｸ ﾓｼﾞﾚｼﾞ[...] ﾚｼﾞ[...] ｶﾒﾗﾋﾞｭｰ[...]'
                    }, 'children': []
                }
                ]
            },
            {
                'data': {
                    'text': '補正データ取得', 'value': '', 'addParam': '{"cmdId":"GRPGET_OFFSET"}', className: 'tree-select-closed'
                }, 'children': [{
                    'data': {
                        'addParam': '{"cmdId":"CMDGETOFF", "tblId":"TBLGETOFF", "parent":"GRPVISION"}', 'text': '補正データ取得 ...', 'value': 'ﾋﾞｼﾞｮﾝ ﾎｾｲﾃﾞｰﾀｼｭﾄｸ \'...\' ﾋﾞｼﾞｮﾝﾚｼﾞ[...] ｼﾞｬﾝﾌﾟ ﾗﾍﾞﾙ[...]'
                    }, 'children': []
                },
                {
                    'data': {
                        'addParam': '{"cmdId":"CMDGETOFF", "tblId":"TBLGETOFF", "parent":"GRPVISION"}', 'text': '補正データ取得 文字レジ', 'value': 'ﾋﾞｼﾞｮﾝ ﾎｾｲﾃﾞｰﾀｼｭﾄｸ ﾓｼﾞﾚｼﾞ[...] ﾋﾞｼﾞｮﾝﾚｼﾞ[...] ｼﾞｬﾝﾌﾟ ﾗﾍﾞﾙ[...]'
                    }, 'children': []
                }
                ]
            },
            {
                'data': {
                    'text': 'ビジョン変数設定', 'value': '', 'addParam': '{"cmdId":"GRPOVERRIDE"}', className: 'tree-select-closed'
                }, 'children': [{
                    'data': {
                        'addParam': '{"cmdId":"CMDOVERRIDE", "tblId":"TBLOVERRIDE", "parent":"GRPVISION"}', 'text': 'ビジョン変数設定 ...', 'value': 'ﾋﾞｼﾞｮﾝ ﾍﾝｽｳｾｯﾃｲ \'...\' 0.0'
                    }, 'children': []
                },
                {
                    'data': {
                        'addParam': '{"cmdId":"CMDOVERRIDE", "tblId":"TBLOVERRIDE", "parent":"GRPVISION"}', 'text': 'ビジョン変数設定 文字レジ', 'value': 'ﾋﾞｼﾞｮﾝ ﾍﾝｽｳｾｯﾃｲ ﾓｼﾞﾚｼﾞ[...] 0.0'
                    }, 'children': []
                }
                ]
            },
            {
                'data': {
                    'addParam': '{"cmdId":"CMDIRVFIND", "tblId":"TBLIRVFIND", "parent":"GRPVISION"}', 'text': 'IRVFIND ...', 'value': 'ﾖﾋﾞﾀﾞｼ IRVFIND(&#34;ﾋﾞｼﾞｮﾝﾌﾟﾛｸﾞﾗﾑ名&#34;=\'...\',&#34;ｶﾒﾗﾋﾞｭｰ番号&#34;=1,&#34;画像ﾚｼﾞｽﾀ番号&#34;=1)'
                }, 'children': []
            },
            {
                'data': {
                    'addParam': '{"cmdId":"CMDIRVSNAP", "tblId":"TBLIRVSNAP", "parent":"GRPVISION"}', 'text': 'IRVSNAP ...', 'value': 'ﾖﾋﾞﾀﾞｼ IRVSNAP(&#34;ﾋﾞｼﾞｮﾝﾌﾟﾛｸﾞﾗﾑ名&#34;=\'...\',&#34;ｶﾒﾗﾋﾞｭｰ番号&#34;=1,&#34;画像ﾚｼﾞｽﾀ番号&#34;=1)'
                }, 'children': []
            }
        ]
    }]
};

function initVisionCommand() {
    commandTree.jp[commandTree.jp.length] = visCommandTree.jp[0];
    commandTree.eg[commandTree.eg.length] = visCommandTree.eg[0];
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   // CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// Modified by [FSI]:
//   - Change lib folder path.

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";
  var WRAP_CLASS = "CodeMirror-activeline";
  var BACK_CLASS = "CodeMirror-activeline-background";
  var GUTT_CLASS = "CodeMirror-activeline-gutter";

  CodeMirror.defineOption("styleActiveLine", false, function(cm, val, old) {
    var prev = old == CodeMirror.Init ? false : old;
    if (val == prev) return
    if (prev) {
      cm.off("beforeSelectionChange", selectionChange);
      clearActiveLines(cm);
      delete cm.state.activeLines;
    }
    if (val) {
      cm.state.activeLines = [];
      updateActiveLines(cm, cm.listSelections());
      cm.on("beforeSelectionChange", selectionChange);
    }
  });

  function clearActiveLines(cm) {
    for (var i = 0; i < cm.state.activeLines.length; i++) {
      cm.removeLineClass(cm.state.activeLines[i], "wrap", WRAP_CLASS);
      cm.removeLineClass(cm.state.activeLines[i], "background", BACK_CLASS);
      cm.removeLineClass(cm.state.activeLines[i], "gutter", GUTT_CLASS);
    }
  }

  function sameArray(a, b) {
    if (a.length != b.length) return false;
    for (var i = 0; i < a.length; i++)
      if (a[i] != b[i]) return false;
    return true;
  }

  function updateActiveLines(cm, ranges) {
    var active = [];
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i];
      var option = cm.getOption("styleActiveLine");
      if (typeof option == "object" && option.nonEmpty ? range.anchor.line != range.head.line : !range.empty())
        continue
      var line = cm.getLineHandleVisualStart(range.head.line);
      if (active[active.length - 1] != line) active.push(line);
    }
    if (sameArray(cm.state.activeLines, active)) return;
    cm.operation(function() {
      clearActiveLines(cm);
      for (var i = 0; i < active.length; i++) {
        cm.addLineClass(active[i], "wrap", WRAP_CLASS);
        cm.addLineClass(active[i], "background", BACK_CLASS);
        cm.addLineClass(active[i], "gutter", GUTT_CLASS);
      }
      cm.state.activeLines = active;
    });
  }

  function selectionChange(cm, sel) {
    updateActiveLines(cm, sel.ranges);
  }
});
                                                                                                                                                                                                                                                                                                                                                                                                                                                          // CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// Modified by [FSI]:
//   - Change lib folder path.

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineExtension("annotateScrollbar", function(options) {
    if (typeof options == "string") options = {className: options};
    return new Annotation(this, options);
  });

  CodeMirror.defineOption("scrollButtonHeight", 0);

  function Annotation(cm, options) {
    this.cm = cm;
    this.options = options;
    this.buttonHeight = options.scrollButtonHeight || cm.getOption("scrollButtonHeight");
    this.annotations = [];
    this.doRedraw = this.doUpdate = null;
    this.div = cm.getWrapperElement().appendChild(document.createElement("div"));
    this.div.style.cssText = "position: absolute; right: 0; top: 0; z-index: 7; pointer-events: none";
    this.computeScale();

    function scheduleRedraw(delay) {
      clearTimeout(self.doRedraw);
      self.doRedraw = setTimeout(function() { self.redraw(); }, delay);
    }

    var self = this;
    cm.on("refresh", this.resizeHandler = function() {
      clearTimeout(self.doUpdate);
      self.doUpdate = setTimeout(function() {
        if (self.computeScale()) scheduleRedraw(20);
      }, 100);
    });
    cm.on("markerAdded", this.resizeHandler);
    cm.on("markerCleared", this.resizeHandler);
    if (options.listenForChanges !== false)
      cm.on("change", this.changeHandler = function() {
        scheduleRedraw(250);
      });
  }

  Annotation.prototype.computeScale = function() {
    var cm = this.cm;
    var hScale = (cm.getWrapperElement().clientHeight - cm.display.barHeight - this.buttonHeight * 2) /
      cm.getScrollerElement().scrollHeight
    if (hScale != this.hScale) {
      this.hScale = hScale;
      return true;
    }
  };

  Annotation.prototype.update = function(annotations) {
    this.annotations = annotations;
    this.redraw();
  };

  Annotation.prototype.redraw = function(compute) {
    if (compute !== false) this.computeScale();
    var cm = this.cm, hScale = this.hScale;

    var frag = document.createDocumentFragment(), anns = this.annotations;

    var wrapping = cm.getOption("lineWrapping");
    var singleLineH = wrapping && cm.defaultTextHeight() * 1.5;
    var curLine = null, curLineObj = null;
    function getY(pos, top) {
      if (curLine != pos.line) {
        curLine = pos.line;
        curLineObj = cm.getLineHandle(curLine);
      }
      if ((curLineObj.widgets && curLineObj.widgets.length) ||
          (wrapping && curLineObj.height > singleLineH))
        return cm.charCoords(pos, "local")[top ? "top" : "bottom"];
      var topY = cm.heightAtLine(curLineObj, "local");
      return topY + (top ? 0 : curLineObj.height);
    }

    var lastLine = cm.lastLine()
    if (cm.display.barWidth) for (var i = 0, nextTop; i < anns.length; i++) {
      var ann = anns[i];
      if (ann.to.line > lastLine) continue;
      var top = nextTop || getY(ann.from, true) * hScale;
      var bottom = getY(ann.to, false) * hScale;
      while (i < anns.length - 1) {
        if (anns[i + 1].to.line > lastLine) break;
        nextTop = getY(anns[i + 1].from, true) * hScale;
        if (nextTop > bottom + .9) break;
        ann = anns[++i];
        bottom = getY(ann.to, false) * hScale;
      }
      if (bottom == top) continue;
      var height = Math.max(bottom - top, 3);

      var elt = frag.appendChild(document.createElement("div"));
      elt.style.cssText = "position: absolute; right: 0px; width: " + Math.max(cm.display.barWidth - 1, 2) + "px; top: "
        + (top + this.buttonHeight) + "px; height: " + height + "px";
      elt.className = this.options.className;
      if (ann.id) {
        elt.setAttribute("annotation-id", ann.id);
      }
    }
    this.div.textContent = "";
    this.div.appendChild(frag);
  };

  Annotation.prototype.clear = function() {
    this.cm.off("refresh", this.resizeHandler);
    this.cm.off("markerAdded", this.resizeHandler);
    this.cm.off("markerCleared", this.resizeHandler);
    if (this.changeHandler) this.cm.off("change", this.changeHandler);
    this.div.parentNode.removeChild(this.div);
  };
});
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       // CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// Highlighting text that matches the selection
//
// Defines an option highlightSelectionMatches, which, when enabled,
// will style strings that match the selection throughout the
// document.
//
// The option can be set to true to simply enable it, or to a
// {minChars, style, wordsOnly, showToken, delay} object to explicitly
// configure it. minChars is the minimum amount of characters that should be
// selected for the behavior to occur, and style is the token style to
// apply to the matches. This will be prefixed by "cm-" to create an
// actual CSS class name. If wordsOnly is enabled, the matches will be
// highlighted only if the selected text is a word. showToken, when enabled,
// will cause the current token to be highlighted when nothing is selected.
// delay is used to specify how much time to wait, in milliseconds, before
// highlighting the matches. If annotateScrollbar is enabled, the occurences
// will be highlighted on the scrollbar via the matchesonscrollbar addon.

// Modified by [FSI]:
//   - Change lib folder path.

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../lib/codemirror"), require("./matchesonscrollbar"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../lib/codemirror", "./matchesonscrollbar"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  var defaults = {
    style: "matchhighlight",
    minChars: 2,
    delay: 100,
    wordsOnly: false,
    annotateScrollbar: false,
    showToken: false,
    trim: true
  }

  function State(options) {
    this.options = {}
    for (var name in defaults)
      this.options[name] = (options && options.hasOwnProperty(name) ? options : defaults)[name]
    this.overlay = this.timeout = null;
    this.matchesonscroll = null;
    this.active = false;
  }

  CodeMirror.defineOption("highlightSelectionMatches", false, function(cm, val, old) {
    if (old && old != CodeMirror.Init) {
      removeOverlay(cm);
      clearTimeout(cm.state.matchHighlighter.timeout);
      cm.state.matchHighlighter = null;
      cm.off("cursorActivity", cursorActivity);
      cm.off("focus", onFocus)
    }
    if (val) {
      var state = cm.state.matchHighlighter = new State(val);
      if (cm.hasFocus()) {
        state.active = true
        highlightMatches(cm)
      } else {
        cm.on("focus", onFocus)
      }
      cm.on("cursorActivity", cursorActivity);
    }
  });

  function cursorActivity(cm) {
    var state = cm.state.matchHighlighter;
    if (state.active || cm.hasFocus()) scheduleHighlight(cm, state)
  }

  function onFocus(cm) {
    var state = cm.state.matchHighlighter
    if (!state.active) {
      state.active = true
      scheduleHighlight(cm, state)
    }
  }

  function scheduleHighlight(cm, state) {
    clearTimeout(state.timeout);
    state.timeout = setTimeout(function() {highlightMatches(cm);}, state.options.delay);
  }

  function addOverlay(cm, query, hasBoundary, style) {
    var state = cm.state.matchHighlighter;
    cm.addOverlay(state.overlay = makeOverlay(query, hasBoundary, style));
    if (state.options.annotateScrollbar && cm.showMatchesOnScrollbar) {
      var searchFor = hasBoundary ? new RegExp("\\b" + query.replace(/[\\\[.+*?(){|^$]/g, "\\$&") + "\\b") : query;
      state.matchesonscroll = cm.showMatchesOnScrollbar(searchFor, false,
        {className: "CodeMirror-selection-highlight-scrollbar"});
    }
  }

  function removeOverlay(cm) {
    var state = cm.state.matchHighlighter;
    if (state.overlay) {
      cm.removeOverlay(state.overlay);
      state.overlay = null;
      if (state.matchesonscroll) {
        state.matchesonscroll.clear();
        state.matchesonscroll = null;
      }
    }
  }

  function highlightMatches(cm) {
    cm.operation(function() {
      var state = cm.state.matchHighlighter;
      removeOverlay(cm);
      if (!cm.somethingSelected() && state.options.showToken) {
        var re = state.options.showToken === true ? /[\w$]/ : state.options.showToken;
        var cur = cm.getCursor(), line = cm.getLine(cur.line), start = cur.ch, end = start;
        while (start && re.test(line.charAt(start - 1))) --start;
        while (end < line.length && re.test(line.charAt(end))) ++end;
        if (start < end)
          addOverlay(cm, line.slice(start, end), re, state.options.style);
        return;
      }
      var from = cm.getCursor("from"), to = cm.getCursor("to");
      if (from.line != to.line) return;
      if (state.options.wordsOnly && !isWord(cm, from, to)) return;
      var selection = cm.getRange(from, to)
      if (state.options.trim) selection = selection.replace(/^\s+|\s+$/g, "")
      if (selection.length >= state.options.minChars)
        addOverlay(cm, selection, false, state.options.style);
    });
  }

  function isWord(cm, from, to) {
    var str = cm.getRange(from, to);
    if (str.match(/^\w+$/) !== null) {
        if (from.ch > 0) {
            var pos = {line: from.line, ch: from.ch - 1};
            var chr = cm.getRange(pos, from);
            if (chr.match(/\W/) === null) return false;
        }
        if (to.ch < cm.getLine(from.line).length) {
            var pos = {line: to.line, ch: to.ch + 1};
            var chr = cm.getRange(to, pos);
            if (chr.match(/\W/) === null) return false;
        }
        return true;
    } else return false;
  }

  function boundariesAround(stream, re) {
    return (!stream.start || !re.test(stream.string.charAt(stream.start - 1))) &&
      (stream.pos == stream.string.length || !re.test(stream.string.charAt(stream.pos)));
  }

  function makeOverlay(query, hasBoundary, style) {
    return {token: function(stream) {
      if (stream.match(query) &&
          (!hasBoundary || boundariesAround(stream, hasBoundary)))
        return style;
      stream.next();
      stream.skipTo(query.charAt(0)) || stream.skipToEnd();
    }};
  }
});
                                                                                                                                                                                                                                                                                                                                                                                                                        .CodeMirror-search-match {
  background: gold;
  border-top: 1px solid orange;
  border-bottom: 1px solid orange;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
  opacity: .5;
}
                                                                                                                                                                                                                                                                                                                            M A T C H  {E S O N S C   R O MATCHE~1JS    MjXX  MjXe  SEARCH  JS    MjXX  MjXڗ4  BJ S      S E A R C  H C U R S O   R . SEARCH~1JS    MjXX  MjX0                                                                                                                                                                                                                                                                                                                                  // CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// Modified by [FSI]:
//   - Change lib folder path.

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../lib/codemirror"), require("./searchcursor"), require("./annotatescrollbar"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../lib/codemirror", "./searchcursor", "./annotatescrollbar"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineExtension("showMatchesOnScrollbar", function(query, caseFold, options) {
    if (typeof options == "string") options = {className: options};
    if (!options) options = {};
    return new SearchAnnotation(this, query, caseFold, options);
  });

  function SearchAnnotation(cm, query, caseFold, options) {
    this.cm = cm;
    this.options = options;
    var annotateOptions = {listenForChanges: false};
    for (var prop in options) annotateOptions[prop] = options[prop];
    if (!annotateOptions.className) annotateOptions.className = "CodeMirror-search-match";
    this.annotation = cm.annotateScrollbar(annotateOptions);
    this.query = query;
    this.caseFold = caseFold;
    this.gap = {from: cm.firstLine(), to: cm.lastLine() + 1};
    this.matches = [];
    this.update = null;

    this.findMatches();
    this.annotation.update(this.matches);

    var self = this;
    cm.on("change", this.changeHandler = function(_cm, change) { self.onChange(change); });
  }

  var MAX_MATCHES = 1000;

  SearchAnnotation.prototype.findMatches = function() {
    if (!this.gap) return;
    for (var i = 0; i < this.matches.length; i++) {
      var match = this.matches[i];
      if (match.from.line >= this.gap.to) break;
      if (match.to.line >= this.gap.from) this.matches.splice(i--, 1);
    }
    var cursor = this.cm.getSearchCursor(this.query, CodeMirror.Pos(this.gap.from, 0), this.caseFold);
    var maxMatches = this.options && this.options.maxMatches || MAX_MATCHES;
    while (cursor.findNext()) {
      var match = {from: cursor.from(), to: cursor.to()};
      if (match.from.line >= this.gap.to) break;
      this.matches.splice(i++, 0, match);
      if (this.matches.length > maxMatches) break;
    }
    this.gap = null;
  };

  function offsetLine(line, changeStart, sizeChange) {
    if (line <= changeStart) return line;
    return Math.max(changeStart, line + sizeChange);
  }

  SearchAnnotation.prototype.onChange = function(change) {
    var startLine = change.from.line;
    var endLine = CodeMirror.changeEnd(change).line;
    var sizeChange = endLine - change.to.line;
    if (this.gap) {
      this.gap.from = Math.min(offsetLine(this.gap.from, startLine, sizeChange), change.from.line);
      this.gap.to = Math.max(offsetLine(this.gap.to, startLine, sizeChange), change.from.line);
    } else {
      this.gap = {from: change.from.line, to: endLine + 1};
    }

    if (sizeChange) for (var i = 0; i < this.matches.length; i++) {
      var match = this.matches[i];
      var newFrom = offsetLine(match.from.line, startLine, sizeChange);
      if (newFrom != match.from.line) match.from = CodeMirror.Pos(newFrom, match.from.ch);
      var newTo = offsetLine(match.to.line, startLine, sizeChange);
      if (newTo != match.to.line) match.to = CodeMirror.Pos(newTo, match.to.ch);
    }
    clearTimeout(this.update);
    var self = this;
    this.update = setTimeout(function() { self.updateAfterChange(); }, 250);
  };

  SearchAnnotation.prototype.updateAfterChange = function() {
    this.findMatches();
    this.annotation.update(this.matches);
  };

  SearchAnnotation.prototype.clear = function() {
    this.cm.off("change", this.changeHandler);
    this.annotation.clear();
  };
});
                                                                                                                                                           // CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// Define search commands. Depends on dialog.js or another
// implementation of the openDialog method.

// Replace works a little oddly -- it will do the replace on the next
// Ctrl-G (or whatever is bound to findNext) press. You prevent a
// replace by making sure the match is no longer selected when hitting
// Ctrl-G.

// Modified by [FSI]:
//   - Change lib folder path.
//   - Remove dialog from require/define and bypass dialog process.
//   - Add for customize dialog procedure and new search procedure.
//   - Customize replace all process for replace and save.

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../lib/codemirror"), require("./searchcursor"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../lib/codemirror", "./searchcursor"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  function searchOverlay(query, caseInsensitive) {
    if (typeof query == "string")
      query = new RegExp(query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"), caseInsensitive ? "gi" : "g");
    else if (!query.global)
      query = new RegExp(query.source, query.ignoreCase ? "gi" : "g");

    return {token: function(stream) {
      query.lastIndex = stream.pos;
      var match = query.exec(stream.string);
      if (match && match.index == stream.pos) {
        stream.pos += match[0].length || 1;
        return "searching";
      } else if (match) {
        stream.pos = match.index;
      } else {
        stream.skipToEnd();
      }
    }};
  }

  function SearchState() {
    this.posFrom = this.posTo = this.lastQuery = this.query = null;
    this.overlay = null;
  }

  function getSearchState(cm) {
    return cm.state.search || (cm.state.search = new SearchState());
  }

  function queryCaseInsensitive(query) {
    return typeof query == "string" && query == query.toLowerCase();
  }

  function getSearchCursor(cm, query, pos) {
    // Heuristic: if the query string is all lowercase, do a case insensitive search.
    return cm.getSearchCursor(query, pos, {caseFold: queryCaseInsensitive(query), multiline: true});
  }

  function persistentDialog(cm, text, deflt, onEnter, onKeyDown) {
    cm.openDialog(text, onEnter, {
      value: deflt,
      selectValueOnOpen: true,
      closeOnEnter: false,
      onClose: function() { clearSearch(cm); },
      onKeyDown: onKeyDown
    });
  }

  // [FSI] Add for new search function.
  function clearAndSearch(cm, option, query) {
    clearSearch(cm);
    option.callback(query);
  }

  function dialog(cm, text, shortText, deflt, f) {
    // [FSI] Add for custermized dialog.
    if (cm.options.searchDialog != undefined) {
      var srhOption = {'text': text, callback: f, repFunc: replaceBody, value: deflt, selectValueOnOpen: true, newSearch: clearAndSearch};
      cm.options.searchDialog(srhOption);
    } else {
      if (cm.openDialog) cm.openDialog(text, f, {value: deflt, selectValueOnOpen: true});
      else f(prompt(shortText, deflt));
    }
  }

  function confirmDialog(cm, text, shortText, fs) {
    // [FSI] Add for custermized dialog.
    if (cm.options.repConfDialog != undefined) {
      var srhOption = {'cm': cm, 'text': text, callback: fs, cancel: clearSearch};
      cm.options.repConfDialog(srhOption);
    } else {
      if (cm.openConfirm) cm.openConfirm(text, fs);
      else if (confirm(shortText)) fs[0]();
    }
  }

  function parseString(string) {
    return string.replace(/\\(.)/g, function(_, ch) {
      if (ch == "n") return "\n"
      if (ch == "r") return "\r"
      return ch
    })
  }

  function parseQuery(query) {
    var isRE = query.match(/^\/(.*)\/([a-z]*)$/);
    if (isRE) {
      try { query = new RegExp(isRE[1], isRE[2].indexOf("i") == -1 ? "" : "i"); }
      catch(e) {} // Not a regular expression after all, do a string search
    } else {
      query = parseString(query)
    }
    if (typeof query == "string" ? query == "" : query.test(""))
      query = /x^/;
    return query;
  }

  function startSearch(cm, state, query) {
    state.queryText = query;
    state.query = parseQuery(query);
    cm.removeOverlay(state.overlay, queryCaseInsensitive(state.query));
    state.overlay = searchOverlay(state.query, queryCaseInsensitive(state.query));
    cm.addOverlay(state.overlay);
    if (cm.showMatchesOnScrollbar) {
      if (state.annotate) { state.annotate.clear(); state.annotate = null; }
      state.annotate = cm.showMatchesOnScrollbar(state.query, queryCaseInsensitive(state.query));
    }
  }

  function doSearch(cm, rev, persistent, immediate) {
    var state = getSearchState(cm);
    if (state.query) return findNext(cm, rev);
    var q = cm.getSelection() || state.lastQuery;
    if (q instanceof RegExp && q.source == "x^") q = null
    if (persistent && cm.openDialog) {
      var hiding = null
      var searchNext = function(query, event) {
        CodeMirror.e_stop(event);
        if (!query) return;
        if (query != state.queryText) {
          startSearch(cm, state, query);
          state.posFrom = state.posTo = cm.getCursor();
        }
        if (hiding) hiding.style.opacity = 1
        findNext(cm, event.shiftKey, function(_, to) {
          var dialog
          if (to.line < 3 && document.querySelector &&
              (dialog = cm.display.wrapper.querySelector(".CodeMirror-dialog")) &&
              dialog.getBoundingClientRect().bottom - 4 > cm.cursorCoords(to, "window").top)
            (hiding = dialog).style.opacity = .4
        })
      };
      persistentDialog(cm, getQueryDialog(cm), q, searchNext, function(event, query) {
        var keyName = CodeMirror.keyName(event)
        var extra = cm.getOption('extraKeys'), cmd = (extra && extra[keyName]) || CodeMirror.keyMap[cm.getOption("keyMap")][keyName]
        if (cmd == "findNext" || cmd == "findPrev" ||
          cmd == "findPersistentNext" || cmd == "findPersistentPrev") {
          CodeMirror.e_stop(event);
          startSearch(cm, getSearchState(cm), query);
          cm.execCommand(cmd);
        } else if (cmd == "find" || cmd == "findPersistent") {
          CodeMirror.e_stop(event);
          searchNext(query, event);
        }
      });
      if (immediate && q) {
        startSearch(cm, state, q);
        findNext(cm, rev);
      }
    } else {
      dialog(cm, getQueryDialog(cm), "Search for:", q, function(query) {
        if (query && !state.query) cm.operation(function() {
          startSearch(cm, state, query);
          state.posFrom = state.posTo = cm.getCursor();
          findNext(cm, rev);
        });
      });
    }
  }

  function findNext(cm, rev, callback) {cm.operation(function() {
    var state = getSearchState(cm);
    var cursor = getSearchCursor(cm, state.query, rev ? state.posFrom : state.posTo);
    if (!cursor.find(rev)) {
      cursor = getSearchCursor(cm, state.query, rev ? CodeMirror.Pos(cm.lastLine()) : CodeMirror.Pos(cm.firstLine(), 0));
      if (!cursor.find(rev)) return;
    }
    cm.setSelection(cursor.from(), cursor.to());
    cm.scrollIntoView({from: cursor.from(), to: cursor.to()}, 20);
    state.posFrom = cursor.from(); state.posTo = cursor.to();
    if (callback) callback(cursor.from(), cursor.to())
  });}

  function clearSearch(cm) {cm.operation(function() {
    var state = getSearchState(cm);
    state.lastQuery = state.query;
    if (!state.query) return;
    state.query = state.queryText = null;
    cm.removeOverlay(state.overlay);
    if (state.annotate) { state.annotate.clear(); state.annotate = null; }
  });}


  function getQueryDialog(cm)  {
    return '<span class="CodeMirror-search-label">' + cm.phrase("Search:") + '</span> <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">' + cm.phrase("(Use /re/ syntax for regexp search)") + '</span>';
  }
  function getReplaceQueryDialog(cm) {
    return ' <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">' + cm.phrase("(Use /re/ syntax for regexp search)") + '</span>';
  }
  function getReplacementQueryDialog(cm) {
    return '<span class="CodeMirror-search-label">' + cm.phrase("With:") + '</span> <input type="text" style="width: 10em" class="CodeMirror-search-field"/>';
  }
  function getDoReplaceConfirm(cm) {
    return '<span class="CodeMirror-search-label">' + cm.phrase("Replace?") + '</span> <button>' + cm.phrase("Yes") + '</button> <button>' + cm.phrase("No") + '</button> <button>' + cm.phrase("All") + '</button> <button>' + cm.phrase("Stop") + '</button> ';
  }

  function replaceAll(cm, query, text) {
    cm.operation(function() {
      for (var cursor = getSearchCursor(cm, query); cursor.findNext();) {
        if (typeof query != "string") {
          var match = cm.getRange(cursor.from(), cursor.to()).match(query);
          cursor.replace(text.replace(/\$(\d)/g, function(_, i) {return match[i];}));
        } else cursor.replace(text);
      }
    });
  }

  function replace(cm, all) {
    if (cm.getOption("readOnly")) return;
    var query = cm.getSelection() || getSearchState(cm).lastQuery;
    var dialogText = '<span class="CodeMirror-search-label">' + (all ? cm.phrase("Replace all:") : cm.phrase("Replace:")) + '</span>';
    dialog(cm, dialogText + getReplaceQueryDialog(cm), dialogText, query, function(query) {
      if (!query) return;
      query = parseQuery(query);
      dialog(cm, getReplacementQueryDialog(cm), cm.phrase("Replace with:"), "", function(text) {
        replaceBody(cm, query, text, all);  // [FSI] Modify: Extract from the original code to function.
      });
    });
  }

  // [FSI] Add save replace line data to edit file.
  function saveReplaceAll(cm, query, text, saveLineCallback) {
    cm.operation(function() {
      var cursor = getSearchCursor(cm, query);  // at 1st, get search cursor.
      cursor.findNext();
      var repArgs = {};
      repArgs.cursor = cursor;
      repArgs.cm = cm;
      repArgs.query = query;
      repArgs.text = text;
      repArgs.callback = saveLineCallback;
      replaceText(repArgs);
    });
  }
  // next [replace all]
  function replaceAllNextLoop(repArgs) {
    if (repArgs.cursor.findNext()) {  // exist next target.
      replaceText(repArgs);
    }
  }
  // process of replace text.
  function replaceText(repArgs) {
    var cursor = repArgs.cursor;
    if (typeof repArgs.query != "string") {
      var match = repArgs.cm.getRange(cursor.from(), cursor.to()).match(query);
      cursor.replace(repArgs.text.replace(/\$(\d)/g, function(_, i) {return match[i];}));
    }
    else {
      cursor.replace(repArgs.text);
    }
    if (repArgs.callback != undefined) {
      repArgs.cursor = cursor;
      repArgs.nextRep = replaceAllNextLoop;
      repArgs.callback(repArgs);
    }
  }

  // [FSI] Modify: Extract from the original code and make it to function.
  //               Add a callback function to save one line in the argument.
  function replaceBody(cm, query, text, all, saveLineCallback) {
    text = parseString(text)
    if (all) {
      // [FSI] if need save, call save replace line process.
      if (saveLineCallback != undefined) {
        saveReplaceAll(cm, query, text, saveLineCallback);
      } else {
        replaceAll(cm, query, text);  // Original code.
      }
    } else {
      clearSearch(cm);
      var cursor = getSearchCursor(cm, query, cm.getCursor("from"));
      var advance = function() {
        var start = cursor.from(), match;
        if (!(match = cursor.findNext())) {
          cursor = getSearchCursor(cm, query);
          if (!(match = cursor.findNext()) ||
              (start && cursor.from().line == start.line && cursor.from().ch == start.ch)) return;
        }
        cm.setSelection(cursor.from(), cursor.to());
        cm.scrollIntoView({from: cursor.from(), to: cursor.to()});
        confirmDialog(cm, getDoReplaceConfirm(cm), cm.phrase("Replace?"),
                      [function() {doReplace(match);}, advance,
                       function() {replaceAll(cm, query, text)}]);
      };
      var doReplace = function(match) {
        cursor.replace(typeof query == "string" ? text :
                       text.replace(/\$(\d)/g, function(_, i) {return match[i];}));
        advance();
      };
      advance();
    }
  }

  CodeMirror.commands.find = function(cm) {clearSearch(cm); doSearch(cm);};
  CodeMirror.commands.findPersistent = function(cm) {clearSearch(cm); doSearch(cm, false, true);};
  CodeMirror.commands.findPersistentNext = function(cm) {doSearch(cm, false, true, true);};
  CodeMirror.commands.findPersistentPrev = function(cm) {doSearch(cm, true, true, true);};
  CodeMirror.commands.findNext = doSearch;
  CodeMirror.commands.findPrev = function(cm) {doSearch(cm, true);};
  CodeMirror.commands.clearSearch = clearSearch;
  CodeMirror.commands.replace = replace;
  CodeMirror.commands.replaceAll = function(cm) {replace(cm, true);};
});
                                                                                                                                                                                                                                                                                                                                                                         // CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// Modified by [FSI]:
//   - Change lib folder path.

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../lib/codemirror"))
  else if (typeof define == "function" && define.amd) // AMD
    define(["../lib/codemirror"], mod)
  else // Plain browser env
    mod(CodeMirror)
})(function(CodeMirror) {
  "use strict"
  var Pos = CodeMirror.Pos

  function regexpFlags(regexp) {
    var flags = regexp.flags
    return flags != null ? flags : (regexp.ignoreCase ? "i" : "")
      + (regexp.global ? "g" : "")
      + (regexp.multiline ? "m" : "")
  }

  function ensureFlags(regexp, flags) {
    var current = regexpFlags(regexp), target = current
    for (var i = 0; i < flags.length; i++) if (target.indexOf(flags.charAt(i)) == -1)
      target += flags.charAt(i)
    return current == target ? regexp : new RegExp(regexp.source, target)
  }

  function maybeMultiline(regexp) {
    return /\\s|\\n|\n|\\W|\\D|\[\^/.test(regexp.source)
  }

  function searchRegexpForward(doc, regexp, start) {
    regexp = ensureFlags(regexp, "g")
    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {
      regexp.lastIndex = ch
      var string = doc.getLine(line), match = regexp.exec(string)
      if (match)
        return {from: Pos(line, match.index),
                to: Pos(line, match.index + match[0].length),
                match: match}
    }
  }

  function searchRegexpForwardMultiline(doc, regexp, start) {
    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start)

    regexp = ensureFlags(regexp, "gm")
    var string, chunk = 1
    for (var line = start.line, last = doc.lastLine(); line <= last;) {
      // This grows the search buffer in exponentially-sized chunks
      // between matches, so that nearby matches are fast and don't
      // require concatenating the whole document (in case we're
      // searching for something that has tons of matches), but at the
      // same time, the amount of retries is limited.
      for (var i = 0; i < chunk; i++) {
        if (line > last) break
        var curLine = doc.getLine(line++)
        string = string == null ? curLine : string + "\n" + curLine
      }
      chunk = chunk * 2
      regexp.lastIndex = start.ch
      var match = regexp.exec(string)
      if (match) {
        var before = string.slice(0, match.index).split("\n"), inside = match[0].split("\n")
        var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length
        return {from: Pos(startLine, startCh),
                to: Pos(startLine + inside.length - 1,
                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),
                match: match}
      }
    }
  }

  function lastMatchIn(string, regexp) {
    var cutOff = 0, match
    for (;;) {
      regexp.lastIndex = cutOff
      var newMatch = regexp.exec(string)
      if (!newMatch) return match
      match = newMatch
      cutOff = match.index + (match[0].length || 1)
      if (cutOff == string.length) return match
    }
  }

  function searchRegexpBackward(doc, regexp, start) {
    regexp = ensureFlags(regexp, "g")
    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {
      var string = doc.getLine(line)
      if (ch > -1) string = string.slice(0, ch)
      var match = lastMatchIn(string, regexp)
      if (match)
        return {from: Pos(line, match.index),
                to: Pos(line, match.index + match[0].length),
                match: match}
    }
  }

  function searchRegexpBackwardMultiline(doc, regexp, start) {
    regexp = ensureFlags(regexp, "gm")
    var string, chunk = 1
    for (var line = start.line, first = doc.firstLine(); line >= first;) {
      for (var i = 0; i < chunk; i++) {
        var curLine = doc.getLine(line--)
        string = string == null ? curLine.slice(0, start.ch) : curLine + "\n" + string
      }
      chunk *= 2

      var match = lastMatchIn(string, regexp)
      if (match) {
        var before = string.slice(0, match.index).split("\n"), inside = match[0].split("\n")
        var startLine = line + before.length, startCh = before[before.length - 1].length
        return {from: Pos(startLine, startCh),
                to: Pos(startLine + inside.length - 1,
                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),
                match: match}
      }
    }
  }

  var doFold, noFold
  if (String.prototype.normalize) {
    doFold = function(str) { return str.normalize("NFD").toLowerCase() }
    noFold = function(str) { return str.normalize("NFD") }
  } else {
    doFold = function(str) { return str.toLowerCase() }
    noFold = function(str) { return str }
  }

  // Maps a position in a case-folded line back to a position in the original line
  // (compensating for codepoints increasing in number during folding)
  function adjustPos(orig, folded, pos, foldFunc) {
    if (orig.length == folded.length) return pos
    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {
      if (min == max) return min
      var mid = (min + max) >> 1
      var len = foldFunc(orig.slice(0, mid)).length
      if (len == pos) return mid
      else if (len > pos) max = mid
      else min = mid + 1
    }
  }

  function searchStringForward(doc, query, start, caseFold) {
    // Empty string would match anything and never progress, so we
    // define it to match nothing instead.
    if (!query.length) return null
    var fold = caseFold ? doFold : noFold
    var lines = fold(query).split(/\r|\n\r?/)

    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {
      var orig = doc.getLine(line).slice(ch), string = fold(orig)
      if (lines.length == 1) {
        var found = string.indexOf(lines[0])
        if (found == -1) continue search
        var start = adjustPos(orig, string, found, fold) + ch
        return {from: Pos(line, adjustPos(orig, string, found, fold) + ch),
                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)}
      } else {
        var cutFrom = string.length - lines[0].length
        if (string.slice(cutFrom) != lines[0]) continue search
        for (var i = 1; i < lines.length - 1; i++)
          if (fold(doc.getLine(line + i)) != lines[i]) continue search
        var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1]
        if (endString.slice(0, lastLine.length) != lastLine) continue search
        return {from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),
                to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))}
      }
    }
  }

  function searchStringBackward(doc, query, start, caseFold) {
    if (!query.length) return null
    var fold = caseFold ? doFold : noFold
    var lines = fold(query).split(/\r|\n\r?/)

    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {
      var orig = doc.getLine(line)
      if (ch > -1) orig = orig.slice(0, ch)
      var string = fold(orig)
      if (lines.length == 1) {
        var found = string.lastIndexOf(lines[0])
        if (found == -1) continue search
        return {from: Pos(line, adjustPos(orig, string, found, fold)),
                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))}
      } else {
        var lastLine = lines[lines.length - 1]
        if (string.slice(0, lastLine.length) != lastLine) continue search
        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)
          if (fold(doc.getLine(start + i)) != lines[i]) continue search
        var top = doc.getLine(line + 1 - lines.length), topString = fold(top)
        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search
        return {from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),
                to: Pos(line, adjustPos(orig, string, lastLine.length, fold))}
      }
    }
  }

  function SearchCursor(doc, query, pos, options) {
    this.atOccurrence = false
    this.doc = doc
    pos = pos ? doc.clipPos(pos) : Pos(0, 0)
    this.pos = {from: pos, to: pos}

    var caseFold
    if (typeof options == "object") {
      caseFold = options.caseFold
    } else { // Backwards compat for when caseFold was the 4th argument
      caseFold = options
      options = null
    }

    if (typeof query == "string") {
      if (caseFold == null) caseFold = false
      this.matches = function(reverse, pos) {
        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold)
      }
    } else {
      query = ensureFlags(query, "gm")
      if (!options || options.multiline !== false)
        this.matches = function(reverse, pos) {
          return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos)
        }
      else
        this.matches = function(reverse, pos) {
          return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos)
        }
    }
  }

  SearchCursor.prototype = {
    findNext: function() {return this.find(false)},
    findPrevious: function() {return this.find(true)},

    find: function(reverse) {
      var result = this.matches(reverse, this.doc.clipPos(reverse ? this.pos.from : this.pos.to))

      // Implements weird auto-growing behavior on null-matches for
      // backwards-compatiblity with the vim code (unfortunately)
      while (result && CodeMirror.cmpPos(result.from, result.to) == 0) {
        if (reverse) {
          if (result.from.ch) result.from = Pos(result.from.line, result.from.ch - 1)
          else if (result.from.line == this.doc.firstLine()) result = null
          else result = this.matches(reverse, this.doc.clipPos(Pos(result.from.line - 1)))
        } else {
          if (result.to.ch < this.doc.getLine(result.to.line).length) result.to = Pos(result.to.line, result.to.ch + 1)
          else if (result.to.line == this.doc.lastLine()) result = null
          else result = this.matches(reverse, Pos(result.to.line + 1, 0))
        }
      }

      if (result) {
        this.pos = result
        this.atOccurrence = true
        return this.pos.match || true
      } else {
        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0)
        this.pos = {from: end, to: end}
        return this.atOccurrence = false
      }
    },

    from: function() {if (this.atOccurrence) return this.pos.from},
    to: function() {if (this.atOccurrence) return this.pos.to},

    replace: function(newText, origin) {
      if (!this.atOccurrence) return
      var lines = CodeMirror.splitLines(newText)
      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin)
      this.pos.to = Pos(this.pos.from.line + lines.length - 1,
                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0))
    }
  }

  CodeMirror.defineExtension("getSearchCursor", function(query, pos, caseFold) {
    return new SearchCursor(this.doc, query, pos, caseFold)
  })
  CodeMirror.defineDocExtension("getSearchCursor", function(query, pos, caseFold) {
    return new SearchCursor(this, query, pos, caseFold)
  })

  CodeMirror.defineExtension("selectMatches", function(query, caseFold) {
    var ranges = []
    var cur = this.getSearchCursor(query, this.getCursor("from"), caseFold)
    while (cur.findNext()) {
      if (CodeMirror.cmpPos(cur.to(), this.getCursor("to")) > 0) break
      ranges.push({anchor: cur.from(), head: cur.to()})
    }
    if (ranges.length)
      this.setSelections(ranges, 0)
  })
});
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        // CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  var WORD = /[\w$]+/, RANGE = 500;

  CodeMirror.registerHelper("hint", "anyword", function(editor, options) {
    var word = options && options.word || WORD;
    var range = options && options.range || RANGE;
    var cur = editor.getCursor(), curLine = editor.getLine(cur.line);
    var end = cur.ch, start = end;
    while (start && word.test(curLine.charAt(start - 1))) --start;
    var curWord = start != end && curLine.slice(start, end);

    var list = options && options.list || [], seen = {};
    var re = new RegExp(word.source, "g");
    for (var dir = -1; dir <= 1; dir += 2) {
      var line = cur.line, endLine = Math.min(Math.max(line + dir * range, editor.firstLine()), editor.lastLine()) + dir;
      for (; line != endLine; line += dir) {
        var text = editor.getLine(line), m;
        while (m = re.exec(text)) {
          if (line == cur.line && m[0] === curWord) continue;
          if ((!curWord || m[0].lastIndexOf(curWord, 0) == 0) && !Object.prototype.hasOwnProperty.call(seen, m[0])) {
            seen[m[0]] = true;
            list.push(m[0]);
          }
        }
      }
    }
    return {list: list, from: CodeMirror.Pos(cur.line, start), to: CodeMirror.Pos(cur.line, end)};
  });
});
                                                                                                                                                                                                                                                                                                                                      .CodeMirror-hints {
  position: absolute;
  z-index: 10;
  overflow: hidden;
  list-style: none;

  margin: 0;
  padding: 2px;

  -webkit-box-shadow: 2px 3px 5px rgba(0,0,0,.2);
  -moz-box-shadow: 2px 3px 5px rgba(0,0,0,.2);
  box-shadow: 2px 3px 5px rgba(0,0,0,.2);
  border-radius: 3px;
  border: 1px solid silver;

  background: white;
  font-size: 90%;
  font-family: monospace;

  max-height: 20em;
  overflow-y: auto;
}

.CodeMirror-hint {
  margin: 0;
  padding: 0 4px;
  border-radius: 2px;
  white-space: pre;
  color: black;
  cursor: pointer;
}

li.CodeMirror-hint-active {
  background: #08f;
  color: white;
}
                                                                                                                                                                                                                                                                                                                                                                             // CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// Modified for iRProgrammer by FSI
// [9/20/2018] Special processing 'touchstart'

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  var HINT_ELEMENT_CLASS        = "CodeMirror-hint";
  var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";

  // This is the old interface, kept around for now to stay
  // backwards-compatible.
  CodeMirror.showHint = function(cm, getHints, options) {
    if (!getHints) return cm.showHint(options);
    if (options && options.async) getHints.async = true;
    var newOpts = {hint: getHints};
    if (options) for (var prop in options) newOpts[prop] = options[prop];
    return cm.showHint(newOpts);
  };

  CodeMirror.defineExtension("showHint", function(options) {
    options = parseOptions(this, this.getCursor("start"), options);
    var selections = this.listSelections()
    if (selections.length > 1) return;
    // By default, don't allow completion when something is selected.
    // A hint function can have a `supportsSelection` property to
    // indicate that it can handle selections.
    if (this.somethingSelected()) {
      if (!options.hint.supportsSelection) return;
      // Don't try with cross-line selections
      for (var i = 0; i < selections.length; i++)
        if (selections[i].head.line != selections[i].anchor.line) return;
    }

    if (this.state.completionActive) this.state.completionActive.close();
    var completion = this.state.completionActive = new Completion(this, options);
    if (!completion.options.hint) return;

    CodeMirror.signal(this, "startCompletion", this);
    completion.update(true);
  });

  CodeMirror.defineExtension("closeHint", function() {
    if (this.state.completionActive) this.state.completionActive.close()
  })

  function Completion(cm, options) {
    this.cm = cm;
    this.options = options;
    this.widget = null;
    this.debounce = 0;
    this.tick = 0;
    this.startPos = this.cm.getCursor("start");
    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;

    var self = this;
    cm.on("cursorActivity", this.activityFunc = function() { self.cursorActivity(); });
  }

  var requestAnimationFrame = window.requestAnimationFrame || function(fn) {
    return setTimeout(fn, 1000/60);
  };
  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;

  Completion.prototype = {
    close: function() {
      if (!this.active()) return;
      this.cm.state.completionActive = null;
      this.tick = null;
      this.cm.off("cursorActivity", this.activityFunc);

      if (this.widget && this.data) CodeMirror.signal(this.data, "close");
      if (this.widget) this.widget.close();
      CodeMirror.signal(this.cm, "endCompletion", this.cm);
    },

    active: function() {
      return this.cm.state.completionActive == this;
    },

    pick: function(data, i) {
      var completion = data.list[i];
      if (completion.hint) completion.hint(this.cm, data, completion);
      else this.cm.replaceRange(getText(completion), completion.from || data.from,
                                completion.to || data.to, "complete");
      CodeMirror.signal(data, "pick", completion);
      this.close();
    },

    cursorActivity: function() {
      if (this.debounce) {
        cancelAnimationFrame(this.debounce);
        this.debounce = 0;
      }

      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);
      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||
          pos.ch < this.startPos.ch || this.cm.somethingSelected() ||
          (!pos.ch || this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {
        this.close();
      } else {
        var self = this;
        this.debounce = requestAnimationFrame(function() {self.update();});
        if (this.widget) this.widget.disable();
      }
    },

    update: function(first) {
      if (this.tick == null) return
      var self = this, myTick = ++this.tick
      fetchHints(this.options.hint, this.cm, this.options, function(data) {
        if (self.tick == myTick) self.finishUpdate(data, first)
      })
    },

    finishUpdate: function(data, first) {
      if (this.data) CodeMirror.signal(this.data, "update");

      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);
      if (this.widget) this.widget.close();

      this.data = data;

      if (data && data.list.length) {
        if (picked && data.list.length == 1) {
          this.pick(data, 0);
        } else {
          this.widget = new Widget(this, data);
          CodeMirror.signal(data, "shown");
        }
      }
    }
  };

  function parseOptions(cm, pos, options) {
    var editor = cm.options.hintOptions;
    var out = {};
    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];
    if (editor) for (var prop in editor)
      if (editor[prop] !== undefined) out[prop] = editor[prop];
    if (options) for (var prop in options)
      if (options[prop] !== undefined) out[prop] = options[prop];
    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos)
    return out;
  }

  function getText(completion) {
    if (typeof completion == "string") return completion;
    else return completion.text;
  }

  function buildKeyMap(completion, handle) {
    var baseMap = {
      Up: function() {handle.moveFocus(-1);},
      Down: function() {handle.moveFocus(1);},
      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},
      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},
      Home: function() {handle.setFocus(0);},
      End: function() {handle.setFocus(handle.length - 1);},
      Enter: handle.pick,
      Tab: handle.pick,
      Esc: handle.close
    };

    var mac = /Mac/.test(navigator.platform);

    if (mac) {
      baseMap["Ctrl-P"] = function() {handle.moveFocus(-1);};
      baseMap["Ctrl-N"] = function() {handle.moveFocus(1);};
    }

    var custom = completion.options.customKeys;
    var ourMap = custom ? {} : baseMap;
    function addBinding(key, val) {
      var bound;
      if (typeof val != "string")
        bound = function(cm) { return val(cm, handle); };
      // This mechanism is deprecated
      else if (baseMap.hasOwnProperty(val))
        bound = baseMap[val];
      else
        bound = val;
      ourMap[key] = bound;
    }
    if (custom)
      for (var key in custom) if (custom.hasOwnProperty(key))
        addBinding(key, custom[key]);
    var extra = completion.options.extraKeys;
    if (extra)
      for (var key in extra) if (extra.hasOwnProperty(key))
        addBinding(key, extra[key]);
    return ourMap;
  }

  function getHintElement(hintsElement, el) {
    while (el && el != hintsElement) {
      if (el.nodeName.toUpperCase() === "LI" && el.parentNode == hintsElement) return el;
      el = el.parentNode;
    }
  }

  function Widget(completion, data) {
    this.completion = completion;
    this.data = data;
    this.picked = false;
    var widget = this, cm = completion.cm;
    var ownerDocument = cm.getInputField().ownerDocument;
    var parentWindow = ownerDocument.defaultView || ownerDocument.parentWindow;

    var hints = this.hints = ownerDocument.createElement("ul");
    var theme = completion.cm.options.theme;
    hints.className = "CodeMirror-hints " + theme;
    this.selectedHint = data.selectedHint || 0;

    var completions = data.list;
    for (var i = 0; i < completions.length; ++i) {
      var elt = hints.appendChild(ownerDocument.createElement("li")), cur = completions[i];
      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS);
      if (cur.className != null) className = cur.className + " " + className;
      elt.className = className;
      if (cur.render) cur.render(elt, data, cur);
      else elt.appendChild(ownerDocument.createTextNode(cur.displayText || getText(cur)));
      elt.hintId = i;
    }

    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);
    var left = pos.left, top = pos.bottom, below = true;
    hints.style.left = left + "px";
    hints.style.top = top + "px";
    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.
    var winW = parentWindow.innerWidth || Math.max(ownerDocument.body.offsetWidth, ownerDocument.documentElement.offsetWidth);
    var winH = parentWindow.innerHeight || Math.max(ownerDocument.body.offsetHeight, ownerDocument.documentElement.offsetHeight);
    (completion.options.container || ownerDocument.body).appendChild(hints);
    var box = hints.getBoundingClientRect(), overlapY = box.bottom - winH;
    var scrolls = hints.scrollHeight > hints.clientHeight + 1
    var startScroll = cm.getScrollInfo();

    if (overlapY > 0) {
      var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);
      if (curTop - height > 0) { // Fits above cursor
        hints.style.top = (top = pos.top - height) + "px";
        below = false;
      } else if (height > winH) {
        hints.style.height = (winH - 5) + "px";
        hints.style.top = (top = pos.bottom - box.top) + "px";
        var cursor = cm.getCursor();
        if (data.from.ch != cursor.ch) {
          pos = cm.cursorCoords(cursor);
          hints.style.left = (left = pos.left) + "px";
          box = hints.getBoundingClientRect();
        }
      }
    }
    var overlapX = box.right - winW;
    if (overlapX > 0) {
      if (box.right - box.left > winW) {
        hints.style.width = (winW - 5) + "px";
        overlapX -= (box.right - box.left) - winW;
      }
      hints.style.left = (left = pos.left - overlapX) + "px";
    }
    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling)
      node.style.paddingRight = cm.display.nativeBarWidth + "px"

    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {
      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },
      setFocus: function(n) { widget.changeActive(n); },
      menuSize: function() { return widget.screenAmount(); },
      length: completions.length,
      close: function() { completion.close(); },
      pick: function() { widget.pick(); },
      data: data
    }));

    if (completion.options.closeOnUnfocus) {
      var closingOnBlur;
      cm.on("blur", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });
      cm.on("focus", this.onFocus = function() { clearTimeout(closingOnBlur); });
    }

    cm.on("scroll", this.onScroll = function() {
      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();
      var newTop = top + startScroll.top - curScroll.top;
      var point = newTop - (parentWindow.pageYOffset || (ownerDocument.documentElement || ownerDocument.body).scrollTop);
      if (!below) point += hints.offsetHeight;
      if (point <= editor.top || point >= editor.bottom) return completion.close();
      hints.style.top = newTop + "px";
      hints.style.left = (left + startScroll.left - curScroll.left) + "px";
    });

    CodeMirror.on(hints, "dblclick", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}
    });

    CodeMirror.on(hints, "click", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        if (completion.options.completeOnSingleClick) widget.pick();
      }
    });

    // [9/20/2018] FSI Add for iPad
    CodeMirror.on(hints, "touchstart", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        if (completion.options.completeOnSingleClick) widget.pick();
      }
    });

    CodeMirror.on(hints, "mousedown", function() {
      setTimeout(function(){cm.focus();}, 20);
    });

    CodeMirror.signal(data, "select", completions[this.selectedHint], hints.childNodes[this.selectedHint]);
    return true;
  }

  Widget.prototype = {
    close: function() {
      if (this.completion.widget != this) return;
      this.completion.widget = null;
      this.hints.parentNode.removeChild(this.hints);
      this.completion.cm.removeKeyMap(this.keyMap);

      var cm = this.completion.cm;
      if (this.completion.options.closeOnUnfocus) {
        cm.off("blur", this.onBlur);
        cm.off("focus", this.onFocus);
      }
      cm.off("scroll", this.onScroll);
    },

    disable: function() {
      this.completion.cm.removeKeyMap(this.keyMap);
      var widget = this;
      this.keyMap = {Enter: function() { widget.picked = true; }};
      this.completion.cm.addKeyMap(this.keyMap);
    },

    pick: function() {
      this.completion.pick(this.data, this.selectedHint);
    },

    changeActive: function(i, avoidWrap) {
      if (i >= this.data.list.length)
        i = avoidWrap ? this.data.list.length - 1 : 0;
      else if (i < 0)
        i = avoidWrap ? 0  : this.data.list.length - 1;
      if (this.selectedHint == i) return;
      var node = this.hints.childNodes[this.selectedHint];
      if (node) node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, "");
      node = this.hints.childNodes[this.selectedHint = i];
      node.className += " " + ACTIVE_HINT_ELEMENT_CLASS;
      if (node.offsetTop < this.hints.scrollTop)
        this.hints.scrollTop = node.offsetTop - 3;
      else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)
        this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;
      CodeMirror.signal(this.data, "select", this.data.list[this.selectedHint], node);
    },

    screenAmount: function() {
      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
    }
  };

  function applicableHelpers(cm, helpers) {
    if (!cm.somethingSelected()) return helpers
    var result = []
    for (var i = 0; i < helpers.length; i++)
      if (helpers[i].supportsSelection) result.push(helpers[i])
    return result
  }

  function fetchHints(hint, cm, options, callback) {
    if (hint.async) {
      hint(cm, callback, options)
    } else {
      var result = hint(cm, options)
      if (result && result.then) result.then(callback)
      else callback(result)
    }
  }

  function resolveAutoHints(cm, pos) {
    var helpers = cm.getHelpers(pos, "hint"), words
    if (helpers.length) {
      var resolved = function(cm, callback, options) {
        var app = applicableHelpers(cm, helpers);
        function run(i) {
          if (i == app.length) return callback(null)
          fetchHints(app[i], cm, options, function(result) {
            if (result && result.list.length > 0) callback(result)
            else run(i + 1)
          })
        }
        run(0)
      }
      resolved.async = true
      resolved.supportsSelection = true
      return resolved
    } else if (words = cm.getHelper(cm.getCursor(), "hintWords")) {
      return function(cm) { return CodeMirror.hint.fromList(cm, {words: words}) }
    } else if (CodeMirror.hint.anyword) {
      return function(cm, options) { return CodeMirror.hint.anyword(cm, options) }
    } else {
      return function() {}
    }
  }

  CodeMirror.registerHelper("hint", "auto", {
    resolve: resolveAutoHints
  });

  CodeMirror.registerHelper("hint", "fromList", function(cm, options) {
    var cur = cm.getCursor(), token = cm.getTokenAt(cur);
    var term, from = CodeMirror.Pos(cur.line, token.start), to = cur;
    if (token.start < cur.ch && /\w/.test(token.string.charAt(cur.ch - token.start - 1))) {
      term = token.string.substr(0, cur.ch - token.start);
    } else {
      term = "";
      from = cur;
    }
    var found = [];
    for (var i = 0; i < options.words.length; i++) {
      var word = options.words[i];
      if (word.slice(0, term.length) == term)
        found.push(word);
    }

    if (found.length) return {list: found, from: from, to: to};
  });

  CodeMirror.commands.autocomplete = CodeMirror.showHint;

  var defaultOptions = {
    hint: CodeMirror.hint.auto,
    completeSingle: true,
    alignWithWord: true,
    closeCharacters: /[\s()\[\]{};:>,]/,
    closeOnUnfocus: true,
    completeOnSingleClick: true,
    container: null,
    customKeys: null,
    extraKeys: null
  };

  CodeMirror.defineOption("hintOptions", null);
});
                       /* BASICS */

/* [FSI] Modified .CodeMirror to fit editor section. */
/*       Add .CodeMirror-activeline-gutter for highlight execute line. */
/*       Add for highlight of paused line number. */

.CodeMirror {
  /* Set height, width, borders, and global font properties here */
  font-family: monospace;
  height: 95%;	/* [FSI] Modify: 2017/4/12 300px->95% */
  color: black;
  direction: ltr;
}

/* PADDING */

.CodeMirror-lines {
  padding: 4px 0; /* Vertical padding around content */
}
.CodeMirror pre {
  padding: 0 4px; /* Horizontal padding of content */
}

.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {
  background-color: white; /* The little square between H and V scrollbars */
}

/* GUTTER */

.CodeMirror-gutters {
  border-right: 1px solid #ddd;
  background-color: #f7f7f7;
  white-space: nowrap;
}
.CodeMirror-linenumbers {}
.CodeMirror-linenumber {
  padding: 0 3px 0 5px;
  min-width: 20px;
  text-align: right;
  color: #999;
  white-space: nowrap;
}

.CodeMirror-guttermarker { color: black; }
.CodeMirror-guttermarker-subtle { color: #999; }

/* CURSOR */

.CodeMirror-cursor {
  border-left: 1px solid black;
  border-right: none;
  width: 0;
}
/* Shown when moving in bi-directional text */
.CodeMirror div.CodeMirror-secondarycursor {
  border-left: 1px solid silver;
}
.cm-fat-cursor .CodeMirror-cursor {
  width: auto;
  border: 0 !important;
  background: #7e7;
}
.cm-fat-cursor div.CodeMirror-cursors {
  z-index: 1;
}
.cm-fat-cursor-mark {
  background-color: rgba(20, 255, 20, 0.5);
  -webkit-animation: blink 1.06s steps(1) infinite;
  -moz-animation: blink 1.06s steps(1) infinite;
  animation: blink 1.06s steps(1) infinite;
}
.cm-animate-fat-cursor {
  width: auto;
  border: 0;
  -webkit-animation: blink 1.06s steps(1) infinite;
  -moz-animation: blink 1.06s steps(1) infinite;
  animation: blink 1.06s steps(1) infinite;
  background-color: #7e7;
}
@-moz-keyframes blink {
  0% {}
  50% { background-color: transparent; }
  100% {}
}
@-webkit-keyframes blink {
  0% {}
  50% { background-color: transparent; }
  100% {}
}
@keyframes blink {
  0% {}
  50% { background-color: transparent; }
  100% {}
}

/* Can style cursor different in overwrite (non-insert) mode */
.CodeMirror-overwrite .CodeMirror-cursor {}

.cm-tab { display: inline-block; text-decoration: inherit; }

.CodeMirror-rulers {
  position: absolute;
  left: 0; right: 0; top: -50px; bottom: -20px;
  overflow: hidden;
}
.CodeMirror-ruler {
  border-left: 1px solid #ccc;
  top: 0; bottom: 0;
  position: absolute;
}

/* DEFAULT THEME */

.cm-s-default .cm-header {color: blue;}
.cm-s-default .cm-quote {color: #090;}
.cm-negative {color: #d44;}
.cm-positive {color: #292;}
.cm-header, .cm-strong {font-weight: bold;}
.cm-em {font-style: italic;}
.cm-link {text-decoration: underline;}
.cm-strikethrough {text-decoration: line-through;}

.cm-s-default .cm-keyword {color: #708;}
.cm-s-default .cm-atom {color: #219;}
.cm-s-default .cm-number {color: #164;}
.cm-s-default .cm-def {color: #00f;}
.cm-s-default .cm-variable,
.cm-s-default .cm-punctuation,
.cm-s-default .cm-property,
.cm-s-default .cm-operator {}
.cm-s-default .cm-variable-2 {color: #05a;}
.cm-s-default .cm-variable-3, .cm-s-default .cm-type {color: #085;}
.cm-s-default .cm-comment {color: #a50;}
.cm-s-default .cm-string {color: #a11;}
.cm-s-default .cm-string-2 {color: #f50;}
.cm-s-default .cm-meta {color: #555;}
.cm-s-default .cm-qualifier {color: #555;}
.cm-s-default .cm-builtin {color: #30a;}
.cm-s-default .cm-bracket {color: #997;}
.cm-s-default .cm-tag {color: #170;}
.cm-s-default .cm-attribute {color: #00c;}
.cm-s-default .cm-hr {color: #999;}
.cm-s-default .cm-link {color: #00c;}

.cm-s-default .cm-error {color: #f00;}
.cm-invalidchar {color: #f00;}

.CodeMirror-composing { border-bottom: 2px solid; }

/* Default styles for common addons */

div.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}
div.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}
.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }
.CodeMirror-activeline-background {background: #e8f2ff;}
/* [FSI] Add for highlight of execute line number. */
.CodeMirror-activeline-gutter {background: #87cefa;}
/* [FSI] Add for highlight of paused line number. */
.CodeMirror-pause-number {background: #87cefa;}

/* STOP */

/* The rest of this file contains styles related to the mechanics of
   the editor. You probably shouldn't touch them. */

.CodeMirror {
  position: relative;
  overflow: hidden;
  background: white;
}

.CodeMirror-scroll {
  overflow: scroll !important; /* Things will break if this is overridden */
  /* 30px is the magic margin used to hide the element's real scrollbars */
  /* See overflow: hidden in .CodeMirror */
  margin-bottom: -30px; margin-right: -30px;
  padding-bottom: 30px;
  height: 100%;
  outline: none; /* Prevent dragging from highlighting the element */
  position: relative;
}
.CodeMirror-sizer {
  position: relative;
  border-right: 30px solid transparent;
}

/* The fake, visible scrollbars. Used to force redraw during scrolling
   before actual scrolling happens, thus preventing shaking and
   flickering artifacts. */
.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {
  position: absolute;
  z-index: 6;
  display: none;
}
.CodeMirror-vscrollbar {
  right: 0; top: 0;
  overflow-x: hidden;
  overflow-y: scroll;
}
.CodeMirror-hscrollbar {
  bottom: 0; left: 0;
  overflow-y: hidden;
  overflow-x: scroll;
}
.CodeMirror-scrollbar-filler {
  right: 0; bottom: 0;
}
.CodeMirror-gutter-filler {
  left: 0; bottom: 0;
}

.CodeMirror-gutters {
  position: absolute; left: 0; top: 0;
  min-height: 100%;
  z-index: 3;
}
.CodeMirror-gutter {
  white-space: normal;
  height: 100%;
  display: inline-block;
  vertical-align: top;
  margin-bottom: -30px;
}
.CodeMirror-gutter-wrapper {
  position: absolute;
  z-index: 4;
  background: none !important;
  border: none !important;
}
.CodeMirror-gutter-background {
  position: absolute;
  top: 0; bottom: 0;
  z-index: 4;
}
.CodeMirror-gutter-elt {
  position: absolute;
  cursor: default;
  z-index: 4;
}
.CodeMirror-gutter-wrapper ::selection { background-color: transparent }
.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }

.CodeMirror-lines {
  cursor: text;
  min-height: 1px; /* prevents collapsing before first draw */
}
.CodeMirror pre {
  /* Reset some styles that the rest of the page might have set */
  -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;
  border-width: 0;
  background: transparent;
  font-family: inherit;
  font-size: inherit;
  margin: 0;
  white-space: pre;
  word-wrap: normal;
  line-height: inherit;
  color: inherit;
  z-index: 2;
  position: relative;
  overflow: visible;
  -webkit-tap-highlight-color: transparent;
  -webkit-font-variant-ligatures: contextual;
  font-variant-ligatures: contextual;
}
.CodeMirror-wrap pre {
  word-wrap: break-word;
  white-space: pre-wrap;
  word-break: normal;
}

.CodeMirror-linebackground {
  position: absolute;
  left: 0; right: 0; top: 0; bottom: 0;
  z-index: 0;
}

.CodeMirror-linewidget {
  position: relative;
  z-index: 2;
  padding: 0.1px; /* Force widget margins to stay inside of the container */
}

.CodeMirror-widget {}

.CodeMirror-rtl pre { direction: rtl; }

.CodeMirror-code {
  outline: none;
}

/* Force content-box sizing for the elements where we expect it */
.CodeMirror-scroll,
.CodeMirror-sizer,
.CodeMirror-gutter,
.CodeMirror-gutters,
.CodeMirror-linenumber {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
}

.CodeMirror-measure {
  position: absolute;
  width: 100%;
  height: 0;
  overflow: hidden;
  visibility: hidden;
}

.CodeMirror-cursor {
  position: absolute;
  pointer-events: none;
}
.CodeMirror-measure pre { position: static; }

div.CodeMirror-cursors {
  visibi