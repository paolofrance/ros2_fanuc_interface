LAYABLE);//delete the pop-up screen(confirmation)
  //pop-up screen display
  display_popupmsg_common(top, appendArg, true);
}

/*
 =========================================================================
 @function name          : display_popupmsg_common
 @argument[dist_window]  : the window to insert pop-up screen frame.
 @argument[appendArg]    : Warning message string you want to display.
 @argument[hideCloseBtn] : `true` is hide close button.
 @description            : Display pop-up screen.
 @return                 : none.
 =========================================================================
*/
function display_popupmsg_common(dist_window, appendArg, hideCloseBtn) {
  var popupInsertFrame = dist_window;//set the window to insert pop-up screen frame.
  var popupStmPath = "/frh/irprog/ihmieditor/iframe/";
  var contensPage = popupStmPath + "popup_screen.stm";//pop-up screen stm filepath.

  //set popup customizeObj
  var customizeObj = {};
  if(appendArg != null) customizeObj.appendArg = appendArg;
  customizeObj.callerWindowObj = window;//if caller window removed, ihcp remove popup.
  customizeObj.hideCloseBtn = hideCloseBtn;//hide close button
  toast.delete();

  var nIdx = appendArg.popup_screen_type - 1;
  g_popup_frame[nIdx].disp_sts = DEF_POPUP_SCRN_STS.REQ_ON;
  //show pop-up screen
  ihmif.appendPopupFrm(contensPage, null, popupInsertFrame, customizeObj);
}

/*
 =========================================================================
 @function name       : cb_closepopup_location_reload
 @argument[id]        : Operation element ID at pop-up close.
 @argument[operation] : Operation at close. 
 @argument[arg]       : current pop-up screen type. 
 @description         : callback func after popup button selected.
                      : Clear the pop-up screen and redraw timeline.
 @return              : none
 =========================================================================
*/
function cb_closepopup_location_reload(id, operation, arg) {
  var popup_screen_type = arg;
  delete_popup_screen(popup_screen_type);//delete pop-up screen
  rebuild_timeline();//redraw timeline.
}

/*
 =========================================================================
 @function name       : cb_closepopup_move_prglist
 @argument[id]        : Operation element ID at pop-up close.
 @argument[operation] : Operation at close. 
 @argument[arg]       : current pop-up screen type. 
 @description         : callback func after popup button selected.
                      : The pop-up screen is not deleted, and the screen changes to the program selection screen.
 @return              : none
 =========================================================================
*/
function cb_closepopup_move_prglist(id, operation, arg) {
  if(arg) {
    var popup_screen_type = arg;
    delete_popup_screen(popup_screen_type);//delete pop-up screen
  }
  move_prglist();    //display the program selection screen
}

/*
 =========================================================================
 @function name   : cb_sub_close_popup_speed_clamp
 @argument[value] : Checkbox value (true: checked / false: unchecked).
 @description     : If the check box is checked, set the flag "need_show_popup_flg" to "false".
 @return          : none
 =========================================================================
*/
function cb_sub_close_popup_speed_clamp(value) {
  if (typeof value === 'boolean') {
    if (value == true){
      need_show_popup_flg = false;//Set false if you choose not to show pop-up screen again.
    }
  }
}

/*
 =========================================================================
 @function name    : addCmntFeeder
 @argument[addElm] : Target element
 @description      : Add comment feeder.
 @return           : none
 =========================================================================
*/
function addCmntFeeder(addElm) {
  var container = $('<div>', {class: 'commentContainer'});
  var cmnt = g_program_data[addElm.id].param.replace(/\</g, '&lt;').replace(/\>/g, '&gt;');
  container.html('<span class=commentText>' + cmnt + '</span>');
  $(addElm).append(container);

  if(addElm.parentNode.nodeName != '#document-fragment') {
    commentOmitCheck(addElm);
    prevCommentOmitCheck(addElm);
  }
}

/*
 =========================================================================
 @function name    : commentOmitCheck
 @argument[chkElm] : Target element
 @description      : Check to see if any comments need to be omitted.
 @return           : none
 =========================================================================
*/
function commentOmitCheck(chkElm) {
  var chkCmnt = chkElm.getElementsByClassName('commentContainer');
  if(chkCmnt[0] != undefined) {
    $(chkCmnt[0].firstElementChild).removeClass('commentOmit');
    $(chkCmnt[0].firstElementChild).css('width', '');
  }

  /** function: Check that the right edge of the screen and notes. (true:Not rightmost and no notes) **/
  var chkScrnEdgeComment = function(elm) {
    if(g_program_data[elm.id] != undefined && chkScrnEdge(elm.id, 'right') &&
       (g_program_data[elm.id].baseId != 'comment' ||
        g_program_data[elm.id].baseId == 'comment' && g_program_data[elm.id].param == '')) {
        return true;
    }
    return false;
  }

  var cnt = 0, chkCnt = 0;
  while(chkCnt < 3) {
    var chkNextElm = cnt == 0 ? chkElm.nextElementSibling : chkNextElm.nextElementSibling;
    if(chkNextElm == null || chkScrnEdge(chkElm.id, 'right') || chkScrnEdgeComment(chkNextElm)) break;
    if(g_program_data[chkNextElm.id] == undefined) {
      cnt++;
      continue;
    }
    /* instruction element */
    if(chkNextElm.classList.contains('posTeach') || chkNextElm.classList.contains('normal')) {
      /* Note is set on the comment instruction. */
      if(g_program_data[chkNextElm.id].baseId == 'comment' && g_program_data[chkNextElm.id].param != '') {
        var chkNextCmnt = chkNextElm.getElementsByClassName('commentContainer');
        if(chkNextCmnt[0] != undefined &&
           chkElm.offsetLeft + chkCmnt[0].offsetWidth + chkCmnt[0].firstElementChild.offsetWidth > chkNextElm.offsetLeft + 7) {
          $(chkCmnt[0].firstElementChild).addClass('commentOmit');
          var setWidth = (chkNextElm.offsetLeft + 7) - (chkElm.offsetLeft + chkCmnt[0].offsetWidth);
          $(chkCmnt[0].firstElementChild).css('width', setWidth);
        }
        break;
      }
    }
    cnt++, chkCnt++;
  }

  /* vertical scroll view */
  if(g_tlScroll_direction == TL_SCRL_VRTCL) {
    if(chkElm.offsetLeft + chkCmnt[0].offsetWidth + chkCmnt[0].firstElementChild.offsetWidth > chkElm.parentElement.offsetWidth - 7) {
      $(chkCmnt[0].firstElementChild).addClass('commentOmit');
      $(chkCmnt[0].firstElementChild).css('width', (chkElm.parentElement.offsetWidth - 7) - (chkElm.offsetLeft + chkCmnt[0].offsetWidth));
    }
  }
}

/*
 =========================================================================
 @function name   : chkScrnEdge
 @argument[elmId] : Check ID.
 @argument[edge]  : Edge to be checked ('left':Left side edge / 'right':Right side edge)
 @description     : Check if the elements of the ID are at the edge of the screen.
 @return          : Check result. (true: edge of screen)
 =========================================================================
*/
function chkScrnEdge(elmId, edge) {
  if(g_tlScroll_direction == TL_SCRL_VRTCL) {
    if(edge == 'left') {
      if(getPositionFromTLBeginning(elmId) % get_dispWidth_iconNum() == 1) return true;
    }
    else {
      if(getPositionFromTLBeginning(elmId) % get_dispWidth_iconNum() == 0) return true;
    }
  }
  return false;
}

/*
 =========================================================================
 @function name    : prevCommentOmitCheck
 @argument[refElm] : Reference element
 @description      : Check to see if it is necessary to omit the forward comment.
 @return           : none
 =========================================================================
*/
function prevCommentOmitCheck(refElm) {
  var cnt = 0, chkCnt = 0;
  while(cnt < 3) {
    var chkPrevElm = cnt == 0 ? refElm.previousElementSibling : chkPrevElm.previousElementSibling;
    if(chkPrevElm == null || chkPrevElm.id == 'TL_spacer') break;
    if(g_program_data[chkPrevElm.id] == undefined) {
      cnt++;
      continue;
    }
    if(chkPrevElm.classList.contains('posTeach') || chkPrevElm.classList.contains('normal')) {
      if(g_program_data[chkPrevElm.id].baseId == 'comment' && g_program_data[chkPrevElm.id].param != '') {
        commentOmitCheck(chkPrevElm);
        break;
      }
    }
    cnt++, chkCnt++;
  }
}

/*
 =========================================================================
 @function name   : getPositionFromTLBeginning
 @argument[elmId] : ID of the instruction to be checked
 @description     : Checks to see how many elements with a given ID are located from the beginning of the timeline.
 @return          : Position from the beginning
 =========================================================================
*/
function getPositionFromTLBeginning(elmId) {
  return g_TL_progInfo.dispProg.indexOf(elmId) + 1;
}

/*
 =========================================================================
 @function name   : getRowFromTLTop
 @argument[elmId] : ID of the target element
 @description     : Get the number of rows from the top for the element with the specified ID.
 @return          : How many rows from the top
 =========================================================================
*/
function getRowFromTLTop(elmId) {
  var ret = 1;
  /* vertical scroll view */
  if(g_tlScroll_direction == TL_SCRL_VRTCL) {
    ret = Math.ceil(getPositionFromTLBeginning(elmId) / get_dispWidth_iconNum());
  
    ret = (ret > 0) ? ret : 1;
  }

  return ret;
}

/*
 =========================================================================
 @function name : getColumnRowFromTLTop
 @argument      : none
 @description   : Get the number of rows from the top of the cursor.
 @return        : Number of rows where the cursor is displayed
 =========================================================================
*/
function getColumnRowFromTLTop() {
  var ret = g_TL_elm.getElementsByClassName('clm_active')[0].id;

  return (ret == 'exe_column') ? 1 : Number(ret.replace('exe_column_',''));
}

/*
 =========================================================================
 @function name    : chk_basicInstruction
 @argument[baseId] : Base ID of the instruction to be checked
 @description      : Checks if the specified instruction is a basic instruction
 @return           : Result (true: basic instruction / false: Advanced instruction)
 =========================================================================
*/
function chk_basicInstruction(baseId) {
  return (Object.keys(g_xml_data).indexOf(baseId) == -1) ? true : false;
}

/*
=========================================================================
@function name      : setSysValXHR
@argument[frameXml] : XML string
@argument[callback] : Callback function to be called after processing
@argument[arg]      : Callback argument
@description        : Set system variables.
@return             : none
=========================================================================
*/
function setSysValXHR(frameXml, callback, arg) {
  // Create File
  var fileXvr = top.irprogapi.inner.createBlob(frameXml);
  top.postXHR('ihmiSysVal.xvr', fileXvr, callback, arg); // io
}

/*
=========================================================================
@function name      : setHistSysValXHR
@argument[callback] : Callback function to be called after processing
@argument[arg]      : Callback argument
@description        : Writes history to system variables
@return             : none
=========================================================================
*/
function setHistSysValXHR(callback, arg) {
	var frameXml = "";
	frameXml += '<?xml version="1.0" encoding="Shift_JIS"?>\r';
	frameXml += '<XMLVAR>\r<PROG name="*SYSTEM*">\r';
	frameXml += '<VAR name="$IHMI_EDIT.$HIST[1]">' + g_latest_command[0] +'</VAR>\r';
	frameXml += '<VAR name="$IHMI_EDIT.$HIST[2]">' + g_latest_command[1] +'</VAR>\r';
	frameXml += '<VAR name="$IHMI_EDIT.$HIST[3]">' + g_latest_command[2] +'</VAR>\r';
	frameXml += '<VAR name="$IHMI_EDIT.$HIST[4]">' + g_latest_command[3] +'</VAR>\r';
	frameXml += '<VAR name="$IHMI_EDIT.$HIST[5]">' + g_latest_command[4] +'</VAR>\r';
    frameXml += '<VAR name="$IHMI_EDIT.$HIST[6]">' + g_latest_command[5] +'</VAR>\r';
    frameXml += '<VAR name="$IHMI_EDIT.$HIST[7]">' + g_latest_command[6] +'</VAR>\r';
    frameXml += '<VAR name="$IHMI_EDIT.$HIST[8]">' + g_latest_command[7] +'</VAR>\r';
    frameXml += '<VAR name="$IHMI_EDIT.$HIST[9]">' + g_latest_command[8] +'</VAR>\r';
    frameXml += '<VAR name="$IHMI_EDIT.$HIST[10]">' + g_latest_command[9] +'</VAR>\r';
	frameXml += '</PROG>\r</XMLVAR>';
	
	// Create File
	var fileXvr = top.irprogapi.inner.createBlob(frameXml);
	var cbArgs = {};
	//cbArgs.sysIndex = sysIndex;
	cbArgs.cbFunc = callback;
	cbArgs.cbObj = arg;
	top.postXHR('ihmiSysVal.xvr', fileXvr, callback, cbArgs); // io
}

/*
 =========================================================================
 @function name  : redraw_posInfoPin
 @argument[id]   : ID of the instruction to redraw the position pin
 @description    : Redraw the position information pin.
 @return         : none
 =========================================================================
*/
function redraw_posInfoPin(id) {
  $('#' + id).find('.posInfoNo').remove();
  $('#' + id).find('.posOmit').remove();
  /* When posinfo is specified, only the selected pin is displayed. */
  var posInfo = getPosInfoList(id);
  if (posInfo.flg.length > 0 || posInfo.endFlg.length > 0) {
    chkPosInfo(null, g_program_data[id].param, id, posInfo);
  } else {
    for (var pos = 0; pos < g_program_data[id].position.length && pos < 4; pos++) {
      if(g_program_data[id].position[pos].disp == 'ON') {
        /* Create position pin. */
        addPosTriangle(document.getElementById(id), g_program_data[id].position[pos].number, pos);
      }
    }
  }
}

/*
 =========================================================================
 @function name : set_tl_dispName
 @argument[]    : none
 @description   : Set the name of the program being displayed.
 @return        : none
 =========================================================================
*/
function set_tl_dispName() {
  var nameElm = document.getElementById('dispProgName');
  if(nameElm) {
    nameElm.innerText = (current_prog_name != TL_NO_DISP_NAME) ? current_prog_name : '';
  }
}

/*
 =========================================================================
 @function name : get_progList_bkt
 @argument[]    : none
 @description   : Create and retrieve a list of the bracket instruction from the program being displayed.
 @return        : none
 =========================================================================
*/
function get_progList_bkt() {
  return g_TL_progInfo.saveProg.filter(function(key) { return stretch_idStrChk(STRETCH_ID_CHK_ALL, key); });
}

/*
 =========================================================================
 @function name : get_progList_bktlead
 @argument[]    : none
 @description   : Create and retrieve a list of the bracket lead instruction from the program being displayed.
 @return        : none
 =========================================================================
*/
function get_progList_bktlead() {
  return g_TL_progInfo.bktSaveProg.filter(function(key) { return stretch_idStrChk(STRETCH_ID_CHK_LEAD, key); });
}

/*
 =========================================================================
 @function name : get_progList_selected
 @argument[]    : none
 @description   : Create a list from the program being displayed with the specified parameters matching g_program_data[].select.
 @return        : none
 =========================================================================
*/
function get_progList_selected(select) {
  return g_TL_progInfo.saveProg.filter(function(key) { return g_program_data[key].select == select; });
}

/*
 =========================================================================
 @function name      : addEmptyPosition_forMotionReplace
 @argument[targetId] : Target instruction ID
 @description        : Replace instruction : Add unteached information when replacing Curve.
 @return             : none
 =========================================================================
*/
function addEmptyPosition_forMotionReplace(targetId) {
  var addPosNum = g_program_data[targetId].position[1].number;
  get_posNumData(addPosNum, posNumData_cb, null);

  /** Callback function **/
  function posNumData_cb(posNum, resultPosRecArray, cbArg) {
    var cartKey = ['X', 'Y', 'Z', 'W', 'P', 'R'];
    /* new empty position data */
    position.push(make_position_data(posNum));
    var pData = position.slice(-1)[0];
    pData.Comment = resultPosRecArray[0].comment;
    for (key in resultPosRecArray) {
      var posData = resultPosRecArray[key];
      pData.posData.push({ poskey: [] });
      var gData = pData.posData.slice(-1)[0];

      gData.configStr = posData.conf;
      gData.ufVal = posData.uf;
      gData.utVal = posData.ut;
      gData.groupNumber = Number(posData.group);
      gData.empty = posData.empty;

      /* cart */
      for(var cnt = 0; cnt < cartKey.length; cnt++) {
        gData.poskey[cnt] = { key: cartKey[cnt], val: posData.cart[cartKey[cnt]] };
      }
      /* extend axes */
      for (var axesCnt = 1; cnt <= 8; cnt++, axesCnt++) {
        gData.poskey[cnt] = { key: 'EXT' + axesCnt, val: posData.ext['E' + axesCnt] };
      }
    }
  }
}

/*
 =========================================================================
 @function name      : get_posNumData
 @argument[posnum]   : Position number from which to obtain data.
 @argument[callback] : Callback function.
 @argument[arg]      : Arguments to be set for the callback function.
 @description        : Obtains the data of the specified position information number with a callback function.
 @return             : none
 =========================================================================
*/
function get_posNumData(posnum, callback, arg) {
  var cbArg1 = {callback:get_posValue_cb, number:posnum, cbArg: arg};

  /** Callback function **/
  function get_posValue_cb(cbArg) {
    var posNum = cbArg.number;
    var resultPosRecArray = cbArg.posRecArray;
    callback(posNum, resultPosRecArray, cbArg.cbArg); // Call callback function.
  };

  top.get_posValue(true,                        /* Synchronous (false : Asynchronous) */
                   current_prog_name,           /* target program */
                   posnum,                      /* Position information number from which to obtain data */
                   analizeAndCreatePosInfo,     /* Callback function */
                   cbArg1,                      /* First argument of callback function */
                   null);                       /* Second argument of callback function */
}

/*
 =========================================================================
 @function name          : analizeAndCreatePosInfo
 @argument[status]       : result
 @argument[prog_name]    : current program name
 @argument[posnum]       : position number
 @argument[postxt]       : position data
 @argument[comment]      : position data comments
 @argument[callbackarg1] : Any object to pass to the callback function.
 @argument[callbackarg2] : Any object to pass to the callback function.
 @description            : Analyze the acquired data and molding.
 @return                 : none
 =========================================================================
*/
function analizeAndCreatePosInfo(status, prog_name, posnum, postxt, comment, callbackarg1, callbackarg2) {
  var isNotTeached = false, posRecArray = [], posRec = JSON.parse(JSON.stringify(DEF_UNTEACHED_POS_VAL)), resultPosRec;
  var statusUnteached = (ActiveVersion == V9Definition) ?
                          (status === top.IOSTAT_MEMO_189) || (status === '0x700BD') :
                          (status === top.IOSTAT_MEMO_189) || (status === '0x700BD') || (status === top.IOSTAT_MEMO_190) || (status === '0x700BE');

  if((status == IO_SUCCESS) || (status == top.IOSTAT_HRTL_022)) { // HRTL_022 : Get halfway
    if(Array.isArray(postxt)) {
      for(var i = 0; i < postxt.length; i++) {
        posRec = JSON.parse(JSON.stringify(DEF_UNTEACHED_POS_VAL));
        isNotTeached = analizePosTxt(postxt[i], posRec);
        addInfo(isNotTeached, posRec);
        posRecArray.push(posRec);
      }
    }
    else { // Single group
      //This route does not pass.
      isNotTeached = analizePosTxt(postxt, posRec);
      addInfo(isNotTeached, posRec);
      posRecArray.push(posRec);
    }
  }
  else if(statusUnteached) { // unteached
    if(getMotionGroup() > 1) { // valid multi group.
      var mtnGrpArr = getMotionGroupArray();
      for(var g = 0; g <= mtnGrpArr.length; g++) {
        if(!mtnGrpArr[g]) continue; // Skip if it is an invalid group.
        posRec = JSON.parse(JSON.stringify(DEF_UNTEACHED_POS_VAL));
        addInfo(true, posRec);
        posRec.group = g + 1;
        posRecArray.push(posRec);
      }
    }
    else {
      addInfo(true, posRec);
      posRec.group = getCurrentGroupNum();
      posRecArray.push(posRec);
    }
  } else {}

  resultPosRec = [];
  resultPosRec = posRecArray;

  if ((callbackarg1.callback != undefined) && (typeof callbackarg1.callback === 'function')) {
    /* Callback function is called */
    callbackarg1.posRec = resultPosRec;
    callbackarg1.posRecArray = posRecArray;
    callbackarg1.callback(callbackarg1);
  }

  /** function : Add information other than coordinates **/
  function addInfo(isNotTeached, posRec) {
    if(isNotTeached) {
      //exist pos info but not teached.
      posRec.posNumber = posnum;
      posRec.empty = true;
      posRec.comment = (comment !== null) ? comment:  '';
    } else {
      var robotAxes = top.irprogapi.getAxisData();
      posRec.axes = (posRec.crntFrm == top.COORDINATECART) ? getExtendAxesCount(posRec.group): robotAxes.robot[posRec.group];
      posRec.posNumber = posnum;
      posRec.comment = comment;
      var frameType = ((posRec.conf != undefined) && (posRec.conf.length > 0)) ? top.COORDINATECART : top.COORDINATEJOINT;
      posRec.frame = frameType;
      posRec.rep = getRepKind(frameType, posRec.group);
      posRec.empty = false;
    }
  }

  /** function : Analysis of coordinate information **/
  function analizePosTxt(postxt, posRec) {
    //judge uninitialize
    //ex "Group: 1 Uninitialized"
    var uninitMatchResult = postxt.match(/Group:\s*\d+\s*Uninitialized\s*/);
    var isNotTeached = (uninitMatchResult === null) ? false: true;

    //1st incase joint. J1 = 0.000000 deg  -> J1 : 0.000000 deg
    postxt = postxt.replace(/\s*=/g,':');
    //2nd text data"X: 0.000000 Y: 0.000000~" -> make array ["X: 0.000000", "Y: 0.000000", ~]
    var matchArray = postxt.match(/\w+:\s*[a-zA-Z0-9.-]+\s*/g);
    var matchResult, key, utVal, ufVal;
    var posKeyTable = [ // for Analyze position string.
      {matchKey: 'GROUP', matchStr: /^Group$/},
      {matchKey: 'CART', matchStr: /^[XYZWPR]/},
      {matchKey: 'JOINT', matchStr: /^[J]\d/},
      {matchKey: 'EXT', matchStr: /^EXT\d/},
      {matchKey: 'UF', matchStr: /^UF$/},
      {matchKey: 'UT', matchStr: /^UT$/}
    ];

    for(var i = 0; i < matchArray.length; i++) {
      //3rd array ["X: 0.000000", "Y: 0.000000", ,]
      matchResult = matchArray[i].match(/(\w+):\s*([a-zA-Z0-9.-]+)\s*/);
      if(matchResult !== null) {
        //set posRec struct
        key = matchResult[1];
          var matchPos = posKeyTable.find(function(tbl) { return key.match(tbl.matchStr) });
        if(matchPos == null) continue;

        switch(matchPos.matchKey) {
          case 'GROUP':
            posRec.group = parseInt(matchResult[2]);
            if(isNotTeached) return isNotTeached;
            break;
          case 'CART': // cartesian
            posRec.cart[key] = parseFloat(matchResult[2]);
            break;
          case 'JOINT':
            posRec.joint[key] = parseFloat(matchResult[2]);
            break;
          case 'EXT': // extend axis
            var extendNum = parseInt(key.substr(3));
            posRec.ext['E' + extendNum] = parseFloat(matchResult[2]);
            break;
          case 'UF':
            ufVal = parseInt(matchResult[2]);
            if(isNaN(ufVal)) ufVal = '';
            posRec.uf = parseInt(ufVal);
            break;
          case 'UT':
            utVal = parseInt(matchResult[2]);
            if(isNaN(utVal)) utVal = '';
            posRec.ut = parseInt(utVal);
            break;
          default:
            break;
        }
      }
    }
    var matchArrayConf = postxt.match(/(Config):\s*(.+)[\r\n]/);
    if (matchArrayConf !== null) {//config
        posRec.conf = matchArrayConf[2];
    }
    return isNotTeached;
  }
}

/*
 =========================================================================
 @function name  : startMonitorCurProgModify
 @argument       : none
 @description    : start monitor 'VarEvent'
 @return         : none
 =========================================================================
*/
function startMonitorCurProgModify() {
  /* Monitor start check */
  if(!g_progModifyInfo.runMonitor && g_progModifyInfo.initializing && !g_progModifyInfo.frcStop) {
      /* Start PMON monitor for $IHMI_EDIT.$MDFY_TIME */
    g_progModifyInfo.runMonitor = true;
    top.rpcmc_startVarMonitor(top.SYSNAME_C, '$IHMI_EDIT.$MDFY_TIME', 100);
  }
}

/*
 =========================================================================
 @function name  : stopMonitorCurProgModify
 @argument       : none
 @description    : stop current program modify monitor
 @return         : none
 =========================================================================
*/
function stopMonitorCurProgModify() {
  g_progModifyInfo.initializing = false;
  /* Monitoring */
  if(g_progModifyInfo.runMonitor) {
    /* Stop PMON monitor for $IHMI_EDIT.$MDFY_TIME */
    g_progModifyInfo.runMonitor = false;
    top.rpcmc_stopVarMonitor(top.SYSNAME_C, '$IHMI_EDIT.$MDFY_TIME', 100);
  }
}

/*
 =========================================================================
 @function name    : monitorEventCurProgModify
 @argument[valStr] : varName's value
 @description      : Processing when update time is received
 @return           : none
 =========================================================================
*/
function monitorEventCurProgModify(valStr) {
  if(!g_progModifyInfo.runMonitor) return;
  var splitStr = valStr.split(',');

  /** function : Check for differences from stored values. **/
  function defChkModifyTime(splitStr) {
    var ret = false;
    /* Modify time of the program being displayed */
    if(current_prog_name == splitStr[0]) {
      /* Determine the storage destination */
      var modifiedDest = (tp_prog_name == splitStr[0]) ? 'main' : 'sub';
      /* Modified check */
      ret = (g_progModifyInfo[modifiedDest].name != '' && g_progModifyInfo[modifiedDest].time != 0) &&
            (g_progModifyInfo[modifiedDest].name == splitStr[0] && g_progModifyInfo[modifiedDest].time < Number(splitStr[1]));
    }
    return ret;
  }

  /* There is a difference with the stored value. */
  if(defChkModifyTime(splitStr)) {
    /* Stores notified information */
    setCurProgModifyTime(splitStr[0], splitStr[1]);
    /* main program */
    if(tp_prog_name === splitStr[0]) {
      create_screen_finish_flg = true;  /* Flag set for completion check */
    }
    modifyProgReload(splitStr[0], PRG_LOAD_REASON_MONITOR);
  }
}

/*
 =========================================================================
 @function name     : modifyProgReload
 @argument[prgName] : Program name to reload
 @argument[reason]  : Reason for loading
 @description       : Reload process when subprograms are edited from externally
 @return            : none
 =========================================================================
*/
function modifyProgReload(prgName, reason) {
  dispOnWaiting(0);
  if(activeTarget != '') {
    icon_inactive();
  }
  if(g_btnTeaching_list.weldteach.existsTimeline == true) {
    top.setArcTeachFg(false);
    weldingTeachEnd(false);
  }
  /* delete the pop-up screen */
  delete_popup_screen(DEF_POPUP_SCRN_TYP.ALL);
  /* initialize */
  initializ_timeline();
  init_record();
  /* reload the program */
  var cbFunc = (reason == PRG_LOAD_REASON_MONITOR) ? readPrgFromMonitorCB :
               (reason == PRG_LOAD_REASON_EXEC) ? readPrgFromExecCB : readPrgCallback;
  getProgramText(prgName, 1, cbFunc);
}

/*
 =========================================================================
 @function name  : setCurProgModifyTime
 @argument[prog] : Name of the program that made the modification
 @argument[time] : Modification time
 @description    : Stores notified information
 @return         : none
 =========================================================================
*/
function setCurProgModifyTime(prog, time) {
  /* The modified time of the displayed program or the main program. */
  if(current_prog_name == prog || tp_prog_name == prog) {
    /* Determine the storage destination */
    var modifiedDest = (tp_prog_name == prog) ? 'main' : 'sub';
    g_progModifyInfo[modifiedDest] = {name: prog, time: Number(time)};
  }
}

/*
 =========================================================================
 @function name    : initCurProgModifyInfo
 @argument[target] : Target of initialization. (If unspecified, both main/sub are initialized.)
 @description      : Initialize the destination
 @return           : none
 =========================================================================
*/
var INIT_MDFY_INFO_MAIN = 'main';
var INIT_MDFY_INFO_SUB  = 'sub';
function initCurProgModifyInfo(target) {
  /* unspecified */
  if(typeof target == 'undefined') {
    g_progModifyInfo[INIT_MDFY_INFO_MAIN] = {name: '', time: 0};
    g_progModifyInfo[INIT_MDFY_INFO_SUB]  = {name: '', time: 0};
  }
  else {
    if([INIT_MDFY_INFO_MAIN, INIT_MDFY_INFO_SUB].includes(target)) {
      g_progModifyInfo[target] = {name: '', time: 0};
    }
  }
}

/*
 =========================================================================
 @function name      : getCurProgModifyTime
 @argument[callback] : Callback process to be called after acquisition.
 @description        : Get the value of '$IHMI_EDIT.$MDFY_TIME'.
 @return             : none
 =========================================================================
*/
function getCurProgModifyTime(callback) {
  g_progModifyInfo.initializing = true;
  /* Get modify time */
  getProgAttr(current_prog_name, top.MM_MDFY_TIME_C, modifyTimeCallback);

  /** Callback function **/
  /* [io_type]  : I/O type at request
   * [io_index] : I/O index at request
   * [str]      : The value of the system variable obtained.
   * [arg]      : Arguments set at the time of the request. (not used)
   * [status]   : State of the system variable (0x00:exists / other:not exists) */
  function modifyTimeCallback(status, progName, attrType, str, arg) {
    if(status == IO_SUCCESS) {
      /* Stores notified information */
      setCurProgModifyTime(progName, str);
      /* Callback is specified */
      if(typeof callback == 'function') { callback(); }
      g_progModifyInfo.initializing = false;
    }
  }
}

/*
 =========================================================================
 @function name        : notifyComponentPosEdit
 @argument[editStatus] : Component Editing Status
 @description          : Notification of Component edit start/completion
 @return               : none
 =========================================================================
*/
function notifyComponentPosEdit(editStatus) {
  /* Component is editing the coordinates */
  if(editStatus) {
    stopMonitorCurProgModify();
  }
  /* Editing complete */
  else {
    getCurProgModifyTime(startMonitorCurProgModify);
  }
}

/*
 =========================================================================
 @function name    : checkErrorCode
 @argument[valStr] : Value notified by monitor (String)
 @description      : Alarm check after Path Teach implementation.
 @return           : none
 =========================================================================
*/
function checkErrorCode(valStr) {
  /* function */
  function getCompErrCode(cmpFacId, cmpErrNum) {
    var cmpFacIdBin = ('0000000000000' + (Number(cmpFacId)).toString(2)).slice(-13);
    var facNext = cmpFacIdBin.slice(0, -7);
    var facPre = cmpFacIdBin.slice(-7);
    var cmpFacCode = facPre + facNext;
    var cmpErrNumBin = ('0000000000' + (Number(cmpErrNum)).toString(2)).slice(-10);
    return cmpFacCode + '_' + cmpErrNumBin;
  }

  var errCodeBin = (('00000000000000000000000000000000' + (Number(valStr) >>> 0).toString(2)).slice(-32));
  var facCode = errCodeBin.slice(9, 22);
  var errCode = errCodeBin.slice(22);
  var almErrCode = facCode + '_' + errCode;
  /* TPIF-298 */
  if(almErrCode == getCompErrCode(ALM_FAC_ID_TEACH, ALM_NUM_SPEED_CLAMP)) {
    var dispStr = langResource.ihmieditor_pop_path_teach_clamp_message1_c + '<br><br>' +
                  langResource.ihmieditor_pop_path_teach_clamp_message2_c;
    /* Displaying wizard screen */
    if(g_editor_status.pathTeachInfo.wizDisp) {
      g_editor_status.pathTeachInfo.clampErr = dispStr;
    } else {
      display_popupmsg_alert(DEF_POPUP_SCRN_TYP.ALERT, dispStr, DISP_CLOSE_BTN);
    }
  }
}
                                                                                                                                                                                                             /*
 * @fileoverview : define file
 * @char-code    : SJIS
 * @NewLineCode  : LF
 */
//=============================================================================
// define
//=============================================================================
var ihmif = top.IHMIComponents.cf;

// define version
var V9Definition = 9;   //program version V9.40
var V10Definition = 10; //program version V10
var ActiveVersion = V9Definition; //current version

// program version
var PROG_VERSION	= 'v00.55.01';

var device = '';         // device
//=============================================================================
// Event type determination by device type
//=============================================================================
//Device judgment by UA
if(navigator.userAgent.indexOf('iPhone') > 0 ||
	navigator.userAgent.indexOf('iPod') > 0 ||
	navigator.userAgent.indexOf('Windows Phone') > 0 ||
	navigator.userAgent.indexOf('iPad') > 0 ||
	navigator.userAgent.indexOf('Android') > 0) {
	device = 'smt';
}
else{
	device = 'pc';
}

// Time measurement(1:output / 0: no output)
var DEBUG_TIME_MEASURE = 0;

// touch / drag event
var startEventTouch = 'touchstart';     // Drag start event
var moveEventTouch  = 'touchmove';      // Event being dragged
var endEventTouch   = 'touchend';       // Drag end event
var leaveEventTouch = 'touchleave';     // Leave event
var startEventMouse = 'mousedown';      // Drag start event
var moveEventMouse  = 'mousemove';      // Event being dragged
var endEventMouse   = 'mouseup';        // Drag end event
var leaveEventMouse = 'mouseleave';     // Leave event

// Waiting Animation delay value
var WAIT_ANIMATION_DELAY_VAL = 300;

//// Act Mode2(ROBO/SIMU)
//var MODE2_ROBO	    = 0;
//var MODE2_SIMU	    = 1;
//var MODE2_ACTION    = MODE2_ROBO;

// ProgramIconNo
var ICON_NO_KAKUJIKU	= 11;	// axis
var ICON_NO_STRAIGHT	= 12;	// Straight
var ICON_NO_CIRCULAR	= 13;	// circular
var ICON_NO_CIRCLEARC	= 14;
var ICON_NO_SPLINE		= 15;
var ICON_NO_MACRO		= 21;	// macro
var ICON_NO_CALL		= 22;	//
var ICON_NO_WAIT		= 23;	//
var ICON_NO_IF			= 31;	//
var ICON_NO_IFELSE		= 32;	//
var ICON_NO_IFEND		= 33;	//
var ICON_NO_FOR			= 34;	//
var ICON_NO_FOREND		= 35;	//
var ICON_NO_JUMP		= 36;	//
var ICON_NO_LABEL		= 37;	//
var ICON_NO_REGI		= 41;	//
var ICON_NO_PAYLOAD		= 42;	//
var ICON_NO_OUTPUT		= 44;	//
var ICON_NO_COMMENT		= 51;	//
var ICON_NO_VSN_LINE	= 61;	//
var ICON_NO_VSN_JOINT	= 62;	//
var ICON_NO_NOCONNECT	= 63;	//
var ICON_NO_ARC_LINE	= 71;	//
var ICON_NO_ARC_CIRCLE	= 72;	//
var ICON_NO_LASER_PRE	= 73;	//
var ICON_NO_LASER_LS	= 74;	//
var ICON_NO_LASER_LE	= 75;	//
var ICON_NO_LASER_PWC   = 76;	//
var ICON_NO_LASER_PRE_SI = 77;	//
var ICON_NO_LASER_LS_SI	 = 78;	//
var ICON_NO_LASER_LE_SI	 = 79;	//
var ICON_NO_LASER_WIRC   = 80;	//

var ICON_NO_WELD_START_MO = 81;	//
var ICON_NO_ARC_STOP_MO	  = 82;	//
var ICON_NO_WELD_START_AL = 83;	//
var ICON_NO_ARC_STOP_AL	  = 84;	//
var ICON_NO_SET_UFRAME   =  85;
var ICON_NO_SET_UTOOL    =  86;
var ICON_NO_SEL_UFRAME   =  87;
var ICON_NO_SEL_UTOOL    =  88;
var ICON_NO_LASER_K_PRE	= 89;	// 
var ICON_NO_LASER_K_LS	= 90;	// 
var ICON_NO_LASER_K_LE	= 91;	// 

var ICON_NO_SENSOR_ON  = 92;
var ICON_NO_SENSOR_OFF = 93;
var ICON_NO_SEARCH_ON  = 94;
var ICON_NO_DETECT_JOINT   = 95;
var ICON_NO_TRACK_DPM  = 96;
var ICON_NO_TRACK_END  = 97;

var ICON_NO_NOSUPPORT    = 99;

var ICON_NO_WELD_START_CA = 100;
var ICON_NO_ARC_STOP_CA   = 101;

// String
var ORDER_LINE     = langResource.ihmieditor_order_l_c;
var ORDER_JOINT    = langResource.ihmieditor_order_j_c;
var ORDER_CURVE    = langResource.ihmieditor_order_c_c;
var ORDER_CIRCLEARC= langResource.ihmieditor_order_a_c;
var ORDER_SPLINE   = langResource.ihmieditor_order_s_c;
var ORDER_CALL     = langResource.ihmieditor_order_call_c;
var ORDER_WAIT     = langResource.ihmieditor_order_wait_c;
var ORDER_POS      = langResource.ihmieditor_order_pos_c;
var ORDER_FINE     = langResource.ihmieditor_order_ichigime_c;
var ORDER_CNT      = langResource.ihmieditor_order_nameraka_c;
var ORDER_CR       = langResource.ihmieditor_order_cr_c;
var ORDER_ERRORNUM = langResource.ihmieditor_order_errornum_c;
var ORDER_JUMP     = langResource.ihmieditor_order_jump_c;
var ORDER_LABEL    = langResource.ihmieditor_order_label_c;
var ORDER_REGI     = langResource.ihmieditor_order_regi_c;
var ORDER_WELD_SPEED = langResource.ihmieditor_order_weld_speed_c;
var ORDER_POSREGI  = langResource.ihmieditor_order_posregi_c;
var ORDER_STRREGI  = langResource.ihmieditor_order_strregi_c;
var ORDER_PAYLOAD  = langResource.ihmieditor_order_payload_c;
var ORDER_UFRAME   = langResource.ihmieditor_order_uframe_c;
var ORDER_UTOOL    = langResource.ihmieditor_order_utool_c; 
var ORDER_UFRAME_NUM = langResource.ihmieditor_order_uframe_num_c;
var ORDER_UTOOL_NUM  = langResource.ihmieditor_order_utool_num_c; 
var ORDER_PULSE    = langResource.ihmieditor_order_pulse_c;
var ORDER_ON       = langResource.ihmieditor_order_on_c;
var ORDER_OFF      = langResource.ihmieditor_order_off_c;
var ORDER_CONFIG   = langResource.ihmieditor_order_config_c;
var ORDER_ARGUMENT = langResource.ihmieditor_order_argument_c;
var ORDER_CONSTANT = langResource.ihmieditor_order_constant_c;
var ORDER_AND      = langResource.ihmieditor_order_and_c;
var ORDER_OR       = langResource.ihmieditor_order_or_c;
var ORDER_TIMER_OF = langResource.ihmieditor_order_timeroverflow_c;
var ORDER_TIMER    = langResource.ihmieditor_order_timer_c;
var ORDER_TIMEOUT  = langResource.ihmieditor_order_timeout_c;
var ORDER_WELDSTART= langResource.ihmieditor_order_weldstart_c;
var ORDER_WELDEND  = langResource.ihmieditor_order_weldend_c;
var ORDER_VOFFSET  = langResource.ihmieditor_order_voffset_c;
var ORDER_VR       = langResource.ihmieditor_order_vr_c;
var ORDER_PLE_LS   = langResource.ihmieditor_order_laser_pre_ls_c;
var ORDER_LS       = langResource.ihmieditor_order_laser_ls_c;
var ORDER_LE       = langResource.ihmieditor_order_laser_le_c;
var ORDER_PWC      = langResource.ihmieditor_order_laser_powc_c;
var ORDER_SLPU     = langResource.ihmieditor_order_laser_slope_up_c;
var ORDER_SLPD     = langResource.ihmieditor_order_laser_slope_down_c;
var ORDER_LS_SCH   = langResource.ihmieditor_order_laser_ls_sch_c;
var ORDER_WIRC     = langResource.ihmieditor_order_laser_wirc_c;

var ORDER_SENSOR       = langResource.ihmieditor_order_arc_sensor_c;
var ORDER_SEARCH       = langResource.ihmieditor_order_arc_search_c;
var ORDER_DETECT_JOINT = langResource.ihmieditor_order_arc_detect_joint_c;
var ORDER_TRACK        = langResource.ihmieditor_order_track_c;
var ORDER_TRACK_DPM    = langResource.ihmieditor_order_arc_tracking_dpm_c;
var ORDER_TRACK_END    = langResource.ihmieditor_order_arc_tracking_end_c;

var ORDER_MAX_SPEED    = langResource.ihmieditor_order_max_speed_c;
var DTL_CONSTANT     = langResource.ihmieditor_detail_constant_c;

//operation
var OPERATION_ADD = 1;
var OPERATION_SORT = 2;
var OPERATION_DELETE = 3;
var OPERATION_EDIT = 4;
var OPERATION_PASTE = 5;
var OPERATION_DELETE_MULTI = 6;
var OPERATION_STRETCH = 7;
var OPERATION_TOUCHUP = 8;
var OPERATION_EDIT_MULTI = 9;
var OPERATION_ADD_MULTI = 10;
var OPERATION_SORT_EDIT = 11;
var OPERATION_COPY_EDIT = 12;
var OPERATION_REPLACE = 13;
var OPERATION_REMARK = 14;
var OPERATION_UNREMARK = 15;
var OPERATION_SET_POS = 16;

var IFRAMEID_PRIM = "prim";
//position format
var FORMAT_JOINT = 9;
var FORMAT_CART = 2;
var FORMAT_CART_ADD = 6;
var FORMAT_MULTI = 0;

//position kind
var POSKIND_POSNUM       = 1;
var POSKIND_POSREGI      = 2;
var POSKIND_POSREGI_REGI = 4;
var POSKIND_POSREGI_AR   = 8;

//For coordinate conversion check
var COORDINATECART  = 0; 			// Coordinate Cartesian mode
var COORDINATEJOINT = 1; 			// Coordinate Joint mode
var cart_only_order = [
	"bktlead-inst_easyaw_start",		//easy arc
	"bktend-inst_easyaw_end",			//easy arc
	"bktlead-inst_easywv_start",		//easy weave
	"bktend-inst_easywv_end",			//easy weave
];

//Coordinate key of position data
var COORD_KEY = {
	CART : [ 'X',  'Y',  'Z',  'W',  'P',  'R'],
	JOINT: ['J1', 'J2', 'J3', 'J4', 'J5', 'J6'],
	EXT  : ['E1','E2','E3']
};

//Ext key of Editor Global Position
var EDITOR_POS_EXT_KEY = ['EXT1','EXT2','EXT3'];

// unit
var PERCENT				=0;
var SEC					=1;
var MSEC				=2;

//// Table number
//var INDEX_DISPTAB_ID	= 0;
//var INDEX_ID			= 1;
//var INDEX_CLASS			= 2;
//var INDEX_DISPNAME		= 3;
//var INDEX_ICON			= 4;
//var INDEX_G_VAL			= 5;
//var INDEX_ICON_NO		= 6;

var iconTbl = {
				/* 	Display tab ID				iconType(class)			Display name					                        Icon image											Counter		iconNo	*/
	'straight'	:	{ category:	'cat_motion',	iconType: 'posTeach',	dispName: langResource.ihmieditor_icon_L_c,				imgPath: 'img/flow/add_liner.png',					idCnt: 1,	iconNo: ICON_NO_STRAIGHT,	dtlPath: 'iframe/detail_liner'		},
	'kakujiku'	:	{ category:	'cat_motion',	iconType: 'posTeach',	dispName: langResource.ihmieditor_icon_J_c,				imgPath: 'img/flow/add_joint.png',					idCnt: 1,	iconNo: ICON_NO_KAKUJIKU,	dtlPath: 'iframe/detail_joint'		},
	'curve'		:	{ category:	'cat_motion',	iconType: 'posTeach',	dispName: langResource.ihmieditor_icon_curve,			imgPath: 'img/flow/add_circular.png',				idCnt: 1,	iconNo: ICON_NO_CIRCULAR,	dtlPath: 'iframe/detail_curve'		},
	'circlearc'	:	{ category:	'cat_motion',	iconType: 'posTeach',	dispName: langResource.ihmieditor_icon_circlearc,		imgPath: 'img/flow/add_circlearc.png',				idCnt: 1,	iconNo: ICON_NO_CIRCLEARC,	dtlPath: 'iframe/detail_circlearc'	},
	'macro'		:	{ category:	'cat_ctrl',		iconType: 'normal',		dispName: langResource.ihmieditor_icon_macro_c,			imgPath: 'img/flow/add_macro.png',					idCnt: 1,	iconNo: ICON_NO_MACRO,		dtlPath: 'iframe/detail_macro'		},
	'call'		:	{ category:	'cat_ctrl',		iconType: 'normal',		dispName: langResource.ihmieditor_icon_call_c,			imgPath: 'img/flow/add_call.png',					idCnt: 1,	iconNo: ICON_NO_CALL,		dtlPath: 'iframe/detail_call'		},
	'wait'		:	{ category:	'cat_ctrl',		iconType: 'normal',		dispName: langResource.ihmieditor_icon_wait_c,			imgPath: 'img/flow/add_wait.png',					idCnt: 1,	iconNo: ICON_NO_WAIT,		dtlPath: 'iframe/detail_wait'		},
	'iflead'	:	{ category:	'cat_ctrl',		iconType: 'normal',		dispName: langResource.ihmieditor_icon_if_c,			imgPath: 'img/flow/add_if.png',						idCnt: 1,	iconNo: ICON_NO_IF,			dtlPath: 'iframe/detail_if'			},
	'ifelse'	:	{ category:	'',				iconType: 'normal',		dispName: langResource.ihmieditor_icon_if_else_c,		imgPath: 'img/flow/add_else.png',					idCnt: 1,	iconNo: ICON_NO_IFELSE,		dtlPath: ''							},
	'ifend'		:	{ category:	'',				iconType: 'normal',		dispName: langResource.ihmieditor_icon_if_end_c,		imgPath: '',										idCnt: 1,	iconNo: ICON_NO_IFEND,		dtlPath: ''							},
	'forlead'	:	{ category:	'cat_ctrl',		iconType: 'normal',		dispName: langResource.ihmieditor_icon_for_c,			imgPath: 'img/flow/add_for.png',					idCnt: 1,	iconNo: ICON_NO_FOR,		dtlPath: 'iframe/detail_for'		},
	'forend'	:	{ category:	'',				iconType: 'normal',		dispName: langResource.ihmieditor_icon_for_end_c,		imgPath: '',										idCnt: 1,	iconNo: ICON_NO_FOREND,		dtlPath: ''							},
	'jump'		:	{ category:	'cat_ctrl',		iconType: 'normal',		dispName: langResource.ihmieditor_icon_jump_c,			imgPath: 'img/flow/add_jump.png',					idCnt: 1,	iconNo: ICON_NO_JUMP,		dtlPath: 'iframe/detail_jump'		},
	'label'		:	{ category:	'cat_ctrl',		iconType: 'normal',		dispName: langResource.ihmieditor_icon_label_c,			imgPath: 'img/flow/add_label.png',					idCnt: 1,	iconNo: ICON_NO_LABEL,		dtlPath: 'iframe/detail_label'		},
	'output'	:	{ category:	'cat_io',		iconType: 'normal',		dispName: langResource.ihmieditor_icon_out_c,			imgPath: 'img/flow/add_output_0.png',				idCnt: 1,	iconNo: ICON_NO_OUTPUT,		dtlPath: 'iframe/detail_output'		},
	'regi'		:	{ category:	'cat_other',	iconType: 'normal',		dispName: langResource.ihmieditor_icon_registers_c,		imgPath: 'img/flow/add_regi.png',					idCnt: 1,	iconNo: ICON_NO_REGI,		dtlPath: 'iframe/detail_regi'		},
	'payload'	:	{ category:	'cat_other',	iconType: 'normal',		dispName: langResource.ihmieditor_icon_payload_c,		imgPath: 'img/flow/add_payload.png',				idCnt: 1,	iconNo: ICON_NO_PAYLOAD,	dtlPath: 'iframe/detail_payload'	},
	'comment'	:	{ category:	'cat_other',	iconType: 'normal',		dispName: langResource.ihmieditor_icon_comment_c,		imgPath: 'img/flow/add_comment.png',				idCnt: 1,	iconNo: ICON_NO_COMMENT,	dtlPath: 'iframe/detail_comment'	},
	'nosupport'	:	{ category:	'cat_other',	iconType: 'normal',		dispName: langResource.ihmieditor_icon_text_code_c,		imgPath: 'img/flow/add_nosup.png',					idCnt: 1,	iconNo: ICON_NO_NOSUPPORT,	dtlPath: 'iframe/detail_nosupport'	},
	'noconnect'	:	{ category:	'',				iconType: 'normal',		dispName: langResource.ihmieditor_icon_no_connect_c,	imgPath: '/frh/vision/crxvision/visionblock_dc.png',idCnt: 1,	iconNo: ICON_NO_NOCONNECT,	dtlPath: '/frh/vision/crxvision/visionblock_dc'},
	'setuframe'	:	{ category:	'cat_other',	iconType: 'normal',		dispName: langResource.ihmieditor_icon_set_uframe_c,	imgPath: 'img/flow/set_uframe.png',					idCnt: 1,	iconNo: ICON_NO_SET_UFRAME,	dtlPath: 'iframe/detail_set_uframe'	},
	'setutool'	:	{ category:	'cat_other',	iconType: 'normal',		dispName: langResource.ihmieditor_icon_set_utool_c,		imgPath: 'img/flow/set_utool.png',					idCnt: 1,	iconNo: ICON_NO_SET_UTOOL,	dtlPath: 'iframe/detail_set_utool'	},
	'seluframe'	:	{ category:	'cat_other',	iconType: 'normal',		dispName: langResource.ihmieditor_icon_sel_uframe_c,	imgPath: 'img/flow/select_uframe.png',				idCnt: 1,	iconNo: ICON_NO_SEL_UFRAME,	dtlPath: 'iframe/detail_sel_uframe'	},
	'selutool'	:	{ category:	'cat_other',	iconType: 'normal',		dispName: langResource.ihmieditor_icon_sel_utool_c,		imgPath: 'img/flow/select_utool.png',				idCnt: 1,	iconNo: ICON_NO_SEL_UTOOL,	dtlPath: 'iframe/detail_sel_utool'	},
};
var iconTbl_spline = { category: 'cat_motion', iconType: 'posTeach', dispName: langResource.ihmieditor_icon_spline, imgPath: 'img/flow/add_spline.png', idCnt: 1, iconNo: ICON_NO_SPLINE, dtlPath: 'iframe/detail_spline' };
var iconTbl_ex1 = {
	'searchon'		:	{ category:	'cat_ctrl',	iconType: 'normal',		dispName: langResource.ihmieditor_icon_arc_search_on_c,		imgPath: 'img/flow/search_on.png',		idCnt: 1,	iconNo: ICON_NO_SEARCH_ON,		dtlPath: 'iframe/detail_arc_search_on'		},
	'detectjoint'	:	{ category:	'cat_ctrl',	iconType: 'normal',		dispName: langResource.ihmieditor_icon_arc_detect_joint_c,	imgPath: 'img/flow/detect_joint.png',	idCnt: 1,	iconNo: ICON_NO_DETECT_JOINT,	dtlPath: 'iframe/detail_arc_detect_joint'	},
};
var iconTbl_ex2 = {
	'trackdpm'		:	{ category:	'cat_motion',	iconType: 'normal',	dispName: langResource.ihmieditor_icon_arc_tracking_dpm_c,	imgPath: 'img/flow/track_dpm.png',		idCnt: 1,	iconNo: ICON_NO_TRACK_DPM,		dtlPath: 'iframe/detail_arc_track_dpm'	},
	'trackend'		:	{ category:	'cat_motion',	iconType: 'normal',	dispName: langResource.ihmieditor_icon_arc_tracking_end_c,	imgPath: 'img/flow/track_end.png',		idCnt: 1,	iconNo: ICON_NO_TRACK_END,		dtlPath: 'iframe/detail_arc_track_end'	},
};
var iconTab_arc_ex_l = {
	'sensoron'		:	{ category:	'cat_ctrl',	iconType: 'normal',		dispName: langResource.ihmieditor_icon_arc_sensor_on_c,		imgPath: 'img/flow/sensor_on.png',		idCnt: 1,	iconNo: ICON_NO_SENSOR_ON,		dtlPath: 'iframe/detail_arc_sensor_on'	},
	'sensoroff'		:	{ category:	'cat_ctrl',	iconType: 'normal',		dispName: langResource.ihmieditor_icon_arc_sensor_off_c,	imgPath: 'img/flow/sensor_off.png',		idCnt: 1,	iconNo: ICON_NO_SENSOR_OFF,		dtlPath: 'iframe/detail_arc_sensor_off'	},
};
var iconSortTbl = [
	'straight',
	'kakujiku',
	'curve',
	'circlearc',
	'macro',
	'call',
	'wait',
	'iflead',
	'ifelse',
	'ifend',
	'forlead',
	'forend',
	'jump',
	'label',
	'output',
	'regi',
	'payload',
	'comment',
	'nosupport',
	'noconnect',
	'setuframe',
	'setutool',
	'seluframe',
	'selutool',
];
// arc motion icon table
var arcMotionTbl = {
	'straight_arc'	  :	{ baseId:	'straight',	iconType: 'posTeach',	dispName: langResource.ihmieditor_icon_arc_L_c,			imgPath: 'img/flow/add_liner.png',					idCnt: 1,	iconNo: ICON_NO_STRAIGHT	},
	'curve_arc'		  : { baseId:	'curve',	  iconType: 'posTeach',	dispName: langResource.ihmieditor_icon_arc_C_c,			imgPath: 'img/flow/add_circular.png',				idCnt: 1,	iconNo: ICON_NO_CIRCULAR	},
}

// Timeline Instruction program start position
var TL_PROG_LEAD_POS	= 3;
var TL_ICON_WIDTH		= 54;	/* Icon width */
var TL_ICON_WIDTH_OUTER	= 74;	/* Icon width + Left and right margins */
var PROG_AREA_TAB_HEIGHT = 49;
var HANDLERESIZE_HEIGHT = 12;

var DEF_GRAPHIC_AREA_HEIGHT	= ($(window)[0].outerHeight - (top.document.getElementById('statbar').clientHeight + top.document.getElementById('tpkeys').clientHeight)) * 0.40;
var DEF_GRAPHIC_AREA_HEIGHT_RATE = 0.40;
if(top.document.getElementById('home') != null) {
	DEF_GRAPHIC_AREA_HEIGHT	= Math.floor(top.document.getElementById('home').clientHeight * 0.43);
	DEF_GRAPHIC_AREA_HEIGHT_RATE = 0.43;
}

var CONST_PI = 3.14159265359;
var RAD_2_DEG = 180 / CONST_PI;

var spdValMinMax = {
	'mm/sec'  :['1',	'100'	],
	'cm/min'  :['1',	'3000'	],
	'inch/min':['0.1',	'18000'	],
	'deg/sec' :['1',	'6553.5'],
	'sec'     :['0.1',	'3200.0'],
	'msec'    :['1',	'32000'	],
	'%'       :['1',	'100'	]
};

var SPD_LIMIT = {
	'mm/sec'  :['65535'],
	'cm/min'  :['65535'],
	'inch/min':['4724.4'],
	'deg/sec' :['65536']
}

//weld speed system value unit.
var weldSpeedUnit = {
	'1' : "mm/sec",
	'2' : "cm/min",
	'3' : "inch/min",
	'4' : "deg/sec"
};

//pop-up screen types
var DEF_POPUP_SCRN_TYP = {
	ALL        : 0,//all
	SPEED_CLAMP: 1,//speed clamp
	NOT_SUPPORT: 2,//not support
	ALERT      : 3,//alert_message
	CONFIRM    : 4,//confirmation
	REPLACE_MTN: 5,//replace
	FAVO_UPDATE: 6,//favorite update
	REMARK     : 7,//remark
	NOT_DISPLAYABLE : 8 //not displayable
};

//pop-up screen display request status
var DEF_POPUP_SCRN_STS = {
	REQ_OFF: 0,//
	REQ_ON : 1,//display requesting
	REQ_CANCEL : 2,//request cancel
};

//pop-up screen frames
var g_popup_frame = [
	// key popup_screen_type: number, iframe_object: iframe object
	{popup_screen_type: DEF_POPUP_SCRN_TYP.SPEED_CLAMP, iframe_object: null, disp_sts: DEF_POPUP_SCRN_STS.REQ_OFF},//speed clamp
	{popup_screen_type: DEF_POPUP_SCRN_TYP.NOT_SUPPORT, iframe_object: null, disp_sts: DEF_POPUP_SCRN_STS.REQ_OFF},//not support
	{popup_screen_type: DEF_POPUP_SCRN_TYP.ALERT      , iframe_object: null, disp_sts: DEF_POPUP_SCRN_STS.REQ_OFF},//alert_message
	{popup_screen_type: DEF_POPUP_SCRN_TYP.CONFIRM    , iframe_object: null, disp_sts: DEF_POPUP_SCRN_STS.REQ_OFF},//confirmation
	{popup_screen_type: DEF_POPUP_SCRN_TYP.REPLACE_MTN, iframe_object: null, disp_sts: DEF_POPUP_SCRN_STS.REQ_OFF},//confirmation
	{popup_screen_type: DEF_POPUP_SCRN_TYP.FAVO_UPDATE, iframe_object: null, disp_sts: DEF_POPUP_SCRN_STS.REQ_OFF},//confirmation
	{popup_screen_type: DEF_POPUP_SCRN_TYP.REMARK     , iframe_object: null, disp_sts: DEF_POPUP_SCRN_STS.REQ_OFF},//confirmation
	{popup_screen_type: DEF_POPUP_SCRN_TYP.NOT_DISPLAYABLE , iframe_object: null, disp_sts: DEF_POPUP_SCRN_STS.REQ_OFF} //confirmation
];

var detailCondVarSel_1 = [
	{tp:ORDER_REGI, val:'0'},
	{tp:'AO', val:'1'},
	{tp:'AI', val:'2'},
	{tp:'GO', val:'3'},
	{tp:'GI', val:'4'},
	{tp:'DO', val:'5'},
	{tp:'DI', val:'6'},
	{tp:'RO', val:'7'},
	{tp:'RI', val:'8'},
	{tp:'SO', val:'9'},
	{tp:'SI', val:'10'},
	{tp:'UO', val:'11'},
	{tp:'UI', val:'12'},
	{tp:'F' , val:'13'},
];
var detailCondVarSel_2 = [
	{tp:'', val:'0'},
	{tp:ORDER_REGI, val:'1'},
];
var detailCondVarSel_3 = [
	{tp:ORDER_ON, val:'0'},
	{tp:ORDER_OFF, val:'1'},
	{tp:'DO', val:'2'},
	{tp:'DI', val:'3'},
	{tp:'RO', val:'4'},
	{tp:'RI', val:'5'},
	{tp:'SO', val:'6'},
	{tp:'SI', val:'7'},
	{tp:'UO', val:'8'},
	{tp:'UI', val:'9'},
	{tp:ORDER_REGI, val:'10'},
	{tp:'F',  val:'11'},
];
var detailCondVarSelIf_1 = [
  {tp:'', val:'0'},
  {tp:ORDER_REGI, val:'1'},
  {tp:'AO', val:'2'},
  {tp:'AI', val:'3'},
  {tp:'GO', val:'4'},
  {tp:'GI', val:'5'},
  {tp:ORDER_ON, val:'6'},
  {tp:ORDER_OFF, val:'7'},
  {tp:'DO', val:'8'},
  {tp:'DI', val:'9'},
  {tp:'RO', val:'10'},
  {tp:'RI', val:'11'},
  {tp:'SO', val:'12'},
  {tp:'SI', val:'13'},
  {tp:'UO', val:'14'},
  {tp:'UI', val:'15'},
  {tp:'F' , val:'16'}
];
var detailCondVarSelIf_2 = [
  {tp:'', val:'0'},
  {tp:ORDER_REGI, val:'1'},
  {tp:'AO', val:'2'},
  {tp:'AI', val:'3'},
  {tp:'GO', val:'4'},
  {tp:'GI', val:'5'}
];
var detailCondVarSelIf_3 = [
  {tp:ORDER_ON, val:'0'},
  {tp:ORDER_OFF, val:'1'},
  {tp:'DO', val:'2'},
  {tp:'DI', val:'3'},
  {tp:'RO', val:'4'},
  {tp:'RI', val:'5'},
  {tp:'SO', val:'6'},
  {tp:'SI', val:'7'},
  {tp:'UO', val:'8'},
  {tp:'UI', val:'9'},
  {tp:'F',  val:'10'}
];
var detailCondSelOpe_1 = [
	{tp:'>', val:'0'},
	{tp:'>=', val:'1'},
	{tp:'=', val:'2'},
	{tp:'<=', val:'3'},
	{tp:'<', val:'4'},
	{tp:'<>', val:'5'},
];
var detailCondSelOpe_2 = [
	{tp:'=', val:'0'},
	{tp:'<>', val:'1'},
];

var regiCondVarSel = [
	{tp:ORDER_REGI, val:'1'},
	{tp:ORDER_POSREGI, val:'2'},
	{tp:'GI', val:'3'},
	{tp:'GO', val:'4'},
	{tp:'AI', val:'5'},
	{tp:'AO', val:'6'},
	{tp:'DI', val:'7'},
	{tp:'DO', val:'8'},
	{tp:'RI', val:'9'},
	{tp:'RO', val:'10'},
	{tp:'SI', val:'11'},
	{tp:'SO', val:'12'},
	{tp:'UI', val:'13'},
	{tp:'UO', val:'14'},
	{tp:'', val:'0'},
];

var g_regIOlimit_val = {
	'DI' : {max: 200, min: 1},
	'DO' : {max: 200, min: 1},
	'AI' : {max: 64, min: 1},
	'AO' : {max: 64, min: 1},
	'GI' : {max: 300, min: 1},
	'GO' : {max: 300, min: 1},
	'F'  : {max: 200, min: 1},
	'RI' : {max: 64, min: 1},
	'RO' : {max: 64, min: 1},
	'SI' : {max: 200, min: 0},
	'SO' : {max: 200, min: 0},
	'UI' : {max: 200, min: 1},
	'UO' : {max: 200, min: 1}
	/* The regi and posRegi values will be added later by getSystemDataCallback(). */
};

var SLCT_IDX = {
  VARIABLE_CONST: 0,
  VALUE_CONST: 0
};
var SLCT_PTN = {
  VARIABLE_IO: 5,
  VALUE_ONOFF: 1
};
var COMPO_TYPE = {
  SELECT: 0,
  TEXTBOX: 1
};
var COND_SIDE = {
  LEFT: 0,
  RIGHT: 1
};
var TEXTBOX_TYPE = {
  INDEX: 1,
  CONST: 2,
  HIDE: 3
};
var SLCT_TYPE = {
  NUM: 1,
  BOOLEAN: 2
};

var ICON_AREA_KEY = ["_all", "_history"];

var progtabId = {
	"progTab_paste": {'iconAreaId':"multiCopyArea"},
	"progTab_1_fav": {'iconAreaId':"cat_fav"},
	"progTab_1_his": {'iconAreaId':"cat_his"},
	"progTab_1_1"  : {'iconAreaId':"cat_all"},
	"progTab_1_2"  : {'iconAreaId':"cat_motion"},
	"progTab_1_3"  : {'iconAreaId':"cat_ctrl"},
	"progTab_1_4"  : {'iconAreaId':"cat_io"},
	"progTab_1_5"  : {'iconAreaId':"cat_other"},
};

var addMotionCondVarSel = [
	['','0'],
	['Wjnt',"1"],
	['ACC',"2"],
	['Skip,LBL[]',"3"],
	['Offset',"4"],
	['Offset,PR[]',"5"],
	['Tool_Offset',"6"],
	['Tool_Offset,PR[]',"7"],
	['INC',"8"],
	// ['EV%',"9"],
	// ['Ind.EV%',"10"],
	['PTH',"11"],
	['BREAK',"12"],
	['TB sec,CALL',"13"],
	['TB sec,DO[]=',"14"],
	['DB mm,CALL',"15"],
	['DB mm,DO[]=',"16"],
	['TA sec,CALL',"17"],
	['TA sec,DO[]=',"18"],
];

var jointAddMotionCondVarSel = [
	['','0'],
	['ACC',"1"],
	['Skip,LBL[]',"2"],
	['Offset',"3"],
	['Offset,PR[]',"4"],
	['Tool_Offset',"5"],
	['Tool_Offset,PR[]',"6"],
	['INC',"7"],
	// ['EV%',"8"],
	// ['Ind.EV%',"9"],
	['PTH',"10"],
	['BREAK',"11"],
	['TB sec,CALL',"12"],
	['TB sec,DO[]=',"13"],
	['DB mm,CALL',"14"],
	['DB mm,DO[]=',"15"],
	['TA sec,CALL',"16"],
	['TA sec,DO[]=',"17"],
];

var circlearcSplineAddMotionCondVarSel = [
  ['','0'],
  ['Wjnt',"1"],
  ['ACC',"2"],
  ['Offset',"3"],
  ['Offset,PR[]', "4"],
  ['Tool_Offset',"5"],
  ['Tool_Offset,PR[]',"6"],
  // ['EV%',"7"],
  // ['Ind.EV%',"8"],
  ['PTH',"9"],
  ['BREAK',"10"],
  ['TB sec,CALL',"11"],
  ['TB sec,DO[]=',"12"],
  ['DB mm,CALL',"13"],
  ['DB mm,DO[]=',"14"],
  ['TA sec,CALL',"15"],
  ['TA sec,DO[]=',"16"]
];

/* LineTracking data */
var lineTrackList = {
	'jp': {
		[langResource.ihmieditor_define_lineschedule_c] : 'lineschedule',
		[langResource.ihmieditor_define_lineboundary_c] : 'lineboundary',
		[langResource.ihmieditor_define_lineend_c] : 'lineend'
	},
	'eg': {
		'LINE_TRACK_SCHEDULE_NUMBER': 'lineschedule',
		'LINE_TRACK_BOUNDARY_NUMBER': 'lineboundary',
		'CONTINUE_TRACK_AT_PROG_END': 'lineend'
	}
};

var g_XMLVal = [];

/* Line count */
var lineCount = {
	'jp': langResource.ihmieditor_define_lineCount_c,
	'eg': 'LINE_COUNT'
};
/* Local Register */
var localReg = {
	'jp': langResource.ihmieditor_define_localReg_c,
	'eg': 'LOCAL_REGISTERS'
};
var ATTR_MAX_NUM = 19;
var MAX_LINE_COUNT = 880;
var TEDT_ADDLINE_DEFAULT = 502;  /* Path teach point:500 + bracket:2 */
var SAVE_SPLIT_REF_VAL_PASTELINE = 100;
var SAVE_SPLIT_REF_VAL_ADD = 2;
var MAX_NESTLINE_NUM = 20;
var MAX_NESTLINE_NUM_VRTCL = 6;
var MAX_SAMPLEPROG_LINE = 100;

var pre_ls_ini =[];
var ls_ini = [];
var le_ini = [];

var k_pre_ls_ini =[];
var k_ls_ini = [];
var k_le_ini = [];

var ls_out_flg;
/* group axes */
var groupAxes = {
	'jp': langResource.ihmieditor_define_groupAxes_c,
	'eg': 'DEFAULT_GROUP'
};

/* unteached position data */
var DEF_UNTEACHED_POS_VAL = {
  posKind: 1, // 1=pos num, 2=pos reg
  posNumber: 0,
  posRegNum: 0,
  axes: 0, // axes count for pos reg
  comment: '',
  frame: -1,
  group: 1,
  uf: 0,
  ut: 0,
  conf: '',
  rep: 0,
  cart: {X: 0.0, Y: 0.0, Z: 0.0, W: 0.0, P: 0.0, R: 0.0},
  joint: {J1: 0.0, J2: 0.0, J3: 0.0, J4: 0.0, J5: 0.0, J6: 0.0},
  ext: {E1: 0.0, E2: 0.0, E3: 0.0},
  empty: true
};

/* position register control */
var DEF_POSREGI_VAL = {
  Config: '',
  P: 0,
  R: 0,
  W: 0,
  X: 0,
  Y: 0,
  Z: 0,
  axes: 0,
  comment: '',
  gnum: 1,
  rep: 2,
  uframe: 'F',
  utool: 'F',
  empty: true
};

/* For reading read-only files. */
/* For detail screen */
var g_dtlContent_vrtclSz = 0;
var g_dtlContent_hrznSz = 0;
const dtlMutObserver = new MutationObserver((entries) => {
	var content = dtlfrm_contentchk(activeTarget);
	if(content != null) {
		if(content.scrollHeight != g_dtlContent_vrtclSz || content.scrollWidth != g_dtlContent_hrznSz) {
			g_dtlContent_vrtclSz = content.scrollHeight;
			g_dtlContent_hrznSz = content.scrollWidth;
			$("#detailRestrict").css({
				'height':content.scrollHeight,
				'width':content.scrollWidth,
			});
			scrlThumbResize(content, 'detail_scrlTrack_vrtcl', false);
			scrlPosUpdate($('#dtl_scrlThumb_vrtcl')[0], content, 'detail_scrlTrack_vrtcl', content.scrollTop);
			scrlThumbResize(content, 'detail_scrlTrack_hrzn', true);
			scrlPosUpdate($('#dtl_scrlThumb_hrzn')[0], content, 'detail_scrlTrack_hrzn', content.scrollLeft);
		}
	}
});

//additional instruction type
const TYPE_NORMAL_LJ = 1;
const TYPE_VISION_LJ = 2;
const TYPE_NO_SUPPORT = 3;
const TYPE_WELD_LJ = 4;
const TYPE_PLELS_LJ = 5;
const TYPE_LS_LJ = 6;
const TYPE_LE_LJ = 7;
const TYPE_PWC_LJ = 8;
const TYPE_ARCSTART_LJ = 9;
const TYPE_ARCEND_LJ = 10;
const iconPriorityTable = [
  { searchStr: new RegExp('^' + langResource.ihmieditor_order_weldstart_c + '\\['),  type: TYPE_ARCSTART_LJ, supportChk: function (orderType) { return (g_insOption.arcTool && orderType === ORDER_LINE) } },
  { searchStr: new RegExp('^' + langResource.ihmieditor_order_weldend_c + '\\['),    type: TYPE_ARCEND_LJ,   supportChk: function (orderType) { return (g_insOption.arcTool && orderType === ORDER_LINE) } },
  { searchStr: new RegExp('^' + langResource.ihmieditor_order_weldstart_c + '\\['),  type: TYPE_ARCSTART_LJ, supportChk: function (orderType) { return (g_insOption.arcTool && orderType === ORDER_CIRCLEARC) } },
  { searchStr: new RegExp('^' + langResource.ihmieditor_order_weldend_c + '\\['),    type: TYPE_ARCEND_LJ,   supportChk: function (orderType) { return (g_insOption.arcTool && orderType === ORDER_CIRCLEARC) } },
  { searchStr: new RegExp('^' + langResource.ihmieditor_order_laser_pre_ls_c),       type: TYPE_PLELS_LJ,    supportChk: function (orderType) { return (g_insOption.laser && orderType === ORDER_LINE) } },
  { searchStr: new RegExp('^' + langResource.ihmieditor_order_laser_ls_c + '\\['),   type: TYPE_LS_LJ,       supportChk: function (orderType) { return (g_insOption.laser && orderType === ORDER_LINE) } },
  { searchStr: new RegExp('^' + langResource.ihmieditor_order_laser_ls_sch_c + '\\['), type: TYPE_LS_LJ,     supportChk: function (orderType) { return (g_insOption.laser && orderType === ORDER_LINE) } },
  { searchStr: new RegExp('^' + langResource.ihmieditor_order_laser_le_c + '\\['),   type: TYPE_LE_LJ,       supportChk: function (orderType) { return (g_insOption.laser && orderType === ORDER_LINE) } },
  { searchStr: new RegExp('^' + langResource.ihmieditor_order_laser_pre_ls_c),       type: TYPE_PLELS_LJ,    supportChk: function (orderType) { return (g_insOption.laser && orderType === ORDER_JOINT) } },
  { searchStr: new RegExp('^' + langResource.ihmieditor_order_laser_ls_c + '\\['),   type: TYPE_LS_LJ,       supportChk: function (orderType) { return (g_insOption.laser && orderType === ORDER_JOINT) } },
  { searchStr: new RegExp('^' + langResource.ihmieditor_order_laser_ls_sch_c + '\\['), type: TYPE_LS_LJ,     supportChk: function (orderType) { return (g_insOption.laser && orderType === ORDER_JOINT) } },
  { searchStr: new RegExp('^' + langResource.ihmieditor_order_laser_le_c + '\\['),   type: TYPE_LE_LJ,       supportChk: function (orderType) { return (g_insOption.laser && orderType === ORDER_JOINT) } },
  { searchStr: new RegExp('^' + langResource.ihmieditor_order_laser_ls_c + '\\['),   type: TYPE_LS_LJ,       supportChk: function (orderType) { return (g_insOption.laser && orderType === ORDER_CURVE) } },
  { searchStr: new RegExp('^' + langResource.ihmieditor_order_laser_ls_sch_c + '\\['), type: TYPE_LS_LJ,     supportChk: function (orderType) { return (g_insOption.laser && orderType === ORDER_CURVE) } },
  { searchStr: new RegExp('^' + langResource.ihmieditor_order_laser_le_c + '\\['),   type: TYPE_LE_LJ,       supportChk: function (orderType) { return (g_insOption.laser && orderType === ORDER_CURVE) } },
  { searchStr: new RegExp('^' + langResource.ihmieditor_order_laser_ls_c + '\\['),   type: TYPE_LS_LJ,       supportChk: function (orderType) { return (g_insOption.laser && orderType === ORDER_CIRCLEARC) } },
  { searchStr: new RegExp('^' + langResource.ihmieditor_order_laser_ls_sch_c + '\\['), type: TYPE_LS_LJ,     supportChk: function (orderType) { return (g_insOption.laser && orderType === ORDER_CIRCLEARC) } },
  { searchStr: new RegExp('^' + langResource.ihmieditor_order_laser_le_c + '\\['),   type: TYPE_LE_LJ,       supportChk: function (orderType) { return (g_insOption.laser && orderType === ORDER_CIRCLEARC) } },
  { searchStr: new RegExp('^' + langResource.ihmieditor_order_laser_ls_c + '\\['),   type: TYPE_LS_LJ,       supportChk: function (orderType) { return (g_insOption.laser && orderType === ORDER_SPLINE) } },
  { searchStr: new RegExp('^' + langResource.ihmieditor_order_laser_ls_sch_c + '\\['), type: TYPE_LS_LJ,     supportChk: function (orderType) { return (g_insOption.laser && orderType === ORDER_SPLINE) } },
  { searchStr: new RegExp('^' + langResource.ihmieditor_order_laser_le_c + '\\['),   type: TYPE_LE_LJ,       supportChk: function (orderType) { return (g_insOption.laser && orderType === ORDER_SPLINE) } },
  { searchStr: new RegExp('^' + langResource.ihmieditor_order_voffset_c + '$'),      type: TYPE_VISION_LJ,   supportChk: function (orderType) { return g_insOption.vision } },
  { searchStr: new RegExp('^' + langResource.ihmieditor_order_voffset_c + ','),      type: TYPE_VISION_LJ,   supportChk: function (orderType) { return g_insOption.vision } },
];

var WITOUT_REPLACE = 0;
var SPD2 = {
  PCNT: 1,
  MMSEC: 2
};
var ROUTE2 = {
  CNT100: 1
};
// "O_" means Other
var ADD_MTN = {
  C2J: langResource.ihmieditor_order_wjnt_c + '|' + langResource.ihmieditor_order_rtcp_c,
  C2O_J: '',
  O_C2J: langResource.ihmieditor_order_wjnt_c + '|' + langResource.ihmieditor_order_rtcp_c + '|' + langResource.ihmieditor_order_ap_ld_c + '|' + langResource.ihmieditor_order_rt_ld_c,
  O_C2C: langResource.ihmieditor_order_offset_c + '|' + langResource.ihmieditor_order_mrot_c + '|' + langResource.ihmieditor_order_ap_ld_c + '|' + langResource.ihmieditor_order_rt_ld_c,
  O_C2O_JC: langResource.ihmieditor_order_mrot_c
};
var INST_POS = {
  ADD: 1,
  SPLIT: 2
};
var SAVE_LINE = {
  SINGLE: 1,
  DUAL: 2
};
var MTN_REPLACE_TBL = {
  straight: {
    kakujiku  :{speed: SPD2.PCNT, route: ROUTE2.CNT100, addMotion: ADD_MTN.O_C2J, position: WITOUT_REPLACE, save: SAVE_LINE.SINGLE},
    curve     :{speed: WITOUT_REPLACE, route: WITOUT_REPLACE, addMotion: ADD_MTN.O_C2C, position: INST_POS.ADD, save: SAVE_LINE.SINGLE},
    circlearc :{speed: WITOUT_REPLACE, route: WITOUT_REPLACE, addMotion: ADD_MTN.O_C2O_JC, position: WITOUT_REPLACE, save: SAVE_LINE.SINGLE},
    spline    :{speed: WITOUT_REPLACE, route: ROUTE2.CNT100, addMotion: ADD_MTN.O_C2O_JC, position: WITOUT_REPLACE, save: SAVE_LINE.SINGLE}
  },
  kakujiku: {
    straight  :{speed: SPD2.MMSEC, route: WITOUT_REPLACE, addMotion: ADD_MTN.O_C2O_JC, position: WITOUT_REPLACE, save: SAVE_LINE.SINGLE},
    curve     :{speed: SPD2.MMSEC, route: WITOUT_REPLACE, addMotion: ADD_MTN.O_C2C, position: INST_POS.ADD, save: SAVE_LINE.SINGLE},
    circlearc :{speed: SPD2.MMSEC, route: WITOUT_REPLACE, addMotion: ADD_MTN.O_C2O_JC, position: WITOUT_REPLACE, save: SAVE_LINE.SINGLE},
    spline    :{speed: SPD2.MMSEC, route: ROUTE2.CNT100, addMotion: ADD_MTN.O_C2O_JC, position: WITOUT_REPLACE, save: SAVE_LINE.SINGLE}
  },
  curve: {
    straight  :{speed: WITOUT_REPLACE, route: WITOUT_REPLACE, addMotion: ADD_MTN.C2O_J, position: INST_POS.SPLIT, save: SAVE_LINE.DUAL},
    kakujiku  :{speed: SPD2.PCNT, route: ROUTE2.CNT100, addMotion: ADD_MTN.C2J, position: INST_POS.SPLIT, save: SAVE_LINE.DUAL},
    circlearc :{speed: WITOUT_REPLACE, route: WITOUT_REPLACE, addMotion: ADD_MTN.C2O_J, position: INST_POS.SPLIT, save: SAVE_LINE.DUAL},
    spline    :{speed: WITOUT_REPLACE, route: ROUTE2.CNT100, addMotion: ADD_MTN.C2O_J, position: INST_POS.SPLIT, save: SAVE_LINE.DUAL}
  },
  circlearc: {
    straight  :{speed: WITOUT_REPLACE, route: WITOUT_REPLACE, addMotion: ADD_MTN.O_C2O_JC, position: WITOUT_REPLACE, save: SAVE_LINE.SINGLE},
    kakujiku  :{speed: SPD2.PCNT, route: ROUTE2.CNT100, addMotion: ADD_MTN.O_C2J, position: WITOUT_REPLACE, save: SAVE_LINE.SINGLE},
    curve     :{speed: WITOUT_REPLACE, route: WITOUT_REPLACE, addMotion: ADD_MTN.O_C2C, position: INST_POS.ADD, save: SAVE_LINE.SINGLE},
    spline    :{speed: WITOUT_REPLACE, route: ROUTE2.CNT100, addMotion: ADD_MTN.O_C2O_JC, position: WITOUT_REPLACE, save: SAVE_LINE.SINGLE}
  },
  spline: {
    straight  :{speed: WITOUT_REPLACE, route: WITOUT_REPLACE, addMotion: ADD_MTN.O_C2O_JC, position: WITOUT_REPLACE, save: SAVE_LINE.SINGLE},
    kakujiku  :{speed: SPD2.PCNT, route: ROUTE2.CNT100, addMotion: ADD_MTN.O_C2J, position: WITOUT_REPLACE, save: SAVE_LINE.SINGLE},
    curve     :{speed: WITOUT_REPLACE, route: WITOUT_REPLACE, addMotion: ADD_MTN.O_C2C, position: INST_POS.ADD, save: SAVE_LINE.SINGLE},
    circlearc :{speed: WITOUT_REPLACE, route: WITOUT_REPLACE, addMotion: ADD_MTN.O_C2O_JC, position: WITOUT_REPLACE, save: SAVE_LINE.SINGLE},
  },
  vsnline: {
    vsnjoint  :{speed: SPD2.PCNT, route: ROUTE2.CNT100, addMotion: ADD_MTN.O_C2J, position: WITOUT_REPLACE, save: SAVE_LINE.SINGLE}
  },
  vsnjoint: {
    vsnline  :{speed: SPD2.MMSEC, route: WITOUT_REPLACE, addMotion: ADD_MTN.O_C2O_JC, position: WITOUT_REPLACE, save: SAVE_LINE.SINGLE}
  },
  weldstartml: {
    weldstartca  :{speed: WITOUT_REPLACE, route: WITOUT_REPLACE, addMotion: ADD_MTN.O_C2O_JC, position: WITOUT_REPLACE, save: SAVE_LINE.SINGLE},
  },

  weldstartca: {
    weldstartml  :{speed: WITOUT_REPLACE, route: WITOUT_REPLACE, addMotion: ADD_MTN.O_C2O_JC, position: WITOUT_REPLACE, save: SAVE_LINE.SINGLE},
  },
  weldstopml: {
    weldstopca  :{speed: WITOUT_REPLACE, route: WITOUT_REPLACE, addMotion: ADD_MTN.O_C2O_JC, position: WITOUT_REPLACE, save: SAVE_LINE.SINGLE},
  },
  weldstopca: {
    weldstopml  :{speed: WITOUT_REPLACE, route: WITOUT_REPLACE, addMotion: ADD_MTN.O_C2O_JC, position: WITOUT_REPLACE, save: SAVE_LINE.SINGLE},
  }
};
var EDITER_API_SUCCESS = 0;
var EDITER_API_ERROR = -1;

/** For alarm dialog **/
/* Facility Code */
var ALM_FAC_ID_TEACH = 9;

/* Alarm Number */
var ALM_NUM_SPEED_CLAMP = 298;
                                                                                                                                                                                                                                                                                                                                                 // Use jQuery
/*
 * jQuery JavaScript Library
 * https://jquery.com/
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
*/
// Use jQuery
/*
 * jQuery JavaScript Library
 * https://jquery.com/
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
*/
//=============================================================================
// define
//=============================================================================
//=============================================================================
// Global variable
//=============================================================================
var addProg = [];
var dropProgNum = "";
var dropProgEndNum = "";
var addDropTarget = "";
var voffsetArg = {
  vreg: "-1",
  posKind: parent.POS_KIND_POSNUM
};
var detailDispTbl = {
/* baseId			Detailscreen title											load function					save function	*/
  'straight'	:	{ title: langResource.ihmieditor_title_linermotion_c,		loadFunc: detail_load_straight,	saveFunc: fixDataSave_motion	},
  'kakujiku'	:	{ title: langResource.ihmieditor_title_jointmotion_c,		loadFunc: detail_load_kakujiku,	saveFunc: fixDataSave_motion	},
  'curve'		:	{ title: langResource.ihmieditor_title_curve,				loadFunc: detail_load_circular,	saveFunc: fixDataSave_motion	},
  'circlearc'	:	{ title: langResource.ihmieditor_title_circlearc,			loadFunc: detail_load_straight,	saveFunc: fixDataSave_motion	},
  'spline'		:	{ title: langResource.ihmieditor_title_spline,				loadFunc: detail_load_straight,	saveFunc: fixDataSave_motion	},
  'macro'		:	{ title: langResource.ihmieditor_title_macro_c,				loadFunc: detail_load_macro,	saveFunc: fixDataSave_macro		},
  'call'		:	{ title: langResource.ihmieditor_title_call_c,				loadFunc: detail_load_call,		saveFunc: fixDataSave_call		},
  'wait'		:	{ title: langResource.ihmieditor_title_wait_c,				loadFunc: detail_load_wait,		saveFunc: fixDataSave_wait		},
  'iflead'		:	{ title: langResource.ihmieditor_title_if_c,				loadFunc: detail_load_if,		saveFunc: fixDataSave_if		},
  'forlead'		:	{ title: langResource.ihmieditor_title_for_c,				loadFunc: detail_load_for,		saveFunc: fixDataSave_for		},
  'jump'		:	{ title: langResource.ihmieditor_title_jump_label_c,		loadFunc: detail_load_jumplabel,saveFunc: fixDataSave_jump		},
  'label'		:	{ title: langResource.ihmieditor_title_label_c,				loadFunc: detail_load_label,	saveFunc: fixDataSave_label		},
  'output'		:	{ title: langResource.ihmieditor_title_externaloutoput_c,	loadFunc: detail_load_output,	saveFunc: fixDataSave_output	},
  'regi'		:	{ title: langResource.ihmieditor_title_register_c,			loadFunc: detail_load_regi,		saveFunc: fixDataSave_regi		},
  'payload'		:	{ title: langResource.ihmieditor_title_payload_setup_c,		loadFunc: detail_load_payload,	saveFunc: fixDataSave_payload	},
  'comment'		:	{ title: langResource.ihmieditor_title_comment_c,			loadFunc: detail_load_comment,	saveFunc: fixDataSave_comment	},
  'nosupport'	:	{ title: langResource.ihmieditor_title_text_code_c,			loadFunc: detail_load_text_code,saveFunc: fixDataSave_nosupport	},
  'noconnect'	:	{ title: langResource.ihmieditor_title_noconnect_c,			loadFunc: null,					saveFunc: null					},
  'setuframe'	:	{ title: langResource.ihmieditor_title_set_uframe_c,		loadFunc: detail_load_setuframe,saveFunc: fixDataSave_frame		},
  'setutool'	:	{ title: langResource.ihmieditor_title_set_utool_c,			loadFunc: detail_load_setutool,	saveFunc: fixDataSave_frame		},
  'seluframe'	:	{ title: langResource.ihmieditor_title_sel_uframe_c,		loadFunc: detail_load_seluframe,saveFunc: fixDataSave_frame		},
  'selutool'	:	{ title: langResource.ihmieditor_title_sel_utool_c,			loadFunc: detail_load_selutool,	saveFunc: fixDataSave_frame		},
};

/*
 =========================================================================
 @function name        : detailDisp_funcSetting
 @argument[targetElm]  : 
 @description          : Detailed tab display switching when icon is selected
 @return               : none
 =========================================================================
*/
function detailDisp_funcSetting(targetElm) {
  var detailDispTbl_ex1 = {
    'searchon'		:	{ title: langResource.ihmieditor_title_arc_search_on_c,		loadFunc: detail_load_searchon,		saveFunc: null					},
    'detectjoint'	:	{ title: langResource.ihmieditor_title_arc_detect_joint_c,	loadFunc: detail_load_detectjoint,	saveFunc: fixDataSave_detectjoint},
  };
  var detailDispTbl_ex2 = {
    'trackdpm'		:	{ title: langResource.ihmieditor_title_arc_tracking_dpm_c,	loadFunc: detail_load_trackdpm,		saveFunc: fixDataSave_trackdpm	},
    'trackend'		:	{ title: langResource.ihmieditor_title_arc_tracking_end_c,	loadFunc: detail_load_trackend,		saveFunc: null					},
  };
  var detailDispTbl_vsn = {
    'vsnline'	:	{ title: langResource.ihmieditor_title_linermotion_v_c,		loadFunc: detail_load_vsnline,	saveFunc: fixDataSave_motion	},
    'vsnjoint'	:	{ title: langResource.ihmieditor_title_jointmotion_v_c,		loadFunc: detail_load_vsnjoint,	saveFunc: fixDataSave_motion	},
  };
  var detailDispTbl_force = {
  };
  var detailDispTbl_arc = {
    'weldstartml'	:	{ title: langResource.ihmieditor_title_arcstartml_c,	loadFunc: detail_load_weldstartml,	saveFunc: fixDataSave_weldstartml	},
    'weldstopml'	:	{ title: langResource.ihmieditor_title_arcstopml_c,		loadFunc: detail_load_weldstopml,	saveFunc: fixDataSave_weldstopml	},
    'weldstartal'	:	{ title: langResource.ihmieditor_title_arcstartal_c,	loadFunc: detail_load_weldstartal,	saveFunc: fixDataSave_weldstartal	},
    'weldstopal'	:	{ title: langResource.ihmieditor_title_arcstopal_c,		loadFunc: detail_load_weldstopal,	saveFunc: fixDataSave_weldstopal	},
    'weldstartca'	:	{ title: langResource.ihmieditor_title_arcstartca_c,	loadFunc: detail_load_weldstartml,	saveFunc: fixDataSave_weldstartml	},
    'weldstopca'	:	{ title: langResource.ihmieditor_title_arcstopca_c,		loadFunc: detail_load_weldstopml,	saveFunc: fixDataSave_weldstopml	},
  };
  var detailDispTbl_arc_ex_l = {
    'sensoron'		:	{ title: langResource.ihmieditor_title_arc_sensor_on_c,		loadFunc: detail_load_sensoron,		saveFunc: null					},
    'sensoroff'		:	{ title: langResource.ihmieditor_title_arc_sensor_off_c,	loadFunc: detail_load_sensoroff,	saveFunc: null					},
  };
  var detailDispTbl_laser = {
    'laserpre'	:	{ title: null,	loadFunc: detail_load_laserpre,	saveFunc: fixDataSave_motion_laser	},
    'laserls'	:	{ title: null,	loadFunc: detail_load_laserls,	saveFunc: fixDataSave_motion_laser	},
    'laserle'	:	{ title: null,	loadFunc: detail_load_laserle,	saveFunc: fixDataSave_motion_laser	},
    'laserpresi':	{ title: null,	loadFunc: detail_load_laserpre,	saveFunc: fixDataSave_laser_si		},
    'laserlssi'	:	{ title: null,	loadFunc: detail_load_laserls,	saveFunc: fixDataSave_laser_si		},
    'laserlesi'	:	{ title: null,	loadFunc: detail_load_laserle,	saveFunc: fixDataSave_laser_si		},
    'laserpow'	:	{ title: null,	loadFunc: detail_load_laserpow,	saveFunc: fixDataSave_laserpow		},
    'laserkpre'	:	{ title: null,	loadFunc: detail_load_laserpre,	saveFunc: fixDataSave_motion_laser	},
    'laserkls'	:	{ title: null,	loadFunc: detail_load_laserls,	saveFunc: fixDataSave_motion_laser	},
    'laserkle'	:	{ title: null,	loadFunc: detail_load_laserle,	saveFunc: fixDataSave_motion_laser	},
    'lasercls'	:	{ title: null,	loadFunc: detail_load_laserls,	saveFunc: fixDataSave_motion_laser	},
    'lasercle'	:	{ title: null,	loadFunc: detail_load_laserle,	saveFunc: fixDataSave_motion_laser	},
    'lasercals'	:	{ title: null,	loadFunc: detail_load_laserls,	saveFunc: fixDataSave_motion_laser	},
    'lasercale'	:	{ title: null,	loadFunc: detail_load_laserle,	saveFunc: fixDataSave_motion_laser	},
    'laserwirc'	:	{ title: null,	loadFunc: detail_load_laserwirc,saveFunc: fixDataSave_laserwirc		},
  };
  var detailDispTbl_laser_ex_s = {
    'lasersls': { title: null, loadFunc: detail_load_laserls, saveFunc: fixDataSave_motion_laser },
    'lasersle': { title: null, loadFunc: detail_load_laserle, saveFunc: fixDataSave_motion_laser },
  };

  if(g_order_option.indexOf("R900") != -1 || g_order_option.indexOf("R901") != -1) {
    for(var key in detailDispTbl_ex1) {
      detailDispTbl[key] = detailDispTbl_ex1[key];
    }
  }
  if(g_order_option.indexOf("R739") != -1) {
    for(var key in detailDispTbl_ex2) {
      detailDispTbl[key] = detailDispTbl_ex2[key];
    }
  }

  /* vision */
  if(g_insOption.vision) {
    for(var key in detailDispTbl_vsn) {
      detailDispTbl[key] = detailDispTbl_vsn[key];
    }
  }
  /* force control */
  if(g_insOption.FCtrl) {
    for(var key in detailDispTbl_force) {
      detailDispTbl[key] = detailDispTbl_force[key];
    }
  }
  /* arc tool */
  if(g_insOption.arcTool) {
    for(var key in detailDispTbl_arc) {
      detailDispTbl[key] = detailDispTbl_arc[key];
    }
    if(g_order_option.indexOf("R900") != -1 || g_order_option.indexOf("R901") != -1) {
      for(var exKey in detailDispTbl_arc_ex_l) {
        detailDispTbl[exKey] = detailDispTbl_arc_ex_l[exKey];
      }
    }
  }
  /* laser tool */
  if(g_insOption.laser) {
    for(var key in detailDispTbl_laser) {
      detailDispTbl[key] = detailDispTbl_laser[key];
    }
    if (g_order_option.indexOf("R904") != -1) {
      for (var exKey in detailDispTbl_laser_ex_s) {
        detailDispTbl[exKey] = detailDispTbl_laser_ex_s[exKey];
      }
    }
  }
}

/*
 =========================================================================
 @function name       : detailTab_disp
 @argument[targetId]  : 
 @description         : Detailed tab display switching when icon is selected
 @return              : none
 =========================================================================
*/
function detailTab_disp(targetId) {
  /* parts_handleresize_area position adjustment */
  active_vrtcl_scrlAdjust();
  /* Switch to details tab */
  $('#progTab_1').removeClass('progTab_active');
  $('#progArea_1').removeClass('progArea_active');
  $('#progTab_2').addClass('progTab_active');
  $('#progArea_2').addClass('progArea_active');

  /* Switching display items according to icon type */
  $('.detail_actSet').removeClass('active_disp');
  document.getElementById("detail_version").classList.add('hide');

  var params = [];
  var tmp_param = [];
  var frm_id = get_detail_frm_id(targetId);
  document.getElementById("detail_act").classList.add('active');
  $('#' + frm_id).off();
  if(document.getElementById(frm_id) == null) {
    /* Add display element */
    append_detailhtml(g_program_data[targetId].baseId);
    
    if(frm_id) {
      $('#' + frm_id).on('load', detail_load);
      lateralResizeFunc();
    }
  }
  else {
    lateralResizeFunc();
    document.getElementById(frm_id).parentElement.classList.add('active_disp');
    var content = dtlfrm_contentchk(targetId);
    if(content != null) $(content).scrollTop(0).scrollLeft(0);
    detail_load();
  }
}

/*
 =========================================================================
 @function name      : get_detail_frm_id
 @argument[actElmId] : 
 @description        : Get the iframe ID of the details screen.
 @return             : detail_frm id
 =========================================================================
*/
function get_detail_frm_id(actElmId) {
  var frm_id = '';
  if(g_program_data[actElmId] != undefined) {
    frm_id = 'detail_frm_' + iconSortTbl.indexOf(g_program_data[actElmId].baseId);
  }
  
  return frm_id;
}

/*
 =========================================================================
 @function name   : detail_load
 @argument[event] : onload event
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
var g_labelNumList = [];
function detail_load(event) {
  var afterProc = true;
  // Set functions and values required for each process.
  if(detailDispTbl[g_program_data[activeTarget].baseId]) {
    /* The title of the detail screen exists. */
    if(detailDispTbl[g_program_data[activeTarget].baseId].title) {
      titleIns(detailDispTbl[g_program_data[activeTarget].baseId].title);
    }
    /* Set parameters on the detail screen. */
    if(detailDispTbl[g_program_data[activeTarget].baseId].loadFunc) {
      var dtfrm = document.getElementById(get_detail_frm_id(activeTarget)).contentWindow;
      afterProc = detailDispTbl[g_program_data[activeTarget].baseId].loadFunc(event, dtfrm);
    }
  }
  
  if(afterProc) detail_load_afterProc();
}

/*
 =========================================================================
 @function name : detail_load_afterProc
 @argument[]    : none
 @description   : 
 @return        : none
 =========================================================================
*/
function detail_load_afterProc() {
  unredo_flg = true;
  /* Register focus event. */
  inputfocusEvt_Reregister();
  dispOffWaiting();

  /* Scrollbar setting */
  var insStr = '<style type="text/css">.content::-webkit-scrollbar{display:none;}body::-webkit-scrollbar{display:none;}</style>';
  var content = dtlfrm_contentchk(activeTarget);
  if(content != null) {
    content.addEventListener('click', focusout_onclick, false);

    /* Detailed display of the screen in the read-only file */
    if(g_RO_flg || !g_TPenbl_flg || g_program_data[activeTarget].remark) {
      /* Setup a layer to block editing. */
      $('#detail_act').addClass('detail_noEdit');
      $('.restrictContainer').scrollTop(0).scrollLeft(0);
      $('.restrictContainer').css({
        'left': content.offsetLeft,
        'width': 'calc(100% - ' + (content.offsetLeft + 9) + 'px)',
      });
      $("#detailRestrict").css({
        'height':content.scrollHeight,
        'width':content.scrollWidth,
      });
      /* If only "g_program_data[activeTarget].remark" is true. */
      if(!(g_RO_flg || !g_TPenbl_flg)) {
        set_sortableReadOnly_detailArea();
      }
    }

    /* Set horizontal scrolling. */
    $(content).css({
//      'position':'absolute',
//      'height':'100%',
//      'width':'calc(100% - 9px)',
      'overflow-x':'auto',
      'overflow-y':'scroll',
      'white-space':'nowrap',
      'scrollbar-width':'none',
      '-ms-overflow-style':'none'
    });
    if(content.ownerDocument.head.innerHTML.indexOf(insStr) == -1) {
      content.ownerDocument.head.innerHTML += insStr;
    }
    detail_scrlCtrl(content);
    
    var config = {attributes:true, attributeFilter:["style"], childList: true, subtree: true};
    dtlMutObserver.observe(content, config);
  }
  else {
    var retElm = document.getElementById(get_detail_frm_id(activeTarget));
    insStr = insStr.replace('.content::-webkit-scrollbar{display:none;}', '');
    if(retElm.contentWindow.document.head.innerHTML.indexOf(insStr) == -1) {
      retElm.contentWindow.document.head.innerHTML += insStr;
    }
  }
}

/*
 =========================================================================
 @function name    : commentParse
 @argument[]       :
 @argument[]       :
 @description      :
 @return           : commentParseParam
 =========================================================================
*/
function commentParse(drawPrams){
  /*colonMatch = Matches colon other than in single quotes*/
  var colonMatch = /:(?=([^']*'[^']*')*[^']*$)/;
  /*commaMatch = Matches comma other than in single quotes and [] */
  var commaMatch = /,(?=(?:[^']*'[^']*')*[^']*$)(?![^\[]*\])/g;
    var splitParam = drawPrams.split(commaMatch);
    for(var i = 0; i < splitParam.length; i++){
      if(splitParam[i].match(colonMatch)){
        /* No termination exists. */
        if(splitParam[i].match(/\]$/) == null) {
          /* Combine strings. */
          for(var cmbcnt = i; cmbcnt < splitParam.length; cmbcnt++) {
            if(typeof splitParam[cmbcnt + 1] != 'undefined') {
              splitParam[cmbcnt] = splitParam[cmbcnt] + ',' + splitParam[cmbcnt + 1];
              splitParam.splice(cmbcnt + 1, 1);
              /* Joining is completed to the end. */
              if(splitParam[cmbcnt].match(/\]$/)) break;
            }
          }
        }
        var start = splitParam[i].indexOf(':');
        var end = splitParam[i].lastIndexOf(']');
        var param1 = splitParam[i].substr(0,start);
        var param2 = splitParam[i].substr(end);
        splitParam[i] = param1 + param2;
      }
    }
    var commentParseParam = splitParam.join();
    return commentParseParam;
}
/*
 =========================================================================
 @function name    : addLabelNumList
 @argument[addNum] : The label number to be saved.
 @argument[oldNum] : Previous number.
 @description      : Save the label numbers in ascending order.
 @return           : none
 =========================================================================
*/
function addLabelNumList(addNum, oldNum) {
  if(addNum !== '') {
    if(oldNum != null) {
      delLabelNumList(oldNum);
    }
    /* If the label number is not kept, it is saved. */
    if(g_labelNumList.indexOf(addNum) === -1) {
      g_labelNumList.push(addNum);
      
      g_labelNumList.sort(compare);
    }
  }
}

/*
 =========================================================================
 @function name    : delLabelNumList
 @argument[delNum] : Label number to be deleted.
 @description      : Delete the label numbers in g_labelNumList[].
 @return           : none
 =========================================================================
*/
function delLabelNumList(delNum) {
	var newArray = g_labelNumList.filter(elm => elm !== delNum);
	g_labelNumList = Array.from(newArray);
}

/*
 =========================================================================
 @function name   : set_detail_condParam_wait
 @argument[param] : 
 @description     : Determine which radio button to select.
 @return          : 
 =========================================================================
*/
function set_detail_condParam_wait(param) {
  var dtfrm = document.getElementById(get_detail_frm_id(activeTarget)).contentWindow;
  var ret = false;
  var sel1 = null, sel1_num = null, sign = null, sel2 = null, sel2_num = null;
  param[0] = outputComment_del(param[0]);
  var chkStr = '';
  
  var toChkStr = new RegExp(ORDER_TIMEOUT + ',');
  if (param.length != 3 || (param[2] != undefined && param[2].match(toChkStr))) {
    dtfrm.document.getElementById('time_out_option').refresh(null,"1",false);
    dtfrm.document.getElementById("time_out_detail").classList.add("show");
    dtfrm.document.getElementById("time_out_detail").classList.remove("hidden");

    var split_param = param[2].split(",");
    var labelnum = split_param[1].replace(/[^0-9]/g, '');
    if (labelnum === "")  labelnum = "0";
    var array = g_labelNumList.toString(10).split(',');
    dtfrm.document.getElementById('jump_select').refresh(array,labelnum,null,false);
    var arg = param[2].split(/\s/)[0];
    if(arg.indexOf(':') != -1) arg = arg.substr(0, arg.indexOf(':'));
    sel2_num = detail_valReplace_chk(getIntegerRealNumber(arg.replace(/(^\(|\)$)/g, '')));
    param[2] = param[2].replace(new RegExp('\\s' + ORDER_TIMEOUT + ',' + ORDER_LABEL + '\\[.*\\]$'), '');
  }
  else {
    dtfrm.document.getElementById('time_out_option').refresh(null,"2",false);
  }
  
  /* Get the type of left side. */
  var sel1_data = null;
  var sel1ChkStr = new RegExp('((' + ORDER_REGI + '|AO|AI|GO|GI|DO|DI|RO|RI|SO|SI|UO|UI|F)\\[)');
  var matchResult = param[0].match(sel1ChkStr);
  if(matchResult) {
    var tpChk = detailCondVarSel_1.find(function(data) {return data.tp == matchResult[2]});
    if(tpChk) sel1_data = tpChk;
  }
  if(sel1_data) sel1 = sel1_data.val;
  sel1_num = detail_valReplace_chk(param[0].replace(/[^0-9]/g, ''));
  dtfrm.inputVal[COND_SIDE.LEFT][sel1_data.tp].val = Number(sel1_num);
  
  var sel2_data = null;
  param[2] = outputComment_del(param[2]);
  if(Number(sel1) <= 4) {
    var dtfrmSelTbl = dtfrm.componentList[COMPO_TYPE.SELECT]['.operator_select1'];
    var opeTbl = detailCondSelOpe_1;
    var rightTbl = detailCondVarSel_2;
    var callFunc = dtfrm.switchValueDisplayPattern1;
    var setArray = dtfrm.componentList[COMPO_TYPE.SELECT]['.value_select1'];
    var targetElm1 = dtfrm.document.getElementById('wait.operator_select1');
    if(!param[2].match(new RegExp('^' + ORDER_ARGUMENT))) {
      if(param[2].match(new RegExp(rightTbl[1].tp))) {
        sel2_data = rightTbl[1];
        var targetElm2 = dtfrm.document.getElementById('wait.value_select1');
        var targetElm3 = dtfrm.document.getElementById('wait.value_index');
      }
      else {
        var isNum_param2 = isIntegerRealNumber(param[2].replace(/(^\(|\)$)/g, ''));
        if(isNum_param2 ||
           (!isNum_param2 && param[2].match(toChkStr))) {
          sel2_data = rightTbl[0];
          var targetElm2 = dtfrm.document.getElementById('wait.value_select1');
          var targetElm3 = dtfrm.document.getElementById('wait.value_const');
        }
        else {
          return ret;
        }
      }
    }
  }
  else {
    var dtfrmSelTbl = dtfrm.componentList[COMPO_TYPE.SELECT]['.operator_select2'];
    var opeTbl = detailCondSelOpe_2;
    var rightTbl = detailCondVarSel_3;
    var callFunc = dtfrm.switchValueDisplayPattern2;
    var setArray = dtfrm.componentList[COMPO_TYPE.SELECT]['.value_select2'];
    var sel2ChkStr = new RegExp('^(' + ORDER_ON + '|' + ORDER_OFF + '|(' + ORDER_REGI + '|DO|DI|RO|RI|SO|SI|UO|UI|F)\\[)');
    var targetElm1 = dtfrm.document.getElementById('wait.operator_select2');
    var targetElm2 = dtfrm.document.getElementById('wait.value_select2');
    var targetElm3 = dtfrm.document.getElementById('wait.value_index');
  }
  /* Determine the sign table. */
  var opeChk = opeTbl.find(function(data) {return data.tp == param[1]});
  if(opeChk) sign = opeChk.val;

  /* Get the type of right side. */
  var valRange = {};
  if(sel2ChkStr) {
    var prm2_matchResult = param[2].match(sel2ChkStr);
    if(prm2_matchResult) {
      var prm2_tpChk = rightTbl.find(function(data) {return data.tp == prm2_matchResult[1] || data.tp == prm2_matchResult[2]});
      if(prm2_tpChk) sel2_data = prm2_tpChk;
    }
  }
  if(sel2_data) {
    sel2 = sel2_data.val;
    if(sel2_num == null) {
      var sel2_numchk = (param[2].indexOf(':') == -1) ? param[2] : param[2].substr(0, param[2].indexOf(':'));
      sel2_num = detail_valReplace_chk(getIntegerRealNumber(sel2_numchk.replace(/(^\(|\)$)/g, '')));
    }
    if(sel2_data.tp != ORDER_ON && sel2_data.tp != ORDER_OFF) {
      valRange = (sel2_data.tp == '') ?
                   dtfrm.componentList[COMPO_TYPE.TEXTBOX]['.value_const'] : g_regIOlimit_val[sel2_data.tp];
      if(sel2_data.tp != '') dtfrm.inputVal[COND_SIDE.RIGHT][sel2_data.tp].val = Number(sel2_num);
    }
  }
  
  /* Update when all values are obtained. */
  if(sel1 != null && sel1_num != null && sign != null && sel2 != null && sel2_num != null) {
    ret = true;
    dtfrm.switchValueSelectDisplay(sel1);
    dtfrm.document.getElementById('wait.variable_select').refresh(dtfrm.componentList[COMPO_TYPE.SELECT]['.variable_select'], sel1, null, false);
    if(sel1_data.tp == ORDER_REGI) {
      editorAPI.funcs.refreshLocalRTBComp(dtfrm.document.getElementById('wait.variable_index'), sel1_num, false, true);
    } else {
      dtfrm.document.getElementById('wait.variable_index').refresh(sel1_num, g_regIOlimit_val[sel1_data.tp].min, g_regIOlimit_val[sel1_data.tp].max, false);
    }
    targetElm1.refresh(dtfrmSelTbl, sign, null, false);
    callFunc(sel2);
    if(targetElm2) targetElm2.refresh(setArray, sel2, null, false);
    if(Object.keys(valRange).length) {
      if(sel2_data.tp == ORDER_REGI) {
        editorAPI.funcs.refreshLocalRTBComp(targetElm3, sel2_num, false, true);
      } else {
        targetElm3.refresh(sel2_num, valRange.min, valRange.max, false);
      }
    }
  }
  
  return ret;
}

/*
 =========================================================================
 @function name   : set_detail_condParam_if
 @argument[param] : 
 @description     : Determine which radio button to select.
 @return          : none
 =========================================================================
*/
function set_detail_condParam_if(param) {
  var dtfrm = document.getElementById(get_detail_frm_id(activeTarget)).contentWindow;
  var ret = false;
  var sel1 = null, sel1_num = null, sign = null, sel2 = null, sel2_num = null;
  param[0] = outputComment_del(param[0].replace(/^\(*/, ''));
  param[2] = outputComment_del(param[2].replace(/\)*$/, ''));
  var chkStr = '';

  var selIf_1_data = detailCondVarSelIf_1[0];
  if (!(isIntegerRealNumber(param[0].replace(/(^\(|\)$)/g, '')))) {
    var sel1ChkStr = new RegExp('^(' + ORDER_ON + '|' + ORDER_OFF + '|(' + ORDER_REGI + '|AO|AI|GO|GI|DO|DI|RO|RI|SO|SI|UO|UI|F)\\[)');
    var matchResult = param[0].match(sel1ChkStr);
    if(matchResult) {
      var tpChk = detailCondVarSelIf_1.find(function(data) {return data.tp == matchResult[1] || data.tp == matchResult[2]});
      if(tpChk) selIf_1_data = tpChk;
    }
  }
  sel1 = selIf_1_data.val;
  sel1_num = detail_valReplace_chk(getIntegerRealNumber(param[0].replace(/(^\(|\)$)/g, '')));
  var varRange = {};
  var targetVarTxt = dtfrm.document.getElementById('if.variable_index');
  if (sel1 == '0') {
    varRange = dtfrm.componentList[COMPO_TYPE.TEXTBOX]['.variable_const'];
    targetVarTxt = dtfrm.document.getElementById('if.variable_const');
  } else {
    /* Set maximum/minimum values except ON/OFF. */
    if(sel1 != '6' && sel1 != '7') {
      varRange = g_regIOlimit_val[selIf_1_data.tp];
      dtfrm.inputVal[COND_SIDE.LEFT][selIf_1_data.tp].val = Number(sel1_num);
    }
  }

  var selIf_2_data = null;
  /* Integer datatype */
  if(Number(sel1) <= SLCT_PTN.VARIABLE_IO) {
    var dtfrmSelTbl = dtfrm.componentList[COMPO_TYPE.SELECT]['.operator_select1'];
    var opeTbl = detailCondSelOpe_1;
    var rightTbl = detailCondVarSelIf_2;
    var callFunc = dtfrm.switchValueDisplayPattern1;
    var setArray = dtfrm.componentList[COMPO_TYPE.SELECT]['.value_select1'];
    var targetElm1 = dtfrm.document.getElementById('if.operator_select1');
    if(!param[2].match(new RegExp('^' + ORDER_ARGUMENT))) {
      if(isIntegerRealNumber(param[2].replace(/(^\(|\)$)/g, ''))) {
        selIf_2_data = rightTbl[0];
        var targetElm2 = dtfrm.document.getElementById('if.value_select1');
        var targetElm3 = dtfrm.document.getElementById('if.value_const');
      }
      else {
        var sel2ChkStr = new RegExp('(' + ORDER_REGI + '|AO|AI|GO|GI)\\[');
        var targetElm2 = dtfrm.document.getElementById('if.value_select1');
        var targetElm3 = dtfrm.document.getElementById('if.value_index');
      }
    }
  }
  /* Boolean datatype */
  else {
    var dtfrmSelTbl = dtfrm.componentList[COMPO_TYPE.SELECT]['.operator_select2'];
    var opeTbl = detailCondSelOpe_2;
    var rightTbl = detailCondVarSelIf_3;
    var callFunc = dtfrm.switchValueDisplayPattern2;
    var setArray = dtfrm.componentList[COMPO_TYPE.SELECT]['.value_select2'];
    var sel2ChkStr = new RegExp('(' + ORDER_ON + '|' + ORDER_OFF + '|(DO|DI|RO|RI|SO|SI|UO|UI|F)\\[)');
    var targetElm1 = dtfrm.document.getElementById('if.operator_select2');
    var targetElm2 = dtfrm.document.getElementById('if.value_select2');
    var targetElm3 = dtfrm.document.getElementById('if.value_index');
  }
  /* Determine the sign table. */
  var opeChk = opeTbl.find(function(data) {return data.tp == param[1]});
  if(opeChk) sign = opeChk.val;
  
  /* Get the type of right side. */
  var valRange = {};
  if(sel2ChkStr) {
    var prm2_matchResult = param[2].match(sel2ChkStr);
    if(prm2_matchResult) {
      var prm2_tpChk = rightTbl.find(function(data) {return data.tp == prm2_matchResult[1] || data.tp == prm2_matchResult[2]});
      if(prm2_tpChk) selIf_2_data = prm2_tpChk;
    }
  }
  if(selIf_2_data) {
    sel2 = selIf_2_data.val;
    sel2_num = detail_valReplace_chk(getIntegerRealNumber(param[2].replace(/(^\(|\)$)/g, '')));
    if(selIf_2_data.tp != ORDER_ON && selIf_2_data.tp != ORDER_OFF) {
      valRange = (selIf_2_data.tp == '') ?
                   dtfrm.componentList[COMPO_TYPE.TEXTBOX]['.value_const'] : g_regIOlimit_val[selIf_2_data.tp];
      if(selIf_2_data.tp != '') dtfrm.inputVal[COND_SIDE.RIGHT][selIf_2_data.tp].val = Number(sel2_num);
    }
  }
  
  /* Update when all values are obtained. */
  if(sel1 != null && sel1_num != null && sign != null && sel2 != null && sel2_num != null) {
    ret = true;
    dtfrm.switchValueSelectDisplay(sel1);
    dtfrm.document.getElementById('if.variable_select').refresh(dtfrm.componentList[COMPO_TYPE.SELECT]['.variable_select'], sel1, null, false);
    if(Object.keys(varRange).length) {
      if (selIf_1_data.tp == ORDER_REGI) { // Regi
        editorAPI.funcs.refreshLocalRTBComp(targetVarTxt, sel1_num, false, true);
      } else {
        targetVarTxt.refresh(sel1_num, varRange.min, varRange.max, false);
      }
    }
    targetElm1.refresh(dtfrmSelTbl, sign, null, false);
    callFunc(sel2);
    targetElm2.refresh(setArray, sel2, null, false);
    if(Object.keys(valRange).length) {
      if(selIf_2_data.tp == ORDER_REGI) {
        editorAPI.funcs.refreshLocalRTBComp(targetElm3, sel2_num, false, true);
      } else {
        targetElm3.refresh(sel2_num, valRange.min, valRange.max, false);
      }
    }
  }
  
  return ret;
}

/*
 =========================================================================
 @function name      : outputComment_del
 @argument[chkParam] : 
 @description        : 
 @return             : The string after deleting the comment.
 =========================================================================
*/
function outputComment_del(chkParam) {
  return (chkParam.indexOf('\:') != -1) ? chkParam.replace(/\:.*]$/g, ']') : chkParam;
}

/*
 =========================================================================
 @function name   : set_regi_condParam
 @argument[param] : 
 @description     : Determine which radio button to select.
 @return          : none
 =========================================================================
*/
function set_regi_condParam(param) {
  var dtfrm = document.getElementById(get_detail_frm_id(activeTarget)).contentWindow;
  var idx1 = null;
  var selVal = null;
  var idx2 = null;
  var chkStr = '';
  
  param[0] = outputComment_del(param[0]);
  param[1] = outputComment_del(param[1]);
  
  idx1 = detail_valReplace_chk(param[0].replace(/[^0-9]/g, ''));
  
  for(var cnt in dtfrm.selectRegiValList) {
    if(dtfrm.selectRegiValList[cnt][0] === langResource.ihmieditor_detail_constant_c) {
      var flg_isNum_param1 = isIntegerRealNumber(param[1].replace(/(^\(|\)$)/g, ''));
      if((flg_isNum_param1) || (param[1] === ORDER_CONSTANT)) {
        selVal = dtfrm.selectRegiValList[cnt][1];
        break;
      }
    }
    else {
      chkStr = new RegExp('^' + dtfrm.selectRegiValList[cnt][0]);
      if(param[1].match(chkStr)) {
        selVal = dtfrm.selectRegiValList[cnt][1];
        break;
      }
    }
  }
  
  idx2 = detail_valReplace_chk(getIntegerRealNumber(param[1].replace(/(^\(|\)$)/g, '')));
  
  /* Update when all values are obtained. */
  if (idx1 != null && selVal != null && idx2 != null) {
    editorAPI.funcs.refreshLocalRTBComp(dtfrm.document.getElementById('regi_index'), idx1, false, true);
    dtfrm.document.getElementById('regi_val_select').refresh(dtfrm.regComponent['regi_val_select'].data, selVal, null, false);
    if(selVal === '0') {
      dtfrm.document.getElementById('regi_val_const').refresh(idx2,
                                                              dtfrm.regComponent['regi_val_const'].min,
                                                              dtfrm.regComponent['regi_val_const'].max,
                                                              false);
      dtfrm.show_constarea(dtfrm.SHOW_CONSTAREA);
    }
    else {
      dtfrm.show_constarea(dtfrm.HIDE_CONSTAREA);
      if (dtfrm.selectRegiValList[cnt][0] == ORDER_REGI) {
        editorAPI.funcs.refreshLocalRTBComp(dtfrm.document.getElementById('regi_val_index'), idx2, false, true);
      } else {
        dtfrm.document.getElementById('regi_val_index').refresh(idx2, g_regIOlimit_val[dtfrm.selectRegiValList[cnt][0]].min, g_regIOlimit_val[dtfrm.selectRegiValList[cnt][0]].max, false);
      }
      dtfrm.inputVal[dtfrm.selectRegiValList[cnt][0]].val = Number(idx2);
    }
  }
}

/*
 =========================================================================
 @function name   : detail_load_straight
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
//Added to support position registers.To be deleted when the position register is officially supported.
function detail_load_straight(event, dtfrm) {
  /* Set the common items. */
  loadParam_motionCommon(dtfrm);
  
  /* Position information */
  var initArgs = loadParam_posCmp_initArg(g_program_data[activeTarget].position[0].number,
                                          g_program_data[activeTarget].position[0].kind,
                                          dtfrm.document.getElementById("robotPos"));
  if(!unredo_flg || g_RO_flg || !g_TPenbl_flg) {
    initArgs.fold = false;
  }
  var fixedProgInfo = {progName: current_prog_name, lRegNums: g_config['localReg'].slice()};
  dtfrm.document.getElementById('robotPos').setPrgInfoCallback(getProgInfo_forComp, fixedProgInfo, notifyComponentPosEdit);
  dtfrm.document.getElementById("robotPos").refresh(initArgs);
  dtfrm.document.getElementById("robotPos").setCallback(dtfrm.callBackPosition);
  
  return true;
}

/*
 =========================================================================
 @function name   : loadParam_speed
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function loadParam_speed(dtfrm) {
  /* regi[regi */
  if(String(g_program_data[activeTarget].speed.method).indexOf(ORDER_REGI + '[' + ORDER_REGI + '[') != -1) {
    var method = dtfrm.selectOptionListSpeedMethod[2][1];
    var refreshElm = dtfrm.document.getElementById('speed_regi_regi_index');
  }
  /* regi */
  else if(String(g_program_data[activeTarget].speed.method).indexOf(ORDER_REGI + '[') != -1) {
    var method = dtfrm.selectOptionListSpeedMethod[1][1];
    var refreshElm = dtfrm.document.getElementById('speed_regi_index');
  }
  /* weld speed */
  else if(String(g_program_data[activeTarget].speed.val).indexOf(ORDER_WELD_SPEED) != -1) {
    // var method = dtfrm.selectOptionListSpeedMethod?.[3]?.[1];
    var method = dtfrm.selectOptionListSpeedMethod[3] && dtfrm.selectOptionListSpeedMethod[3][1];
  }
  /* constant */
  else {
    var method = dtfrm.selectOptionListSpeedMethod[0][1];
  }
  if(method == undefined){
    method = dtfrm.selectOptionListSpeedMethod[0][1];
  }
  dtfrm.document.getElementById('speed_method').refresh(dtfrm.selectOptionListSpeedMethod, method, null, false);
  dtfrm.selectSpeedMethod('speed_method', null, method);
  if(refreshElm != undefined && refreshElm != null) {
    var regVal = g_program_data[activeTarget].speed.val.replace(/[^0-9]/g, '');
    regVal = regVal == '' ? '0' : regVal;
    editorAPI.funcs.refreshLocalRTBComp(refreshElm, regVal, false, true);
  }
  // speed
  for(var cnt = 0; cnt < dtfrm.selectOptionListSpeedUnit.length; cnt++) {
    var unitVal = dtfrm.selectOptionListSpeedUnit[cnt][1];
    if (dtfrm.selectOptionListSpeedUnit[cnt][0] == g_program_data[activeTarget].speed.unit.replace('.', '')) {
      dtfrm.document.getElementById('unit_l').refresh(dtfrm.selectOptionListSpeedUnit, unitVal, null, false);
      if(method == dtfrm.selectOptionListSpeedMethod[0][1]) {
        var spdVal = g_program_data[activeTarget].speed.val == '...' ? '0' : g_program_data[activeTarget].speed.val;
        dtfrm.document.getElementById('speed_' + unitVal).refresh(spdVal,
                                                                  spdValMinMax[dtfrm.selectOptionListSpeedUnit[cnt][0]][0],
                                                                  spdValMinMax[dtfrm.selectOptionListSpeedUnit[cnt][0]][1],
                                                                  false);
      }
      dtfrm.document.getElementById('speedTextBoxArea' + unitVal).classList.remove('hide');
    } else {
      dtfrm.document.getElementById('speedTextBoxArea' + unitVal).classList.add('hide');
    }
  }
  if(g_program_data[activeTarget].speed.unit === '') {
    var spdTxt = dtfrm.document.getElementById('unit_l').getValue();
    if(spdTxt != '') {
      dtfrm.document.getElementById('speedTextBoxArea' + spdTxt).classList.remove('hide');
    }
  }
}

/*
 =========================================================================
 @function name   : loadParam_route
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function loadParam_route(dtfrm) {
  switch(g_program_data[activeTarget].route.stop) {
    case ORDER_CNT + ' ' + ORDER_REGI:
        var stop = dtfrm.selectOptionListStop[2][1];
        var elm = dtfrm.document.getElementById("nameraka_regi_index");
      break;
    case ORDER_CR:
      // For "spline", there is no "CR" in the list.
        var stop = (dtfrm.document.title == 'Spline') ? dtfrm.crSlct.txt : dtfrm.selectOptionListStop[3][1];
        var elm = dtfrm.document.getElementById("stop_cr_val");
        break;
    case ORDER_CNT:
        var stop = dtfrm.selectOptionListStop[1][1];
        var elm = dtfrm.document.getElementById("nameraka_l");
      break;
    case ORDER_FINE:
    default:
        var stop = dtfrm.selectOptionListStop[0][1];
      break;
  }
  dtfrm.document.getElementById('stop_l').refresh(dtfrm.selectOptionListStop, stop, null, false);
  // For "spline", there is no "CR" in the list.
  dtfrm.selectStopUnit('stop_l', null, ((dtfrm.document.title == 'Spline') && (stop == dtfrm.crSlct.txt)) ? dtfrm.crSlct.idx : stop);
  if(elm != undefined && elm != null) {
    switch(elm.id) {
      case 'nameraka_l':
        elm.refresh(["0", "10", "20", "30", "40", "50", "60", "70", "80", "90", "100"], String(g_program_data[activeTarget].route.val), null, false);
        break;
      case 'stop_cr_val':
        elm.refresh(String(g_program_data[activeTarget].route.val), '0', '1000', (dtfrm.document.title == 'Spline'));
        break;
      case 'nameraka_regi_index':
        var setVal = g_program_data[activeTarget].route.val === '' ? '0' : String(g_program_data[activeTarget].route.val);
        if (Number(g_regIOlimit_val[ORDER_REGI].max) <= 255) {
          editorAPI.funcs.refreshLocalRTBComp(elm, setVal, false, false);
        } else {
          elm.refresh(setVal, String(g_regIOlimit_val[ORDER_REGI].min), '255', false);
        }
        break;
      default:
        break;
    }
  }
}

/*
 =========================================================================
 @function name   : loadParam_additionalMotion
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
var DETAIL_ADD_MOTION_MAX = 99;
function loadParam_additionalMotion(dtfrm) {
  var chkTbl = {
    'joint'      :['kakujiku', 'vsnjoint', 'laserkpre', 'laserkls', 'laserkle'],
    'circlearc'  :['circlearc', 'lasercals', 'lasercale', 'weldstartca', 'weldstopca'],
    'spline'     :['spline', 'lasersls', 'lasersle'],
    'vision'     :['vsnline', 'vsnjoint'],
    'arc'        :['weldstartml', 'weldstopml', 'weldstartca', 'weldstopca'],
    'laser'      :['laserpre', 'laserls', 'laserle', 'laserkpre', 'laserkls', 'laserkle', 'lasercls', 'lasercle', 'lasercals', 'lasercale', 'lasersls', 'lasersle'],
  };
  var loadBaseId = g_program_data[activeTarget].baseId;
  var visionChk = chkTbl['vision'].includes(loadBaseId);
  var arcChk = chkTbl['arc'].includes(loadBaseId);
  var lsrChk = chkTbl['laser'].includes(loadBaseId);

  var optStr = g_program_data[activeTarget].addMotion.slice();
  /* Remove the additional motion of the vision. */
  if(visionChk && !arcChk && !lsrChk) {
    for(var i in optStr) {
      if((optStr[i].indexOf(ORDER_VOFFSET+','+ ORDER_VR) != -1) || (optStr[i] == ORDER_VOFFSET)) {
        optStr.splice(i,1);
      }
    }
  }
  /* Remove the additional motion of the arc. */
  if(arcChk) {
    for(var i in optStr) {
      if((optStr[i].indexOf(ORDER_WELDSTART) != -1) || (optStr[i].indexOf(ORDER_WELDEND) != -1)) {
        optStr.splice(i,1);
      }
    }
  }
  /* Remove the additional motion of the laser. */
  if(lsrChk && !arcChk) {
    var lsrCmd = new RegExp('(' + ORDER_PLE_LS + '|' + ORDER_LS + '|' + ORDER_LE + '|' + ORDER_SLPU + '|' + ORDER_SLPD + ')');
    var cnt = 0;
    while(optStr.length > cnt) {
      if(optStr[cnt].match(lsrCmd)) {
        optStr.splice(cnt,1);
      }
      else {
        cnt++;
      }
    }
  }

  /* There is an additional instruction to display. */
  if(optStr.length > 0) {
    dtfrm.document.getElementById('option_formlist').refresh(null, optStr.length - 1, DETAIL_ADD_MOTION_MAX, null);
    
    var newList = dtfrm.document.getElementsByClassName('input-form-list-row');
    for(var cnt = 0; cnt < newList.length; cnt++) {
      var nodes = newList[cnt].getElementsByTagName('input');
      nodes[0].refresh(langConvEng(optStr[cnt]), 255, false);
      nodes[0].setCallback(dtfrm.textboxCallback);
    }
    var addMotionList = (chkTbl['joint'].includes(loadBaseId)) ?
                           jointAddMotionCondVarSel : (chkTbl['circlearc'].includes(loadBaseId) || chkTbl['spline'].includes(loadBaseId)) ?
                           circlearcSplineAddMotionCondVarSel : addMotionCondVarSel;
    dtfrm.document.getElementById("addmotion_select_" + cnt).refresh(addMotionList, 0, null, false);
    dtfrm.document.getElementById("addmotion_select_" + cnt).setCallback(dtfrm.callbackSelectAddMotion);
  }
}

/*
 =========================================================================
 @function name   : loadParam_motionCommon
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function loadParam_motionCommon(dtfrm) {
  /* initialize */
  dtfrm.initPosLeft();
  dtfrm.initPosRight();
  dtfrm.initAddMotion();
  
  /* Speed */
  loadParam_speed(dtfrm);
  
  /* Route */
  loadParam_route(dtfrm);
  
  /* Additional motion */
  loadParam_additionalMotion(dtfrm);
}

/*
 =========================================================================
 @function name     : loadParam_posCmp_initArg
 @argument[posNum]  : Positional values
 @argument[posKind] : Type of position information
 @argument[elm]     : Position component elements
 @description       : Function execution and input value setting when reading the details tab.
 @return            : none
 =========================================================================
*/
function loadParam_posCmp_initArg(posNum, posKind, elm) {
  var initArgs = {
    initCompleteCallback: posInitCompleteCallback,
    initCompleteArgs: { posNumber: posNum, elem: elm },
    fold: true,
    disableComment: false,
    posMode: 15,
    posKind: posKind,
    behindDefaultPosRegNum: 1,
    behindDefaultPosRegRegNum: 1,
    behindDefaultPosRegArgNum: 1,
    number: posNum,
    group: null
  };

  /* Favorite savemode is position disabled */
  if(g_favoriteFlg.tlAdd || g_favoriteFlg.progAdd || g_favoriteFlg.favoEdit) {
    initArgs.number = -1;
  }

  return initArgs;
}

/*
 =========================================================================
 @function name   : detail_load_kakujiku
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
//Added to support position registers.To be deleted when the position register is officially supported.
function detail_load_kakujiku(event, dtfrm) {
  /* Set the common items. */
  loadParam_motionCommon(dtfrm);
  
  /* Position information */
  var initArgs = loadParam_posCmp_initArg(g_program_data[activeTarget].position[0].number,
                                          g_program_data[activeTarget].position[0].kind,
                                          dtfrm.document.getElementById("robotPos"));
  if(!unredo_flg || g_RO_flg || !g_TPenbl_flg) {
    initArgs.fold = false;
  }
  var fixedProgInfo = {progName: current_prog_name, lRegNums: g_config['localReg'].slice()};
  dtfrm.document.getElementById('robotPos').setPrgInfoCallback(getProgInfo_forComp, fixedProgInfo, notifyComponentPosEdit);
  dtfrm.document.getElementById("robotPos").refresh(initArgs);
  dtfrm.document.getElementById("robotPos").setCallback(dtfrm.callBackPosition);

  return true;
}

/*
 =========================================================================
 @function name   : detail_load_circular
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
//Added to support position registers.To be deleted when the position register is officially supported.
function detail_load_circular(event, dtfrm) {
  /* Set the common items. */
  loadParam_motionCommon(dtfrm);
  /* Set the via offset */
  var offset = '0', indexVal = '0';
  if(g_program_data[activeTarget].position[0].offsetMotion) {
    var offsetChkTbl = [
      {chkStr:new RegExp('^' + langResource.ihmieditor_order_offset_c + '\\,' + ORDER_POSREGI + '\\[' + ORDER_ARGUMENT), val:'4'},
      {chkStr:new RegExp('^' + langResource.ihmieditor_order_offset_c + '\\,' + ORDER_POSREGI + '\\[' + ORDER_REGI), val:'3'},
      {chkStr:new RegExp('^' + langResource.ihmieditor_order_offset_c + '\\,' + ORDER_POSREGI + '\\['), val:'2'},
      {chkStr:new RegExp('^' + langResource.ihmieditor_order_offset_c), val:'1'},
      {chkStr:new RegExp('^' + langResource.ihmieditor_order_tool_offset_c + '\\,' + ORDER_POSREGI + '\\[' + ORDER_ARGUMENT), val:'8'},
      {chkStr:new RegExp('^' + langResource.ihmieditor_order_tool_offset_c + '\\,' + ORDER_POSREGI + '\\[' + ORDER_REGI), val:'7'},
      {chkStr:new RegExp('^' + langResource.ihmieditor_order_tool_offset_c + '\\,' + ORDER_POSREGI + '\\['), val:'6'},
      {chkStr:new RegExp('^' + langResource.ihmieditor_order_tool_offset_c), val:'5'},
      {chkStr:new RegExp('^' + langResource.ihmieditor_order_voffset_c + '\\,' + ORDER_VR + '\\[' + ORDER_ARGUMENT), val:'12'},
      {chkStr:new RegExp('^' + langResource.ihmieditor_order_voffset_c + '\\,' + ORDER_VR + '\\[' + ORDER_REGI), val:'11'},
      {chkStr:new RegExp('^' + langResource.ihmieditor_order_voffset_c + '\\,' + ORDER_VR + '\\['), val:'10'},
      {chkStr:new RegExp('^' + langResource.ihmieditor_order_voffset_c), val:'9'},
    ];
    var offsetChk = offsetChkTbl.find(function(data) {return g_program_data[activeTarget].position[0].offsetMotion.match(data.chkStr)});
    if(offsetChk) {
      offset = offsetChk.val;
      var strChk = g_program_data[activeTarget].position[0].offsetMotion.replace(offsetChk.chkStr, '');
      indexVal = ((strChk.match(/\:/)) ? strChk.substring(0, strChk.indexOf(':')) : strChk).replace(/[^0-9]/g, '');
      indexVal = indexVal ? indexVal : '0';
    }
  }
  dtfrm.initViaOffset(offset, indexVal);
  
  /* Position information */
  var initArgs = loadParam_posCmp_initArg(g_program_data[activeTarget].position[0].number,
                                          g_program_data[activeTarget].position[0].kind,
                                          dtfrm.document.getElementById("robotPos1"));
  var initArgs2 = loadParam_posCmp_initArg(g_program_data[activeTarget].position[1].number,
                                           g_program_data[activeTarget].position[1].kind,
                                           dtfrm.document.getElementById("robotPos2"));
  if (!unredo_flg || g_RO_flg || !g_TPenbl_flg) {
    initArgs.fold = false;
    initArgs2.fold = false;
  }
  var fixedProgInfo = {progName: current_prog_name, lRegNums: g_config['localReg'].slice()};
  dtfrm.document.getElementById('robotPos1').setPrgInfoCallback(getProgInfo_forComp, fixedProgInfo, notifyComponentPosEdit);
  dtfrm.document.getElementById("robotPos1").refresh(initArgs);
  dtfrm.document.getElementById("robotPos1").setCallback(dtfrm.callBackPosition);
  dtfrm.document.getElementById('robotPos2').setPrgInfoCallback(getProgInfo_forComp, fixedProgInfo, notifyComponentPosEdit);
  dtfrm.document.getElementById("robotPos2").refresh(initArgs2);
  dtfrm.document.getElementById("robotPos2").setCallback(dtfrm.callBackPosition);

  return true;
}

/*
 =========================================================================
 @function name   : detail_load_macro
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_macro(event, dtfrm) {
  var param = g_program_data[activeTarget].param;
  dtfrm.document.getElementById("macro_name").refresh(macro_list, param, null, false);

  return true;
}

/*
 =========================================================================
 @function name   : detail_load_call
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_call(event, dtfrm) {
  var afterProc = false;
  if(g_sysval['$KAREL_ENB'] == undefined) {
    getKarelEnbl(event);
  }
  else {
    detail_load_callScreen();
    afterProc = true;
  }
  return afterProc;
}

/*
 =========================================================================
 @function name   : getKarelEnbl
 @argument[event] : onload event.
 @description     : 
 @return          : none
 =========================================================================
*/
function getKarelEnbl(event) {
  var sysValArr = [
    '$KAREL_ENB'
  ];
  getSysValXHR(sysValArr, getKarelEnbl_CB, event);
}

/*
 =========================================================================
 @function name     : getKarelEnbl_CB
 @argument[status]  : 
 @argument[getText] : 
 @argument[cbArgs]  : 
 @description       : 
 @return            : none
 =========================================================================
*/
function getKarelEnbl_CB(status, getText, cbArgs) {
  var xmlObj = getSysValXmlData(getText, 'VAR');
  if (xmlObj == null) { return; } // Add error messages if needed.
  var convData = extractRcvXHRData(xmlObj, 'VAR');
  
  g_sysval['$KAREL_ENB'] = {value: Number(convData['$KAREL_ENB'])};
  
  detail_load_callScreen(cbArgs);
}

/*
 =========================================================================
 @function name   : detail_load_callScreen
 @argument[event] : onload event
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_callScreen(event) {
  var dtfrm = document.getElementById(get_detail_frm_id(activeTarget)).contentWindow;
  var call_list = programFileList.map(function(item) {return item.name});
  var karel_call_list = karelProgramFileList.map(function(item) {return item.name});

  var params = split_param_call(g_program_data[activeTarget].param);

  var param = (params[0] == "") ? '' : params[0].trim();

  var argparam = '';
  if (params[1] === undefined) {
    params[1] = "";
  } else {
    params[1] = langConvEng(params[1].replace(/\)$/, ''));
    /*commaMatch = Matches comma other than in single quotes and [] */
    var commaMatch = /,(?=(?:[^']*'[^']*')*[^']*$)(?![^\[]*\])/g;
    argparam = params[1].split(commaMatch);
  }
  if (g_sysval['$KAREL_ENB'].value == 1 && karel_call_list.findIndex(function(element){ return element === param}) != -1) {
    var radio_sel = 2;
    dtfrm.document.getElementById("call_name").refresh(karel_call_list, param, null, false);
  } else {
    var radio_sel = 1;
    dtfrm.document.getElementById("call_name").refresh(call_list, param, null, false);
  }
  dtfrm.tp_select = 0;
  dtfrm.karel_select = 0;
  dtfrm.document.getElementById("argments_formlist").removeAllRows();
  dtfrm.document.getElementById("program_sel1").style.display = '';
  dtfrm.document.getElementById("program_sel2").style.display = '';
  if(g_sysval['$KAREL_ENB'].value == 1) {
    dtfrm.document.getElementById("program_sel1").refresh(null, radio_sel, false);
    dtfrm.document.getElementById("program_sel2").style.display = 'none';
    dtfrm.document.getElementById("program_sel1").style.display = '';
  }
  else {
    dtfrm.document.getElementById("program_sel2").refresh(null, 1, false);
    dtfrm.document.getElementById("program_sel1").style.display = 'none';
    dtfrm.document.getElementById("program_sel2").style.display = '';
  }

  if(argparam.length > 0) {
    dtfrm.document.getElementById("argments_formlist").refresh(null, argparam.length - 1, null, null);
    
    var newList = dtfrm.document.getElementsByClassName('input-form-list-row');
    for(var argcnt = 0; argcnt < newList.length; argcnt++) {
      var nodes = newList[argcnt].getElementsByTagName('input');
      if (!isNaN(Number(argparam[argcnt].replace(/(^\(|\)$)/g, '')))) {
        nodes[0].refresh(argparam[argcnt].replace(/(^\(|\)$)/g, ''), 255, false);
      }
      else {
        nodes[0].refresh(langConvEng(argparam[argcnt]), 255, false);
      }
      nodes[0].setCallback(dtfrm.textboxCallback);
    }
  }
  else {
    dtfrm.document.getElementById('argument_1').refresh('', 255, false);
  }
  /* Update the css in the stm as it is hidden when it is first loaded. */
  dtfrm.document.body.style.visibility = 'visible';
  
  if(typeof event != 'undefined') {
    detail_load_afterProc();
  }
}

/*
 =========================================================================
 @function name   : detail_load_for
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_for(event, dtfrm) {
  var param = split_param_for(g_program_data[activeTarget].param);
  
  /* loop select */
  detail_load_for_judgeVal(dtfrm, 'loop', param[0].replace(/^FOR\s/, ''));
  
  /* init value */
  detail_load_for_judgeVal(dtfrm, 'init', param[2]);

  /* count type */
  dtfrm.document.getElementById('to_down').refresh(dtfrm.selectToDownList, param[3].indexOf('DOWNTO') != -1 ? 1 : 0, null, false);
  
  /* end value */
  detail_load_for_judgeVal(dtfrm, 'end', param[4]);

  return true;
}

/*
 =========================================================================
 @function name      : detail_load_for_valueJudge
 @argument[dtfrm]    : Frame on the detail screen.
 @argument[judgeStr] : String for judgment.
 @argument[val]      : Check value.
 @description        : 
 @return             : none
 =========================================================================
*/
function detail_load_for_judgeVal(dtfrm, judgeStr, val) {
  var selChkStr1 = new RegExp('^' + ORDER_REGI + '\\[');
  var selChkStr2 = new RegExp('^' + ORDER_ARGUMENT + '\\[');
  var list = judgeStr == 'loop' ? dtfrm.selectLoopList['disp'] : dtfrm.selectOptionList['disp'];
  var cmpList = dtfrm.componentList;
  
  /* type */
  val = outputComment_del(val).replace(/(^\(|\)$)/g, '');
  /* Determine the array number */
  if(val.match(selChkStr1)) {
    val = val.replace(selChkStr1, '').replace(/\]$/, '');
    var num = val.match(selChkStr1) ? 2 : val.match(selChkStr2) ? 3 : 1;
    if(judgeStr == 'loop') num = num - 1;  // Adjust for loop counter.
  }
  else if(val.match(selChkStr2)) {
    val = val.replace(selChkStr2, '').replace(/\]$/, '');
    var num = val.match(selChkStr1) ? 5 : val.match(selChkStr2) ? 6 : 4;
  }
  else {
    var num = 0;
  }
  dtfrm.document.getElementById(judgeStr + '_val').refresh(list, list[num][1], false);
  
  /* value */
  var inputId = judgeStr + '_val' + (num + 1);
  var textArea = dtfrm.document.getElementsByClassName(judgeStr + 'TextBoxArea');
  val = val.replace(/[^0-9_-]/g, '');
  if (val == '') val = 0;
  var tbRCmp = ['loop_val1', 'loop_val2', 'init_val2', 'init_val3', 'init_val6', 'end_val2', 'end_val3', 'end_val6'];
  for (var init = 0; init < textArea.length; init++) {
    if (textArea[init].firstElementChild.id == inputId) {
      if (tbRCmp.indexOf(inputId) >= 0) {
        editorAPI.funcs.refreshLocalRTBComp(dtfrm.document.getElementById(inputId), val, false, true);
      } else {
        dtfrm.document.getElementById(inputId).refresh(val, cmpList[inputId].min, cmpList[inputId].max, false);
      }
      top.IHMIComponents.cf.turnOnOffClass(textArea[init], 'hide', false);
    }
    else {
      var id = textArea[init].firstElementChild.id;
      var setVal = cmpList[id].min < 0 ? 0 : cmpList[id].min;
      if (tbRCmp.indexOf(id) >= 0) {
        editorAPI.funcs.refreshLocalRTBComp(dtfrm.document.getElementById(id), setVal, false, true);
      } else {
        dtfrm.document.getElementById(id).refresh(setVal, cmpList[id].min, cmpList[id].max, false);
      }
      top.IHMIComponents.cf.turnOnOffClass(textArea[init], 'hide', true);
    }
  }
}

/*
 =========================================================================
 @function name   : detail_load_jumplabel
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_jumplabel(event, dtfrm) {
  var tmpStr = g_program_data[activeTarget].param;
  var chkStr = new RegExp(ORDER_JUMP + ' ' + ORDER_LABEL + '\\[');
  var array = g_labelNumList.toString(10).split(',');
  var setNumStr = (tmpStr.match(chkStr)) ? detail_valReplace_chk(tmpStr.replace(/[^0-9]/g, '')) : '0';
  dtfrm.document.getElementById('jump_select').refresh(array, setNumStr, null, false);

  return true;
}

/*
 =========================================================================
 @function name   : detail_load_label
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_label(event, dtfrm) {
  var labelNum = (g_program_data[activeTarget].param !== "") ?
                    g_program_data[activeTarget].param.replace(/[^0-9]/g, '') : '0';
  dtfrm.document.getElementById('label_text').refresh(labelNum, "1", "32766", false);
  dtfrm.document.getElementById('setreq_str').style.display = '';
  var rmv_str = new RegExp('(' + ORDER_LABEL + '\\[|\\]$)', 'g');
  var cpChk = g_program_data[activeTarget].param.replace(rmv_str, '');
  if((g_program_data[activeTarget].remark == false && cpChk[0] === '*') ||
      cpChk === '0') {
    dtfrm.document.getElementById('setreq_str').style.display = 'block';
    var cgInput = dtfrm.document.getElementsByTagName('INPUT');
    if(cpChk[0] === '*' && cgInput.length != 0) {
      for(var cnt = 0; cnt < cgInput.length; cnt++) {
        cgInput[cnt].style.color = "rgb(230, 0, 18)";
      }
    }
  }

  return true;
}

/*
 =========================================================================
 @function name   : detail_load_payload
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_payload(event, dtfrm) {
  if(g_program_data[activeTarget].param.match(new RegExp('^' + ORDER_CALL + '\\s-INST_PAYLOAD'))) {
    var replaceStr = new RegExp('(^' + ORDER_CALL + '\\s-INST_PAYLOAD\\(|\\)$)', 'g');
    var arg = g_program_data[activeTarget].param.replace(replaceStr, '').split(',');
    dtfrm.payloadVer = arg[0];
    var numType = arg[1];
    var setNum = detail_valReplace_chk(arg[2].replace(/[^0-9]/g, ''));
    var setTime = (arg[3].match(/^(\d+\.\d{2})$/)) ? arg[3] : Number(arg[3]).toFixed(2);
    if(setTime == '0.00') setTime = '0';
  }
  else {
    dtfrm.payloadVer = '';
    var replaceStr = new RegExp('^' + ORDER_PAYLOAD + '\\[|\\]$', 'g');
    var chkStr = outputComment_del(g_program_data[activeTarget].param).replace(replaceStr, "");
    var numType = (chkStr.match(new RegExp('^' + ORDER_REGI + '\\['))) ? '1' : '0';
    var setNum = detail_valReplace_chk(chkStr.replace(/[^0-9]/g, ''));
    var setTime = '0';
  }

  dtfrm.document.getElementById("payload_select").refresh(dtfrm.selectPayloadList, numType, null, false);
  /* Number type:Constant */
  if(numType == '0') {
    dtfrm.document.getElementById("indexarea").style.display = 'none';
    dtfrm.document.getElementById("constarea").style.display = 'block';
    dtfrm.document.getElementById("payload_const").refresh(setNum, "1", g_payload_schnum.toString(10), false);
    editorAPI.funcs.refreshLocalRTBComp(dtfrm.document.getElementById("payload_index"), "1", false, true);
  }
  /* Number type:Register */
  else {
    dtfrm.document.getElementById("constarea").style.display = 'none';
    dtfrm.document.getElementById("indexarea").style.display = 'block';
    editorAPI.funcs.refreshLocalRTBComp(dtfrm.document.getElementById("payload_index"), setNum, false, true);
    dtfrm.document.getElementById("payload_const").refresh("1", "1", g_payload_schnum.toString(10), false);
  }
  /* Waiting time */
  var groupChk = payload_motionGrpChk();  /* Multi group check */
  var timeMax = groupChk ? '0' : '327.67';
  var disableFlg = (groupChk && setTime == '0') ? true : false;
  dtfrm.document.getElementById("time_val").refresh(setTime, "0.00", timeMax, disableFlg);

  return true;
}

/* =========================================================================
 @function name   : payload_motionGrpChk
 @return          : true : A motion group other than 1 is specified.
 =========================================================================*/
function payload_motionGrpChk() {
  for(var cnt = 1; cnt < g_motion_group_array.length; cnt++) {
    if(g_motion_group_array[cnt]) return true;
  }
  return false;
}

/*
 =========================================================================
 @function name   : detail_load_comment
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_comment(event, dtfrm) {
  dtfrm.document.getElementById('comment').setConfig(dtfrm.inputFilter.filter, dtfrm.inputFilter.validate, dtfrm.inputFilter.minLen);
  dtfrm.document.getElementById('comment').refresh(g_program_data[activeTarget].param, 32, false);

  return true;
}

/*
 =========================================================================
 @function name   : detail_load_text_code
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_text_code(event, dtfrm) {
  dtfrm.document.getElementById('text_form').setConfig(dtfrm.inputFilter.filter, dtfrm.inputFilter.validate, dtfrm.inputFilter.minLen);
  dtfrm.document.getElementById('text_form').refresh(langConvEng(g_program_data[activeTarget].param), 255, false);

  return true;
}

/*
 =========================================================================
 @function name   : detail_load_setuframe
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_setuframe(event, dtfrm) {
  var param = g_program_data[activeTarget].param.split('=');
  detail_load_frame_judgeVal('SET', dtfrm, 'uframe', param[0]);
  detail_load_frame_judgeVal('SET', dtfrm, 'posReg', param[1]);

  return true;
}

/*
 =========================================================================
 @function name   : detail_load_setutool
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_setutool(event, dtfrm) {
  var param = g_program_data[activeTarget].param.split('=');
  detail_load_frame_judgeVal('SET', dtfrm, 'utool', param[0]);
  detail_load_frame_judgeVal('SET', dtfrm, 'posReg', param[1]);

  return true;
}

/*
 =========================================================================
 @function name   : detail_load_seluframe
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_seluframe(event, dtfrm) {
  detail_load_frame_judgeVal('SEL', dtfrm, 'uframe', g_program_data[activeTarget].param);

  return true;
}

/*
 =========================================================================
 @function name   : detail_load_selutool
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_selutool(event, dtfrm) {
  detail_load_frame_judgeVal('SEL', dtfrm, 'utool', g_program_data[activeTarget].param);

  return true;
}

/*
=========================================================================
@function name      : detail_load_frame_judgeVal
@argument[order]    : SET or SELECT order
@argument[dtfrm]    : Frame on the detail screen.
@argument[judgeStr] : String for judgment.
@argument[param]    : Check value.
@description        : 
@return             : none
=========================================================================
*/
function detail_load_frame_judgeVal(order, dtfrm, judgeStr, param) {
  var val = "";
  var list = dtfrm.selectList['disp'];
  var progName = param;
  var cmpList = dtfrm.componentList;
  var selChkStr1 = new RegExp('^' + ORDER_REGI + '\\[');
  var selChkStr2 = new RegExp('^' + ORDER_ARGUMENT + '\\[');
  var selChkStr3 = new RegExp('^' + ORDER_UFRAME + '\\[');
  var selChkStr4 = new RegExp('^' + ORDER_UTOOL + '\\[');
  var selChkStr5 = new RegExp('^' + ORDER_POSREGI + '\\[');
  var splitProgName = "";
  switch(order){
    case 'SET':
      if(progName.indexOf("GP") != -1){
        splitProgName = progName.split(':');
        progName = splitProgName[1];
      }
      /* type */
      progName = outputComment_del(progName).replace(/(^\(|\)$)/g, '');
      /* Determine the array number */
      if(progName.match(selChkStr3)) {
        val = progName.replace(selChkStr3, '').replace(/\]$/, '');
        var num = val.match(selChkStr1) ? 1 : val.match(selChkStr2) ? 2 : 0;
        break;
      }
      else if(progName.match(selChkStr4)) {
        val = progName.replace(selChkStr4, '').replace(/\]$/, '');
        var num = val.match(selChkStr1) ? 1 : val.match(selChkStr2) ? 2 : 0;
        break;
      }
      else if(progName.match(selChkStr5) || splitProgName != "") {
        val = progName.replace(selChkStr5, '').replace(/\]$/, '');
        var num = val.match(selChkStr1) ? 1 : val.match(selChkStr2) ? 2 : 0;
        break;
      }
      else {
        var num = 0;
      }
      break;
    case 'SEL':
      splitProgName = progName.split("=");
      /* type */
      splitProgName[1] = outputComment_del(splitProgName[1]).replace(/(^\(|\)$)/g, '');
      /* Determine the array number */
      if(splitProgName[1].match(selChkStr1)) {
        val = splitProgName[1].replace(selChkStr1, '').replace(/\]$/, '');
        var num = val.match(selChkStr1) ? 2 : val.match(selChkStr2) ? 3 : 1;
      }
      else if(splitProgName[1].match(selChkStr2)) {
        val = splitProgName[1].replace(selChkStr2, '').replace(/\]$/, '');
        var num = val.match(selChkStr1) ? 5 : val.match(selChkStr2) ? 6 : 4;
      }
      else {
        val = splitProgName[1];
        var num = 0;
      }
      break;
    default:
      break;
  }
  dtfrm.document.getElementById(judgeStr + '_val').refresh(list, list[num][1], false);
  /* multigroup */
  var refFlag = 0;
  var groupVal = "";
  var groupArea = dtfrm.document.getElementsByClassName('multigroupArea');
  if(splitProgName != ""){
    for(var loop = 0; loop < 2; loop++){
      if(splitProgName[loop].indexOf("GP") != -1){
        if(splitProgName[loop].match(/[1-8]/g) != null) {
          groupVal = splitProgName[loop].match(/[1-8]/g).join(",");
        }
        dtfrm.document.getElementById("group_val").refresh(groupVal, "20", true);
        top.IHMIComponents.cf.turnOnOffClass(groupArea[0], 'hide', false);
        break;
      }
      else{
        if(refFlag == 0) {
          dtfrm.document.getElementById("group_val").refresh(null, "20", true);
          top.IHMIComponents.cf.turnOnOffClass(groupArea[0], 'hide', true);
          refFlag = 1;
        }
      }
    }
  }else{
    if(judgeStr == 'posReg') {
      dtfrm.document.getElementById("group_val").refresh(null, "20", true);
      top.IHMIComponents.cf.turnOnOffClass(groupArea[0], 'hide', true);
    }
  }
  /* value */
  var inputId = judgeStr + '_val' + (num + 1);
  var textArea = dtfrm.document.getElementsByClassName(judgeStr + 'TextboxArea');
  val = val.replace(/[^0-9_-]/g, '');
  if (val == '') val = judgeStr == "posReg" ? 0 : -1;
  var tbRCmp = (order == 'SET') ? ['uframe_val2', 'utool_val2', 'posReg_val2'] : ['uframe_val2', 'uframe_val3', 'uframe_val6', 'utool_val2', 'utool_val3', 'utool_val6'];
  var tbPRCmp = ['posReg_val1'];
  for(var init = 0; init < textArea.length; init++) {
    if (textArea[init].firstElementChild.id == inputId) {
      if (tbRCmp.indexOf(inputId) >= 0) {
        editorAPI.funcs.refreshLocalRTBComp(dtfrm.document.getElementById(inputId), val, false, true);
      } else if (tbPRCmp.indexOf(inputId) >= 0) {
        editorAPI.funcs.refreshLocalPRTBComp(dtfrm.document.getElementById(inputId), val, false, true);
      } else {
        dtfrm.document.getElementById(inputId).refresh(val, cmpList[inputId].min, cmpList[inputId].max, false);
      }
      top.IHMIComponents.cf.turnOnOffClass(textArea[init], 'hide', false);
    }
    else {
      var id = textArea[init].firstElementChild.id;
      var setVal = cmpList[id].min < 0 ? 0 : cmpList[id].min;
      if (tbRCmp.indexOf(id) >= 0) {
        editorAPI.funcs.refreshLocalRTBComp(dtfrm.document.getElementById(id), setVal, false, true);
      } else if (tbPRCmp.indexOf(id) >= 0) {
        editorAPI.funcs.refreshLocalPRTBComp(dtfrm.document.getElementById(id), setVal, false, true);
      } else {
        dtfrm.document.getElementById(id).refresh(setVal, cmpList[id].min, cmpList[id].max, false);
      }
      top.IHMIComponents.cf.turnOnOffClass(textArea[init], 'hide', true);
    }
  }
}

/*
 =========================================================================
 @function name   : detail_load_output
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_output(event, dtfrm) {
  var out_sel = ['do', 'ro', 'ao', 'go', 'f', 'direct'];
  
  /* Split the parameter into a left side and a right side. */
  var param = param_combineCheck('=', split_param(g_program_data[activeTarget].param));

  /* Get the selected position of the radio button. */
  var chkStr = new RegExp('^(DO|RO|AO|GO|F)\\[');
  var matchRes = param[0].match(chkStr);
  var o_type = matchRes[1];
  for(var listCnt in dtfrm.selectOutPutList) {
    if(dtfrm.selectOutPutList[listCnt][0] === o_type) {
      break;
    }
  }
  var judgeSel = detail_output_directCheck(listCnt, param);
  dtfrm.document.getElementById('output_list').refresh(null, judgeSel, false);
  for (var o_cnt = 0; o_cnt < out_sel.length; o_cnt++) {
    if(judgeSel == o_cnt + 1) {
      var directSel = listCnt;
      var regVal = (judgeSel === 6) ? langConvEng(param[0]) : (param[0] === '...') ? '0' : param[0];
      if(param[1] != "" && param[1] != undefined) {
        if(out_sel[o_cnt] == 'ao' || out_sel[o_cnt] == 'go') {
          var insVal = param[1].replace(/(^\(|\)$)/g, "");
        }
        else if(out_sel[o_cnt] == 'direct') {
          var insVal = langConvEng(param[1].trim());
        }
        else {
          var chkStr = new RegExp('(' + ORDER_ON + '|ON)');
          var insVal = (param[1].match(chkStr)) ? '0' : '1';
        }
      }
      else {
        var insVal = (out_sel[o_cnt] == 'direct') ? 'OFF' : '1';
      }
      var disabledFlg = false;
    }
    else {
      var directSel = '0';
      var regVal = '1';
      var insVal = (out_sel[o_cnt] == 'direct') ? 'OFF' : '1';
      var disabledFlg = true;
    }
    if(out_sel[o_cnt] == 'direct') {
      dtfrm.document.getElementById('direct_select').refresh(dtfrm.outputComponent[o_cnt]['direct_select'].data,
                                                             directSel,
                                                             null,
                                                             disabledFlg);
      dtfrm.document.getElementById('direct_regi').refresh(regVal,
                                                           dtfrm.outputComponent[o_cnt]['direct_regi'].length,
                                                           disabledFlg);
      dtfrm.document.getElementById('direct_ins').refresh(insVal,
                                                          dtfrm.outputComponent[o_cnt]['direct_ins'].length,
                                                          disabledFlg);
    }
    else {
      dtfrm.document.getElementById(out_sel[o_cnt] + '_regi').refresh(regVal,
                                                                      dtfrm.outputComponent[o_cnt][out_sel[o_cnt] + '_regi'].min,
                                                                      dtfrm.outputComponent[o_cnt][out_sel[o_cnt] + '_regi'].max,
                                                                      disabledFlg);
      if (out_sel[o_cnt] == 'ao' || out_sel[o_cnt] == 'go') {
        dtfrm.document.getElementById(out_sel[o_cnt] + '_ins').refresh(insVal,
                                                             dtfrm.outputComponent[o_cnt][out_sel[o_cnt] + '_ins'].min,
                                                             dtfrm.outputComponent[o_cnt][out_sel[o_cnt] + '_ins'].max,
                                                             disabledFlg);
      }
      else {
        dtfrm.document.getElementById(out_sel[o_cnt] + '_ins').refresh(dtfrm.outputComponent[o_cnt][out_sel[o_cnt] + '_ins'].data,
                                                                       insVal,
                                                                       null,
                                                                       disabledFlg);
      }
    }
  }

  return true;
}

/*
 =========================================================================
 @function name  : detail_output_directCheck
 @argument       : 
 @description    : 
 @return         : none
 =========================================================================
*/
function detail_output_directCheck(listCnt, insParam) {
  var retVal, chkVal;
  var chkKindStr = new RegExp('(^(DO|RO|AO|GO|F)\\[|\\]$)', 'g');
  var dtfrm = document.getElementById(get_detail_frm_id(activeTarget)).contentWindow;
  
  insParam[0] = insParam[0].replace(chkKindStr, '');
  
  /* The index is specified directly. */
  if(insParam[0] === '...' || insParam[0].replace(/[0-9]/g, "") === '') {
    /* DO/RO */
    if ((dtfrm.selectOutPutList[listCnt][1] == '0') ||
        (dtfrm.selectOutPutList[listCnt][1] == '1')) {
      if ((insParam[1] === ORDER_ON) || (insParam[1] === ORDER_OFF) ||
          (insParam[1] === 'ON') || (insParam[1] === 'OFF')) {
        retVal = parseInt(dtfrm.selectOutPutList[listCnt][1]) + 1;
      }
      else {
        retVal = 6;
      }
    }
    /* F */
    else if (dtfrm.selectOutPutList[listCnt][1] == '4') {    /* F */
      if ((insParam[1] === '(' + ORDER_ON + ')') || (insParam[1] === '(' + ORDER_OFF + ')') ||
          (insParam[1] === '(ON)') || (insParam[1] === '(OFF)')) {
        retVal = parseInt(dtfrm.selectOutPutList[listCnt][1]) + 1;
      }
      else {
        retVal = 6;
      }
    }
    /* other(AO/GO) */
    else {
      var chkStr = new RegExp('(e|' + ORDER_ARGUMENT + '|' + ORDER_REGI + '|' + ORDER_POSREGI + ')');
      if (insParam[1].match(chkStr)) {
        retVal = 6;
      }
      else {
        var rightSideConstPrm = insParam[1].replace(/(^\(|\)$)/g, '');
        var isNumConstprm = isIntegerRealNumber(rightSideConstPrm);
        if ((isNumConstprm) && (rightSideConstPrm.length < 14)) {
            retVal = parseInt(dtfrm.selectOutPutList[listCnt][1]) + 1;
        }
        else {
          retVal = 6;
        }
      }
    }
  }
  else {
    retVal = 6;
  }
  
  return retVal;
}

/*
 =========================================================================
 @function name   : detail_load_wait
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_wait(event, dtfrm) {
  /* initialize */
  dtfrm.init_inputVal();
  dtfrm.init_selectIndex('wait', false);
  dtfrm.switchValueSelectDisplay('0');
  
  var array = g_labelNumList.toString(10).split(',');
  dtfrm.document.getElementById('jump_select').refresh(array, "0",null,false);
  dtfrm.document.getElementById('time_out').refresh(g_timeOutVal, "0.0", "327.67", false);
  dtfrm.document.getElementById('time_out_detail').classList.remove("show");
  dtfrm.document.getElementById('time_out_detail').classList.add("hidden");
  
  var param = param_combineCheck('', split_param_wait(g_program_data[activeTarget].param));
  var selChk = radio_wait_selectCheck(param);
  if ((g_program_data[activeTarget] != undefined) && (g_program_data[activeTarget].param !== "")) {
    if (selChk === WAIT_COND_TIME) {
      dtfrm.document.getElementById('wait_sec').refresh(g_program_data[activeTarget].param.replace(/\(sec\)|sec/g, ""), "0.0", "327.67", false);
      dtfrm.init_selectIndex('wait', true);
      dtfrm.document.getElementById('time_out_option').refresh(null, "2", true);
      dtfrm.document.getElementById('conditionValue').refresh("1sec", 255, true);
    }
    else if (selChk === WAIT_COND_SEL) {
      if(set_detail_condParam_wait(param)) {
        dtfrm.document.getElementById('wait_sec').refresh("0.0", "0.0", "327.67", true);
        dtfrm.document.getElementById('conditionValue').refresh("1sec", 255, true);
      }
      else {
        selChk = WAIT_COND_DIRECT;
        dtfrm.document.getElementById('wait_sec').refresh("0.0", "0.0", "327.67", true);
        dtfrm.init_selectIndex('wait', true);
        dtfrm.document.getElementById('time_out_option').refresh(null, "2", true);
        dtfrm.document.getElementById('conditionValue').refresh(langConvEng(g_program_data[activeTarget].param), 255, false);
      }
    }
    else {
      dtfrm.document.getElementById('wait_sec').refresh("0.0", "0.0", "327.67", true);
      dtfrm.init_selectIndex('wait', true);
      dtfrm.document.getElementById('time_out_option').refresh(null, "2", true);
      dtfrm.document.getElementById('conditionValue').refresh(langConvEng(g_program_data[activeTarget].param), 255, false);
    }
  }
  dtfrm.adjustConstTextBoxMarginLeft();
  dtfrm.adjustRadioBtn3MarginTop();
  dtfrm.document.getElementById('time_sel').refresh(null, selChk, false);

  return true;
}

/*
 =========================================================================
 @function name   : detail_load_if
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_if(event, dtfrm) {
  /* initialize */
  dtfrm.init_inputVal();
  dtfrm.init_selectIndex('if', false);
  dtfrm.switchValueSelectDisplay('0');
  
  var param = param_combineCheck('', split_param_wait(g_program_data[activeTarget].param));
  var selChk = radio_if_selectCheck(param);
  if (g_program_data[activeTarget] != undefined) {
    if(selChk === IF_COND_SEL) {
      if(set_detail_condParam_if(param)) {
        dtfrm.document.getElementById('conditionValue').refresh("", 255, true);
      }
      else {
        selChk = IF_COND_DIRECT;
        dtfrm.init_selectIndex('if', true);
        dtfrm.document.getElementById('conditionValue').refresh(langConvEng(g_program_data[activeTarget].param), 255, false);
      }
    }
    else if(selChk === IF_COND_DIRECT) {
      dtfrm.init_selectIndex('if', true);
      dtfrm.document.getElementById('conditionValue').refresh(langConvEng(g_program_data[activeTarget].param), 255, false);
    }
    else {
    }
  }
  dtfrm.document.getElementById('if_list').refresh(null, selChk, false);

  return true;
}

/*
 =========================================================================
 @function name   : detail_load_regi
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_regi(event, dtfrm) {
  /* initialize */
  dtfrm.init_inputVal();
  
  var param = param_combineCheck('=', split_param(g_program_data[activeTarget].param));
  var selChk = radio_regi_selectCheck(param);
  dtfrm.document.getElementById('regi_list').refresh(null, selChk, false);

  if(selChk === REGI_COND_SEL) {
    dtfrm.init_selectIndex(true);
    /* Set parameters. */
    set_regi_condParam(param);
    /* Initialize the direct input section. */
    dtfrm.document.getElementById('regi').refresh("0", 255, true);
    dtfrm.document.getElementById('regi_val').refresh("0", 255, true);
  }
  else if(selChk === REGI_COND_DIRECT) {
    /* Initialize the selection method. */
    dtfrm.init_selectIndex(true);
    dtfrm.show_constarea(dtfrm.SHOW_CONSTAREA);
    /* Set parameters. */
    var regiStr = new RegExp('^(' + ORDER_REGI + '|R)\\[|\\]$', 'g');
    dtfrm.document.getElementById('regi').refresh(langConvEng(param[0].replace(regiStr, '')), 255, false);
    dtfrm.document.getElementById('regi_val').refresh(langConvEng(param[1] != ' ' ? param[1] : '0'), 255, false);
  }
  else {
  }

  return true;
}

/*
 =========================================================================
 @function name    : param_combineCheck
 @argument[cmbStr] : 
 @argument[param]  : 
 @description      : 
 @return           : 
 =========================================================================
*/
function param_combineCheck(cmbStr, param) {
  /* left side. */
  var ifOpt = (g_program_data[activeTarget].baseId == 'iflead') ? (!(isIntegerRealNumber(param[0].replace(/(^\(|\)$)/g, ''))) && (param[0] != ORDER_ON) && (param[0] != ORDER_OFF)) : true;
  if(param[0].match(/\]$/) == null && ifOpt) {
    /* Combine them because they are split in the comment. */
    while(1) {
      if(param[1] == undefined) break;
      param[0] += cmbStr + param[1];
      param.splice(1, 1);
      if(param[0].match(/\]$/)) {
        break;
      }
    }
  }

  /* right side. */
  if(cmbStr != '') {
    if(param.length > 2) {
      /* Combine them because they are split in the comment. */
      while(1) {
        if(param[2] == undefined) break;
        param[1] += cmbStr + param[2];
        param.splice(2, 1);
      }
    }
  }
  else {
    if(param.length > 3) {
      /* Combine them because they are split in the comment. */
      while(1) {
        if(param[3] == undefined) break;
        param[2] += cmbStr + param[3];
        param.splice(3, 1);
      }
    }
  }

  return param;
}

/*
 =========================================================================
 @function name   : detail_load_vsnline
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_vsnline(event, dtfrm) {
  var selType = "";
  detail_load_straight(event, dtfrm);
  dtfrm.document.getElementById('accordionSet').classList.remove('position-folding-bg-desc');
  dtfrm.document.getElementById('accordionSet').classList.add('position-folding-bg-asc');
  dtfrm.document.getElementById('accordionSetOpen').classList.add('hide');
  
  for(var cnt in dtfrm.VRIndirectOrder) {
    dtfrm.VRIndirectOrder[cnt][4] = '0';
  }
  
  var voffsetVRStr = ORDER_VOFFSET + ',' + ORDER_VR;
  var indirect = null;
  var vrChk = g_program_data[activeTarget].addMotion.find(function(data) {
    return data.indexOf(voffsetVRStr) != -1;
  });
  if(vrChk){
    var replaceStr = new RegExp('(' + voffsetVRStr + '\\[|\\]$)', 'g');
    var vrPrm = vrChk.replace(replaceStr, '');
    var rStr = new RegExp(ORDER_REGI + '\\[');
    var arStr = new RegExp(ORDER_ARGUMENT + '\\[');
    if(vrPrm.match(arStr)) {
      indirect = vrPrm.replace(arStr, '').replace(/\]$/, '');
      vrPrm = dtfrm.POS_VREG_INDIRECT_AR;
    }
    else if(vrPrm.match(rStr)) {
      indirect = vrPrm.replace(rStr, '').replace(/\]$/, '');
      vrPrm = dtfrm.POS_VREG_INDIRECT_R;
    }
    voffsetArg.vreg = vrPrm;
  } else {
    voffsetArg.vreg = dtfrm.POS_VREG_UNDEFINE;
  }
  selType = voffsetArg.vreg === dtfrm.POS_VREG_UNDEFINE ? dtfrm.POS_VREG_UNDEFINE : "0";
  top.IHMIComponents.cf.turnOnOffClass(dtfrm.document.getElementById("savedNo"), 'hide', voffsetArg.vreg === dtfrm.POS_VREG_UNDEFINE);
  dtfrm.document.getElementById('selType').refresh(null, selType, false);
  dtfrm.getRegisterInfo(voffsetArg.vreg, indirect);

  return true;
}

/*
 =========================================================================
 @function name   : detail_load_vsnjoint
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_vsnjoint(event, dtfrm) {
  var selType = "";
  detail_load_kakujiku(event, dtfrm);
  dtfrm.document.getElementById('accordionSet').classList.remove('position-folding-bg-desc');
  dtfrm.document.getElementById('accordionSet').classList.add('position-folding-bg-asc');
  dtfrm.document.getElementById('accordionSetOpen').classList.add('hide');
  
  for(var cnt in dtfrm.VRIndirectOrder) {
    dtfrm.VRIndirectOrder[cnt][4] = '0';
  }
  
  var indirect = null;
  var voffsetVRStr = ORDER_VOFFSET + ',' + ORDER_VR;
  var vrChk = g_program_data[activeTarget].addMotion.find(function(data) {
    return data.indexOf(voffsetVRStr) != -1;
  });
  if(vrChk){
    var replaceStr = new RegExp('(' + voffsetVRStr + '\\[|\\]$)', 'g');
    var vrPrm = vrChk.replace(replaceStr, '');
    var rStr = new RegExp(ORDER_REGI + '\\[');
    var arStr = new RegExp(ORDER_ARGUMENT + '\\[');
    if(vrPrm.match(arStr)) {
      indirect = vrPrm.replace(arStr, '').replace(/\]$/, '');
      vrPrm = dtfrm.POS_VREG_INDIRECT_AR;
    }
    else if(vrPrm.match(rStr)) {
      indirect = vrPrm.replace(rStr, '').replace(/\]$/, '');
      vrPrm = dtfrm.POS_VREG_INDIRECT_R;
    }
    voffsetArg.vreg = vrPrm;
  } else {
    voffsetArg.vreg = dtfrm.POS_VREG_UNDEFINE;
  }
  selType = voffsetArg.vreg === dtfrm.POS_VREG_UNDEFINE ? dtfrm.POS_VREG_UNDEFINE : "0";
  top.IHMIComponents.cf.turnOnOffClass(dtfrm.document.getElementById("savedNo"), 'hide', voffsetArg.vreg === dtfrm.POS_VREG_UNDEFINE);
  dtfrm.document.getElementById('selType').refresh(null, selType, false);
  dtfrm.getRegisterInfo(voffsetArg.vreg, indirect);

  return true;
}

/*
 =========================================================================
 @function name   : detail_load_weldstartml
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_weldstartml(event, dtfrm) {
  detail_load_straight(event, dtfrm);
  var weldArgs = [];
  var delStr = new RegExp('(^' + ORDER_WELDSTART + '\\[|\\]$)', 'g');
  var chkStr = new RegExp('(' + ORDER_REGI + '\\[(?<regiValue>\\d+|\\.\\.\\.)\\]|(?<directValue>\\d+(?:\\.\\d+)?|\\.\\.\\.))(?<units>[\\w%]+)?');

  var params = g_program_data[activeTarget].addMotion.slice();
  for(var i in params){
    if(params[i].indexOf(ORDER_WELDSTART) != -1){
      var replaceResult = params[i].replace(delStr, '');
      var splitResult = replaceResult.split(',');
      for(var i = 0; i < splitResult.length; i++){
        var matchResult = splitResult[i].match(chkStr);
        var argObj = {};
        argObj.regi = matchResult.groups.regiValue ? true: false;
        argObj.value = matchResult.groups.regiValue ? matchResult.groups.regiValue : matchResult.groups.directValue;
        argObj.value = (argObj.value == '...') ? '' : argObj.value;
        argObj.units = matchResult.groups.units ? matchResult.groups.units : '';
        weldArgs.push(argObj);
      }
    }
  }
  dtfrm.initDisp(weldArgs);

  return true;
}

/*
 =========================================================================
 @function name   : detail_load_weldstopml
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_weldstopml(event, dtfrm) {
  detail_load_straight(event, dtfrm);
  var weldArgs = [];
  var delStr = new RegExp('(^' + ORDER_WELDSTART + '\\[|\\]$)', 'g');
  var chkStr = new RegExp('(' + ORDER_REGI + '\\[(?<regiValue>\\d+|\\.\\.\\.)\\]|(?<directValue>\\d+(?:\\.\\d+)?|\\.\\.\\.))(?<units>[\\w%]+)?');
  var chkWidStr = new RegExp(/WID:[\d]*/, 'g');
  var wIdTxtBoxDisabled = (activeTarget.indexOf('_fav') != -1) ? true: false;
  if (activeTarget.indexOf('_fav') != -1) {
    g_program_data[activeTarget].addMotion[0] = g_program_data[activeTarget].addMotion[0].replace(chkWidStr, 'WID:0');
  }  
  var params = g_program_data[activeTarget].addMotion.slice();
  for(var i in params){
    if(params[i].indexOf(ORDER_WELDEND) != -1){
      var replaceResult = params[i].replace(delStr, '');
      var splitResult = replaceResult.split(',');
      for(var i = 0; i < splitResult.length; i++){
        var matchResult = splitResult[i].match(chkStr);
        var argObj = {};
        argObj.regi = matchResult.groups.regiValue ? true: false;
        argObj.value = matchResult.groups.regiValue ? matchResult.groups.regiValue : matchResult.groups.directValue;
        argObj.value = (argObj.value == '...') ? '' : argObj.value;
        argObj.units = matchResult.groups.units ? matchResult.groups.units : '';
        if (splitResult[i].match(chkWidStr)) {
          argObj.txtBoxDisabled = wIdTxtBoxDisabled;
        }
        weldArgs.push(argObj);
      }
    }
  }
  dtfrm.initDisp(weldArgs);

  return true;
}

/*
 =========================================================================
 @function name   : detail_load_weldstartal
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_weldstartal(event, dtfrm) {
  var weldArgs = [];
  var delStr = new RegExp('(^' + ORDER_WELDSTART + '\\[|\\]$)', 'g');
  var chkStr = new RegExp('(' + ORDER_REGI + '\\[(?<regiValue>\\d+|\\.\\.\\.)\\]|(?<directValue>\\d+(?:\\.\\d+)?|\\.\\.\\.))(?<units>[\\w%]+)?')

  var params = split_OptionParam();
  for(var i in params){
    if(params[i].indexOf(ORDER_WELDSTART) != -1){
      var replaceResult = params[i].replace(delStr, '');
      var splitResult = replaceResult.split(',');
      /* If it is entered directly, it will appear unselected. */
      if(splitResult.length != 2) splitResult = ['...','...'];
      for(var i = 0; i < splitResult.length; i++){
        var matchResult = splitResult[i].match(chkStr);
        var argObj = {};
        argObj.regi = matchResult.groups.regiValue ? true: false;
        argObj.value = matchResult.groups.regiValue ? matchResult.groups.regiValue : matchResult.groups.directValue;
        argObj.value = (argObj.value == '...') ? '' : argObj.value;
        argObj.units = matchResult.groups.units ? matchResult.groups.units : '';
        weldArgs.push(argObj);
      }
    }
  }
  dtfrm.initDisp(weldArgs);

  return true;
}

/*
 =========================================================================
 @function name   : detail_load_weldstopal
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_weldstopal(event, dtfrm) {
  var weldArgs = [];
  var delStr = new RegExp('(^' + ORDER_WELDEND + '\\[|\\]$)', 'g');
  var chkStr = new RegExp('(' + ORDER_REGI + '\\[(?<regiValue>\\d+|\\.\\.\\.)\\]|(?<directValue>\\d+(?:\\.\\d+)?|\\.\\.\\.))(?<units>[\\w%]+)?')
  var chkNum = new RegExp('/^-?[0-9]+\\.[0-9]+$/');
  var chkWidStr = new RegExp(/WID:[\d]*/, 'g');
  var wIdTxtBoxDisabled = (activeTarget.indexOf('_fav') != -1) ? true: false;
  if (activeTarget.indexOf('_fav') != -1) {
    g_program_data[activeTarget].param = g_program_data[activeTarget].param.replace(chkWidStr, 'WID:0');
  }
  var params = split_OptionParam();
  for(var i in params){
    if(params[i].indexOf(ORDER_WELDEND) != -1){
      var replaceResult = params[i].replace(delStr, '');
      var splitResult = replaceResult.split(',');
      /* If it is entered directly, it will appear unselected. */
      if(splitResult[1].match(chkNum)) splitResult = ['...','...'];
      for(var i = 0; i < splitResult.length; i++){
        var matchResult = splitResult[i].match(chkStr);
        var argObj = {};
        argObj.regi = matchResult.groups.regiValue ? true: false;
        argObj.value = matchResult.groups.regiValue ? matchResult.groups.regiValue : matchResult.groups.directValue;
        argObj.value = (argObj.value == '...') ? '' : argObj.value;
        argObj.units = matchResult.groups.units ? matchResult.groups.units : '';
        if (splitResult[i].match(chkWidStr)) {
          argObj.txtBoxDisabled = wIdTxtBoxDisabled;
        }
        weldArgs.push(argObj);
      }
    }
  }
  dtfrm.initDisp(weldArgs);

  return true;
}

/*
 =========================================================================
 @function name   : detail_load_sensoron
 @argument[dtfrm] : 
 @description     : 
 @return          : none
 =========================================================================
*/
function detail_load_sensoron(event, dtfrm) {
  var sensorArgs = [];
  var delStr = new RegExp('(^' + ORDER_SENSOR + ' ON' + '\\[|\\]$)', 'g');

  var replaceResult = g_program_data[activeTarget].param.replace(delStr, '');
  var splitResult = replaceResult.split(',');
  for (var i = 0; i < splitResult.length; i++) {
    var arg = (['...', '*'].includes(splitResult[i])) ? '0' : splitResult[i];
    sensorArgs.push(arg);
  }

  dtfrm.initDisp(sensorArgs);
  return true;
}

/*
 =========================================================================
 @function name   : detail_load_sensoroff
 @argument[dtfrm] : 
 @description     : 
 @return          : none
 =========================================================================
*/
function detail_load_sensoroff(event, dtfrm) {
  var sensorArgs = [];
  var delStr = new RegExp('(^' + ORDER_SENSOR + ' OFF' + '\\[|\\]$)', 'g');

  var replaceResult = g_program_data[activeTarget].param.replace(delStr, '');
  var splitResult = replaceResult.split(',');
  for (var i = 0; i < splitResult.length; i++) {
    var arg = (['...', '*'].includes(splitResult[i])) ? '0' : splitResult[i];
    sensorArgs.push(arg);
  }

  dtfrm.initDisp(sensorArgs);
  return true;
}

/*
 =========================================================================
 @function name   : detail_load_searchon
 @argument[dtfrm] : 
 @description     : 
 @return          : none
 =========================================================================
*/
function detail_load_searchon(event, dtfrm) {
  var searchArgs = [];
  var delStr = new RegExp('(^' + ORDER_SEARCH + ' ON' + '\\[|\\]$)', 'g');

  var replaceResult = g_program_data[activeTarget].param.replace(delStr, '');
  var splitResult = replaceResult.split(',');
  for (var i = 0; i < splitResult.length; i++) {
    var arg = (['...', '*'].includes(splitResult[i])) ? '0' : splitResult[i];
    searchArgs.push(arg);
  }

  dtfrm.initDisp(searchArgs);
  return true;
}

/*
 =========================================================================
 @function name   : detail_load_detectjoint
 @argument[dtfrm] : 
 @description     : 
 @return          : none
 =========================================================================
*/
function detail_load_detectjoint(event, dtfrm) {
  var detectArgs = [];
  var delStr = new RegExp('(^' + ORDER_DETECT_JOINT + '\\[|\\]$)', 'g');

  var replaceResult = g_program_data[activeTarget].param.replace(delStr, '');
  var splitResult = replaceResult.split(',');
  for (var i = 0; i < splitResult.length; i++) {
    var arg = (['...', '*'].includes(splitResult[i])) ? '0' : splitResult[i];
    detectArgs.push(arg);
  }
  dtfrm.initDisp(detectArgs);
  return true;
}

/*
 =========================================================================
 @function name   : detail_load_trackdpm
 @argument[dtfrm] : 
 @description     : 
 @return          : none
 =========================================================================
*/
function detail_load_trackdpm(event, dtfrm) {
  var trackArgs = {};
  var delStr = new RegExp('(^' + ORDER_TRACK_DPM + '\\[|\\]$)', 'g');
  var chkStr = new RegExp('(' + ORDER_REGI + '\\[(?<regiValue>\\d+|\\.\\.\\.)\\]|(?<directValue>\\d+|\\.\\.\\.))')

  var replaceResult = g_program_data[activeTarget].param.replace(delStr, '');
  var matchResult = replaceResult.match(chkStr);
  
  trackArgs.isRegi = matchResult.groups.regiValue ? true : false;
  trackArgs.value = trackArgs.isRegi ? matchResult.groups.regiValue : matchResult.groups.directValue;
  trackArgs.value = (trackArgs.value == '...') ? '0' : trackArgs.value;

  dtfrm.initDisp(trackArgs);
  return true;
}

/*
 =========================================================================
 @function name   : detail_load_trackend
 @argument[dtfrm] : 
 @description     : 
 @return          : none
 =========================================================================
*/
function detail_load_trackend(event, dtfrm) {
  dtfrm.initDisp();
  return true;
}

/*
 =========================================================================
 @function name   : detail_load_laserpre
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_laserpre(event, dtfrm) {
  var loadparam;
  switch(g_program_data[activeTarget].baseId) {
    case 'laserpre':
      detail_load_straight(event, dtfrm);
      loadparam = g_program_data[activeTarget].addMotion;
      break;
    case 'laserkpre':
      detail_load_kakujiku(event, dtfrm);
      loadparam = g_program_data[activeTarget].addMotion;
      break;
    case 'laserpresi':
    default:
      loadparam = g_program_data[activeTarget].param;
      break;
  }
  /* Initialize the active tab. */
  dtfrm.select_tab(1);

  detail_laser_load(dtfrm, g_program_data[activeTarget].baseId, loadparam);

  return true;
}

/*
 =========================================================================
 @function name   : detail_load_laserls
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_laserls(event, dtfrm) {
  var loadparam;
  switch(g_program_data[activeTarget].baseId) {
    case 'laserls':
    case 'lasercals':
    case 'lasersls':
      detail_load_straight(event, dtfrm);
      loadparam = g_program_data[activeTarget].addMotion;
      break;
    case 'laserkls':
      detail_load_kakujiku(event, dtfrm);
      loadparam = g_program_data[activeTarget].addMotion;
      break;
    case 'lasercls':
      detail_load_circular(event, dtfrm);
      loadparam = g_program_data[activeTarget].addMotion;
      break;
    case 'laserlssi':
    default:
      loadparam = g_program_data[activeTarget].param;
      break;
  }
  /* Initialize the active tab. */
  dtfrm.select_tab(1);

  detail_laser_load(dtfrm, g_program_data[activeTarget].baseId, loadparam);

  return true;
}

/*
 =========================================================================
 @function name   : detail_load_laserle
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_laserle(event, dtfrm) {
  var loadparam;
  switch(g_program_data[activeTarget].baseId) {
    case 'laserle':
    case 'lasercale':
    case 'lasersle':
      detail_load_straight(event, dtfrm);
      loadparam = g_program_data[activeTarget].addMotion;
      break;
    case 'laserkle':
      detail_load_kakujiku(event, dtfrm);
      loadparam = g_program_data[activeTarget].addMotion;
      break;
    case 'lasercle':
      detail_load_circular(event, dtfrm);
      loadparam = g_program_data[activeTarget].addMotion;
      break;
    case 'laserlesi':
    default:
      loadparam = g_program_data[activeTarget].param;
      break;
  }
  /* Initialize the active tab. */
  dtfrm.select_tab(1);

  detail_laser_load(dtfrm, g_program_data[activeTarget].baseId, loadparam);

  return true;
}

/*
 =========================================================================
 @function name   : detail_load_laserpow
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_laserpow(event, dtfrm) {
  detail_laser_load(dtfrm, g_program_data[activeTarget].baseId, g_program_data[activeTarget].param);

  return true;
}

/*
 =========================================================================
 @function name   : detail_load_laserwirc
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_laserwirc(event, dtfrm) {
  detail_laser_load(dtfrm, g_program_data[activeTarget].baseId, g_program_data[activeTarget].param);

  return true;
}

/*
 =========================================================================
 @function name   : detail_load_adinst
 @argument[dtfrm] : Frame on the detail screen.
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_load_adinst(event, dtfrm) {
  var instObj = g_inst_obj[g_program_data[activeTarget].baseId];
  /*colonMatch = Matches colon other than in single quotes*/
  var colonMatch = /:(?=([^']*'[^']*')*[^']*$)/;
  if (g_program_data[activeTarget].param != "") {
    var params = split_param_call(g_program_data[activeTarget].param);
    if (params[0] == "") {
      var param = "";
    } else {
      var param = params[0].trim();
      if(param.match(colonMatch)){
        param = commentParse(param);
      }
    }
    if (params[1] === undefined) {
      params[1] = "";
    } else {
      params[1] = langConvEng(adinstArg_rmvParen(params[1]));
      if(params[1].match(colonMatch)){
        params[1] = commentParse(params[1]);
      }
    }
    var drawFunc = instObj.detail.disp;

    if (stretch_idStrChk(STRETCH_ID_CHK_LEAD, activeTarget)) {
      var endParams = split_param_call(g_program_data[get_stretch_pairId(activeTarget, REQ_ID_KIND_END, null)].param);
      if (endParams[1] === undefined) {
        endParams[1] = "";
      } else {
        endParams[1] = langConvEng(adinstArg_rmvParen(endParams[1]));
        if(endParams[1].match(colonMatch)){
          endParams[1] = commentParse(endParams[1]);
        }
      }
      var drawPrams = langConvEng(endParams[1]);
      var bkflg = true;
    } else {
      var bkflg = false;
      var drawPrams = langConvEng(params[1]);

    }
    if(drawPrams.match(colonMatch)){
      drawPrams = commentParse(drawPrams);
    }
    var robotPos = $('#' + get_detail_frm_id(activeTarget)).contents().find(".position");
    var fixedProgInfo = {progName: current_prog_name, lRegNums: g_config['localReg'].slice()};
    for (var robotpos_cnt = 0; robotpos_cnt < robotPos.length; robotpos_cnt++) {
      dtfrm.document.getElementById(robotPos[robotpos_cnt].id).setPrgInfoCallback(getProgInfo_forComp, fixedProgInfo, notifyComponentPosEdit);
    }
    if ((drawFunc !== undefined && drawFunc != "")) {
      if (bkflg) {
        if (!(eval("dtfrm." + drawFunc + "([\"" + params[1] + "\",\"" + endParams[1] + "\"])"))) {
          errPopUp(g_program_data[activeTarget].baseId + langResource.ihmieditor_pop_adinstructionnotfile_c + "<br>" + langResource.ihmieditor_pop_errorcode_c + "[I501]<br>" + langResource.ihmieditor_pop_moveprglist_c);
        }
      } else {
        if (!(eval("dtfrm." + drawFunc + "(\"" + drawPrams + "\")"))) {
          errPopUp(g_program_data[activeTarget].baseId + langResource.ihmieditor_pop_adinstructionnotfile_c + "<br>" + langResource.ihmieditor_pop_errorcode_c + "[I501]<br>" + langResource.ihmieditor_pop_moveprglist_c);
        }
      }

    }
  }

  return true;
}

/*
 =========================================================================
 @function name  : adinstArg_rmvParen
 @argument[str]  : String to remove parentheses.
 @description    : Remove parentheses from argument numbers.
 @return         : String with parentheses removed.
 =========================================================================
*/
function adinstArg_rmvParen(str) {
  /* Split a string. */
  var arg = str.split(/\,/);
  var retstr = '';

  for(var cnt = 0; cnt < arg.length; cnt++) {
    if(cnt != 0) retstr += ',';
    /* Parameter is string. */
    if(arg[cnt].match(/^\'/)) {
      /* No termination exists. */
      if(arg[cnt].match(/\'$/) == null) {
        /* Combine strings. */
        for(var cmbcnt = cnt; cmbcnt < arg.length; cmbcnt++) {
          if(typeof arg[cnt + 1] != 'undefined') {
            arg[cnt] = arg[cnt] + ',' + arg[cnt + 1];
            arg.splice(cnt + 1, 1);
            /* Joining is completed to the end. */
            if(arg[cnt].match(/\'$/)) break;
          }
        }
      }
      retstr += arg[cnt];
    }
    else {
      retstr += arg[cnt].replace(/(\(|\))/g, '');
    }
  }

  return retstr;
}

/*
 =========================================================================
 @function name  : setInstParam
 @argument       : str
 @description    : Confirm button processing
 @return         : none
 =========================================================================
*/
function setInstParam(str) {
  /* Bracket end side processing is incomplete. */
  if(setEndParamPos.endId != '') {
    setEndParamPos.func = setInstParam;
    setEndParamPos.arg = [str];
    return false;
  }

  g_adin_state.setInstTempFlg = false;
  var setActive = (g_adintarget != "") ? g_adintarget : activeTarget;
  if(setActive == '') return;
  var record_data = {
    id: "",
    lineNum: g_program_data[setActive].array_num + 1,
    contents: g_program_data[setActive],
    param1: {},
    param2: {},
    elem: ""
  }
  if (g_adin_state.setBracketArgFlg && g_adintarget == "") {
    g_adin_state.record[0] = {};
    $.extend(true, g_adin_state.record[0], record_data);
    $.extend(true, g_adin_state.record[0].param1, g_program_data[setActive]);
  } else {
    record_data.type = OPERATION_EDIT;
    $.extend(true, record_data.param1, g_program_data[setActive]);
  }
  
  need_position_save_flg = false;
  var instObj = g_inst_obj[g_program_data[setActive].baseId];
  
  if(g_program_data[setActive].option != undefined){
    var prms = str.split(',');
    if(prms[0].match(/[(]/)){
      var start = prms[0].indexOf('(');
      var end = prms[0].indexOf(')');
      prms[0] = prms[0].substring(start+1,end);
    }
    if(prms[0].match(/["]*[']*/g)){
      prms[0] = prms[0].replace(/["]*[']*/g, '');
    }
    if(g_program_data[setActive].option != prms[0]){
      var errMess = '[I127]';
      errMess = langResource.ihmieditor_pop_errorcode_c+errMess+"<br>";
      errPopUp(errMess+langResource.ihmieditor_pop_loaderr_c+"<br>"+langResource.ihmieditor_pop_moveprglist_c);
    }
  }
  var setParam = "";
  var setStr = str;
  if (setStr.trim() != "") {
    setStr = setLangConvJpEng("(" + setStr + ")");
  }
  setParam = instObj.detail.appName + setStr;
  if ((setParam !== null) && (setParam !== '')) {
    if (instObj.type == "posTeach" || instObj.type == "posBracket") {
      posNumChk(setActive,setStr);
    }
    /* Store in g_program_data */
    data_before_change = JSON.parse(JSON.stringify(g_program_data[setActive]));
    if (g_adintarget != "") {
      fixDropAdinDataSave_g_program(setParam);
      write_mode = EDIT_PRG_OPT_OVERWRITE;
      /* A sample program to add exists. */
      if(addProg.length != 0 && dropProgNum != ""){
        addSampleProgTp(setActive, true);
        dropProgNum = "";
        addProg = [];
      }else{
        del_unused_posno();
        dropSaveFlg = true;
        save_tporder(setActive, write_mode, save_tporder_callback, setActive);
      }
    } else {
      fixDataSave_g_program(setParam);
      if (g_adin_state.setBracketArgFlg) {
        $.extend(true, g_adin_state.record[0].param2, g_program_data[setActive]);
      } else {
        $.extend(true, record_data.param2, g_program_data[setActive]);
        timeline_record.array_add(record_data);
        check_undoredo_active();
        position_record.array_add(position);
        positionregi_record.array_add(g_position_regi);
      }
      
      write_mode = EDIT_PRG_OPT_OVERWRITE;
      del_unused_posno();
      dropSaveFlg = false;
      save_tporder(setActive, write_mode, save_tporder_callback, setActive);
    }
  }
  if (g_adintarget != "") {
    delete_detailhtml_addinst(g_adinDropList[0][0]);
    g_adinDropList.splice(0, 1);
  }

  if (typeof g_adinDropList[0] != "undefined") {
    create_detailhtml_addinst(g_adinDropList[0][2], g_adinDropList[0][0]);
    $('#adin_' + g_adinDropList[0][0]).on('load', evalFunctionCall);
    g_adintarget = g_adinDropList[0][0];
  } else {
    g_adintarget = "";
  }
}

/*
 =========================================================================
 @function name  : setInstParamWithCB
 @argument       : str
 @argument[callback]     : set a CallBack
 @argument[cbarg]        : set an argument of CallBack
 @description    : Confirm button processing
 @return         : none
 =========================================================================
*/
function setInstParamWithCB(str, callback, cbarg) {
  /* Bracket end side processing is incomplete. */
  if(setEndParamPos.endId != '') {
    /* Pending until end-side processing is complete. */
    setEndParamPos.func = setInstParamWithCB;
    setEndParamPos.arg = [str, callback, cbarg];
    /* Return true so that "failure" is not notified in the callback */
    return true;
  }

  g_adin_state.setInstTempFlg = false;
  var setActive = (g_adintarget != "") ? g_adintarget : activeTarget;
  if (setActive == '') return false;
  var record_data = {
    id: "",
    lineNum: g_program_data[setActive].array_num + 1,
    contents: g_program_data[setActive],
    param1: {},
    param2: {},
    elem: ""
  }
  if (g_adin_state.setBracketArgFlg && g_adintarget == "") {
    g_adin_state.record[0] = {};
    $.extend(true, g_adin_state.record[0], record_data);
    $.extend(true, g_adin_state.record[0].param1, g_program_data[setActive]);
  } else {
    record_data.type = OPERATION_EDIT;
    $.extend(true, record_data.param1, g_program_data[setActive]);
  }
  
  need_position_save_flg = false;
  var instObj = g_inst_obj[g_program_data[setActive].baseId];
  
  if(g_program_data[setActive].option != undefined){
    var prms = str.split(',');
    if(prms[0].match(/[(]/)){
      var start = prms[0].indexOf('(');
      var end = prms[0].indexOf(')');
      prms[0] = prms[0].substring(start+1,end);
    }
    if(prms[0].match(/["]*[']*/g)){
      prms[0] = prms[0].replace(/["]*[']*/g, '');
    }
    if(g_program_data[setActive].option != prms[0]){
      var errMess = '[I127]';
      errMess = langResource.ihmieditor_pop_errorcode_c+errMess+"<br>";
      errPopUp(errMess+langResource.ihmieditor_pop_loaderr_c+"<br>"+langResource.ihmieditor_pop_moveprglist_c);
    }
  }
  var setParam = "";
  var setStr = str;
  if (setStr.trim() != "") {
    setStr = setLangConvJpEng("(" + setStr + ")");
  }
  setParam = instObj.detail.appName + setStr;
  var isSaveTp = (setParam !== null) && (setParam !== '');
  if (isSaveTp) {
    if (instObj.type == "posTeach" || instObj.type == "posBracket") {
      posNumChk(setActive,setStr);
    }
    /* Store in g_program_data */
    data_before_change = JSON.parse(JSON.stringify(g_program_data[setActive]));
    if (g_adintarget != "") {
      fixDropAdinDataSave_g_program(setParam);
      write_mode = EDIT_PRG_OPT_OVERWRITE;
      if (addProg.length != 0 && dropProgNum != "") {
        addSampleProgTp(setActive, true);
        dropProgNum = "";
        addProg = [];
      }else{
        del_unused_posno();
        dropSaveFlg = true;
        var save_tporder_cbarg = {
          id: setActive,
          callback: callback,
          cbarg: cbarg
        };
        save_tporder(setActive, write_mode, save_tporder_callbackWithCB, save_tporder_cbarg);
      }
    } else {
      fixDataSave_g_program(setParam);
      if (g_adin_state.setBracketArgFlg) {
        $.extend(true, g_adin_state.record[0].param2, g_program_data[setActive]);
      } else {
        $.extend(true, record_data.param2, g_program_data[setActive]);
        timeline_record.array_add(record_data);
        check_undoredo_active();
        position_record.array_add(position);
        positionregi_record.array_add(g_position_regi);
      }
      
      write_mode = EDIT_PRG_OPT_OVERWRITE;
      del_unused_posno();
      dropSaveFlg = false;
      var save_tporder_cbarg = {
        id: setActive,
        callback: callback,
        cbarg: cbarg
      };
      save_tporder(setActive, write_mode, save_tporder_callbackWithCB, save_tporder_cbarg);
    }
  }
  if (g_adintarget != "") {
    delete_detailhtml_addinst(g_adinDropList[0][0]);
    g_adinDropList.splice(0, 1);
  }

  if (typeof g_adinDropList[0] != "undefined") {
    create_detailhtml_addinst(g_adinDropList[0][2], g_adinDropList[0][0]);
    $('#adin_' + g_adinDropList[0][0]).on('load', evalFunctionCall);
    g_adintarget = g_adinDropList[0][0];
  } else {
    g_adintarget = "";
  }
  return isSaveTp;
}
/*
 =========================================================================
 @function name  : setParamTemp
 @argument       : str
 @description    :
 @return         : none
 =========================================================================
*/
function setParamTemp(str) {
  /* Bracket end side processing is incomplete. */
  if(setEndParamPos.endId != '') {
    setEndParamPos.func = setParamTemp;
    setEndParamPos.arg = [str];
    return false;
  }

  g_adin_state.setInstTempFlg = true;
  var setActive = (g_adintarget != "") ? g_adintarget : activeTarget;
  var record_data = {
    id: "",
    lineNum: g_program_data[setActive].array_num + 1,
    contents: g_program_data[setActive],
    param1: {},
    param2: {},
    elem: "",
    type: OPERATION_EDIT
  }
  $.extend(true, record_data.param1, g_program_data[setActive]);
  need_position_save_flg = false;
  var instObj = g_inst_obj[g_program_data[setActive].baseId];
  
  if(g_program_data[setActive].option != undefined){
    var prms = str.split(',');
    if(prms[0].match(/[(]/)){
      var start = prms[0].indexOf('(');
      var end = prms[0].indexOf(')');
      prms[0] = prms[0].substring(start+1,end);
    }
    if(prms[0].match(/["]*[']*/g)){
      prms[0] = prms[0].replace(/["]*[']*/g, '');
    }
    if(g_program_data[setActive].option != prms[0]){
      var errMess = '[I127]';
      errMess = langResource.ihmieditor_pop_errorcode_c+errMess+"<br>";
      errPopUp(errMess+langResource.ihmieditor_pop_loaderr_c+"<br>"+langResource.ihmieditor_pop_moveprglist_c);
    }
  }
  var setParam = "";
  var setStr = str;
  if (setStr.trim() != "") {
    setStr = setLangConvJpEng("(" + setStr + ")");
  }
  setParam = instObj.detail.appName + setStr;
  if ((setParam !== null) && (setParam !== '')) {
    if (instObj.type == "posTeach" || instObj.type == "posBracket") {
      posNumChk(setActive,setStr);
    }
    /* Store in g_program_data */
    data_before_change = JSON.parse(JSON.stringify(g_program_data[setActive]));
    if (g_adintarget != "" && dropSaveFlg) {
      fixDropAdinDataSave_g_program(setParam);
      write_mode = EDIT_PRG_OPT_OVERWRITE;
      if(addProg.length != 0 && dropProgNum != ""){
        addSampleProgTp(setActive,true);
        dropProgNum = "";
        addProg = [];
      }else{
        del_unused_posno();
        save_tporder(setActive, write_mode, save_tporder_callback, setActive);
        
      }
      dropSaveFlg = false;
    } else {
      fixDropAdinDataSave_g_program(setParam);
      if(g_program_data[setActive].position.length > 0){
        updatePosTeach(setActive);
      }
      position_record.array_overwrite(position);
      positionregi_record.array_overwrite(g_position_regi);
      save_tporder(setActive, write_mode, save_tporder_callback, setActive);
    }
  }
}

/*
 =========================================================================
 @function name     : setDropEnd
 @argument          : end dropFunction
 @description       : 
 @return            : 
 =========================================================================
*/
function setDropEnd() {
  if (g_adin_state.adinstAttachedFlg || save_id_array.length > 0 || addProg.length > 0 || setEndParamPos.endId != '') {
    watchDropEndEvent();
    return;
  }
  g_adin_state.setInstTempFlg = false;
  if (g_adin_state.adinstAttachedFlg) {
    addprgRecord();
  }
  if (g_adintarget != "") {
    delete_detailhtml_addinst(g_adinDropList[0][0]);
    g_adinDropList.splice(0, 1);
  }
  if (typeof g_adinDropList[0] != "undefined") {
    create_detailhtml_addinst(g_adinDropList[0][2], g_adinDropList[0][0]);
    $('#adin_' + g_adinDropList[0][0]).on('load', evalFunctionCall);
    g_adintarget = g_adinDropList[0][0];
  } else {
    g_adintarget = "";
  }
  dispOffWaiting();
}
/*
 =========================================================================
 @function name   : getPosInfoList
 @argument[]      :
 @description     :
 @return          : posinfo list
 =========================================================================
*/
function getPosInfoList(id) {
  var posInfo = {
    flg: [],
    endFlg: []
  }
  if (chk_basicInstruction(g_program_data[id].baseId)) return posInfo;
  var tpName = id.startsWith("bktend") ?
    get_stretch_pairId(id, REQ_ID_KIND_LEAD, null).split(/[0-9]*$/)[0]
    : g_program_data[id].baseId;
  var xmlData = g_inst_obj[tpName];
  if (xmlData.detail.posinfo != "") posInfo.flg = xmlData.detail.posinfo.split(",");
  if (xmlData.end != undefined){
    if (xmlData.end.posinfo != "") posInfo.endFlg = xmlData.end.posinfo.split(",");
  }
  return posInfo;
}
/*
 =========================================================================
 @function name     : chkPosInfo
 @argument[elm]     : Element to add a position pin. (Specified only when generating icons.)
 @argument[param]   : Parameters for Advanced Instructions.
 @argument[id]      : ID of Advanced Instructions.
 @argument[posInfo] : Flag whether positional information can be displayed or not.
 @description       : check posInfoTag
 @return            : 
 =========================================================================
*/
function chkPosInfo(elm, param, id, posInfo) {
  /* type normal posInfoTag check */
  var leadIdChk = id.startsWith("bktlead");
  var endIdChk = id.startsWith("bktend");
  var posInfoCnt = 0;
  /* Not bracket instruction. */
  if (!leadIdChk && !endIdChk) {
    if (!posInfo.flg.length) return;
    setPosInfo(id, elm, param, posInfo.flg, posInfoCnt);
    return;
  }
  var startId = get_stretch_pairId(id, REQ_ID_KIND_LEAD, null);
  var startElm = (leadIdChk && elm) ? elm : document.getElementById(startId);
  var startPrm = (leadIdChk && elm) ? param : g_program_data[startId].param;
  posInfoCnt = setPosInfo(startId, startElm, startPrm, posInfo.flg, posInfoCnt);
  /* End instruction has position infomation. */
  if (posInfo.endFlg.length > 0) {
    var endId = get_stretch_pairId(id, REQ_ID_KIND_END, null);
    /* g_program does not exist at the timing of setting the pin on the start side when copying */
    if (g_program_data[endId] == undefined) return;
    var endElm = leadIdChk ? document.getElementById(endId) : elm;
    var endPrm = leadIdChk ? g_program_data[endId].param : param;
    /* Closed state. */
    if (g_program_data[startId].stretch.state == 'stretch_close') {
      /* Lead instruction position information is filled in and cannot be added. */
      if (posInfoCnt >= 4) return;
      /* Add a position pin for the End instruction to the Lead instruction icon. */
      setPosInfo(endId, startElm, endPrm, posInfo.endFlg, posInfoCnt);
    } else {
      /* Add a position pin for the End instruction. */
      posInfoCnt = 0;
      setPosInfo(endId, endElm, endPrm, posInfo.endFlg, posInfoCnt);
    }
  }
  return;
}
/*
 =========================================================================
 @function name     : posNumChk
 @argument          : 
 @description       : setPosTeach PIN & set poskind
 @return            : 
 =========================================================================
*/
function posNumChk(activeId, setStr) {
  var elm = document.getElementById(activeId);
  var posInfo = getPosInfoList(activeId);
  if (posInfo.flg.length > 0 || posInfo.endFlg.length > 0) {
    chkPosInfo(elm, setStr, activeId, posInfo);
    return;
  }
  /* default instruction*/ 
  if (setStr == null) {
    var posKind = [
      {kind:POSKIND_POSNUM,       key: 'posNumber'   },
      {kind:POSKIND_POSREGI,      key: 'posRegNum'   },
      {kind:POSKIND_POSREGI_REGI, key: 'posRegRegNum'},
      {kind:POSKIND_POSREGI_AR,   key: 'posRegArgNum'},
    ];
    $('#' + activeId).find('.posInfoNo').remove();
    $('#' + activeId).find('.posOmit').remove();
    var robotPos = $(document.getElementById(get_detail_frm_id(activeId))).contents().find(".position");
    for (var posNumCnt = 0; posNumCnt < g_program_data[activeId].position.length; posNumCnt++) {
      if (typeof robotPos[posNumCnt] != "undefined"){
        var pos_data = robotPos[posNumCnt].getPosInfoCurrentKind();
        g_program_data[activeId].position[posNumCnt].kind = pos_data.posKind;
        var kindChk = posKind.find(function(data) {
          return data.kind == pos_data.posKind;
        });
        if(kindChk) {
          g_program_data[activeId].position[posNumCnt].number = Number(pos_data[kindChk.key]);
          if(elm && g_program_data[activeId].position[posNumCnt].disp == 'ON') {
            addPosTriangle(elm, pos_data[kindChk.key], posNumCnt);
          }
        }
      }
    }
  /* High functionality instruction*/  
  } else {
    var posInfo = getPosInfoList(activeId);
    var posInfoCnt = 0;
    setPosInfo(activeId, elm, setStr, posInfo, posInfoCnt);
  }
}
/*
 =========================================================================
 @function name   : setPosInfo
 @argument[]      :
 @description     : add bracketEnd posTeach pin
 @return          :
 =========================================================================
*/
function setPosInfo(id, elm, param, posInfo, posInfoCnt){
  if (posInfo == undefined) posInfo = [];
  if (posInfoCnt == undefined) posInfoCnt = 0;
  if (posInfoCnt == 0) {
    $('#' + id).find('.posInfoNo').remove();
    $('#' + id).find('.posOmit').remove();
  }
  var posCnt = 0;
  var posRegStr = '^(' + ORDER_POSREGI + '|PR)\\[';
  var kindChk = [
    {matchStr: new RegExp(posRegStr + '(' + ORDER_REGI + '|R)\\['),      kind: POSKIND_POSREGI_REGI, defStr: 'PR[R[N' },
    {matchStr: new RegExp(posRegStr + '(' + ORDER_ARGUMENT + '|AR)\\['), kind: POSKIND_POSREGI_AR,   defStr: 'PR[AR[N'},
    {matchStr: new RegExp(posRegStr),                                    kind: POSKIND_POSREGI,      defStr: 'PR[N'   },
    {matchStr: new RegExp('^(' + ORDER_POS + '|P)\\['),                  kind: POSKIND_POSNUM,       defStr: 'P[N'    },
  ];
  var get_posnum = function(id, cnt, prm, chkstr) {
    /* Route where drop operation & undo & redo were performed */
    if (prm.startsWith(chkstr)) {
      var posnum = (g_program_data[id].position[cnt].number != 0) ? g_program_data[id].position[cnt].number :
                      (g_program_data[id].position[cnt].kind == POSKIND_POSNUM) ? posIndex_get() : 1;
    } else {
      var posnum = Number(prm.replace(/[^0-9]/g, ""));
    }
    return posnum;
  }
  var prm = commentParse(split_param_call(param)[1]).split(",");
  for (var prmCnt = 0; prmCnt < prm.length; prmCnt++) {
    if (posCheck(prm[prmCnt])) {
      if (g_program_data[id].position[posCnt] != undefined) {
        var posnum = 0;
        var chkResult = kindChk.find(function(data) {
          return prm[prmCnt].match(data.matchStr);
        });
        if(chkResult) {
          g_program_data[id].position[posCnt].kind = chkResult.kind;
          posnum = get_posnum(id, posCnt, prm[prmCnt], chkResult.defStr);
        }
        g_program_data[id].position[posCnt].number = posnum;
      }
      if ((!posInfo.length && id.startsWith("bktend")) ||
          (posInfo.length > 0 && posInfo[prmCnt] != "ON") ||
          (elm == null)) {
        posCnt++;
        continue;
      }
      if (g_program_data[id].position[posCnt].disp == 'ON' && posInfoCnt < 4) {
        addPosTriangle(elm, posnum, posCnt, id);
        posInfoCnt++;
      }
      posCnt++;
    }
  }
  return posInfoCnt;
}

/*
 =========================================================================
 @function name     : addInstructionPos
 @argument          : Sample programs value check
 @description       : 
 @return            : editPrg
 =========================================================================
*/
function addInstructionPos(addProg){
  var spaceMatch = /\s+(?![^\[]*\])/g;
  var commaMatch = /,(?=(?:[^']*'[^']*')*[^']*$)/g;
  var array_string = addProg.split(spaceMatch);

  var posnumReplace = function(chkstr) {
    var posRegStr = "(" + ORDER_POSREGI + "|PR)";
    var indirectStr = "(" + ORDER_REGI + "|" + ORDER_ARGUMENT + "|R|AR)";
    var posnum = (chkstr.match(new RegExp("(" + ORDER_POS + "|P)\\[N\\]"))) ? getMinPos() :
                   (chkstr.match(new RegExp(posRegStr + "\\[" + indirectStr + "\\[N\\]"))) ? "1" :
                     (chkstr.match(new RegExp(posRegStr + "\\[N\\]"))) ? getMinPosreg() : "";
    return posnum ? chkstr.replace("[N]", "[" + posnum + "]") : chkstr;
  };
  var nameCheck = function(refName, chkName) {
    return refName == chkName.substring(0, chkName.indexOf('(')) ||
           refName == chkName.substring(0, chkName.indexOf('(')).toUpperCase() ||
           refName == chkName;
  };

  if (array_string[0] != ORDER_LINE && array_string[0] != ORDER_JOINT && array_string[0] != ORDER_CURVE && array_string[0] != ORDER_CIRCLEARC && array_string[0] != ORDER_SPLINE &&
    array_string[0] != "L" && array_string[0] != "J" && array_string[0] != "C" && array_string[0] != "A" && array_string[0] != "S") {
    array_string[0] = " " + array_string[0];
  }
  for(var num = 0; num < array_string.length; num++) {
    if(array_string[num].indexOf("(") != -1) {
      var start = array_string[num].indexOf("(");
      var tpName = array_string[num].substr(0, start + 1);
      var param = array_string[num].substr(start + 1);
      var splitPrm = param.split(commaMatch);

      for(var i = 0; i < splitPrm.length; i++) {
        splitPrm[i] = posnumReplace(splitPrm[i]);
      }
      array_string[num] = tpName + splitPrm.join(",");
    } else {
      array_string[num] = posnumReplace(array_string[num]);
    }
    /* Check the program file list */
    var existChk = programFileList.find(function(data) {
      return nameCheck(data.name, array_string[num]);
    });
    if(existChk) {
      existChk = existChk.name;
    } else {
      /* Check the karel program file list */
      existChk = karelProgramFileList.find(function(data) {
        return nameCheck(data.name, array_string[num]);
      });
      if(existChk) {
        existChk = existChk.name;
      } else {
        /* Check the list of advanced function instructions. */
        existChk = Object.keys(g_xml_data).find(function(key) {
          var chkKeyStr = key.replace(/^(bktlead|bktend)/, '').toUpperCase();
          return nameCheck(chkKeyStr, array_string[num]);
        });
      }
    }
    if(existChk) {
      existChk = existChk.replace(/^(bktlead|bktend)/, '').toUpperCase();
      var cmbStr = array_string[num].replace(new RegExp('(^' + existChk + ')'), '');
    }
    array_string[num] = (!existChk) ? setLangConvJpEng(array_string[num]) : existChk + setLangConvJpEng(cmbStr);
  }
  var editProg = array_string.join(" ");
  posTemporary = [];
  posRegTemporary = [];
  return editProg;
}

/*
 =========================================================================
 @function name     : elmChangeCheck
 @argument[]        : 
 @description       : change elment advinst check
 @return            : 
 =========================================================================
*/
function elmChangeCheck(){
  var config = {childList: true};
  adinObservFlag = true;
  adinstObserver.observe(document.body, config);

}
/*
 =========================================================================
 @function name     : addInstructionbracket
 @argument[addProg] : Sample programs to add
 @description       : Receive a sample program to add. : Externally Called I/F
 @return            : none
 =========================================================================
*/

function addInstructionBracket(progList,dropNum,dropEndNum, dropFuncFlg) {
  setSampleProgInfo(progList,dropFuncFlg,dropNum,dropEndNum);
}
/*
 =========================================================================
 @function name     : addInstructionProg
 @argument[addProg] : Sample programs to add
 @description       : Receive a sample program to add. : Externally Called I/F
 @return            : none
 =========================================================================
*/
function addInstructionProg(progList,dropNum,dropFuncFlg) {
  setSampleProgInfo(progList,dropFuncFlg,dropNum);
}

/*
 =========================================================================
 @function name     : setSampleProgInfo
 @argument[addProg] : Sample programs to add
 @description       : Receive a sample program to add. : Externally Called I/F
 @return            : none
 =========================================================================
*/
function setSampleProgInfo(progList,dropFuncFlg,dropNum,dropEndNum) {
  var errMess = "";
  var numCheck = /^\d*$/;
  if(dropFuncFlg == true) {
    samplePrg_status.dropFunc = true;
  }
  if((typeof progList == "undefined") || (progList.length == 0) || 
     (typeof progList != "object") || (progList.length > MAX_SAMPLEPROG_LINE)) {
    errMess += '[I132]';
  }
  
  if(!numCheck.test(dropNum) || dropNum == 0 || 
     typeof dropNum == "undefined" || (progList != 0 && progList.length+1 < dropNum)) {
      errMess += '[I133]';
  }
  if(dropEndNum) {
    if(!numCheck.test(dropEndNum) || dropEndNum == 0 || typeof dropEndNum == "undefined" ||
      (progList != 0 && progList.length+2 < dropEndNum) || dropEndNum <= dropNum) {
        errMess += '[I134]';
    }
  }
  
  if(errMess) {
    errMess = langResource.ihmieditor_pop_errorcode_c+errMess+"<br>";
    errPopUp(errMess+langResource.ihmieditor_pop_loaderr_c+"<br>"+langResource.ihmieditor_pop_moveprglist_c);
    return;
  }
  addProg = progList.concat();
  dropProgNum = dropNum;
  if(dropEndNum) dropProgEndNum = dropEndNum;
}

/*
 =========================================================================
 @function name     : dispAddProgSave
 @argument[addProg] : Sample programs to add
 @description       : Receive a sample program to add. : Externally Called I/F
 @return            : none
 =========================================================================
*/
function dispAddProgSave(prg, dropFuncFlg){
  if(dropFuncFlg == true){
    samplePrg_status.dropFunc = true;
  }
  if(typeof prg == "object"){
    for(var i in prg){
      addProg.push(prg[i]);
    }
  }else if(typeof prg != "undefined"){
    addProg.push(prg);
  }
  dropProgNum = -1;
  if(addProg.length > 0 && activeTarget != ""){
    addSampleProgTp(activeTarget, false);
  }
}

/*
 =========================================================================
 @function name     : getAddPos
 @argument[addProg] : get robot position
 @description       :
 @return            : none
 =========================================================================
*/
function updatePosData(updatePosNum){
  if(typeof updatePosNum == "number"){
    var grpNum = 1;
    if(g_MTGData.savingTeachPosFlg){ /*End position teaching of EASYARC in case of HANDLETEACH*/
      updatePosCallBack(top.KXYZWPR, top.TXML_TP_REC_TYPE, grpNum, g_MTGData.teachPosData.cart, updatePosNum);
      return;
    }
    top.get_curpos(top.KXYZWPR, top.TXML_TP_REC_TYPE, grpNum, updatePosCallBack, updatePosNum);
  }
}
/*
 =========================================================================
 @function name     : updatePosCallBack
 @argument[addProg] : get robot position
 @description       : updatePosData callback
 @return            : none
 =========================================================================
*/
function updatePosCallBack(dataForm, posType, grpNum, posData, posNum){
  var cbArg = {};
  cbArg.tblKind = POSTBLKIND_REGS;
  cbArg.posNo = posNum;
  if(ufutSystemValues.length == 0){
    ufutSystemValues[0] = {grp: 1, UF: 0, UT: 1};
  }
  var posJson = analyzeCartesianPosition(posData);
  save_icon_position_cnt = 0;
  for (var i = 0; i < position.length; i++) {
    if (position[i].posNumber == cbArg.posNo) {
      positionNo = i;
      break;
    }
  }
  var posDataIdx = 0;
  for (var j = 0; j < position[positionNo].posData.length; j++) {
    if (position[positionNo].posData[j].groupNumber == grpNum) {
      posDataIdx = j;
      break;
    }
  }
  position[positionNo].posData[posDataIdx].poskey[0] = posJson.posData[posDataIdx].poskey[0];
  position[positionNo].posData[posDataIdx].poskey[1] = posJson.posData[posDataIdx].poskey[1];
  position[positionNo].posData[posDataIdx].poskey[2] = posJson.posData[posDataIdx].poskey[2];
  position[positionNo].posData[posDataIdx].poskey[3] = posJson.posData[posDataIdx].poskey[3];
  position[positionNo].posData[posDataIdx].poskey[4] = posJson.posData[posDataIdx].poskey[4];
  position[positionNo].posData[posDataIdx].poskey[5] = posJson.posData[posDataIdx].poskey[5];
  position[positionNo].posNumber = Number(cbArg.posNo);
  position[positionNo].Comment = posJson.Comment;
  position[positionNo].posData[posDataIdx].ufVal = posJson.posData[posDataIdx].ufVal;
  position[positionNo].posData[posDataIdx].utVal = posJson.posData[posDataIdx].utVal;
  position[positionNo].posData[posDataIdx].configStr = posJson.posData[posDataIdx].configStr;
  updatePositionObj(positionNo);
  save_posdata(positionNo, editPosCallback);
  addProg = [];

  if(activeTarget.toUpperCase().startsWith("-INST_ARC_HANDLE_TEACH")){
    var parentData = getNestPosition();
    if(parentData != false){
      for(var k in parentData){
        if(parentData[k].parentId.toUpperCase().startsWith("BKTLEAD-INST_EASYAW_START")){
          var endId = get_stretch_pairId(parentData[k].parentId, REQ_ID_KIND_END, null);
          var copyId = activeTarget;
          var record_data = {
            id: [copyId],
            contents: [g_program_data[copyId]],
            place1: g_program_data[copyId].array_num,
            place2: g_program_data[endId].array_num,
            type: OPERATION_SORT,
          }
          /* progInfo update */
          progInfo_update(endId, [copyId], true);
          
          order_nestChk(copyId);
          g_program_arrayNumSave();
          draw_TLscale(false);
          tl_adjust_dispRange();
          var pasteIndex = endId == 'TL_spacer' ? 0 : g_program_data[endId].array_num + 1;
          if(record_data.place2 > record_data.place1) {
            pasteIndex += record_data.contents.length;
          }
          var startIndex = record_data.place1 + 1;
          var endIndex = startIndex + record_data.contents.length - 1;
          save_id_array = [];
          save_id_array.push(copyId);
          save_pasteLine(startIndex, endIndex, pasteIndex, 1, save_pasteLine_callback, save_id_array[0]);
          
          timeline_record.array_add(record_data);
          check_undoredo_active();
          break;
        }
      }
    }
    /*Teaching positon saving start or end flag.(true:Teaching position saving now/false:Teaching position save completed)*/
    g_MTGData.savingTeachPosFlg = false;
  }
  position_record.array_add(position);
  positionregi_record.array_add(g_position_regi);
}

/*
 =========================================================================
 @function name           : addSampleProgTp
 @argument[addedId]       : Added instruction ID
 @argument[sampleProgFlg] : To be set when the sample program is added.
 @argument[prgLine]       : sample program add line. (from setTpOrder function)
 @argument[order_array]   : sample program array. (from setTpOrder function)
 @description             : When an instruction is added, the attached instruction is added.
 @return                  : none
 =========================================================================
*/

function addSampleProgTp(addedId, sampleProgFlg, prgLine, order_array) {
  var tmpId = '';
  var refElmId = addedId;
  var addProgArray = [];
  var scrlChk = false;
  var setTpOrderFlg = false;
  addProgId = [];
  save_id_array = [];
  addProgId.dropId = [];
  addProgId.endId = [];
  var createProg = function(arrayNum) {
    addProg[arrayNum] = addInstructionPos(addProg[arrayNum]);
    tmpId = cmn_commandCreate('nosupport', null);
    if(typeof addProg[arrayNum] != "undefined") {
      g_program_data[tmpId].param = (arrayNum != Object.keys(addProg)[arrayNum]) ? "" : addProg[arrayNum];
      addProgId[arrayNum] = tmpId;
      addProgArray.push(tmpId);
      save_id_array.push(tmpId);
    }
    return tmpId;
  };
  if(prgLine) {
    if((prgLine <= 0) || (prgLine > g_TL_progInfo.saveProg.length + 1)) return false;
    setTpOrderFlg = true;
    addProg = order_array;
  }
  if(g_TL_progInfo.saveProg.length + addProg.length > MAX_LINE_COUNT) {
    /* Pop-up display due to excessive number of lines. */
    popup_lineCountMax();
    addProg = [];
    return false;
  }
  if(dropProgEndNum) var endId = get_stretch_pairId(addedId, REQ_ID_KIND_END, null);
  if(dropProgNum > 0 || setTpOrderFlg) {
    for(var cnt = 0; cnt < dropProgNum - 1; cnt++) {
      createProg(cnt);
    }
    if(!setTpOrderFlg) {
      addProgArray.push(addedId);
    }
    if(endId) {
      refElmId = endId;
    }
    if(cnt != addProg.length) {
      for(var cnt = cnt; cnt < addProg.length; cnt++) {
        tmpId = createProg(cnt);
        if(typeof addProg[cnt] != "undefined") refElmId = tmpId;
      }
    }
  } else if(dropProgNum == -1) {
    for(var cnt = 0; cnt < addProg.length; cnt++) {
      createProg(cnt);
      if(typeof addProg[cnt] != "undefined") {
        if(addProg[cnt].startsWith(ORDER_LINE) || addProg[cnt].startsWith(ORDER_JOINT) ||
           addProg[cnt].startsWith(" " + ORDER_CALL + " " + "-INST_EASYAW_START")) {
//          scrlChk = true;
          addProgArray.push(refElmId);
        }
        scrlChk = true;
      }
    }
  }
  if(!setTpOrderFlg) {
    var svPrgIdx = g_TL_progInfo.saveProg.indexOf(addedId);
    /* Refer to the program line immediately before the program line you want to insert */
    var pasteRefId = (svPrgIdx == 0) ? 'TL_spacer' : g_TL_progInfo.saveProg[svPrgIdx - 1];
    /* saveProg & dispProg update */
    progInfo_del_splice(addedId);
  }
  else {
    var addIdx = prgLine - 1;
    var pasteRefId = (addIdx == 0) ? 'TL_spacer' : get_array_num_to_iconid(addIdx - 1);
  }
  progInfo_update(pasteRefId, addProgArray, false);
  g_adin_state.adinstAttachedFlg = true;
  g_adin_state.continuousRep = null;
  if(dropProgNum > 0) {
    addProgId.splice(dropProgNum - 1, 0, addedId);
    addProgId.dropId = addedId;
  } else {
    addProgId.dropId = null;
  }
  for(var int = 0; int < save_id_array.length; int++){
    var tlNum = g_TL_progInfo.saveProg.indexOf(save_id_array[int]) + 1;
    var setParam = " " + tlNum + ":"+ g_program_data[save_id_array[int]].param + " ";
    set_program_data(setParam, save_id_array[int]);
  }
  if(endId) {
    addProgId.splice(dropProgEndNum - 1, 0, endId);
    addProgId.endId = endId;
  }
  g_program_arrayNumSave();
  check_progOrder();
  need_position_save_flg = true;
  save_id_array = add_sampleprg_data(sampleProgFlg);
  if(scrlChk) iconDrop_TLScroll(save_id_array[save_id_array.length - 1]);
  if(g_wt_longPress_state.state == 'startAdding') {
    g_wt_longPress_state.addStartElmId = save_id_array[0];
  }
  else if(g_wt_longPress_state.state == 'endAdding') {
    g_wt_longPress_state.addEndElmId = save_id_array[0];
  } else {}
  del_unused_posno();
  save_tporder(save_id_array[0], EDIT_PRG_OPT_INSERT_AFTER, save_tporder_callback, save_id_array.shift());
  addProg = [];
  return true;
}
/*
 =========================================================================
 @function name  : evalFunctionCall
 @argument       : 
 @description    : Function call executed on drop.
 @return         : none
 =========================================================================
*/
function evalFunctionCall() {
  var isBracket = stretch_idStrChk(STRETCH_ID_CHK_LEAD, g_adinDropList[0][0]);
  if (isBracket) {
    var endParam = g_program_data[get_stretch_pairId(g_adinDropList[0][0], REQ_ID_KIND_END, null)].param;

    var start = endParam.indexOf("(");
    var end = endParam.lastIndexOf(")");
    endParam = endParam.substring(start + 1, end);
    endParam = langConvEng(endParam.replace(/'/g, "\\'"));
    var evalStr = "[\'" + langConvEng(g_adinDropList[0][1].replace(/'/g, "\\'")) + "\',\'" + endParam + "\']";
  } else {
    var evalStr = "\'" + langConvEng(g_adinDropList[0][1].replace(/'/g, "\\'")) + "\'";
  }
  var adinFrm = document.getElementById("adin_" + g_adinDropList[0][0]).contentWindow;
  var evalReturn = true;
  var evalAppName = g_inst_obj[g_adinDropList[0][2]]["detail"]["appName"];
  if (typeof adinFrm[g_xml_data[g_adinDropList[0][2]].func] != "undefined") {
    try {
      var robotPos = adinFrm.document.getElementsByClassName('position');
      var fixedProgInfo = {progName: current_prog_name, lRegNums: g_config['localReg'].slice()};
      for (var robotpos_cnt = 0; robotpos_cnt < robotPos.length; robotpos_cnt++) {
        robotPos[robotpos_cnt].setPrgInfoCallback(getProgInfo_forComp, fixedProgInfo, notifyComponentPosEdit);
      }
      evalReturn = eval("adinFrm." + g_xml_data[g_adinDropList[0][2]].func + "(" + evalStr + ")");
    } catch(e) {
      errPopUp(
        evalAppName + langResource.ihmieditor_pop_adinstructionnotfile_c
        + "<br>" + langResource.ihmieditor_pop_errorcode_c
        + ((isBracket) ? "[I504]" : "[I503]") + "<br>"
        + langResource.ihmieditor_pop_moveprglist_c);
      return;
    }
  }
  if (evalReturn === false) {
    errPopUp(evalAppName + langResource.ihmieditor_pop_adinstructionnotfile_c + "<br>" + langResource.ihmieditor_pop_errorcode_c + "[I502]<br>" + langResource.ihmieditor_pop_moveprglist_c);
  }
}

/*
 =========================================================================
 @function name  : setEndParam
 @argument       : str
 @description    : Confirm button  processing
 @return         : none
 =========================================================================
*/
var setEndParamPos = {endId:'', func:null, arg:[], bktUndoInfo: {hold: false, withoutRegist: null}};
function setEndParam(str) {
  var setActive = (g_adintarget != "") ? g_adintarget : activeTarget;
  if(setActive == '') return;
  var instObj = g_inst_obj[g_program_data[setActive].baseId];
  var endId = get_stretch_pairId(setActive,REQ_ID_KIND_END,null);
  var record_data = {
    id: "",
    lineNum: g_program_data[endId].array_num + 1,
    contents: g_program_data[endId],
    param1: {},
    param2: {},
    elem: ""
  }
  if (g_adin_state.setBracketArgFlg && g_adintarget == "") {
    g_adin_state.record[1] = {};
    $.extend(true, g_adin_state.record[1], record_data);
    $.extend(true, g_adin_state.record[1].param1, g_program_data[endId]);
  } else {
    record_data.type = OPERATION_EDIT
    $.extend(true, record_data.param1, g_program_data[endId]);
  }

  need_position_save_flg = false;
  var setParam = "";
  var setStr = str;
  if (setStr.trim() != "") {
    setStr = setLangConvJpEng("(" + setStr + ")");
  }
  setParam = instObj.end.appName + setStr;

  if ((setParam !== null) && (setParam !== '')) {
    if (instObj.type == "posTeach" || instObj.type == "posBracket") {
      posNumChk(endId, setStr);
      setEndParamPos.endId = endId;
    }
    if (g_adintarget != "") {
      data_before_change = JSON.parse(JSON.stringify(g_program_data[endId]));
      fixDropAdinDataSave_g_program(setParam);
      write_mode = EDIT_PRG_OPT_OVERWRITE;
      dropSaveFlg = true;
      save_tporder(endId, write_mode, save_tporder_callback, endId);
    } else {
      data_before_change = JSON.parse(JSON.stringify(g_program_data[endId]));
      fixDataSave_g_program(setParam, null, null, null, endId);
      if (g_adin_state.setBracketArgFlg) {
        $.extend(true, g_adin_state.record[1].param2, g_program_data[endId]);
      } else {
        $.extend(true, record_data.param2, g_program_data[endId]);
        timeline_record.array_add(record_data);
        check_undoredo_active();
        position_record.array_add(position);
        positionregi_record.array_add(g_position_regi);
      }
      write_mode = EDIT_PRG_OPT_OVERWRITE;
      dropSaveFlg = false;
      save_tporder(endId, write_mode, save_tporder_callback, endId);
    }
  }
}
/*
 =========================================================================
 @function name  : setEndParamWithCB
 @argument       : str
 @argument[callback]     : set a CallBack
 @argument[cbarg]        : set an argument of CallBack
 @description    : Confirm button processing
 @return         : none
 =========================================================================
*/
function setEndParamWithCB(str, callback, cbarg) {
  var setActive = (g_adintarget != "") ? g_adintarget : activeTarget;
  if (setActive == '') return false;
  var instObj = g_inst_obj[g_program_data[setActive].baseId];
  var endId = get_stretch_pairId(setActive,REQ_ID_KIND_END,null);
  var record_data = {
    id: "",
    lineNum: g_program_data[endId].array_num + 1,
    contents: g_program_data[endId],
    param1: {},
    param2: {},
    elem: ""
  }
  if (g_adin_state.setBracketArgFlg && g_adintarget == "") {
    g_adin_state.record[1] = {};
    $.extend(true, g_adin_state.record[1], record_data);
    $.extend(true, g_adin_state.record[1].param1, g_program_data[endId]);
  } else {
    record_data.type = OPERATION_EDIT
    $.extend(true, record_data.param1, g_program_data[endId]);
  }

  need_position_save_flg = false;
  var setParam = "";
  var setStr = str;
  if (setStr.trim() != "") {
    setStr = setLangConvJpEng("(" + setStr + ")");
  }
  setParam = instObj.end.appName + setStr;
  var isSaveTp = (setParam !== null) && (setParam !== '');
  if (isSaveTp) {
    if (instObj.type == "posTeach" || instObj.type == "posBracket") {
      posNumChk(endId, setStr);
      setEndParamPos.endId = endId;
    }
    if (g_adintarget != "") {
      data_before_change = JSON.parse(JSON.stringify(g_program_data[endId]));
      fixDropAdinDataSave_g_program(setParam);
      write_mode = EDIT_PRG_OPT_OVERWRITE;
      dropSaveFlg = true;
      var save_tporder_cbarg = {
        id: endId,
        callback: callback,
        cbarg: cbarg
      };
      save_tporder(endId, write_mode, save_tporder_callbackWithCB, save_tporder_cbarg);
    } else {
      data_before_change = JSON.parse(JSON.stringify(g_program_data[endId]));
      fixDataSave_g_program(setParam, null, null, null, endId);
      if (g_adin_state.setBracketArgFlg) {
        $.extend(true, g_adin_state.record[1].param2, g_program_data[endId]);
      } else {
        $.extend(true, record_data.param2, g_program_data[endId]);
        timeline_record.array_add(record_data);
        check_undoredo_active();
        position_record.array_add(position);
        positionregi_record.array_add(g_position_regi);
      }
      write_mode = EDIT_PRG_OPT_OVERWRITE;
      dropSaveFlg = false;
      var save_tporder_cbarg = {
        id: endId,
        callback: callback,
        cbarg: cbarg
      };
      save_tporder(endId, write_mode, save_tporder_callbackWithCB, save_tporder_cbarg);
    }
  }
  return isSaveTp;
}

/*
=========================================================================
@function name  : setLangConvJpEng
@argument       : str
@description    : argument is language convert.
@return         : convert str
=========================================================================
*/
function setLangConvJpEng(str){
  if(gcurrentLang == "jp" || gcurrentLang == "kn"){
    var commaMatch = /,(?=(?:[^']*'[^']*')*[^']*$)/g;
    var spaceMatch = /\s+(?![^\[]*\])/g;
    var splitChgTbl = [
      {chkStr: new RegExp('^' + langResource.ihmieditor_order_vision_c), splitCnd: spaceMatch, joinStr: ' '},
      {chkStr: new RegExp('^' + langResource.ihmieditor_order_call_c),   splitCnd: commaMatch, joinStr: ','},
      {chkStr: /./                                                     , splitCnd: commaMatch, joinStr: ','},
    ];

    var chkResult = splitChgTbl.find(function(data) {return str.match(data.chkStr)});
    if(chkResult) {
      var prm = str.split(chkResult.splitCnd);

      var singleQuote = /[']/;
      var replacePrmList = [];
      var vOffsetPram = /VOFFSET(?=(?:[^']*'[^']*')*[^']*$)/g;
      var substrPram = /SUBSTR(?=(?:[^']*'[^']*')*[^']*$)/g;
      var findstrPram = /FINDSTR(?=(?:[^']*'[^']*')*[^']*$)/g;
      var strlenPram = /STRLEN(?=(?:[^']*'[^']*')*[^']*$)/g;
      var offsetPram = /Tool_Offset(?=(?:[^']*'[^']*')*[^']*$)/g;
      var breakPram = /BREAK(?=(?:[^']*'[^']*')*[^']*$)/g;
      var pulsePram = /PULSE(?=(?:[^']*'[^']*')*[^']*$)/g;
      var jposPram = /Jpos(?=(?:[^']*'[^']*')*[^']*$)/g;
      var LposPram = /Lpos(?=(?:[^']*'[^']*')*[^']*$)/g;
      var skipPram = /Skip(?=(?:[^']*'[^']*')*[^']*$)/g;
      var offPram = /OFF(?=(?:[^']*'[^']*')*[^']*$)/g;
      var onPram = /ON(?=(?:[^']*'[^']*')*[^']*$)/g;
      var pthPram = /PTH(?=(?:[^']*'[^']*')*[^']*$)/g;
      var andPram = /AND(?=(?:[^']*'[^']*')*[^']*$)/g;
      var orPram = /OR(?=(?:[^']*'[^']*')*[^']*$)/g;
      var incPram = /INC(?=(?:[^']*'[^']*')*[^']*$)/g;
      var accPram = /ACC(?=(?:[^']*'[^']*')*[^']*$)/g;
      var wjntPram = /Wjnt(?=(?:[^']*'[^']*')*[^']*$)/g;
      var taPram = /TA(?=(?:[^']*'[^']*')*[^']*$)/g;
      var tbPram = /Tb(?=(?:[^']*'[^']*')*[^']*$)/g;
      Object.keys(prm).forEach(function (key) {
        if(singleQuote.test(prm[key])){
          prm[key] = prm[key].replace(vOffsetPram,langResource.ihmieditor_order_voffset_c);
          prm[key] = prm[key].replace(findstrPram,langResource.ihmieditor_order_findstr_c);
          prm[key] = prm[key].replace(substrPram,langResource.ihmieditor_order_substr_c);
          prm[key] = prm[key].replace(strlenPram,langResource.ihmieditor_order_strren_c);
          prm[key] = prm[key].replace(offsetPram,langResource.ihmieditor_order_offset_c);
          prm[key] = prm[key].replace(breakPram,langResource.ihmieditor_order_break_c);
          prm[key] = prm[key].replace(pulsePram,langResource.ihmieditor_order_pulse_c);
          prm[key] = prm[key].replace(jposPram,langResource.ihmieditor_order_jpos_c);
          prm[key] = prm[key].replace(LposPram,langResource.ihmieditor_order_lpos_c);
          prm[key] = prm[key].replace(skipPram,langResource.ihmieditor_order_skip_c);
          prm[key] = prm[key].replace(offPram,langResource.ihmieditor_order_off_c);
          prm[key] = prm[key].replace(onPram,langResource.ihmieditor_order_on_c);
          prm[key] = prm[key].replace(pthPram,langResource.ihmieditor_order_pth_c);
          prm[key] = prm[key].replace(orPram,langResource.ihmieditor_order_or_c);
          prm[key] = prm[key].replace(incPram,langResource.ihmieditor_order_inc_c);
          prm[key] = prm[key].replace(accPram,langResource.ihmieditor_order_acc_c);
          prm[key] = prm[key].replace(andPram,langResource.ihmieditor_order_and_c);
          prm[key] = prm[key].replace(wjntPram,langResource.ihmieditor_order_wjnt_c);
          prm[key] = prm[key].replace(taPram,langResource.ihmieditor_order_ta_c);
          prm[key] = prm[key].replace(tbPram,langResource.ihmieditor_order_tb_c);
        }else{
          prm[key] = prm[key].replace(/TIMER_OVERFLOW\[/g,langResource.ihmieditor_order_timeroverflow_c+'[');
          prm[key] = prm[key].replace(/Tool_Offset/g,langResource.ihmieditor_order_tool_offset_c);
          prm[key] = prm[key].replace(/UFRAME\[/g,langResource.ihmieditor_order_uframe_c+'[');
          prm[key] = prm[key].replace(/UFRAME_NUM\[/g,langResource.ihmieditor_order_uframe_num_c+'[');
          prm[key] = prm[key].replace(/VOFFSET/g,langResource.ihmieditor_order_voffset_c);
          prm[key] = prm[key].replace(/Constant/g,langResource.ihmieditor_order_constant_c);
          prm[key] = prm[key].replace(/UTOOL\[/g,langResource.ihmieditor_order_utool_c+'[');
          prm[key] = prm[key].replace(/UTOOL_NUM\[/g,langResource.ihmieditor_order_utool_num_c+'[');
          prm[key] = prm[key].replace(/TIMER\[/g,langResource.ihmieditor_order_timer_c+'[');
          prm[key] = prm[key].replace(/FINDSTR/g,langResource.ihmieditor_order_findstr_c);
          prm[key] = prm[key].replace(/Ind\.EV/g,langResource.ihmieditor_order_ind_ev_c);
          prm[key] = prm[key].replace(/STRLEN/g,langResource.ihmieditor_order_strren_c);
          prm[key] = prm[key].replace(/SUBSTR/g,langResource.ihmieditor_order_substr_c);
          prm[key] = prm[key].replace(/Offset/g,langResource.ihmieditor_order_offset_c);
          prm[key] = prm[key].replace(/LBL\[/g,langResource.ihmieditor_order_lbl_c+'[');
          prm[key] = prm[key].replace(/BREAK/g,langResource.ihmieditor_order_break_c);
          prm[key] = prm[key].replace(/PULSE/g,langResource.ihmieditor_order_pulse_c);
          prm[key] = prm[key].replace(/AR\[/g, langResource.ihmieditor_order_argument_c+'[');
          prm[key] = prm[key].replace(/PR\[/g, langResource.ihmieditor_order_posregi_c+'[');
          prm[key] = prm[key].replace(/SR\[/g, langResource.ihmieditor_order_strregi_c+'[');
          prm[key] = prm[key].replace(/VR\[/g,langResource.ihmieditor_order_vr_c+'[');
          prm[key] = prm[key].replace(/\,CALL/g,',' + langResource.ihmieditor_order_call_c);
          prm[key] = prm[key].replace(/^CALL/g, langResource.ihmieditor_order_call_c);
          prm[key] = prm[key].replace(/Jpos/g,langResource.ihmieditor_order_jpos_c);
          prm[key] = prm[key].replace(/Lpos/g,langResource.ihmieditor_order_lpos_c);
          prm[key] = prm[key].replace(/Skip/g,langResource.ihmieditor_order_skip_c);
          prm[key] = prm[key].replace(/Wjnt/g,langResource.ihmieditor_order_wjnt_c);
          prm[key] = prm[key].replace(/R\[/g, langResource.ihmieditor_order_regi_c+'[');
          prm[key] = prm[key].replace(/P\[/g, langResource.ihmieditor_order_pos_c+'[');
          prm[key] = prm[key].replace(/ACC/g,langResource.ihmieditor_order_acc_c);
          prm[key] = prm[key].replace(/\sAND/g,' ' + langResource.ihmieditor_order_and_c);
          prm[key] = prm[key].replace(/INC/g,langResource.ihmieditor_order_inc_c);
          prm[key] = prm[key].replace(/PTH/g,langResource.ihmieditor_order_pth_c);
          prm[key] = prm[key].replace(/OFF/g,langResource.ihmieditor_order_off_c);
          prm[key] = prm[key].replace(/ON/g,langResource.ihmieditor_order_on_c);
          prm[key] = prm[key].replace(/\sOR/g,' ' + langResource.ihmieditor_order_or_c);
          prm[key] = prm[key].replace(/TA\s/g,langResource.ihmieditor_order_ta_c + ' ');
          prm[key] = prm[key].replace(/TB\s/g,langResource.ihmieditor_order_tb_c + ' ');
          prm[key] = prm[key].replace(/DB\s/g,langResource.ihmieditor_order_db_c + ' ');
          prm[key] = prm[key].replace(/EV/g,langResource.ihmieditor_order_ev_c);
        }
        replacePrmList.push(prm[key]);
      });
      str = replacePrmList.join(chkResult.joinStr);
    }
  }

  return str;
}

/*
 =========================================================================
 @function name  : langConvEng
 @argument       : str
 @description    : argument is english only
 @return         : convert str
 =========================================================================
*/
function langConvEng(str) {
  var regExpWord = new RegExp(langResource.ihmieditor_order_timeroverflow_c + '\\[', 'g');
  str = str.replace(regExpWord, 'TIMER_OVERFLOW[');
  regExpWord = new RegExp(langResource.ihmieditor_order_constant_c, 'g');
  str = str.replace(regExpWord, 'Constant');
  regExpWord = new RegExp(langResource.ihmieditor_order_timer_c + '\\[', 'g');
  str = str.replace(regExpWord, 'TIMER[');
  regExpWord = new RegExp(langResource.ihmieditor_order_uframe_c + '\\[', 'g');
  str = str.replace(regExpWord, 'UFRAME[');
  regExpWord = new RegExp(langResource.ihmieditor_order_utool_c + '\\[', 'g');
  str = str.replace(regExpWord, 'UTOOL[');
  regExpWord = new RegExp(langResource.ihmieditor_order_uframe_num_c + '\\[', 'g');
  str = str.replace(regExpWord, 'UFRAME_NUM[');
  regExpWord = new RegExp(langResource.ihmieditor_order_utool_num_c + '\\[', 'g');
  str = str.replace(regExpWord, 'UTOOL_NUM[');
  regExpWord = new RegExp(langResource.ihmieditor_order_posregi_c + '\\[', 'g');
  str = str.replace(regExpWord, 'PR[');
  regExpWord = new RegExp(langResource.ihmieditor_order_strregi_c + '\\[', 'g');
  str = str.replace(regExpWord, 'SR[');
  regExpWord = new RegExp(langResource.ihmieditor_order_argument_c + '\\[', 'g');
  str = str.replace(regExpWord, 'AR[');
  regExpWord = new RegExp(langResource.ihmieditor_order_vr_c + '\\[', 'g');
  str = str.replace(regExpWord, 'VR[');
  regExpWord = new RegExp(langResource.ihmieditor_order_regi_c + '\\[', 'g');
  str = str.replace(regExpWord, 'R[');
  regExpWord = new RegExp(langResource.ihmieditor_order_pos_c + '\\[', 'g');
  str = str.replace(regExpWord, 'P[');
  regExpWord = new RegExp(langResource.ihmieditor_order_pulse_c, 'g');
  str = str.replace(regExpWord, 'PULSE');
  regExpWord = new RegExp(langResource.ihmieditor_order_lpos_c, 'g');
  str = str.replace(regExpWord, 'Lpos');
  regExpWord = new RegExp(langResource.ihmieditor_order_jpos_c, 'g');
  str = str.replace(regExpWord, 'Jpos');
  regExpWord = new RegExp(langResource.ihmieditor_order_strren_c, 'g');
  str = str.replace(regExpWord, 'STRLEN');
  regExpWord = new RegExp(langResource.ihmieditor_order_findstr_c, 'g');
  str = str.replace(regExpWord, 'FINDSTR');
  regExpWord = new RegExp(langResource.ihmieditor_order_substr_c, 'g');
  str = str.replace(regExpWord, 'SUBSTR');
  regExpWord = new RegExp(langResource.ihmieditor_order_and_c, 'g');
  str = str.replace(regExpWord, 'AND');
  regExpWord = new RegExp(langResource.ihmieditor_order_or_c, 'g');
  str = str.replace(regExpWord, 'OR');
  regExpWord = new RegExp(langResource.ihmieditor_order_on_c, 'g');
  str = str.replace(regExpWord, 'ON');
  regExpWord = new RegExp(langResource.ihmieditor_order_off_c, 'g');
  str = str.replace(regExpWord, 'OFF');
  regExpWord = new RegExp(langResource.ihmieditor_order_skip_c, 'g');
  str = str.replace(regExpWord, 'Skip');
  regExpWord = new RegExp(langResource.ihmieditor_order_lbl_c, 'g');
  str = str.replace(regExpWord, 'LBL');
  regExpWord = new RegExp(langResource.ihmieditor_order_tool_offset_c, 'g');
  str = str.replace(regExpWord, 'Tool_Offset');
  regExpWord = new RegExp(langResource.ihmieditor_order_offset_c, 'g');
  str = str.replace(regExpWord, 'Offset');
  regExpWord = new RegExp(langResource.ihmieditor_order_voffset_c, 'g');
  str = str.replace(regExpWord, 'VOFFSET');
  regExpWord = new RegExp(langResource.ihmieditor_order_break_c, 'g');
  str = str.replace(regExpWord, 'BREAK');
  regExpWord = new RegExp(langResource.ihmieditor_order_ind_ev_c, 'g');
  str = str.replace(regExpWord, 'Ind.EV');
  regExpWord = new RegExp(langResource.ihmieditor_order_ev_c, 'g');
  str = str.replace(regExpWord, 'EV');
  regExpWord = new RegExp(langResource.ihmieditor_order_wjnt_c, 'g');
  str = str.replace(regExpWord, 'Wjnt');
  regExpWord = new RegExp(langResource.ihmieditor_order_acc_c, 'g');
  str = str.replace(regExpWord, 'ACC');
  regExpWord = new RegExp(langResource.ihmieditor_order_ta_c, 'g');
  str = str.replace(regExpWord, 'TA');
  regExpWord = new RegExp(langResource.ihmieditor_order_tb_c, 'g');
  str = str.replace(regExpWord, str.match(new RegExp(langResource.ihmieditor_order_tb_c + '\\s*\\d*\\.\\dmm')) ? 'DB' : 'TB');
  regExpWord = new RegExp(langResource.ihmieditor_order_inc_c, 'g');
  str = str.replace(regExpWord, 'INC');
  regExpWord = new RegExp(langResource.ihmieditor_order_pth_c, 'g');
  str = str.replace(regExpWord, 'PTH');
  regExpWord = new RegExp(langResource.ihmieditor_order_call_c, 'g');
  str = str.replace(regExpWord, 'CALL');
  return str;
}

/*
 =========================================================================
 @function name  : posCheck
 @argument       : check str
 @description    : Check position information
 @return         : 
 =========================================================================
*/
function posCheck(str) {
  if (str.indexOf('P[') != -1 || str.indexOf(ORDER_POS + '[') != -1 ||
      str.indexOf('PR[') != -1 || str.indexOf(ORDER_POSREGI + '[') != -1) {
    return true;
  } else {
    return false;
  }
}

/*
 =========================================================================
 @function name  : titleIns
 @argument       : title name
 @description    : Give a title
 @return         : none
 =========================================================================
*/
function titleIns(title) {
  var content = dtlfrm_contentchk(activeTarget);
  
  if(title != "" && content != null && content.length != 0) {
    var titleStr = title + ((g_program_data[activeTarget].remark) ? ' ' + langResource.ihmieditor_title_instruction_remarked_c : '');
    if(g_program_data[activeTarget].baseId == '-INST_ARC_HANDLE_TEACH' || g_program_data[activeTarget].baseId == '-INST_WRIST_BUTTON_TEACH') {
      $('.detail-helplinkArea', content).css('display', (g_program_data[activeTarget].remark ? 'none' : ''));
    }
    if(content.getElementsByClassName('detail_title').length == 0) {
      var insLabel = document.createElement('div');
      insLabel.classList.add('detail_title');
      var insTitle = document.createElement('span');
      $(insTitle).html(titleStr);
      $(insLabel).prepend(insTitle);
      
      content.prepend(insLabel);
      $(insTitle).css('font-size', '25px');
      $(insLabel).css({
        'position':'relative',
        'display':'inline-block',
        'height':'35px',
        'margin':'5px 0 0 20px',
        'text-align':'center',
        'border-bottom':'solid 2px rgb(0, 0, 0)',
        'line-height':'35px',
      });
    }
    else {
      var titleList = content.getElementsByClassName('detail_title');
      for(var cnt = 0; cnt < titleList.length; cnt++) {
        if(cnt == 0) {
          titleList[cnt].children[0].innerHTML = titleStr;
        }
        else {
          var setText = titleList[cnt].children[0].innerText.replace(' ' + langResource.ihmieditor_title_instruction_remarked_c, '');
          setText = setText + ((g_program_data[activeTarget].remark) ? ' ' + langResource.ihmieditor_title_instruction_remarked_c : '');
          titleList[cnt].children[0].innerHTML = setText;
        }
      }
    }
  }
}

/*
 =========================================================================
 @function name : radio_wait_selectCheck
 @argument[]    : none
 @description   : WAIT : Determine which radio button to select.
 @return        : none
 =========================================================================
*/
var WAIT_COND_TIME = '1';
var WAIT_COND_SEL = '2';
var WAIT_COND_DIRECT = '3';
function radio_wait_selectCheck(param) {
  var ret = WAIT_COND_DIRECT;
  var chk_str = new RegExp('(' + ORDER_POSREGI + '|PR|' + ORDER_TIMER_OF + '|TIMER_OVERFLOW' + '|' + ORDER_TIMER + '|TIMER' + '| ' + ORDER_AND + ' | ' + ORDER_OR + ' | AND | OR | DIV | MOD |\\$|\\+|\\*|\\/)', 'g');
  if(param.length < 3) {
    /* The standby condition is seconds. */
    if(param.length == 1 && param[0].match(/(sec|\(sec\))$/)) {
      param[0] = param[0].replace(/(sec|\(sec\))/, '');
      /* An integer greater than or equal to 0, or to two decimal places. */
      if(param[0].match(/^(\d*|\.)\.?(\d{2}|\d{1})?$/)) {
        ret = WAIT_COND_TIME;
        /* Decimal point adjustment. */
        if(param[0].match(/^(?!.*(\d+\.\d{2})).*$/)) {
          g_program_data[activeTarget].param = Number(param[0]).toFixed(2) + '(sec)';
        }
      }
    }
  }
  else {
    param[0] = outputComment_del(param[0]);
    if(param[2].match(chk_str) == null) {
      var isRightParamNum = isIntegerRealNumber(param[2].replace(/(^\(|\)$)/g, ''));
      var onoffchk = new RegExp('^(' + ORDER_ON + '|' + ORDER_OFF + ')');
      var timeChkStr = new RegExp('\\s' + ORDER_TIMEOUT + '\\,' + ORDER_LABEL + '\\[');
      if(cond_waitvariableselectCheck(param[0]) && (cond_waitvariableselectCheck(param[2]) || param[2].match(onoffchk) || isRightParamNum)) {
        if(param[2].match(timeChkStr) == null ||
           (param[2].match(timeChkStr) && param[2].match(new RegExp(ORDER_LABEL + '\\[(\\d+|\\.{3})\\]')))) {
          ret = WAIT_COND_SEL;
        }
      }
    }
  }
  return ret;
}

/*
 =========================================================================
 @function name : radio_if_selectCheck
 @argument[]    : none
 @description   : IF : Determine which radio button to select.
 @return        : none
 =========================================================================
*/
var IF_COND_SEL = '1';
var IF_COND_DIRECT = '2';
function radio_if_selectCheck(param) {
  var ret = IF_COND_DIRECT;
  var chk_str = new RegExp('(' + ORDER_POSREGI + '|PR|' + ORDER_TIMER_OF + '|TIMER_OVERFLOW' + '|' + ORDER_TIMER + '|TIMER' + '|' +
                                ORDER_AND + '|' + ORDER_OR + '|AND|OR|DIV|MOD|\\$|\\+|\\-|\\*|\\/|\\=|\\<\\>|\\<|\\<\\=|\\>|\\>\\=)', 'g');
  if(param.length > 2) {
    param[0] = outputComment_del(param[0]);
    var flg_isNum_param0 = isIntegerRealNumber(param[0].replace(/(^\(|\)$)/g, ''));
    var flg_isNum_param2 = isIntegerRealNumber(param[2].replace(/(^\(|\)$)/g, ''));
    if(param[2].match(chk_str) == null || flg_isNum_param2 ) {
        if((cond_ifvariableselectCheck(param[0]) || flg_isNum_param0 || param[0] == ORDER_ON || param[0] == ORDER_OFF) &&
           (cond_ifvariableselectCheck(param[2]) || flg_isNum_param2 || param[2] == ORDER_ON || param[2] == ORDER_OFF)) {
        ret = IF_COND_SEL;
      }
    }
  }
  return ret;
}

/*
 =========================================================================
 @function name   : radio_regi_selectCheck
 @argument[param] : Left and right side parameters.
 @description     : REGI : Determine which radio button to select.
 @return          : Results of the judgment.
 =========================================================================
*/
var REGI_COND_SEL = '1';
var REGI_COND_DIRECT = '2';
function radio_regi_selectCheck(param) {
  var ret = REGI_COND_SEL;
  var chkLeftStr = new RegExp('^(' + ORDER_REGI + '|R)\\[(' + ORDER_REGI + '|' + ORDER_ARGUMENT + '|R|AR)\\[');
  var regi_replace_str = new RegExp('^(' + ORDER_REGI + '|R)' + '\\[|\\]$', 'g');
  var chkRightStr = new RegExp('^(' + ORDER_CONSTANT + '|(' + ORDER_REGI + '|R|AO|AI|GO|GI|DO|DI|RO|RI|SO|SI|UO|UI)\\[)');
  var indirectStr = new RegExp('(' + ORDER_REGI + '|' + ORDER_ARGUMENT + '|R|AR)\\[');
  var chk_str = new RegExp('(' + ORDER_TIMER_OF + '|TIMER_OVERFLOW' + '|' + ORDER_TIMER + '|TIMER|DIV|MOD|' + ORDER_POSREGI + '|PR|\\$|\\+|\\-|\\*|\\/)', 'g');
  
  if(param[0].match(chkLeftStr)) {
    ret = REGI_COND_DIRECT;
  }
  else {
    if (param[0].replace(/[^0-9]/g, "") === "") {
      param[0] = "0";
    }
    else {
      param[0] = outputComment_del(param[0]).replace(regi_replace_str, "");
      if(param[0].replace(/[0-9]/g, "") !== "") ret = REGI_COND_DIRECT;
    }
  }
  
  var rightParam = param[1].split(/\s+/);
  
  var tmp_param1 = outputComment_del(param[1]);
  var flg_isNum_param1 = isIntegerRealNumber(tmp_param1.replace(/(^\(|\)$)/g, ''));
  if(rightParam.length > 1) {
    return REGI_COND_DIRECT;
  }
  if( param[1].match(chk_str)) {
    if(!flg_isNum_param1) {
      return REGI_COND_DIRECT;
    }
  }
  
  if(ret === REGI_COND_SEL) {
    param[1] = outputComment_del(param[1]);
    var matchResult = param[1].match(chkRightStr);
    flg_isNum_param1 = isIntegerRealNumber(param[1].replace(/(^\(|\)$)/g, ''));
    if(flg_isNum_param1) {
      ret = REGI_COND_SEL;
    }
    else if(matchResult) {
      var chkStr = param[1].replace(matchResult[0], '');
      ret = chkStr.match(indirectStr) == null ? REGI_COND_SEL : REGI_COND_DIRECT;
    }
    else {
      ret = REGI_COND_DIRECT;
    }
  }
  return ret;
}

/*
 =========================================================================
 @function name : cond_ifvariableselectCheck
 @argument[str] : Check string
 @description   : IF : Determine which radio button to select.
 @return        : none
 =========================================================================
*/
function cond_ifvariableselectCheck(str) {
  var ret = false;
  var chkStr = new RegExp('(' + ORDER_REGI + '|AO|AI|GO|GI|DO|DI|RO|RI|SO|SI|UO|UI|F)\\[');
  var chkIndirectStr = new RegExp('(' + ORDER_LABEL + '|' + ORDER_REGI + '|R|AO|AI|GO|GI|DO|DI|RO|RI|SO|SI|UO|UI|F)\\[(' + ORDER_REGI + '|' + ORDER_ARGUMENT + '|R|AR)\\[');
  var notChkStr = new RegExp('(' + ORDER_POSREGI + '|' + ORDER_STRREGI + ')\\[');
  var timeChkStr = new RegExp('^\\d+\\s' + ORDER_TIMEOUT + '\\,' + ORDER_LABEL + '\\[');
  if((str.match(notChkStr) == null && str.match(chkStr) && str.match(chkIndirectStr) == null) ||
     (str.match(timeChkStr) && str.match(chkIndirectStr) == null)) {
    ret = true;
  }
  return ret;
}

/*
 =========================================================================
 @function name : cond_waitvariableselectCheck
 @argument[str] : Check string
 @description   : WAIT : Determine which radio button to select.
 @return        : none
 =========================================================================
*/
function cond_waitvariableselectCheck(str) {
  var ret = false;
  var chkStr = new RegExp('(' + ORDER_REGI + '|AO|AI|GO|GI|DO|DI|RO|RI|SO|SI|UO|UI)\\[');
  var chkIndirectStr = new RegExp('(' + ORDER_LABEL + '|' + ORDER_REGI + '|R|AO|AI|GO|GI|DO|DI|RO|RI|SO|SI|UO|UI)\\[(' + ORDER_REGI + '|' + ORDER_ARGUMENT + '|R|AR)\\[');
  var notChkStr = new RegExp('(' + ORDER_POSREGI + '|' + ORDER_STRREGI + ')\\[');
  var timeChkStr = new RegExp('^-?\\d*\\.?\\d+\\s' + ORDER_TIMEOUT + '\\,' + ORDER_LABEL + '\\[');
  if((str.match(notChkStr) == null && str.match(chkStr) && str.match(chkIndirectStr) == null) ||
     (str.replace(/(^\(|\))/g, '').match(timeChkStr) && str.match(chkIndirectStr) == null)) {
    ret = true;
  }
  return ret;
}

/*
 =========================================================================
 @function name  : split_param
 @argument       : str_data
 @description    : Parse a string
 @return         : spl_data
 =========================================================================
*/
function split_param(str_data) {
  var spl_data = str_data.split(/=/);
  return spl_data;
}
/*
 =========================================================================
 @function name  : split_param_for
 @argument       : str_data
 @description    : Parsing roop strings
 @return         : Split data.
 =========================================================================
*/
function split_param_for(str_data) {
  var retArray = [];
  var tmpStrArray = param_combineCheck('', str_data.split(/(=)/));
  retArray.push(tmpStrArray[0], tmpStrArray[1]);
  var spl_data = (tmpStrArray[2].indexOf(' DOWNTO ') == -1) ?
                   tmpStrArray[2].split(/(\sTO\s)/) : tmpStrArray[2].split(/(\sDOWNTO\s)/);
  return retArray.concat(spl_data);
}

/*
 =========================================================================
 @function name  : split_param_call
 @argument       : str_data
 @description    : Parsing call program strings
 @return         : spl_data
 =========================================================================
*/
function split_param_call(str_data) {
  var spl_data = str_data.split(/\(/);
  var length = spl_data.length;
  if (length > 2) {
    for (var num = 2; num < length; num++) {
      spl_data[1] = spl_data[1] + '(' + spl_data[2];
      spl_data.splice(2, 1);
    }
  }
  if(typeof spl_data[1] != 'undefined') spl_data[1] = spl_data[1].replace(/\)$/, '');
  return spl_data;
}

/*
 =========================================================================
 @function name  : split_param_wait
 @argument       : str_data
 @description    : Parse a string
 @return         : spl_data
 =========================================================================
*/
function split_param_wait(str_data) {
  var spl_data = str_data.split(/(<>|>=|<=|>|=|<)/);
  return spl_data;
}

/*
 =========================================================================
 @function name    : posInitCompleteCallback
 @argument[cbArgs] : 
 @description      : Callback function of Position data initialization completion.
                   : (Because initialization (refresh) takes time)
 @return           : none
 =========================================================================
*/
function posInitCompleteCallback(cbArgs) {
  // If there is any processing you want to do after refreshing the position data, please add it here.
}

/*
 =========================================================================
 @function name  : split_OptionParam
 @argument       : 
 @description    : 
 @return         : Option array
 =========================================================================
*/
function split_OptionParam() {
  var chkRegiStr = new RegExp('^(' + ORDER_REGI + '|' + ORDER_POSREGI + '|' + ORDER_ARGUMENT + '|AR|PR|R)\\[');
  var optStr = g_program_data[activeTarget].param.split(/\s+/);
  if(optStr.length > 1) {
    if(optStr[0] === '') optStr.splice(0, 1);
    if(optStr[optStr.length - 1] === '') optStr.splice(optStr.length - 1, 1);
  }
  for(var cnt = 0; cnt < optStr.length; cnt++) {
    if((optStr[cnt + 1] != undefined) &&
       ((optStr[cnt + 1].match(chkRegiStr)) ||  (optStr[cnt + 1].match(/(mm|sec)/)) || (optStr[cnt + 1] == '...'))) {
      optStr[cnt] = optStr[cnt] + ' ' + optStr[cnt + 1];
      optStr.splice(cnt + 1, 1);
      cnt -= 1;
    }
  }
  for(var cnt = 0; cnt < optStr.length; cnt++) {
    /* Check the contents of the split. */
    var chkList = [ORDER_WELDSTART.split(/\s+/), ORDER_WELDEND.split(/\s+/)];
    var chkResult = chkList.filter(function(data) { return optStr[cnt] == data[0] });
    if(chkResult.length > 0) {
      for(var addcnt = 0; addcnt < chkResult.length; addcnt++) {
        var chkWeldStr = new RegExp('^' + chkResult[addcnt][1] + '\\[');
        if(optStr[cnt + 1].match(chkWeldStr)){
          optStr[cnt] = optStr[cnt] + ' ' + optStr[cnt + 1];
          optStr.splice(cnt + 1, 1);
          break;
        }
      }
    }
  }
  return optStr;
}

/*
 =========================================================================
 @function name    : detailFix
 @argument[event]  : 
 @description      : Details tab Final processing
 @return           : none
 =========================================================================
*/
function detailFix(id, type, value) {
  /* Position and position register switching events */
  if (id === "robotPos.selposkind") { return; }
  /* The detail screen is already closed. */
  if(activeTarget == '') return;

  var setParam = '';
  var record_data = {
    id: "",
    lineNum: g_program_data[activeTarget].array_num + 1,
    contents: g_program_data[activeTarget],
    param1: {},
    param2: {},
    elem: id,
    type: OPERATION_EDIT
  }
  if (Object.keys(save_failed_data).length) {
    $.extend(true, record_data.param1, save_failed_data);
  } else {
    $.extend(true, record_data.param1, g_program_data[activeTarget]);
  }
  
  /* Basic instrunction */
  if(chk_basicInstruction(g_program_data[activeTarget].baseId)) {
    setParam = document.getElementById('detail_' + iconSortTbl.indexOf(g_program_data[activeTarget].baseId));
  }

  if ((setParam !== null) && (setParam !== '')) {
    /* Store in g_program_data */
    data_before_change = JSON.parse(JSON.stringify(g_program_data[activeTarget]));
    if (fixDataSave_g_program(setParam, id, type, value)) {
      $.extend(true, record_data.param2, g_program_data[activeTarget]);
      timeline_record.array_add(record_data);
      check_undoredo_active();
      position_record.array_add(position);
      positionregi_record.array_add(g_position_regi);
      if(chk_execSave_tporder(type)) {
        write_mode = EDIT_PRG_OPT_OVERWRITE;
        save_tporder(activeTarget, write_mode, save_tporder_callback, activeTarget);
      }
    }
  }
}

/*
 =========================================================================
 @function name  : chk_execSave_tporder
 @argument[type] : Type of operation
 @description    : 
 @return         : 
 =========================================================================
*/
function chk_execSave_tporder(type) {
  var save = true;
  var noSaveTbl = [
    {condition: type == 'altframe'},
  ];
  for(var i in noSaveTbl) {
    if(noSaveTbl[i].condition) {
      save = false;
      break;
    }
  }
  return save;
}

var data_before_change = {};

/*
 =========================================================================
 @function name      : posFix
 @argument[bktEndId] : For the end side of a bracket instruction. (Otherwise, not specified.)
 @description        : Store value to position
 @return             : none
 =========================================================================
*/
function posFix(bktEndId) {
  /* Favorite save mode is position not save. */
  if(g_favoriteFlg.tlAdd || g_favoriteFlg.progAdd || g_favoriteFlg.favoEdit) { return; }

  var pos_kind, totalPosCnt = 0, activePrgName = (typeof bktEndId != "undefined") ? bktEndId : activeTarget;
  var robotPos = $('#' + get_detail_frm_id(activeTarget)).contents().find(".position");

  if(typeof bktEndId != "undefined") { totalPosCnt += g_program_data[activeTarget].position.length; }

  /* Store coordinate data. */
  setPosData(activePrgName, robotPos, totalPosCnt);
}

/*
 =========================================================================
 @function name         : setPosData
 @argument[targetId]    : Target instruction ID
 @argument[robotPos]    : Position Component List
 @argument[totalPosCnt] : position counter
 @description           : Store coordinate data.
 @return                : none
 =========================================================================
*/
function setPosData(targetId, robotPos, totalPosCnt) {
  var mltPosStock = {};
  var coordKey = {
    cart : [ 'X',  'Y',  'Z',  'W',  'P',  'R'],
    joint: ['J1', 'J2', 'J3', 'J4', 'J5', 'J6'],
  };

  /** Callback function : Get values synchronously **/
  function getPositionMultiCB(posNum, resultPosRecArray, callbackarg) {
    mltPosStock = resultPosRecArray;
  }

  for(var posNumCnt = 0; posNumCnt < g_program_data[targetId].position.length; posNumCnt++){
    /* When component does not exist, processing of position is unnecessary */
    if(typeof robotPos[totalPosCnt] == "undefined") continue;

    var pos_kind = robotPos[totalPosCnt].getCurrentPosKind(), mltPosStock = {};
    switch (pos_kind) {
      case POSKIND_POSNUM:   /* P[] */
        var currentPosNum = robotPos[totalPosCnt].getCurrentPosNumber();
        /* If the position number is not set, no processing is required. */
        if (currentPosNum == 0) continue;
        /* Get the coordinates. */
        robotPos[totalPosCnt].getPositionMulti(currentPosNum, true, getPositionMultiCB, null);
        /* Check for "status" */
        var stschk = mltPosStock.find(function(gData) { return typeof gData.status != 'undefined' });
        if (stschk && (stschk.status & 1) === 0) {
          var posDataList = JSON.parse(JSON.stringify(mltPosStock));

          /* Search for the target Position number */
          var pData = position.find(function(data) { return data.posNumber == posDataList[0].posNumber });
          /* No data matched by Position number. */
          if(pData == undefined) {
            position.push(make_position_data(posDataList[0].posNumber));
            pData = position.slice(-1)[0];
          }
          pData.Comment = posDataList[0].comment;

          for (key in posDataList) {
            var posData = posDataList[key];
            /* Search for the target Group number */
            var gData = pData.posData.find(function(data) { return data.groupNumber == posData.group });
            /* No data matched by Group number. */
            if(gData == undefined) {
              pData.posData.push({ poskey: [] });
              gData = pData.posData.slice(-1)[0];
            }
            /* Set coordinate values. */
            if (posData.rep != FORMAT_JOINT) {
              var keyList = coordKey.cart, dataList = posData.cart;
            } else {
              var keyList = coordKey.joint, dataList = posData.joint;
            }
            /* cart / joint */
            for(var cnt= 0; cnt < keyList.length; cnt++) {
              gData.poskey[cnt] = { key: keyList[cnt], val: dataList[keyList[cnt]] };
            }
            /* extend axes */
            for (var axesCnt = 1; cnt <= 8; cnt++, axesCnt++) {
              gData.poskey[cnt] = { key: 'EXT' + axesCnt, val: posData.ext['E' + axesCnt] };
            }
            gData.configStr = posData.conf;
            gData.ufVal = posData.uf;
            gData.utVal = posData.ut;
            gData.groupNumber = Number(posData.group);
            gData.empty = posData.empty;
          }
        }
        break;
      case POSKIND_POSREGI:   /* PR[] */
        var posData = robotPos[totalPosCnt].getPosRegister();
        /* Check for "status" */
        if ((posData.status & 1) === 0) {
          var index = get_g_position_regi_index(posData.group, posData.posRegNum);
          if (!(g_position_regi[index])) { g_position_regi[index] = []; }
          /* cart */
          for(var cnt= 0; cnt < coordKey.cart.length; cnt++) {
            g_position_regi[index][coordKey.cart[cnt]] = posData.cart[coordKey.cart[cnt]];
          }
          /* joint */
          for(var cnt= 0; cnt < coordKey.joint.length; cnt++) {
            g_position_regi[index][coordKey.joint[cnt]] = posData.joint[coordKey.joint[cnt]];
          }
          /* extend axes */
          var axes_num = getExtendAxesCount();
          for (var axes_cnt = 1; axes_cnt <= axes_num; axes_cnt++) {
            g_position_regi[index]['EXT' + axes_cnt] = posData.ext['E' + axes_cnt];
          }
          g_position_regi[index].Config = (posData.rep == FORMAT_JOINT) ? '' : posData.conf;
          g_position_regi[index].axes = posData.axes;
          g_position_regi[index].gnum = posData.group;
          g_position_regi[index].rep = posData.rep;
          g_position_regi[index].uframe = posData.uf;
          g_position_regi[index].utool = posData.ut;
          g_position_regi[index].empty = posData.empty;
          g_position_regi[index].comment = posData.comment;
        }
        break;
      case POSKIND_POSREGI_REGI:   /* PR[R[]] */
      case POSKIND_POSREGI_AR:     /* PR[AR[]] */
      default:
        break;
    }
    totalPosCnt++;
    mltPosStock = {};
  }
  /* Update the list of component position numbers. */
  robotPos[(totalPosCnt == 0) ? totalPosCnt : (totalPosCnt - 1)].updatePositionList(get_allPosIndex());
  del_unused_posno();
}

/*
 =========================================================================
 @function name        : fixDropAdinDataSave_g_program
 @argument[saveParam]  : 
 @description          : 
 @return               : none
 =========================================================================
*/
function fixDropAdinDataSave_g_program(saveParam) {
  var instObj = g_inst_obj[g_adinDropList[0][2]];
  if (instObj.detail.appName == saveParam.substring(0, saveParam.indexOf('(')) || instObj.detail.appName == saveParam.trim()) {
    g_program_data[g_adintarget].param = saveParam;
  } else {
    g_program_data[get_stretch_pairId(g_adintarget, REQ_ID_KIND_END, null)].param = saveParam;
  }
}

/*
 =========================================================================
 @function name       : fixDataSave_g_program
 @argument[saveParam] : Detail screen element
 @argument[id]        : Operated element ID
 @argument[opeType]   : Type of operation
 @argument[value]     : Value after operation
 @argument[activeId]  : Bracket end element ID (For Advanced Instruction)
 @description         : Value storage in g_program_data
 @return              : none
 =========================================================================
*/
function fixDataSave_g_program(saveParam, id, opeType, value, activeId) {
  var needSave = true;
  var dtfrm = document.getElementById(get_detail_frm_id(activeTarget)).contentWindow;
  active_elem = id;
  if(detailDispTbl[g_program_data[activeTarget].baseId]) {
    if(detailDispTbl[g_program_data[activeTarget].baseId].saveFunc) {
      needSave = detailDispTbl[g_program_data[activeTarget].baseId].saveFunc(saveParam, id, opeType, value, activeId, dtfrm);
    }
  }
  /* If favorite save mode, do not save to main program.*/
  if(g_favoriteFlg.tlAdd || g_favoriteFlg.progAdd || g_favoriteFlg.favoEdit) {
    active_elem = "";
    return false;
  }
  return needSave;
}

/*
 =========================================================================
 @function name : fixDataSave_motion
 @argument[]    : 
 @description   : Value storage in g_program_data
 @return        : 
 =========================================================================
*/
function fixDataSave_motion(saveParam, id, opeType, value, activeId, dtfrm) {
  var needSave = false;
  if(!opeType.match(/gp\d/)) {
    /* Speed */
    paramSet_speed(dtfrm);
    /* Route */
    paramSet_route(dtfrm);
    /* Additional motion */
    g_program_data[activeTarget].addMotion = detail_optInstructionSet(id, value, g_program_data[activeTarget].addMotion);
    /* Have two or more positions. */
    if(g_program_data[activeTarget].position.length >= 2) {
      paramSet_offsetMotion(dtfrm);
    }
    posNumChk(activeTarget, null);
    posFix();
    needSave = true;
  }
  return needSave;
}

/*
 =========================================================================
 @function name : fixDataSave_macro
 @argument[]    : 
 @description   : Value storage in g_program_data
 @return        : none
 =========================================================================
*/
function fixDataSave_macro(saveParam, id, opeType, value, activeId, dtfrm) {
  g_program_data[activeTarget].param = dtfrm.document.getElementById("macro_name").getValue();
  return true;
}

/*
 =========================================================================
 @function name : fixDataSave_call
 @argument[]    : 
 @description   : Value storage in g_program_data
 @return        : 
 =========================================================================
*/
function fixDataSave_call(saveParam, id, opeType, value, activeId, dtfrm) {
  var getVal = dtfrm.document.getElementById("call_name").getValue();
  if(getVal == undefined && id === 'program_sel1' && value === '1') {
    var call_list = programFileList.map(function(item) {return item.name});
    dtfrm.document.getElementById("call_name").refresh(call_list, call_list[0], null, false);
    g_program_data[activeTarget].param = call_list[0];
  }
  else {
    g_program_data[activeTarget].param = getVal;
  }
  var formList = dtfrm.document.getElementsByClassName('input-form-list-row');
  var argSetFlg = false;
  for(var cnt = 0; cnt < formList.length; cnt++) {
    if (dtfrm.document.getElementById('argument_' + (cnt + 1)).getValue() !== '') {
      if(!argSetFlg) {
        argSetFlg = true;
        g_program_data[activeTarget].param += '(';
      }
      else {
        g_program_data[activeTarget].param += ',';
      }
      g_program_data[activeTarget].param += setLangConvJpEng(dtfrm.document.getElementById('argument_' + (cnt + 1)).getValue());
    }
  }
  if(argSetFlg) {
    g_program_data[activeTarget].param += ')';
  }
  return true;
}

/*
 =========================================================================
 @function name : fixDataSave_wait
 @argument[]    : 
 @description   : Value storage in g_program_data
 @return        : 
 =========================================================================
*/
function fixDataSave_wait(saveParam, id, opeType, value, activeId, dtfrm) {
  var radio_sel = dtfrm.document.getElementsByClassName('radio-button-option');
  var setvalue = dtfrm.document.getElementById('jump_select').getValue();

  for (var radioCnt = 0; radioCnt < radio_sel.length; radioCnt++) {
    if (radio_sel[radioCnt].classList.contains('selected')) {
      switch(radio_sel[radioCnt].dataset.value) {
        case '1':  /* Time-Designated Method */
          g_program_data[activeTarget].param = Number(dtfrm.document.getElementById('wait_sec').getValue()).toFixed(2) + '(sec)';
          dtfrm.document.getElementById('jump_select').refresh(g_labelNumList,setvalue,null,true);
          break;
        case '2':  /* Selection Method */
          g_program_data[activeTarget].param = detail_cond_combine_wait();
          var array = g_labelNumList.toString(10).split(',');
          dtfrm.document.getElementById('jump_select').refresh(array, setvalue, null, false);
          if (dtfrm.document.getElementById('time_out_option').getValue() === "1") {
            g_program_data[activeTarget].param += " " + ORDER_TIMEOUT + "," + 
                                                  ORDER_LABEL + "[" + dtfrm.document.getElementById('jump_select').getValue() + "]";
          }
          break;
        case '3':  /* direct input method */
          g_program_data[activeTarget].param = setLangConvJpEng(dtfrm.document.getElementById('conditionValue').getValue());
          dtfrm.document.getElementById('jump_select').refresh(g_labelNumList, setvalue, null, true);
          break;
        default:
          break;
      }
      break;
    }
  }
  return true;
}

/*
 =========================================================================
 @function name : detail_cond_combine_wait
 @argument[]    : 
 @description   : Combine conditional statements.
 @return        : Combined string.
 =========================================================================
*/
function detail_cond_combine_wait() {
  var dtfrm = document.getElementById(get_detail_frm_id(activeTarget)).contentWindow;
  var cmbStr = '';

  /* Selector: left side */
  var getVal = dtfrm.document.getElementById('wait.variable_select').getValue();
  var getIdxVal = dtfrm.document.getElementById('wait.variable_index').getValue();
  cmbStr += getCondTpParts(detailCondVarSel_1, getVal);
  cmbStr += '[' + getIdxVal + ']';
  dtfrm.inputVal[COND_SIDE.LEFT][dtfrm.componentList[COMPO_TYPE.SELECT]['.variable_select'][getVal][0]].val = Number(getIdxVal);

  /* Selector: operator */
  if(dtfrm.document.getElementById('wait.operator_select1').style.display == 'block') {
    getVal = dtfrm.document.getElementById('wait.operator_select1').getValue();
    cmbStr += getCondTpParts(detailCondSelOpe_1, getVal);
  }
  else {
    getVal = dtfrm.document.getElementById('wait.operator_select2').getValue();
    cmbStr += getCondTpParts(detailCondSelOpe_2, getVal);
  }

  /* Selector: right side */
  if(dtfrm.document.getElementById('wait.value_select1').style.display == 'block') {
    getVal = dtfrm.document.getElementById('wait.value_select1').getValue();
    if (getVal !== '0') {
      cmbStr += getCondTpParts(detailCondVarSel_2, getVal);
    }
  }
  else if(dtfrm.document.getElementById('wait.value_select2').style.display == 'block') {
    getVal = dtfrm.document.getElementById('wait.value_select2').getValue();
    cmbStr += getCondTpParts(detailCondVarSel_3, getVal);
  }
  else {
  }
  
  if(dtfrm.document.getElementById('wait.indexarea').style.display == 'block') {
    getIdxVal = dtfrm.document.getElementById('wait.value_index').getValue();
    cmbStr += '[' + getIdxVal + ']';
    if(dtfrm.document.getElementById('wait.value_select1').style.display == 'block') {
      dtfrm.inputVal[COND_SIDE.RIGHT][dtfrm.componentList[COMPO_TYPE.SELECT]['.value_select1'][getVal][0]].val = Number(getIdxVal);
    }
    else if(dtfrm.document.getElementById('wait.value_select2').style.display == 'block') {
      dtfrm.inputVal[COND_SIDE.RIGHT][dtfrm.componentList[COMPO_TYPE.SELECT]['.value_select2'][getVal][0]].val = Number(getIdxVal);
    }
    else {}
  }
  else if(dtfrm.document.getElementById('wait.constarea').style.display == 'block') {
    var getValue = dtfrm.document.getElementById('wait.value_const').getText();
    if (getValue.startsWith('-')) {
      getValue = '(' + getValue + ')';
    }
    cmbStr += getValue;
  }
  else {
  }
  
  return cmbStr;
}

/*
 =========================================================================
 @function name : fixDataSave_if
 @argument[]    : 
 @description   : Value storage in g_program_data
 @return        : 
 =========================================================================
*/
function fixDataSave_if(saveParam, id, opeType, value, activeId, dtfrm) {
  var radio_sel = dtfrm.document.getElementsByClassName('radio-button-option');
  for (var radioCnt = 0; radioCnt < radio_sel.length; radioCnt++) {
    if (radio_sel[radioCnt].classList.contains('selected')) {
      /* Selection Method */
      if (radio_sel[radioCnt].dataset.value === '1') {
        g_program_data[activeTarget].param = detail_cond_combine_if();
      }
      /* direct input method */
      else {
        g_program_data[activeTarget].param = setLangConvJpEng(dtfrm.document.getElementById("conditionValue").getValue());
      }
      break;
    }
  }
  return true;
}

/*
 =========================================================================
 @function name : detail_cond_combine_if
 @argument[]    : none
 @description   : Combine conditional statements.
 @return        : Combined string.
 =========================================================================
*/
function detail_cond_combine_if() {
  var dtfrm = document.getElementById(get_detail_frm_id(activeTarget)).contentWindow;
  var cmbStr = '';
  var getVal = '';
  var getIdxVal = '';
  /* Selector: left side */
  if (dtfrm.document.getElementById('if.indexleftarea').style.display == 'block') {
    getVal = dtfrm.document.getElementById('if.variable_select').getValue();
    getIdxVal = dtfrm.document.getElementById('if.variable_index').getValue();
    cmbStr += getCondTpParts(detailCondVarSelIf_1, getVal);
    cmbStr += '[' + getIdxVal + ']';
    dtfrm.inputVal[COND_SIDE.LEFT][dtfrm.componentList[COMPO_TYPE.SELECT]['.variable_select'][getVal][0]].val = Number(getIdxVal);
  }
  else if(dtfrm.document.getElementById('if.constleftarea').style.display == 'block') {
    getVal = dtfrm.document.getElementById('if.variable_const').getText();
    if(getVal.startsWith('-')) {
      cmbStr += '(' + getVal + ')';
    }
    else {
      cmbStr += getVal;
    }
  }
  else {
    getVal = dtfrm.document.getElementById('if.variable_select').getValue();
    cmbStr += getCondTpParts(detailCondVarSelIf_1, getVal);
  }

  /* Selector: operator */
  if(dtfrm.document.getElementById('if.operator_select1').style.display == 'block') {
    getVal = dtfrm.document.getElementById('if.operator_select1').getValue();
    cmbStr += getCondTpParts(detailCondSelOpe_1, getVal);
  }
  else {
    getVal = dtfrm.document.getElementById('if.operator_select2').getValue();
    cmbStr += getCondTpParts(detailCondSelOpe_2, getVal);
  }

  /* Selector: right side */
  if(dtfrm.document.getElementById('if.value_select1').style.display == 'block') {
    getVal = dtfrm.document.getElementById('if.value_select1').getValue();
    if (getVal !== '0') {
      cmbStr += getCondTpParts(detailCondVarSelIf_2, getVal);
    }
  }
  else if(dtfrm.document.getElementById('if.value_select2').style.display == 'block') {
    getVal = dtfrm.document.getElementById('if.value_select2').getValue();
    cmbStr += getCondTpParts(detailCondVarSelIf_3, getVal);
  }
  else {
  }
  if(dtfrm.document.getElementById('if.indexarea').style.display == 'block') {
    getIdxVal = dtfrm.document.getElementById('if.value_index').getValue();
    cmbStr += '[' + getIdxVal + ']';
    if(dtfrm.document.getElementById('if.value_select1').style.display == 'block') {
      dtfrm.inputVal[COND_SIDE.RIGHT][dtfrm.componentList[COMPO_TYPE.SELECT]['.value_select1'][getVal][0]].val = Number(getIdxVal);
    }
    else if(dtfrm.document.getElementById('if.value_select2').style.display == 'block') {
      dtfrm.inputVal[COND_SIDE.RIGHT][dtfrm.componentList[COMPO_TYPE.SELECT]['.value_select2'][getVal][0]].val = Number(getIdxVal);
    }
    else {}
  }
  else if(dtfrm.document.getElementById('if.constarea').style.display == 'block') {
    getVal = dtfrm.document.getElementById('if.value_const').getText();
    if(getVal.startsWith('-')) {
      cmbStr += '(' + getVal + ')';
    }
    else {
      cmbStr += getVal;
    }
  }
  else {
  }
  
  return cmbStr;
}

/*
 =========================================================================
 @function name  : getCondTpParts
 @argument[tbl]  : Tables to search.
 @argument[val]  : input value.
 @description    : Find and return an input value in a table.
 @return         : The corresponding TP.
 =========================================================================
*/
function getCondTpParts(tbl, val) {
	var tpStr = '';
	for(var cnt in tbl) {
		if(val === tbl[cnt].val) {
			tpStr = tbl[cnt].tp;
			break;
		}
	}
	return tpStr;
}

/*
 =========================================================================
 @function name : fixDataSave_regi
 @argument[]    : 
 @description   : Value storage in g_program_data
 @return        : 
 =========================================================================
*/
function fixDataSave_regi(saveParam, id, opeType, value, activeId, dtfrm) {
  var setParam = ORDER_REGI + '[';
  if(dtfrm.document.getElementsByClassName('radio-button-option')[0].classList.contains('selected')) {
    setParam += dtfrm.document.getElementById('regi_index').getValue() + ']=';
    
    var getVal = dtfrm.document.getElementById('regi_val_select').getValue();
    if(getVal != '0') setParam += dtfrm.selectRegiValList[getVal][0] + '[';
    if(dtfrm.document.getElementById('indexarea').style.display == 'block') {
      var getIdxVal = dtfrm.document.getElementById('regi_val_index').getValue();
      setParam += getIdxVal + ']';
      
      dtfrm.inputVal[dtfrm.selectRegiValList[getVal][0]].val = Number(getIdxVal);
    }
    else if(dtfrm.document.getElementById('constarea').style.display == 'block') {
      var getVal = dtfrm.document.getElementById('regi_val_const').getText();
      if(getVal.startsWith('-')) {
        setParam += '(' + getVal + ')';
      }
      else {
        setParam += getVal;
      }
    }
    else {
    }
  }
  else {  /* direct input */
    /* Conditional expression */
    setParam += setLangConvJpEng(dtfrm.document.getElementById("regi").getValue() + "]=" + dtfrm.document.getElementById("regi_val").getValue());
  }
  g_program_data[activeTarget].param = setParam;
  return true;
}

/*
 =========================================================================
 @function name   : detail_optInstructionSet
 @argument[dtfrm] : 
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function detail_optInstructionSet(id, vOffsetVal, param) {
  var dtfrm = document.getElementById(get_detail_frm_id(activeTarget)).contentWindow;
  var formList = dtfrm.document.getElementsByClassName('input-form-list-row');
  var setOptStr = [];
  var editElmId = id;
  var val = '';
  var voffsetParam = '';
  var voffsetChkStr = new RegExp('^(' + ORDER_VOFFSET + '|VOFFSET)$');
  var vrChkStr = new RegExp('(' + ORDER_VOFFSET + '\\,' + ORDER_VR + '|VOFFSET\\,VR)');
  var voffsetStr = ORDER_VOFFSET + ',' + ORDER_VR;
  var laserStr = new RegExp('((' + ORDER_LS + '|' + ORDER_LS_SCH + '|' + ORDER_LE + '|' + ORDER_SLPU + '|' + ORDER_SLPD + ')\\[|' + ORDER_PLE_LS + ')');
  var laserParamIndx = '';
  var targetChk_vsn = ['vsnline', 'vsnjoint'].includes(g_program_data[activeTarget].baseId);
  var targetChk_lsr = ['laserpre', 'laserls', 'laserle', 'laserkpre', 'laserkls', 'laserkle', 'lasercls', 'lasercle', 'lasercals', 'lasercale', 'lasersls', 'lasersle'].includes(g_program_data[activeTarget].baseId);
  if(g_program_data[activeTarget].baseId != 'curve' && param.length > 0) {
    if(id.indexOf('addmotion_') != -1) id = 'addmotion_';
    for(var i in param) {
      if(param[i].match(new RegExp('(' + ORDER_VOFFSET + '\\,' + ORDER_VR + '|^' + ORDER_VOFFSET + '$)'))) {
        if(voffsetParam == '') voffsetParam = param[i];
//        break;
      }
      if(targetChk_lsr && param[i].match(laserStr)) {
        if(laserParamIndx == '') laserParamIndx = i;
      }
    }
    switch(id) {
      case('addmotion_'):
        if(vOffsetVal.match(voffsetChkStr) || vOffsetVal.match(vrChkStr)) {
          param.push((vOffsetVal.match(vrChkStr)) ? voffsetStr : ORDER_VOFFSET);

          val = param.filter(function(value) {
            return value.match(new RegExp('(^' + ORDER_VOFFSET + '\\,' + ORDER_VR + '|^' + ORDER_VOFFSET + '$)'));
          });
          if(val.length <= 2) {
            val = targetChk_vsn ? "'voffset is Already Used'" : '';
          } else if(val.length > 2) {
            val = "'voffset is Already Used'";
          } else {}
        } else {
          val = (targetChk_vsn) ? voffsetParam : '';
        }
        break;
      case ('selType'):
        if(vOffsetVal == 0) {
          val = setLangConvJpEng(voffsetStr + '[1]');
        } else if(vOffsetVal == -1) {
          val = setLangConvJpEng(ORDER_VOFFSET);
        } else {}
        break;
      case ('selVRIndex'):
        var setVal = vOffsetVal;
        var selData = dtfrm.VRIndirectOrder.find(function(array) {
          return array[1] == vOffsetVal;
        });
        if(selData) setVal = selData[0] + '[' + selData[4] + ']';
        val = setLangConvJpEng(voffsetStr + '[' + setVal + ']');
        break;
      case ('index_val.textbox'):
        if(voffsetParam.match(new RegExp(ORDER_VOFFSET + '\\,' + ORDER_VR + '\\[' + ORDER_REGI + '\\['))) {
          val = voffsetStr + '[' + ORDER_REGI + '[' + vOffsetVal + ']]';
          dtfrm.VRIndirectOrder[0][4] = vOffsetVal;
        }
        else if(voffsetParam.match(new RegExp(ORDER_VOFFSET + '\\,' + ORDER_VR + '\\[' + ORDER_ARGUMENT + '\\['))) {
          val = voffsetStr + '[' + ORDER_ARGUMENT + '[' + vOffsetVal + ']]';
          dtfrm.VRIndirectOrder[1][4] = vOffsetVal;
        } else {}
        break;
      case('option_formlist'):
        if(targetChk_vsn) val = setLangConvJpEng(voffsetParam);
        break;
      default:
        val = (targetChk_vsn) ? voffsetParam : "";
        break; 
    }
    if(val) setOptStr.push(val);
  }
  for(var cnt = 0; cnt < formList.length; cnt++) {
    var setParam = dtfrm.document.getElementById('addmotion_' + (cnt + 1)).getValue();
    /*5/17 add*/
    if(setParam.match(/^\s+$/) != null) setParam = '';
    if((targetChk_vsn) && (setParam.match(voffsetChkStr) || setParam.match(vrChkStr))) {
      setParam = '';
    } else if(!targetChk_vsn && (setParam.match(voffsetChkStr) || setParam.match(vrChkStr))) {
      sameCnt++;
    } else {}

    if (setParam !== '') {
      /* remove spaces at both ends */
      setParam = setParam.trim();
      if(sameCnt >= 2 && (vOffsetVal.match(voffsetChkStr) || vOffsetVal.match(vrChkStr))) {
        setOptStr.push("'voffset is Already Used'");
      } else {
        setOptStr.push(setLangConvJpEng(setParam));
      }
    }
  }
  sameCnt = 0;
  if(laserParamIndx) {
    /* Laser additional motion insertion position check. */
    var insPos = (id === 'addmotion_' && vOffsetVal == '' && (editElmId.replace('addmotion_', '') - 1) < laserParamIndx) ?
                    (laserParamIndx - 1) : (laserParamIndx >= 0) ? laserParamIndx : 0;
    setOptStr.splice(insPos, 0, param[laserParamIndx]);
  }
  return setOptStr;
}

/*
 =========================================================================
 @function name   : paramSet_offsetMotion
 @argument[dtfrm] : 
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function paramSet_offsetMotion(dtfrm) {
  var offsetSel = dtfrm.document.getElementById('viaOffset').getValue();
  if(offsetSel == '0') {
    if(g_program_data[activeTarget].position[0].offsetMotion) delete g_program_data[activeTarget].position[0]['offsetMotion'];
  }
  else {
    var offsetTbl = {
      '1'  : {offset:langResource.ihmieditor_order_offset_c                                                        },
      '2'  : {offset:langResource.ihmieditor_order_offset_c + ',' + ORDER_POSREGI + '['                            },
      '3'  : {offset:langResource.ihmieditor_order_offset_c + ',' + ORDER_POSREGI + '[' + ORDER_REGI + '['         },
      '4'  : {offset:langResource.ihmieditor_order_offset_c + ',' + ORDER_POSREGI + '[' + ORDER_ARGUMENT + '['     },
      '5'  : {offset:langResource.ihmieditor_order_tool_offset_c                                                   },
      '6'  : {offset:langResource.ihmieditor_order_tool_offset_c + ',' + ORDER_POSREGI + '['                       },
      '7'  : {offset:langResource.ihmieditor_order_tool_offset_c + ',' + ORDER_POSREGI + '[' + ORDER_REGI + '['    },
      '8'  : {offset:langResource.ihmieditor_order_tool_offset_c + ',' + ORDER_POSREGI + '[' + ORDER_ARGUMENT + '['},
      '9'  : {offset:langResource.ihmieditor_order_voffset_c                                                       },
      '10' : {offset:langResource.ihmieditor_order_voffset_c + ',' + ORDER_VR + '['                                },
      '11' : {offset:langResource.ihmieditor_order_voffset_c + ',' + ORDER_VR + '[' + ORDER_REGI + '['             },
      '12' : {offset:langResource.ihmieditor_order_voffset_c + ',' + ORDER_VR + '[' + ORDER_ARGUMENT + '['         },
    };
    var param = offsetTbl[offsetSel].offset;
    var kind = Number(offsetSel) % 4;
    if(kind != 1) {
      if(kind == 2) {
        param += dtfrm.document.getElementById('offset_indexVal').getValue() + ']';
      }
      else {
        param += dtfrm.document.getElementById('offset_indIndexVal').getValue() + ']]';
      }
    }
    g_program_data[activeTarget].position[0].offsetMotion = param;
  }
}

/*
 =========================================================================
 @function name : fixDataSave_for
 @argument[]    : 
 @description   : Value storage in g_program_data
 @return        : 
 =========================================================================
*/
function fixDataSave_for(saveParam, id, opeType, value, activeId, dtfrm) {
  var getParam = function(dtfrm, str) {
    var list = str == 'loop' ? dtfrm.selectLoopList : dtfrm.selectOptionList;
    var select = dtfrm.document.getElementById(str + '_val').getValue();
    for(var cnt = 0; cnt < list['disp'].length; cnt++) {
      if(list['disp'][cnt][1] == select) {
        var setVal = dtfrm.document.getElementById(str + '_val' + (cnt + 1)).getValue();
        /* Add '()' for negative numbers. */
        if(Number(setVal) < 0) setVal = '(' + setVal + ')';
        g_program_data[activeTarget].param += list['order'][cnt] + setVal;
        /* Add the same number of ']' as '['. */
        for(var i = 0; i < (list['order'][cnt].match(/\[/g) || []).length; i++) {
          g_program_data[activeTarget].param += ']';
        }
        if(str == 'loop') g_program_data[activeTarget].param += '=';
        break;
      }
    }
  }
  g_program_data[activeTarget].param = 'FOR ';
  getParam(dtfrm, 'loop');
  getParam(dtfrm, 'init');
  g_program_data[activeTarget].param += dtfrm.document.getElementById('to_down').getValue() == 0 ? ' TO ': ' DOWNTO ';
  getParam(dtfrm, 'end');
  return true;
}

/*
 =========================================================================
 @function name : fixDataSave_jump
 @argument[]    : 
 @description   : Value storage in g_program_data
 @return        : 
 =========================================================================
*/
function fixDataSave_jump(saveParam, id, opeType, value, activeId, dtfrm) {
  var setParamNum = dtfrm.document.getElementById("jump_select").getValue();
  if(setParamNum == "") setParamNum = "...";
  g_program_data[activeTarget].param = ORDER_JUMP + " " + ORDER_LABEL + "[" + setParamNum + "]";
  return true;
}

/*
 =========================================================================
 @function name : fixDataSave_label
 @argument[]    : 
 @description   : Value storage in g_program_data
 @return        : 
 =========================================================================
*/
function fixDataSave_label(saveParam, id, opeType, value, activeId, dtfrm) {
  var val = dtfrm.document.getElementById("label_text").getValue();
  if(val === "") val = 0;
  g_program_data[activeTarget].param = ORDER_LABEL + "[" + val + "]";
  return true;
}

/*
 =========================================================================
 @function name : fixDataSave_output
 @argument[]    : 
 @description   : Value storage in g_program_data
 @return        : 
 =========================================================================
*/
function fixDataSave_output(saveParam, id, opeType, value, activeId, dtfrm) {
  var o_type = '';
  var radioList = {
    '1': {select:'DO'},
    '2': {select:'RO'},
    '3': {select:'AO'},
    '4': {select:'GO'},
    '5': {select:'F' },
    '6': {select:'direct' },
  };
  var radio_sel = dtfrm.document.getElementsByClassName('radio-button-option');
  for (var radioCnt = 0; radioCnt < radio_sel.length; radioCnt++) {
    if (radio_sel[radioCnt].classList.contains('selected')) {
      o_type = radioList[dtfrm.document.getElementById("output_list").getValue()].select;
      g_program_data[activeTarget].param = setLangConvJpEng(detail_output_paramSet(o_type, id));
      break;
    }
  }
  return true;
}

/*
 =========================================================================
 @function name   : detail_output_paramSet
 @argument[]      : none
 @description     : 
 @return          : Set parameter
 =========================================================================
*/
function detail_output_paramSet(o_type, chgId) {
  setParam = '';
  var directSelList = {
    'DO': {initVal:ORDER_ON},
    'RO': {initVal:ORDER_ON},
    'AO': {initVal:'1'},
    'GO': {initVal:'1'},
    'F' : {initVal:'(' + ORDER_ON + ')'},
  };
  
  var dtfrm = document.getElementById(get_detail_frm_id(activeTarget)).contentWindow;
  if(o_type === 'direct') {      /* direct */
    var selVal = dtfrm.document.getElementById('direct_select').getValue();
    var select = dtfrm.selectOutPutList.find(function(data) { return data[1] == selVal; });
    if(select) {
      setParam = select[0] + '[' + dtfrm.document.getElementById('direct_regi').getValue() + ']=';
      if(chgId === 'direct_select') {
        dtfrm.document.getElementById('direct_ins').refresh(langConvEng(directSelList[select[0]].initVal),
                                                            dtfrm.outputComponent[5]['direct_ins'].length,
                                                            false);
        setParam += directSelList[select[0]].initVal;
      }
      else {
        setParam += dtfrm.document.getElementById('direct_ins').getValue();
      }
    }
    else {
      setParam = 'DO[1]=' + directSelList['DO'].initVal;
    }
  }
  else {
    var oTypeLower = o_type.toLowerCase();
    setParam = o_type + "[" + dtfrm.document.getElementById(oTypeLower + "_regi").getValue() + "]=";
    /* DO/RO/F */
    if(o_type === 'DO' || o_type === 'RO' || o_type === 'F') {
      var listVal = dtfrm.document.getElementById(oTypeLower + "_ins").getValue();
      var selData = (dtfrm.selectOnOffList[0][1] === listVal) ? dtfrm.selectOnOffList[0] : dtfrm.selectOnOffList[1];
      setParam += (o_type === 'DO' || o_type === 'RO') ? langConvEng(selData[0]) : '(' + langConvEng(selData[0]) + ')';
    }
    /* AO/GO */
    else {
      var getValue = dtfrm.document.getElementById(oTypeLower + "_ins").getText();
      if (getValue.startsWith('-')) {
        getValue = '(' + getValue + ')';
      }
      setParam += getValue;
    }
  }
  return setParam;
}

/*
 =========================================================================
 @function name : fixDataSave_payload
 @argument[]    : 
 @description   : Value storage in g_program_data
 @return        : 
 =========================================================================
*/
function fixDataSave_payload(saveParam, id, opeType, value, activeId, dtfrm) {
  if (dtfrm.payloadVer === '1') {
    dtfrm.payloadVer = '2';
  }
  var selType = dtfrm.document.getElementById('payload_select').getValue();
  var num = (selType === '0') ? dtfrm.document.getElementById('payload_const').getValue() :
                                ORDER_REGI + '[' + dtfrm.document.getElementById('payload_index').getValue() + ']';
  var time = dtfrm.document.getElementById('time_val').getValue();

  var setParam = (time != '0') ? ORDER_CALL + ' -INST_PAYLOAD(2,' + selType + ',' + num + ',' + time + ')' :
                                 ORDER_PAYLOAD + '[' + num + ']';
  g_program_data[activeTarget].param = setParam;
  /* Multi group check */
  if(payload_motionGrpChk() && id == 'time_val.textbox' && time == '0') {
    dtfrm.document.getElementById('time_val').refresh(time, '0.00', '0.00', true);
  }
  return true;
}

/*
 =========================================================================
 @function name : fixDataSave_comment
 @argument[]    : 
 @description   : Value storage in g_program_data
 @return        : 
 =========================================================================
*/
function fixDataSave_comment(saveParam, id, opeType, value, activeId, dtfrm) {
  g_program_data[activeTarget].param = dtfrm.document.getElementById("comment").getValue();
  timeline_commentDispCheck(activeTarget);
  return true;
}

/*
 =========================================================================
 @function name : fixDataSave_nosupport
 @argument[]    : 
 @description   : Value storage in g_program_data
 @return        : 
 =========================================================================
*/
function fixDataSave_nosupport(saveParam, id, opeType, value, activeId, dtfrm) {
  g_program_data[activeTarget].param = setLangConvJpEng(dtfrm.document.getElementById("text_form").getValue());
  return true;
}

/*
 =========================================================================
 @function name       : fixDataSave_frame
 @argument[dtfrm]     : Frame on the detail screen.
 @description         : Value storage in g_program_data
 @return              : 
 =========================================================================
*/
function fixDataSave_frame(saveParam, id, opeType, value, activeId, dtfrm){
  var order = (g_program_data[activeTarget].baseId === 'setuframe' || g_program_data[activeTarget].baseId === 'setutool') ? 'SET' : 'SEL';
  var judgeStr = (g_program_data[activeTarget].baseId === 'setuframe' || g_program_data[activeTarget].baseId === 'seluframe') ? 'uframe' : 'utool';
  var gpflag = 0;
  var getParam = function(order, str, dtfrm) {
    var list = dtfrm.selectList;
    var setParam = "";
    var group = dtfrm.document.getElementById('group_val').getValue();
    var select = dtfrm.document.getElementById(str + '_val').getValue();
  
    if(g_program_data[activeTarget].param.indexOf("GP") != -1) gpflag = 1;
    switch(order){
      case 'SET':
        for(var cnt = 0; cnt < list['disp'].length; cnt++) {
          if(list['disp'][cnt][1] == select) {
            var setVal = dtfrm.document.getElementById(str + '_val' + (cnt + 1)).getValue();
            if(setVal == '-1') setVal = "...";
            setParam = list['order'][cnt] + setVal;
            /* Add the same number of ']' as '['. */
            for(var i = 0; i < (list['order'][cnt].match(/\[/g) || []).length; i++) {
              setParam += ']';
            }
            if(str == 'uframe' || str == 'utool'){
              var orderStr = str == 'uframe' ? ORDER_UFRAME : ORDER_UTOOL;
              g_program_data[activeTarget].param = orderStr + '[' + setParam + ']' + '=';
            }
            else if(str == 'posReg'){
              if(gpflag == 1) {
                g_program_data[activeTarget].param += ORDER_POSREGI + "[GP" + group + ":" + setParam + "]";
              }else{
                posRegParam = setParam;
                g_program_data[activeTarget].param += ORDER_POSREGI + "[" + setParam + "]";
              }
            }
            break;
          }
        }
        break;
      case 'SEL':
        for(var cnt = 0; cnt < list['disp'].length; cnt++) {
          if(list['disp'][cnt][1] == select) {
            var setVal = dtfrm.document.getElementById(str + '_val' + (cnt + 1)).getValue();
            if(setVal == '-1') setVal = "...";
            var orderStr = str == 'uframe' ? ORDER_UFRAME_NUM : ORDER_UTOOL_NUM;
            setParam = list['order'][cnt] + setVal;
            /* Add the same number of ']' as '['. */
            for(var i = 0; i < (list['order'][cnt].match(/\[/g) || []).length; i++) {
              setParam += ']';
            }
            break;
          }
        }
        g_program_data[activeTarget].param = gpflag == 0 ? orderStr + "=" + setParam : orderStr + "[GP" + group + "]" + "=" + setParam;
        break;
      default:
        break;
    }
  }
  getParam(order, judgeStr, dtfrm);
  if(order == 'SET') getParam(order, 'posReg', dtfrm);

  return true;
}

/*
 =========================================================================
 @function name : fixDataSave_adinst
 @argument[]    : 
 @description   : Value storage in g_program_data
 @return        : 
 =========================================================================
*/
function fixDataSave_adinst(saveParam, id, opeType, value, activeId, dtfrm) {
  var targetId = activeTarget;
  var instObj = g_inst_obj[g_program_data[activeTarget].baseId];
  if ((instObj.detail.appName == saveParam.substring(0, saveParam.indexOf('('))) ||
      (saveParam.substring(0, saveParam.indexOf('(')) == "" && saveParam == instObj.detail.appName)) {
    g_program_data[activeTarget].param = saveParam;
  } else {
    targetId = get_stretch_pairId(activeTarget, REQ_ID_KIND_END, null);
    g_program_data[targetId].param = saveParam;
  }
  /* Position information available */
  if (g_program_data[targetId].position.length != 0) {
    posFix(activeId); /* "activeId" is undefined except for END */
  }
  return true;
}

/*
 =========================================================================
 @function name : fixDataSave_weldstartml
 @argument[]    : 
 @description   : Value storage in g_program_data
 @return        : 
 =========================================================================
*/
function fixDataSave_weldstartml(saveParam, id, opeType, value, activeId, dtfrm) {
  /* Speed */
  paramSet_speed(dtfrm);
  /* Route */
  paramSet_route(dtfrm);
  /* Additional motion */
  g_program_data[activeTarget].addMotion = detail_optInstructionSet(id, value, g_program_data[activeTarget].addMotion); 

  // set arc param
  var wpParam = '';
  var schParam = '';
  var selectWpObj = dtfrm.dispParam.getWeldProcNum();
  var selectSchObj = dtfrm.dispParam.getWeldSchNum();

  wpParam = (selectWpObj.value !== '') ? selectWpObj.value : '...';
  if(selectWpObj.isRegi){
    wpParam = ORDER_REGI + '[' + wpParam + ']';
  }

  schParam = (selectSchObj.value !== '') ? selectSchObj.value : '...';
  if(selectSchObj.isRegi){
    schParam = ORDER_REGI + '[' + schParam + ']';
  }

  g_program_data[activeTarget].addMotion.push(ORDER_WELDSTART + '[' + wpParam + ',' + schParam + ']');

  posNumChk(activeTarget, null);
  posFix();
  return true;
}

/*
 =========================================================================
 @function name : fixDataSave_weldstopml
 @argument[]    : 
 @description   : Value storage in g_program_data
 @return        : 
 =========================================================================
*/
function fixDataSave_weldstopml(saveParam, id, opeType, value, activeId, dtfrm) {
  /* Speed */
  paramSet_speed(dtfrm);
  /* Route */
  paramSet_route(dtfrm);
  /* Additional motion */
  g_program_data[activeTarget].addMotion = detail_optInstructionSet(id, value, g_program_data[activeTarget].addMotion);
  // set arc param
  var wpParam = '';
  var schParam = '';
  var selectWpObj = dtfrm.dispParam.getWeldProcNum();
  var selectSchObj = dtfrm.dispParam.getWeldSchNum();
  var weldIdNum = dtfrm.dispParam.getWeldIdNum();

  wpParam = (selectWpObj.value !== '') ? selectWpObj.value : '...';
  if(selectWpObj.isRegi){
    wpParam = ORDER_REGI + '[' + wpParam + ']';
  }

  schParam = (selectSchObj.value !== '') ? selectSchObj.value : '...';
  if(selectSchObj.isRegi){
    schParam = ORDER_REGI + '[' + schParam + ']';
  }
  if(g_sysval['$AWSCFG.$WELD_ID_ENA'].value){
    g_program_data[activeTarget].addMotion.push(ORDER_WELDEND + '[' + wpParam + ',' + schParam + ',WID:'+ weldIdNum +']');
  } else {
    g_program_data[activeTarget].addMotion.push(ORDER_WELDEND + '[' + wpParam + ',' + schParam + ']');
  }
  posNumChk(activeTarget, null);
  posFix();
  return true;
}

/*
 =========================================================================
 @function name : fixDataSave_weldstartal
 @argument[]    : 
 @description   : Value storage in g_program_data
 @return        : 
 =========================================================================
*/
function fixDataSave_weldstartal(saveParam, id, opeType, value, activeId, dtfrm) {
  var param = g_program_data[activeTarget].param.split(/\s+/);
  /* option instruction set */
  g_program_data[activeTarget].param = '';
  g_program_data[activeTarget].param = detail_optInstructionSet(id, value, param);
  // set arc param
  var wpParam = '';
  var schParam = '';
  var selectWpObj = dtfrm.dispParam.getWeldProcNum();
  var selectSchObj = dtfrm.dispParam.getWeldSchNum();

  wpParam = (selectWpObj.value !== '') ? selectWpObj.value : '...';
  if(selectWpObj.isRegi){
    wpParam = ORDER_REGI + '[' + wpParam + ']';
  }

  schParam = (selectSchObj.value !== '') ? selectSchObj.value : '...';
  if(selectSchObj.isRegi){
    schParam = ORDER_REGI + '[' + schParam + ']';
  }

  if(g_program_data[activeTarget].param !== ''){
    g_program_data[activeTarget].param += ' ';
  }
  g_program_data[activeTarget].param += ORDER_WELDSTART + '[' + wpParam + ',' + schParam + ']';
  return true;
}

/*
 =========================================================================
 @function name : fixDataSave_weldstopal
 @argument[]    : 
 @description   : Value storage in g_program_data
 @return        : 
 =========================================================================
*/
function fixDataSave_weldstopal(saveParam, id, opeType, value, activeId, dtfrm) {
  var param = g_program_data[activeTarget].param.split(/\s+/);
  /* option instruction set */
  g_program_data[activeTarget].param = '';
  g_program_data[activeTarget].param = detail_optInstructionSet(id, value, param);
  // set arc param
  var wpParam = '';
  var schParam = '';
  var selectWpObj = dtfrm.dispParam.getWeldProcNum();
  var selectSchObj = dtfrm.dispParam.getWeldSchNum();
  var weldIdNum = dtfrm.dispParam.getWeldIdNum();

  wpParam = (selectWpObj.value !== '') ? selectWpObj.value : '...';
  if(selectWpObj.isRegi){
    wpParam = ORDER_REGI + '[' + wpParam + ']';
  }

  schParam = (selectSchObj.value !== '') ? selectSchObj.value : '...';
  if(selectSchObj.isRegi){
    schParam = ORDER_REGI + '[' + schParam + ']';
  }

  if(g_program_data[activeTarget].param !== ''){
    g_program_data[activeTarget].param += ' ';
  }
  if(g_sysval['$AWSCFG.$WELD_ID_ENA'].value){
    g_program_data[activeTarget].param += ORDER_WELDEND + '[' + wpParam + ',' + schParam + ',WID:'+ weldIdNum +']';
  } else {
    g_program_data[activeTarget].param += ORDER_WELDEND + '[' + wpParam + ',' + schParam + ']';
  }
  return true;
}

/*
 =========================================================================
 @function name : fixDataSave_detectjoint
 @argument[]    : 
 @description   : 
 @return        : 
 =========================================================================
*/
function fixDataSave_detectjoint(saveParam, id, opeType, value, activeId, dtfrm) {
  g_program_data[activeTarget].param = '';
  var sensorNum = dtfrm.appParams.getSenser().toString();
  var posRegNum = dtfrm.appParams.getSearchPosNum().toString();
  g_program_data[activeTarget].param += ORDER_DETECT_JOINT + '[' + sensorNum + ',' + posRegNum + ']';
  return true;
}

/*
 =========================================================================
 @function name : fixDataSave_trackdpm
 @argument[]    : 
 @description   : 
 @return        : 
 =========================================================================
*/
function fixDataSave_trackdpm(saveParam, id, opeType, value, activeId, dtfrm) {
  g_program_data[activeTarget].param = '';
  var dpmArg = '';
  if (dtfrm.appParams.getIsReg()) {
    var sensorRegNum = dtfrm.appParams.getSensorRegNum()
    dpmArg += ORDER_REGI + '[' + sensorRegNum.toString() + ']';
  } else {
    var sensorNum = dtfrm.appParams.getSensorNum();
    dpmArg += (sensorNum == 0) ? '...' : sensorNum.toString();
  }
  g_program_data[activeTarget].param += ORDER_TRACK_DPM + '[' + dpmArg + ']';
  return true;
}

/*
 =========================================================================
 @function name : fixDataSave_motion_laser
 @argument[]    : 
 @description   : Value storage in g_program_data
 @return        : 
 =========================================================================
*/
function fixDataSave_motion_laser(saveParam, id, opeType, value, activeId, dtfrm) {
  /* Speed */
  paramSet_speed(dtfrm);
  /* Route */
  paramSet_route(dtfrm);
  /* Additional motion */
  g_program_data[activeTarget].addMotion = detail_optInstructionSet(id, value, g_program_data[activeTarget].addMotion);
  /* Have two or more positions. */
  if(g_program_data[activeTarget].position.length >= 2) {
    paramSet_offsetMotion(dtfrm);
  }
  
  posNumChk(activeTarget, null);
  posFix();
  
  create_laser_data(dtfrm, g_program_data[activeTarget].baseId);
  return true;
}

/*
 =========================================================================
 @function name : fixDataSave_laser_si
 @argument[]    : 
 @description   : Value storage in g_program_data
 @return        : 
 =========================================================================
*/
function fixDataSave_laser_si(saveParam, id, opeType, value, activeId, dtfrm) {
  create_laser_data(dtfrm, g_program_data[activeTarget].baseId);
  return true;
}

/*
 =========================================================================
 @function name : fixDataSave_laserpow
 @argument[]    : 
 @description   : Value storage in g_program_data
 @return        : 
 =========================================================================
*/
function fixDataSave_laserpow(saveParam, id, opeType, value, activeId, dtfrm) {
  var setParam = ORDER_PWC + '[';

  setParam += (dtfrm.document.getElementById('pwc_pos').getValue() == 1) ?
               dtfrm.document.getElementById('ctrl_table').getValue() + ']' :
               ORDER_REGI +'[' + dtfrm.document.getElementById('ctrl_reg').getValue() + ']]';

  g_program_data[activeTarget].param = setParam;
  return true;
}

/*
 =========================================================================
 @function name : fixDataSave_laserwirc
 @argument[]    : 
 @description   : Value storage in g_program_data
 @return        : 
 =========================================================================
*/
function fixDataSave_laserwirc(saveParam, id, opeType, value, activeId, dtfrm) {
  var setParam = ORDER_WIRC + '[Ty=';

  /* Wire feed type */
  setParam += (dtfrm.document.getElementById('pwc_pos').getValue() == 1) ?
                dtfrm.document.getElementById('ctrl_table').getValue() + ',Sp=' :
                ORDER_REGI + '[' + dtfrm.document.getElementById('ctrl_reg').getValue() + '],Sp=';

  /* Wire feed speed */
  setParam += (dtfrm.document.getElementById('pwc_pos2').getValue() == 1) ?
                dtfrm.document.getElementById('ctrl_table2').getValue() + ']' :
                ORDER_REGI + '[' + dtfrm.document.getElementById('ctrl_reg2').getValue() + ']]';

  g_program_data[activeTarget].param = setParam;
  return true;
}

/*
 =========================================================================
 @function name   : detail_valReplace_chk
 @argument[]      : 
 @description     : 
 @return          : 
 =========================================================================
*/
function detail_valReplace_chk(chkVal) {
  if(chkVal === '') {
    chkVal = '0';
  }
  
  return chkVal;
}

/*
 =========================================================================
 @function name   : getSplitId
 @argument[]      : 
 @description     : 
 @return          : TPname split ID
 =========================================================================
*/
function getSplitId(targetId){
  var splitIdNum = '';
  if(typeof g_program_data[targetId] == "undefined") {
    var tblChk = iconSortTbl.find(function(key) {
      return targetId.split(key).length > 1;
    });
    if(tblChk == undefined) return splitIdNum;
    var splitId = targetId.split(tblChk);
    if(splitId[1].match(/[^0-9*]/g) == null) {
      splitIdNum = Number(splitId[1]);
    }
  }
  else {
    splitIdNum = Number(targetId.replace(g_program_data[targetId].baseId, ''));
  }

  return splitIdNum;
}

/*
 =========================================================================
 @function name   : getNestIdList
 @argument[]      : 
 @description     : 
 @return          : parent bracket id
 =========================================================================
*/
function getNestIdList(chkPrgName) {
  var parentIdList = [];
  var idCnt = 0;
  var chkNestNum = 0;
  var parentChkFlg = true;
  var beforeNestNum = "";
  var tpName = "";
  var targetId = "";
  if (activeTarget != "") {
    targetId = activeTarget;
  } else if (g_adintarget != "") {
    targetId = g_adintarget;
  } else if (activeTarget == "" && g_btnTeaching_list.weldteach.existsTimeline == true) {
    targetId = g_btnTeaching_list.weldteach.id;
  }
  /*get activeIcon nestId */
  var tl = g_TL_progInfo.dispProg;
  var targetTlnum = get_TL_targetOrder(targetId);
  /* descending order seach in timeline*/
  for (var cnt = targetTlnum - 1; cnt >= 0; cnt--) {
    /* bktend is not parent*/
    if(stretch_idStrChk(STRETCH_ID_CHK_END, tl[cnt])) continue;
    
    /* bktlead is endTimeline Number < targetTimeline Number parent*/
    if(stretch_idStrChk(STRETCH_ID_CHK_LEAD, tl[cnt])) {
      var endTlnum = tl.indexOf(get_stretch_pairId(tl[cnt], REQ_ID_KIND_END, null));
      if (endTlnum == -1 || (endTlnum > -1 && endTlnum < targetTlnum)) continue;
    }
    
    if(stretch_idStrChk(STRETCH_ID_CHK_ALL, tl[cnt])) {
      var leadId = get_stretch_pairId(tl[cnt], REQ_ID_KIND_LEAD, null);
      if(g_program_data[leadId].stretch.state == 'stretch_open') {
        chkNestNum = g_program_data[tl[cnt]].nest.num;
        if(beforeNestNum == chkNestNum) continue;
        beforeNestNum = chkNestNum;
        var parentTlnum = get_TL_targetOrder(tl[cnt]);
        tpName = (tl[cnt].match(/^bktlead/) != null) ? g_program_data[tl[cnt]].baseId.replace(/^bktlead/, '') :
                 (tl[cnt].match(/^bktend/) != null) ? g_program_data[tl[cnt]].baseId.replace(/^bktend/, '') :
                 (tl[cnt].match(/^iflead/) != null) ? "IF (" + g_program_data[tl[cnt]].param + ") THEN" :
                 (tl[cnt].match(/^forlead/) != null) ? g_program_data[tl[cnt]].param :
                 (tl[cnt].match(/^ifelse/) != null) ? g_program_data[tl[cnt]].param :
                 g_program_data[tl[cnt]].baseId;
        parentIdList[idCnt] = { parentId: tl[cnt], tpName: tpName, tlNum: parentTlnum };
        /*check parent TPname*/
        if (typeof chkPrgName != "undefined") {
          var chkName = chkPrgName.toUpperCase();
          if (chkName == parentIdList[idCnt].tpName.replace(/^bktlead/, '').toUpperCase() ||
              chkName == parentIdList[idCnt].tpName.toUpperCase()) {
            return true;
          } else {
            parentChkFlg = false;
          }
        }
        idCnt++;
        chkNestId = 0;
        if(g_program_data[tl[cnt]].nest.num == 1) break;
      }
    }
  }
  if (parentChkFlg == false || parentIdList.length == 0) {
    return false;
  } else {
    return parentIdList;
  }
}

/*
 =========================================================================
 @function name     : getProgNameList
 @argument[prgName] : The name of the program to get.
 @description       : Get a list of program names that use "prgName" from the beginning of the program name.
 @return            : TPprogramList
 =========================================================================
*/
function getProgNameList(prgName){
  var programList = [], param = "", endParam = "";
  if(typeof prgName != "undefined") {
    for(var i in g_inst_obj) {
      if(g_inst_obj[i].detail.appName.toUpperCase().startsWith(prgName.toUpperCase())) {
        param = "CALL " + g_inst_obj[i].detail.appName +
                    ((g_inst_obj[i].detail.param != "") ? "(" + g_inst_obj[i].detail.param + ")" : "");
        if(typeof g_inst_obj[i].end != "undefined") {
          if(g_inst_obj[i].end.appName.toUpperCase().startsWith(prgName.toUpperCase())) {
            endParam = "CALL " + g_inst_obj[i].end.appName +
                          ((g_inst_obj[i].end.param != "") ? "(" + g_inst_obj[i].end.param + ")" : "");
          }
        }
        programList.push({iconText: g_inst_obj[i].iconText, value: param, endValue: endParam});
        param = "", endParam = "";
      }
    }
  }
  return programList;
}


/*
 =========================================================================
 @function name   : wizard_posFix
 @argument[]      : 
 @description     : position object overwrite
 @return          :
 =========================================================================
*/
function wizard_posFix(bktEndId) {
  var totalPosCnt = 0, robotPos = '';
  var activePrgName = (typeof bktEndId != 'undefined') ? bktEndId : (g_adintarget != '') ? g_adintarget : activeTarget;
  if(activePrgName == '') return false;
  if(activePrgName == bktEndId) { totalPosCnt += g_program_data[activeTarget].position.length; }

  for(var i = 0; i < top.home.length; i++) {
    if(top.home[i] != undefined) {
      if(top.home[i].wizardPageContents != undefined) {
        /* get position component */
        robotPos = $(top.home[i].wizardPageContents).contents().find(".position");
        break;
      }
    }
  }
  if(robotPos == '') return false;
  pos_overwrite(activePrgName, robotPos, totalPosCnt);
}

/*
 =========================================================================
 @function name   : pos_overwrite
 @argument[]      : 
 @description     : 
 @return          :
 =========================================================================
*/
function pos_overwrite(activePrgName, robotPos, totalPosCnt){
  if(activePrgName == undefined || robotPos == undefined) return false;
  if(totalPosCnt == undefined) { totalPosCnt = 0; }

  setPosData(activePrgName, robotPos, totalPosCnt);
}

/*
 =========================================================================
 @function name   : paramSet_speed
 @argument[dtfrm] : 
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function paramSet_speed(dtfrm) {
  var param = {method:'', val:'', unit:''};
  var spdmtd = dtfrm.document.getElementById('speed_method').getValue();
  var spdTxt = dtfrm.document.getElementById('unit_l').getValue();
  if(spdTxt != '') {
    switch(spdmtd) {
      case dtfrm.selectOptionListSpeedMethod[0][1]:  /* Constant */
        param.val = dtfrm.document.getElementById('speed_' + spdTxt).getValue();
        break;
      case dtfrm.selectOptionListSpeedMethod[1][1]:  /* Regi */
        param.method = ORDER_REGI + '[';
        param.val    = dtfrm.document.getElementById('speed_regi_index').getValue();
        break;
      case dtfrm.selectOptionListSpeedMethod[2][1]:  /* Regi[Regi */
        param.method = ORDER_REGI + '[' + ORDER_REGI + '[';
        param.val    = dtfrm.document.getElementById('speed_regi_regi_index').getValue();
        break;
      // case dtfrm.selectOptionListSpeedMethod?.[3]?.[1]:  /* WELD_SPEED */
      case dtfrm.selectOptionListSpeedMethod[3] && dtfrm.selectOptionListSpeedMethod[3][1]:  /* WELD_SPEED */
        param.val    = ORDER_WELD_SPEED;
        break;
      default:
        param.val = dtfrm.document.getElementById('speed_' + spdTxt).getValue();
        break;
    }
    if(param.val != ORDER_WELD_SPEED) {
      var idx = dtfrm.selectOptionListSpeedUnit.find(function(data) {
        return data[1] == spdTxt;
      });
      param.unit = idx[0];
    }
    g_program_data[activeTarget].speed = param;
  }
}

/*
 =========================================================================
 @function name   : paramSet_route
 @argument[dtfrm] : 
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function paramSet_route(dtfrm) {
  var param = {stop:'', val:''};
  var stpTxt = dtfrm.document.getElementById("stop_l").getValue();
  var crCase = undefined;
  if (dtfrm.document.title == 'Spline') crCase = dtfrm.crSlct.txt;
  if (dtfrm.selectOptionListStop[3] != undefined) crCase = dtfrm.selectOptionListStop[3][1];
  switch (stpTxt) {
    case dtfrm.selectOptionListStop[0][1]:  /* FINE */
      param.stop = ORDER_FINE;
      break;
    case dtfrm.selectOptionListStop[1][1]:  /* CNT */
      param.stop = ORDER_CNT;
      param.val  = dtfrm.document.getElementById("nameraka_l").getValue();
      break;
    case dtfrm.selectOptionListStop[2][1]:  /* CNT Regi */
      param.stop = ORDER_CNT + ' ' + ORDER_REGI;
      param.val  = dtfrm.document.getElementById("nameraka_regi_index").getValue();
      break;
    case crCase:  /* CR */
      param.stop = ORDER_CR;
      param.val  = dtfrm.document.getElementById("stop_cr_val").getValue();
      break;
    default:
      param.stop = ORDER_FINE;
      break;
  }
  g_program_data[activeTarget].route = param;
}

/*
 =========================================================================
 @function name   : timeline_commentDispCheck
 @argument[dtfrm] : 
 @description     : Function execution and input value setting when reading the details tab.
 @return          : none
 =========================================================================
*/
function timeline_commentDispCheck(id) {
  var editInst = document.getElementById(id);
  if(!editInst) return;
  var chkCmn = editInst.getElementsByClassName('commentContainer');
  if(chkCmn[0] != undefined) {
    if(g_program_data[id].param != '') {
      chkCmn[0].firstElementChild.innerText = g_program_data[id].param;
      commentOmitCheck(editInst);
    }
    else {
      chkCmn[0].remove();
    }
  }
  else {
    if(g_program_data[id].param != '') {
      addCmntFeeder(editInst);
    }
  }

  /* Check to see if it is necessary to omit the forward comment instruction by editing the comment. */
  prevCommentOmitCheck(editInst);

  /* Adjust timeline width by editing comments. */
  TLdrawAreaBufferResize();
  timelineScrlbarUpdate();
}

/*
 =========================================================================
 @function name : getLoadCheckResultApndStat
 @argument[]    :
 @description   :
 @return        : Display state. (true:Displaying)
 =========================================================================
*/
function getLoadCheckResultApndStat() {
  var moniElm = document.getElementById('upperDisp_moni');
  return (moniElm && moniElm.classList.contains('upper_disp_loadcheckresult'))
}

/*
 =========================================================================
 @function name : isIntegerRealNumber
 @argument[str] : Target string
 @description   : Returns true if the given string is an integer (unsigned/signed) or a real number (unsigned/signed).
 @return        : boolean 
 =========================================================================
*/
function isIntegerRealNumber(str) {
  if( (!str) || (str.length <= 0) ) { return false; }
  var length = 0;

  // Check if it is an integer (unsigned/signed) or a real number (unsigned/signed)."+" is not allowed.
  length = str.replace(/^-?\d*\.?\d+$/,"").length;
  if(length == 0) { return true; }
  return false;
}

/*
 =========================================================================
 @function name : getIntegerRealNumber
 @argument[str] : Target string
 @description   : Extracts and returns a number (signed/unsigned integer or 
                   signed/unsigned real number) from the given string. 
                  If there is no string part that corresponds to the number, 
                  return an empty string (ex."").
 @return        : string 
 =========================================================================
*/
function getIntegerRealNumber(str) {
  var retStr = "";
  if( (!str) || (str.length <= 0) ) { return retStr; }

  //Extracts a number (signed/unsigned integer or signed/unsigned real number) from the given string.
  if( isIntegerRealNumber(str) ) {
    retStr = str;
  }
  else {
    var buff = str.match(/-?\d*\.?\d+/);
    if( buff ) {
      retStr = buff[0];
    }
  }
  return retStr;
}
                                                                                                                                                                                                                                                                                                                                                                                                                 I H M I E  fD I T O R _   D I IHMIED~5JS    MjXX  MjXn  BL E I O _  R E A D . J   S   I H M I E  D I T O R _   F I IHMIED~6JS    MjXX  MjX{_ BL E I O _  &W R I T E .   J S I H M I E  &D I T O R _   F I IHMIED~7JS    MjXX  MjX_U BI T . J S  F    I H M I E  FD I T O R _   I N IHMIED~8JS    MjXX  MjXV\  B. J S      I H M I E  D I T O R _   I O IHMIED~9JS    MjXX  MjX  BY O U T .  BJ S     I H M I E  BD I T O R _   L A // Use jQuery
/*
 * jQuery JavaScript Library
 * https://jquery.com/
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
*/


/*
 =========================================================================
 @function name  : iconArea_verticalSet
 @argument       : none
 @description    : Adjusting the height of the programming area.
 @return         : none
 =========================================================================
*/
function iconArea_verticalSet() {
	if ($("#exe_column").css('position') === "fixed") {
		$("#exe_column").css({'top':g_TL_elm.getBoundingClientRect().top + 6});
	}
	/* When "overlay3" displaying */
	if (document.getElementById("lowwer") != null) {
		$("#lowwer").css('height', $(parts_lowwer).css('height'));
	}
	
	if(document.getElementById('progArea_1').classList.contains('progArea_active')) {
		scrlThumbResize($('#' + progtabId[checkedTabId].iconAreaId)[0], 'progicon_scrl_track', false);
		scrlPosUpdate($('#progicon_scrl_thumb')[0], $('#' + progtabId[checkedTabId].iconAreaId)[0], 'progicon_scrl_track', $('#' + progtabId[checkedTabId].iconAreaId)[0].scrollTop);
	}
	if(g_tlScroll_direction == TL_SCRL_VRTCL) {
		scrlThumbResize(scrlWrpElm, 'TL_scrollbar_vrtcl', false);
		scrlPosUpdate($('#TLscrl_vrtcl_thumb')[0], scrlWrpElm, 'TL_scrollbar_vrtcl', scrlWrpElm.scrollTop);
		if(($('#timelineRestrict')[0].classList.contains('restrict_running') || g_overlay_enbl.timeline) &&
		   $('#timelineRestrict').css('display') === 'block') {
			$('#timelineRestrict').css({'height':document.getElementById('TL_scrollbar').offsetHeight + scrlWrpElm.offsetHeight + 1});
		}
	}
	/* Detailed screen is displayed. */
	if(document.getElementById('progArea_2').classList.contains('progArea_active') &&
	   document.getElementById('detail_act').classList.contains('active')) {
		var content = dtlfrm_contentchk(activeTarget);
		if(content != null) {
			scrlThumbResize(content, 'detail_scrlTrack_vrtcl', false);
			scrlPosUpdate($('#dtl_scrlThumb_vrtcl')[0], content, 'detail_scrlTrack_vrtcl', content.scrollTop);
			if(g_RO_flg || !g_TPenbl_flg || g_program_data[activeTarget].remark) {
				$("#detailRestrict").css({
					'height':content.scrollHeight,
					'width':content.scrollWidth,
				});
			}
		}
	}
}


/*
 =========================================================================
 @function name  : adjustUpLowElem
 @argument[]     : 
 @description    : Adjust the size of the programming area and scroll.
 @return         : none
 =========================================================================
*/
var SYS_ALM_HEIGHT = 37;
function adjustUpLowElem() {
	/* Update element size for drag scroll */
	if (scrollboost !== '') {
		scrollboost.updateMetrics();
	}
	/* Programming area Height adjustment */
	iconArea_verticalSet();
}

/*
 =========================================================================
 @function name       : setArrowPos
 @argument[percentage]: Percentage from the top edge of the screen.
 @description         : Specify the border position in %.
 @return              : none
 =========================================================================
*/
function setArrowPos(percentage) {
	if(typeof percentage == 'number') {
		var prcnt = percentage;
	}
	else {
		var prcnt = Number(percentage.replace(/\%/g, ''));
		if(isNaN(prcnt)) return;
	}
	prcnt = (prcnt > 100) ? 100 : (prcnt < 0) ? 0 : prcnt;
	parts_handleresize_area.refresh({firstAreaSize: prcnt});
	adjustUpLowElem();
}

/*
 =========================================================================
 @function name  : inputFocus_dispSlide
 @argument[slide]: true:up(focus in) / false:down(focus out)
 @description    : Icon area height and width initial value
 @return         : none
 =========================================================================
*/
var borderElemPos = '';
function inputFocus_dispSlide(slide) {
	var pos_y = 0;
		
	if(slide) {
		borderElemPos = parts_upper.clientHeight;
	}
	else {
		pos_y = borderElemPos;
		borderElemPos = '';
	}
		
	parts_handleresize_area.refresh({firstAreaSize: pos_y + 'px'});
	adjustUpLowElem();
	
	if(slide) {
		$('#viewRestrict').addClass('focus_dispSlide');
		sortable_disable(true);
	}
	else {
		$('#viewRestrict').removeClass('focus_dispSlide');
		sortable_disable(false);
	}
}


/*
 =========================================================================
 @function name  : inputFocus_slideForm
 @argument[slide]: 
 @description    : 
 @return         : none
 =========================================================================
*/
function inputFocus_slideForm(slide){
	if(document.activeElement.contentDocument.getElementsByClassName('content').length == 0){
		return;
	}
	if(slide){
		var bodyElm = document.activeElement.contentDocument.getElementsByClassName('content')[0];
		if(bodyElm != null) {
			var titleHeightSize = 30;
			var titlePlusFormHeightSize = 60;
			
			var bodyHeight = bodyElm.clientHeight;
			
			var new_elm=document.createElement("div");
			new_elm.id = 'appendDiv';
			new_elm.style.height = (bodyHeight-titlePlusFormHeightSize)+'px';
			
			bodyElm.appendChild(new_elm);
			
			var upY = document.activeElement.contentDocument.activeElement.getBoundingClientRect().top;
			bodyElm.scrollBy(0,upY-titleHeightSize);
		}
	}else{
		$(document.getElementById(get_detail_frm_id(activeTarget))).contents().find("#appendDiv").remove();
	}
}

/*
 =========================================================================
 @function name  : landscape_dispSlide
 @argument[slide]: true:up(landscape) / false:down(portrait)
 @description    : Move the border up or down according to the orientation of the display.
 @return         : none
 =========================================================================
*/
function landscape_dispSlide(slide) {
	var def_tlHeight = DEF_TIMELINE_AREA_HEIGHT + SYS_ALM_HEIGHT;
	var handleResizeVerticalMoveArea = parts_block.clientHeight - (parts_timeline.offsetHeight + HANDLERESIZE_HEIGHT);

	if(g_tlScroll_direction == TL_SCRL_VRTCL) {
		var pos_y = (def_tlHeight > DEF_GRAPHIC_AREA_HEIGHT) ?
							def_tlHeight : DEF_GRAPHIC_AREA_HEIGHT;
	}
	else {
		var pos_y = (slide) ? 0 : DEF_GRAPHIC_AREA_HEIGHT;
		if(pos_y > handleResizeVerticalMoveArea) {
			pos_y = handleResizeVerticalMoveArea;
		}
	}
	parts_handleresize_area.refresh({firstAreaSize: pos_y + 'px'});
	adjustUpLowElem();
}


                                                                                                                                                                                                                                                             /*
 * @fileoverview : Prototype app for PC version of Chrome.TP program reading function
 * @char-code    : SJIS
 * @NewLineCode  : LF
 */

// Use Encoding.js
// Converts character encoding.
// Copyright (c) 2013-2017 polygon planet <polygon.planet.aqua@gmail.com>
// licensed under the MIT license.
// https://github.com/polygonplanet/encoding.js

// Use jQuery
/*
 * jQuery JavaScript Library
 * https://jquery.com/
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
*/

/* === Tag group define === */
var TAGPROG = 0;
var TAGATTR = 1;
var TAGAPPL = 2;
var TAGMN = 3;
var TAGPOS = 4;
var TAGEND = 5;
var tagNameList = [
  { name: 'PROG', group: TAGPROG },
  { name: 'ATTR', group: TAGATTR },
  { name: 'APPL', group: TAGAPPL },
  { name: 'MN', group: TAGMN },
  { name: 'POS', group: TAGPOS },
  { name: 'END', group: TAGEND }
];
var programData = {
  programName: ''
};
var addId = [];
var addInt = 0;
var dropIdReplaceFlg = false;
/* === Position data status === */
var POSCAPTION = 0;
var POSGROUP = 1;
var POSCOORDINATE = 2;
var POSPOSITION = 3;

/* Judge table */
var instJudgeTbl = [
  /* Motion instruction */
  { chkStr : new RegExp('^(\\d+:|\\/{2})(' + ORDER_LINE + '|' + ORDER_JOINT + '|' + ORDER_CURVE + '|' + ORDER_CIRCLEARC + '|' + ORDER_SPLINE + ')$'),
    func   : set_program_data_motion },
  /* Register IO instruction */
  { chkStr : new RegExp('^(\\/{2}|)(' + ORDER_REGI + '|DO|RO|GO|AO|F)\\[.+'),
    func   : set_program_data_regoutput },
  /* Weld */
  { chkStr : new RegExp('^(\\/{2}|)((' + ORDER_WELDSTART + '|' + ORDER_WELDEND + ')\\[.+|' + ORDER_PLE_LS + '|' + ORDER_PWC + '|' + ORDER_LS_SCH + '|' + ORDER_LE + '|' + ORDER_LS + '|' + ORDER_WIRC + ')'),
    func   : set_program_data_weld },
  /* IF, FOR, comment instructions */
  { chkStr : new RegExp('^(\\/{2}|)(IF|FOR$|ENDFOR|ENDIF|ELSE|!|\\-\\-)'),
    func   : set_program_data_if_for },
  /* Call, advanced instructions */
  { chkStr : new RegExp('^(\\/{2}|)(' + ORDER_CALL + ')'),
    func   : set_program_data_call },
  /* Wait, Label, Jump, Payload */
  { chkStr : new RegExp('^(\\/{2}|)(' + ORDER_WAIT + '|' + ORDER_JUMP + '|' + ORDER_LABEL + '|' + ORDER_PAYLOAD +')'),
    func   : set_program_data_control },
  /* User frame */
  { chkStr : new RegExp('^(\\/{2}|)(' + ORDER_UFRAME  + '|' + ORDER_UTOOL  + ')'),
    func   : set_program_data_uframe },
  /* Tracking */
  { chkStr : new RegExp('^(\\/{2}|)(' + ORDER_SENSOR + '|' + ORDER_SEARCH  + '|' + 'DETECT' + '|' + ORDER_TRACK + ')'),
    func   : set_program_data_new_arc },
//  /* Macro */
//  { chkStr : null,
//    func   : set_program_data_macro },
];

/*
 =========================================================================
 @function name : recentTopPrgCallback
 @argument[]    : none 
 @description   : Callback function to read the program
 @return        : none
 =========================================================================
*/
var recentTopPrgCallback = function () {
  if (programFileList.find(function(prg) { return prg.name === tp_prog_name; }) != undefined) {
    getProgramText(tp_prog_name, 1, readPrgCallback);
  } else {
    //Error popup
    dispOffWaiting();
    display_popupmsg_confirm(window, langResource.ihmieditor_pop_loaderr_c + '<br>' + langResource.ihmieditor_pop_moveprglist_c, cb_closepopup_move_prglist);
    /* Initialization of reloading flag */
    g_editor_status.tl_loading = false;
    return;
  }
}

/*
 =========================================================================
 @function name        : getProgramText
 @argument[progName]   : program name
 @argument[targetKind] : specified product program file
 @argument[callback]   : Callback function called after loading
 @description          : Loads the specified program file.
 @return               : none
 =========================================================================
*/
function getProgramText(progName, targetKind, callback) {
  /* specified product program file. */
  if (targetKind == 0) {
    var asterPos = progName.indexOf('*');
    if (asterPos >= 0) { // if already search edit file
      progName = progName.slice(0, asterPos) + progName.slice(asterPos + 1);
    } else {
      // product file is nothing...
      return false;
    }
  }
  var progFile = addProgramExtension(progName);
  top.loadFile(progFile, callback);
}
  
/*
 =========================================================================
 @function name      : addProgramExtension
 @argument[progName] : Program name.
 @description        : Get LS file name
 @return[tempName]   : LS file name
 =========================================================================
*/
function addProgramExtension(progName) {
  return (progName.indexOf('.LS') < 0) ? progName + '.LS' : progName;;
}

/*
 =========================================================================
 @function name         : readPrgFromMonitorCB
 @argument[status]      : result
 @argument[programName] : Program name.
 @argument[programText] : base64-encoded string array
 @argument[lineCount]   : number of lines
 @description           : Callback to read the program
 @return                : none
 =========================================================================
*/
function readPrgFromMonitorCB(status, programName, programText, lineCount) {
  // If status is error, read the production file.
  if (status != IO_SUCCESS) {
    getProgramText(programName, 0, readPrgFromMonitorCB);
  }
  else {
    readPrgCallback(status, programName, programText, lineCount, PRG_LOAD_REASON_MONITOR);
  }
}

/*
 =========================================================================
 @function name         : readPrgFromExecCB
 @argument[status]      : result
 @argument[programName] : Program name.
 @argument[programText] : base64-encoded string array
 @argument[lineCount]   : number of lines
 @description           : Callback to read the program
 @return                : none
 =========================================================================
*/
function readPrgFromExecCB(status, programName, programText, lineCount) {
  // If status is error, read the production file.
  if (status != IO_SUCCESS) {
    getProgramText(programName, 0, readPrgFromExecCB);
  }
  else {
    readPrgCallback(status, programName, programText, lineCount, PRG_LOAD_REASON_EXEC);
  }
}

/*
 =========================================================================
 @function name         : readPrgCallback
 @argument[status]      : result
 @argument[programName] : Program name.
 @argument[programText] : base64-encoded string array
 @argument[lineCount]   : number of lines
 @argument[reason]      : Reason for loading
 @description           : Callback to read the program
 @return                : none
 =========================================================================
*/
var ls_file_data = [];
var PRG_LOAD_REASON_MONITOR = 1;
var PRG_LOAD_REASON_EXEC    = 2;
function readPrgCallback(status, programName, programText, lineCount, reason) {
  // If status is error, read the production file.
  if (status != IO_SUCCESS) {
    getProgramText(programName, 0, readPrgCallback);
    return;
  }
  /* decode */
  convertProgramLines(programText, lineCount, cvrtCB);

  /** function: Callback processing after decoding **/
  function cvrtCB(lsArray) {
    ls_file_data = lsArray;
    parseProgramFile(ls_file_data, reason); // api.
  }
}

/*
 =========================================================================
 @function name       : convertProgramLines
 @argument[progLines] : Program line (base64-encoded)
 @argument[lineCount] : number of lines
 @argument[callback]  : Callback function to be called after conversion
 @description         : Convert program text data.
 @return              : none
 =========================================================================
*/
function convertProgramLines(progLines, lineCount, callback) {
  // Convert program text data...
  var decodedProg = [];
  if (lineCount > 0) { // If online data read, need to decode.
    if (gcurrentJPLang == 'jp' || gcurrentJPLang == 'eg') {
      /* decode & character code conversion */
      for (var txtIndex = 0; txtIndex < progLines.length; txtIndex++) {
        decodedProg[txtIndex] = convertSjistoUcd(window.atob(progLines[txtIndex].buf)); // utils
      }
      callback(decodedProg);
    } else {
      var filelines;
      var bytesArray = [];
      var text = "";
      var blobData = [];
      var sendDataArray = []; // Send all data at once.
      var CODECRLF = '\r\n';
      /* decode */
      for (var txtIndex = 0; txtIndex < progLines.length; txtIndex++) {
        text = window.atob(progLines[txtIndex].buf) + CODECRLF;
        bytesArray = [];
        for (var convIdx = 0; convIdx < text.length; convIdx++) {
          var tempCharCode = text.charCodeAt(convIdx);
          if (tempCharCode > 0x00) { // Not null character
            bytesArray.push(tempCharCode);
          }
        }
        Array.prototype.push.apply(sendDataArray, bytesArray);
      }
      blobData[0] = new Blob([new Uint8Array(sendDataArray)]);
      var reader = new FileReader();
      reader.addEventListener("loadend", function () {
        filelines = reader.result.split(CODECRLF);
        callback(filelines);
      });
      reader.readAsText(blobData[0], top.irprogapi.global.langEncoding[gcurrentJPLang]);
    }
  } else { // For offline reading No need to decode.
    callback(progLines);
  }
}

/*
 =========================================================================
 @function name        : convertSjistoUcd
 @argument[sJisText]   : SJIS Text
 @description          : Convert SJIS data to Unicode
 @return[decodedProg]  : Unicode Text.
 =========================================================================
*/
function convertSjistoUcd(sJisText) {
  // Shift_JIS to Unicode convert
  var sjisArray = [];
  for (var convIdx = 0; convIdx < sJisText.length; convIdx++) {
    var tempCharCode = sJisText.charCodeAt(convIdx);
    if (tempCharCode > 0x00) { // Not null character
    	sjisArray[convIdx] = tempCharCode;
    }
  }
  var encode = ActiveVersion == V10Definition ? 'UTF-8' : 'SJIS';
  var ucdArray = Encoding.convert(sjisArray, 'Unicode', encode);
  var ucd8Str = Encoding.codeToString(ucdArray);
  return ucd8Str;
}
var tp_prog_name = null;
var current_prog_name = "";

/*
 =========================================================================
 @function name        : parseProgramFile
 @argument[fileLines]  : Program before analysis
 @argument[reason]     : Reason for loading
 @description          : Parse program text data
 @return               : none
 =========================================================================
*/
function parseProgramFile(fileLines, reason) {
  var tagGroup = 0;
  var posStatus = {type: POSCAPTION, posNum: 0, grpNum: 0};
  var result;
  var mnArray = [];
  var mnPosArray = [];
  var c_motion = false;
  initAttribute();
  initApplData();
  initPosition();
  initLineCountInfo();
  /* In some cases, the parsing process is called twice after the timeline initialization, */
  /* so if the value is held in AAA, it should be initialized again.                       */
  if(Object.keys(g_program_data).length) {
    initializ_timeline();
  }
  g_btnTeaching_list = {
    'weldteach': { existsTimeline: false, id: null, count: 0},
    'wristteach': { existsTimeline: false, id: null, count: 0},
  };
  for (var i = 0; i < fileLines.length; i++) {
    if(fileLines[i] == '') continue;
    // Get 1 line data
    var line = fileLines[i];
    // Start at slash?
    if (line.startsWith('/')) { // Header
      var tags = line.split(' '); // Program name is exist after tag name
      var tag = tags[0].substr(1).trim(); // Cut out tag name
      // tag name check
      tagGroup = checkTagName(tag);
      if(tagGroup == TAGPROG) {
        if(tags[2] == tp_prog_name) {
          g_lineCountOver_base['main'] = {overflg:false};
          g_lineCountOver = g_lineCountOver_base['main'];
        }
        else {
          g_lineCountOver = g_lineCountOver_base['sub'];
        }
      }
    } else {
      switch (tagGroup) {
        case TAGATTR: // Attributes
          var attr = line.split('='); // extract attr-key and attr-val.
          var attrPair = {};
          attrPair.key = attr[0].trim();
          attrPair.val = attr[1].replace(/\;$/, '').trim();
          attribute[attribute.length] = attrPair;
          if(!tagParse_attFunc(attrPair)) {
            return false;
          }
          break;
        case TAGAPPL: // Application data
          if (line.indexOf(":") > 1) {
            var appl = line.split(':');
            var applPair = {};
            applPair.key = appl[0].trim();
            applPair.val = appl[1].trim();
            applData[applData.length] = applPair;
          }
          break;
        case TAGMN: // Line is mnemonic
          var colonPos = line.indexOf(':'); // Skip go colon
          var mnText = line.substr(colonPos + 1);
          var lineNum = parseInt(line.trim());
          var setIndex = mnArray.length;
          // If there is no line number, concatenate it to the previous line.
          if ((isNaN(lineNum)) && (colonPos < 0)) {
            break; // Delimitation line, etc. (------ ;)
          }
          if (isNaN(lineNum)) {
            setIndex--;
            mnText = mnArray[setIndex].trim() + ' ' + mnText.trim();
          } else {
            mnText = line; // add index data
          }
          mnArray[setIndex] = (mnText[mnText.length - 1] == ';') ? mnText.substr(0, mnText.length - 1) : mnText;
          break;
        case TAGPOS: // Line is Position data
          mnPosArray.push(line);
          break;
        default:
          // especially none.
          break;
      }
    }
    /* After all attribute[] are stored. */
    if(attribute.length == ATTR_MAX_NUM && g_lineCountOver.overflg) {
      tlPopupDisplayReq(langResource.ihmieditor_pop_linecount_over_c);
      break;
    }
  }

  // Set program data
  for (var i = 0; i < mnArray.length; i++) {
    if (!set_program_data(mnArray[i])) {
      display_popupmsg_confirm(window, langResource.ihmieditor_pop_loaderr_c + '<br>' + langResource.ihmieditor_pop_moveprglist_c, cb_closepopup_move_prglist);
      return;
    }
  }
  // Set position data
  for(var j = 0; j < mnPosArray.length; j++) {
    posStatus = analizePosition(mnPosArray[j], posStatus, getPosDataArray());
  }
  setTimeout(function() {check_parseProg(reason);}, 0);

  /** finction:Processing after parsing **/
  var check_parseProg = function(reason) {
    if(change_prog_flg) {
      exe_column_move(1);
      columnPosInfoUpdate(false);
    }
    check_remainGhost();
    if(g_TL_selectModeFlg) change_TLselectMode(SELECT_MODE_NONE);
    delete_popup_screen(DEF_POPUP_SCRN_TYP.REPLACE_MTN);//delete the pop-up screen
    /* Bracket instruction pair check */
    check_progOrder();
    if(tp_prog_name !== current_prog_name) {
      timeline_record.array_add(g_program_data);
      position_record.array_add(position);
      positionregi_record.array_add(g_position_regi);
      check_undoredo_active();
    }
    g_MTGData.savingTeachPosFlg = false;
    /* Multiple HandleTeach instructions exist. */
    if(g_btnTeaching_list.weldteach.count > 1) {
    tlPopupDisplayReq(langResource.ihmieditor_pop_weldingteach_countover_c + '<BR>' + langResource.ihmieditor_pop_weldingteach_not_operate_c);
    } else if (g_btnTeaching_list.wristteach.count > 1) {
      tlPopupDisplayReq(langResource.ihmieditor_pop_not_displayable_c);
    }
    if (g_btnTeaching_list.weldteach.existsTimeline == true) {
      top.setArcTeachFg(true);
    } else {
      top.setArcTeachFg(false);
    }
    if(g_btnTeaching_list.wristteach.existsTimeline == true) {
      top.setWristTeachFg(true);
    } else {
      top.setWristTeachFg(false);
    }
    /* Icon Drawing */
    display_program_data();
    if (g_btnTeaching_list.weldteach.existsTimeline == true && g_program_data[g_btnTeaching_list.weldteach.id].remark == false) {
      //WeldingTeach 
      weldingTeachStart();
    }
    del_unused_posno();
    /* Holds execution line initial position information */
    if (!animation_flg) {
      // console.log(programLine);
      exe_column_move(programLine);
    }
    //Initialization add sample Program flag
    g_adin_state.adinstAttachedFlg = false;
    g_adin_state.pkgSampleProgAdding  = false;
    g_adin_state.continuousRep = null;
    initcurrentProgStat();
    read_tpprog_finish_flg = true;
    check_read_complete(reason);
    setLineTrack();
    /* read only file */
    if(g_RO_flg) readOnly_setting();

    /* Get modified time */
    getCurProgModifyTime(startMonitorCurProgModify);
    /* Reason is set. */
    if(typeof reason != 'undefined' && (reason == PRG_LOAD_REASON_MONITOR || reason == PRG_LOAD_REASON_EXEC)) {
      if(reason == PRG_LOAD_REASON_MONITOR) dispOffWaiting();
      /* Reloaded toast */
      toast.show(langResource.ihmieditor_pop_edited_reload_c);
    }

    /* Check if favorite need to be upgraded */
    favorite_systemUpdateChk();
    
    if(g_favoDataErrorFlg.malfunction) {
      display_popupmsg_alert(DEF_POPUP_SCRN_TYP.NOT_SUPPORT, langResource.ihmieditor_pop_favoriteprog_malfunction_c, DISP_CLOSE_BTN);
      g_favoDataErrorFlg.malfunction = false;
    }
    if(g_editor_status.pathTeachInfo.clampErr != '') {
      display_popupmsg_alert(DEF_POPUP_SCRN_TYP.ALERT, g_editor_status.pathTeachInfo.clampErr, DISP_CLOSE_BTN);
      g_editor_status.pathTeachInfo.clampErr = '';
    }
  }
}

/*
 =========================================================================
 @function name      : tagParse_attFunc
 @argument[attrPair] : Attribute data
 @description        : Stores data for each key.
 @return[]           : Whether to continue parsing process or not. (false : termination)
 =========================================================================
*/
function tagParse_attFunc(attrPair) {
  var lineCntKey = lineCount[(gcurrentJPLang == 'jp' || gcurrentJPLang == 'kn') ? 'jp' : 'eg'];
  var groupKey = groupAxes[gcurrentJPLang == 'jp' ? gcurrentJPLang : 'eg'];
  var loclaRegKey = localReg[gcurrentJPLang == 'jp' ? gcurrentJPLang : 'eg'];

  switch(attrPair.key) {
    case lineCntKey:    /* LINE_COUNT */
      g_lineCountOver.overflg = (Number(attrPair.val.replace(/[^0-9.]/g, '')) > MAX_LINE_COUNT);
      break;
    case groupKey:      /* DEFAULT_GROUP */
      var posAxesUnit = top.irprogapi.getAxisData();
      var attrVal = attrPair.val.split(',');
      for(var unitCnt = 1; posAxesUnit.robot[unitCnt] != null; unitCnt++) {
        if((posAxesUnit.robot[unitCnt] + posAxesUnit.ext[unitCnt]) == 0 && attrVal[unitCnt - 1] == 1) {
          dispOffWaiting();
          display_popupmsg_alert(DEF_POPUP_SCRN_TYP.NOT_SUPPORT, langResource.ihmieditor_pop_axes_notset_c, HIDE_CLOSE_BTN);
          read_tpprog_finish_flg = true;
          check_read_complete();
          return false;
        }
      }
      delete_popup_screen(DEF_POPUP_SCRN_TYP.ALL);  //delete the pop-up screen
      break;
    case loclaRegKey:   /* LOCAL_REGISTERS */
      g_config['localReg'] = attrPair.val.split(',').map(function(str) {return parseInt(str, 10);});
      break;
    default:
      break;
  }

  return true;
}

/*
 =========================================================================
 @function name : remove4dGraph
 @argument[]    : none
 @description   : Stop 4DGraphic communication
 @return[]      : none
 =========================================================================
*/
function remove4dGraph() {
  if(document.getElementById("webgl")) {
    var graphic_frm = document.getElementById("webgl").contentWindow;
    /* webgl is loading */
    if(typeof graphic_frm.observerDisconnect != 'function') {
      /* Wait for loading to complete. */
      graphic_frm.onload = function() {
        /* Stop 4DGraphic */
        graphic_frm.observerDisconnect();
        graphic_frm.stopTpgl();
      }
    }
    /* webgl is loaded */
    else {
      /* Stop 4DGraphic */
      graphic_frm.observerDisconnect();
      graphic_frm.stopTpgl();
    }
  }
}

/*
 =========================================================================
 @function name : addframe4dGraph
 @argument[]    : none
 @description   : Add or restart 4DGraphic
 @return[]      : none
 =========================================================================
*/
function addframe4dGraph() {
  /* vertical scroll view or horizontal scroll view && Handle is positioned on the upper end */
  if(g_tlScroll_direction == TL_SCRL_VRTCL ||
     g_tlScroll_direction != TL_SCRL_VRTCL && parts_upper.classList.contains('upperEdge_reach')) {
    /* No communication required */
    remove4dGraph();
    return;
  }
  /* webgl exists */
  if(document.getElementById("webgl")) {
    /* Restart 4DGraphic */
    var graphic_frm = document.getElementById("webgl").contentWindow;
    /* webgl is loading */
    if(typeof graphic_frm.observerDisconnect != 'function') {
      /* Wait for loading to complete. */
      graphic_frm.onload = function() {
        graphic_frm.observerResume();
        graphic_frm.restartTpgl();
      }
    }
    /* webgl is loaded */
    else {
      graphic_frm.observerResume();
      graphic_frm.restartTpgl();
    }
  }
  else {
    /* Add 4DGraphic */
    var viewArea = $('<iframe>', {id:'webgl', class: 'webgl', scrolling: 'auto', name: 'webgl', src: '/frh/irprog/ihmieditor/lib/ihmieditor_tpgl1.stm', frameborder: '0'});
    $('#upperDisp_4d').prepend(viewArea[0]);
    parts_handleresize_area.refresh({firstAreaSize: parts_handleresize_area.getSize().first});
  }
}

/*
 =========================================================================
 @function name : removeMonitor
 @argument[]    : none
 @description   : Remove monitor screen
 @return[]      : none
 =========================================================================
*/
var g_lastDispMoni = ''; /* Type of screen that was being displayed when the monitor screen was removed. */
function removeMonitor() {
  var moniElm = document.getElementById('upperDisp_moni');
  if(moniElm && moniElm.firstElementChild) {
    if(moniElm.classList.contains('upper_disp_loadcheckresult') &&
       activeTarget != '' && g_program_data[activeTarget].baseId == 'bktlead-inst_OVLDSTRT') {
      var dtlfrm = document.getElementById(get_detail_frm_id(activeTarget));
      if(dtlfrm) dtlfrm.contentWindow.dispClsNotify();
    }
    $('#upperDisp_moni').removeClass('upper_disp_io upper_disp_reg upper_disp_posreg upper_disp_safeio upper_disp_loadcheckresult');
    g_lastDispMoni = moniElm.firstElementChild.name;
    moniElm.firstElementChild.remove();
  }
}

/*
 =========================================================================
 @function name : addMonitor
 @argument[]    : none
 @description   : Add a monitor screen
 @return[]      : none
 =========================================================================
*/
function addMonitor(monikind) {
  /* Monitor Type Table */
  var moni_data = {
    'monitor_io'     : {src: '/frh/irprog/io/io.htm',                   name: 'monitor_io',     class: 'upper_disp_io'},
    'monitor_reg'    : {src: '/frh/irprog/register/reg.htm',            name: 'monitor_reg',    class: 'upper_disp_reg'},
    'monitor_posreg' : {src: '/frh/irprog/posregister/posregister.htm', name: 'monitor_posreg', class: 'upper_disp_posreg'},
    'monitor_safeio' : {src: '/frh/irprog/dcs/stm/safeio_stat.htm',     name: 'monitor_safeio', class: 'upper_disp_safeio'},
    'monitor_loadcheckresult' : {src: '/frh/inst/screw/scrwtght_crx_load_result.stm', name: 'monitor_loadcheckresult', class: 'upper_disp_loadcheckresult'}, /* Screw tightening only */
  };
  g_lastDispMoni = '';
  if(document.getElementById('upperDisp_moni').firstElementChild) removeMonitor();
  if(moni_data[monikind] == undefined) {
    upperArea_selectHandling('change_4d');
    return;
  };

  $('#upperDisp_moni').html(
    '<iframe id="disp_monitor" scrolling="auto" name="' + moni_data[monikind].name +
    '" src="' + moni_data[monikind].src + '" frameborder="0"></iframe>'
  );
  $('#upperDisp_moni').addClass(moni_data[monikind].class);
  $('#disp_monitor').on('load', function() {
    var $divarea = $('<button>', {id: 'change_4d'});
    var moni_frm = document.getElementById('disp_monitor').contentWindow;
    var headText = '<link rel="stylesheet" type="text/css" href="/frh/irprog/common/css/ihmitpgl_close.css?version=@@VERSION@@">' +
                    '<style type="text/css">body *{-webkit-tap-highlight-color:transparent}</style>';
    $('#disp_monitor').contents().find('head').append(headText);
    $('#pagearea', moni_frm.document).append($divarea);
    $('#change_4d', moni_frm.document).on('click', function(evt) {
      upperArea_selectHandling('change_4d');
    });
  });
}

/*
 =========================================================================
 @function name  : toggleNode_whileSaving
 @argument[hide] : toggle operation(true:hide / false:display)
 @description    : Show/hide node map
 @return[]       : none
 =========================================================================
*/
var g_nodeHide_saving = false; /* Node map display status (true:hidden) */
function toggleNode_whileSaving(hide) {
  if(!document.getElementById('webgl')) return;
  var frm = document.getElementById('webgl').contentWindow;
  var UPDATE_NODE = '$TABUI_EDIT.$UPDATE_NODE';
  /* Hide the node map */
  if(hide) {
    /* Displaying 4D graphics */
    if(document.getElementById('upperDisp_4d').classList.contains('upperDisp_active')) {
      /* Displaying node map */
      if(!g_nodeHide_saving && frm.visNode == frm.NODE_BIT) {
        top.rpcmc_setVar(top.SYSNAME_C, UPDATE_NODE, 0);
        g_nodeHide_saving = true;
      }
    }
  }
  else {
    if(g_nodeHide_saving) {
      top.rpcmc_setVar(top.SYSNAME_C, UPDATE_NODE, 1);
      g_nodeHide_saving = false;
    }
  }
}

/*
 =========================================================================
 @function name    : adin4Dfrm_adjust
 @argument[adjust] : Whether adjustments are necessary (true:Display on left side / false:Display on right side)
 @description      : Adjust the Vision camera frame position
 @return[]         : none
 =========================================================================
*/
function adin4Dfrm_adjust(adjust) {
  if(adjust) {
    $('#adin4Dfrm').addClass('dispLeft');
  }
  else {
    $('#adin4Dfrm').removeClass('dispLeft');
  }
}

/*
 =========================================================================
 @function name : readOnly_setting
 @argument[]    : none
 @description   : Configure read-only settings
 @return[]      : none
 =========================================================================
*/
function readOnly_setting() {
  if (g_TL_selectModeFlg) {
    /* Cancel selected state */
    change_TLselectMode(SELECT_MODE_NONE);
  }
  delete_popup_screen(DEF_POPUP_SCRN_TYP.REPLACE_MTN);//delete the pop-up screen
  progPopMenu_dispUpdate(PROG_SEL_MENU_ICON_UD_00);
  sortable_setting();
  $('#overlay_undoredo').addClass('tp_readOnly');
  $('.undoredo').css('opacity','');
  var config = {childList: true};
  if(activeTarget != '') {
    $('#detail_act').addClass('detail_noEdit');
    var content = dtlfrm_contentchk(activeTarget);
    if(content != null) {
      /* If it is in focus in, let it focus out. */
      if(g_editor_status.detail_inputFocus && content.ownerDocument.activeElement) input_focusout();
      detail_scrlCtrl(content);
      $('.restrictContainer').scrollTop(content.scrollTop).scrollLeft(content.scrollLeft);
      $('.restrictContainer').css({
        'left': content.offsetLeft,
        'width': 'calc(100% - ' + (content.offsetLeft + 9) + 'px)',
      });
      $("#detailRestrict").css({
        'height':content.scrollHeight,
        'width':content.scrollWidth,
      });
      var config = {attributes:true, attributeFilter:["style"], childList: true, subtree: true};
      dtlMutObserver.observe(content, config);
    }
  }
}

/*
 =========================================================================
 @function name        : toastStr_notEdit
 @argument[remarkedId] : For remarked instruction judgment.
 @description          : Determine the toast string if it cannot be edited.
 @return[]             : The wording to display toast.
 =========================================================================
*/
function toastStr_notEdit(remarkedId) {
  /* priority table */
  const strPriorityTbl = [
    {string: langResource.ihmieditor_pop_can_not_edit_tpoff_c,       reason: !g_TPenbl_flg},                            /* TP invalid */
    {string: langResource.ihmieditor_pop_tpreadonly_c,               reason: g_RO_flg },                                /* read only */
    {string: langResource.ihmieditor_pop_remarked_no_edit_c,         reason: (g_program_data[remarkedId] && g_program_data[remarkedId].remark) }, /* remark */
    {string: langResource.ihmieditor_pop_weldingteach_not_operate_2_c, reason: ((g_btnTeaching_list.weldteach.existsTimeline == true && g_program_data[g_btnTeaching_list.weldteach.id] && g_program_data[g_btnTeaching_list.weldteach.id].remark)) }, /* welding teach & remarked*/
    {string: langResource.ihmieditor_pop_weldingteach_not_operate_c, reason: g_btnTeaching_list.weldteach.existsTimeline == true},                  /* welding teach */
    {string: langResource.ihmieditor_pop_wristteach_not_operate_c, reason: g_btnTeaching_list.wristteach.existsTimeline == true},                  /* wrist button teach */
  ];

  var ret = langResource.ihmieditor_pop_tpreadonly_c;  /* default string */
  for(var cnt = 0; cnt < strPriorityTbl.length; cnt++) {
    if(strPriorityTbl[cnt].reason) {
      ret = strPriorityTbl[cnt].string;
      break;
    }
  }

  return ret;
}

/*
 =========================================================================
 @function name : readwrite_setting
 @argument[]    : none
 @description   : Configure the read/write enable setting.
 @return[]      : none
 =========================================================================
*/
function readwrite_setting() {
  /* Read-only or TP disable */
  if(g_RO_flg || !g_TPenbl_flg) {
    readOnly_setting();
  }
  else {
    /* Sortable setting */
    sortable_setting();
    $('#overlay_undoredo').removeClass('tp_readOnly');
    check_undoredo_active();
    
    toast.delete();
    if(!(g_program_data[activeTarget] && g_program_data[activeTarget].remark)) {
      $('.restrictContainer').css('left', '');
      $('#detail_act').removeClass('detail_noEdit');
      $('#detailRestrict').off('click');
    }
    $('.prgicon_area').off('click');
  }
}

/*
 =========================================================================
 @function name       : set_program_data
 @argument[text]      : Program text.
 @argument[updatePrg] : ID before update when adding sample program
 @description         : Set to display structure
 @return[prgchk_flg]  : Program presence flag.Boolean.
 =========================================================================
*/
function set_program_data(text, updatePrg) {
  var comentCheck = /[\[]+/;
  var spaceMatch = /\s+(?![^\[]*\])/g;
  var formedTxt = del_posComment(text);
  
  var array_string = (comentCheck.test(formedTxt)) ? formedTxt.split(spaceMatch) : formedTxt.split(/\s+/);
  array_string = repair_g_program_data(array_string);
  var prgchk_flg = false;

  for (var section_num = 0; section_num <= 2; section_num++) {
    if(array_string[section_num] === '' || array_string[section_num].match(/^\d+:$/)) continue;

    var tblChkResult, tbl;
    for(var tblCnt = 0; tblCnt < instJudgeTbl.length; tblCnt++ ) {
      tblChkResult = array_string[section_num].match(instJudgeTbl[tblCnt].chkStr);
      if(tblChkResult) {
        tbl = instJudgeTbl[tblCnt];
        break;
      }
    }
    if(!tbl) tbl = {chkStr: null, func: set_program_data_macro};
    prgchk_flg = tbl.func(array_string, section_num, updatePrg, tblChkResult, formedTxt);
    /* Exit the process because the instruction has been identified. */
    if(prgchk_flg) break;
  }

  //No support order check
  if (!prgchk_flg) {
    prgchk_flg = true;
    var command = noSupport_replace(array_string, null);
    chk_favoData_set(command, updatePrg);
  }
  return prgchk_flg;
}

/*
 =========================================================================
 @function name       : chk_favoData_set
 @argument[command]   : Created ID
 @argument[updatePrg] : ID before update when adding sample program
 @description         : 
 @return              : none
 =========================================================================
*/
function chk_favoData_set(command, updatePrg) {
  if(g_favoriteFlg.favoLoad) {
    if(g_favoriteList[g_favoriteList.length - 1].iconName == "") {
      g_favoriteList[g_favoriteList.length - 1].iconName = g_program_data[command].baseId;
    }
    else {
      g_favoriteList[g_favoriteList.length - 1].endId = command;
    }
    g_favoProg_data[command] = JSON.parse(JSON.stringify(g_program_data[command]));
    delete g_program_data[command];
  }
  else {
    if(!updatePrg) {
      g_TL_progInfo.saveProg.push(command);
      if(stretch_idStrChk(STRETCH_ID_CHK_ALL, command)) g_TL_progInfo.bktSaveProg.push(command);
    }
  }
}

/*
 =========================================================================
 @function name       : set_program_data_motion
 @argument[strArray]  : Analyzed row data array
 @argument[arrayNum]  : Array number of strArray
 @argument[updatePrg] : ID before update when adding sample program
 @argument[chkStr]    : "match" result when judging instruction type
 @argument[formedTxt] : Original text
 @description         : Processing of parsing motion instructions
 @return              : ID Creation Result (true:success)
 =========================================================================
*/
function set_program_data_motion(strArray, arrayNum, updatePrg, chkStr, formedTxt) {
  var ret = false;
  var progLine = formedTxt.replace(/(^\s*\d+\:\s*|\s$)/g, '');
  if(!g_favoriteFlg.favoLoad && (progLine.match(ORDER_MAX_SPEED))) {
    return ret;
  }
  /* Extract positional information. */
  var posList = strArray.filter(function(data) { return data.match(new RegExp('^(' + ORDER_POS + '|' + ORDER_POSREGI + ')\\['));});
  var posKindList = [];
  for(var poscnt = 0; poscnt < posList.length; poscnt++) {
    var posNum = ((posList[poscnt].match(/\:/)) ?
                    posList[poscnt].substring(0, posList[poscnt].indexOf(':')) : posList[poscnt]).replace(/[^0-9]/g, '');
    posKindList.push({pos: posList[poscnt], kind: judge_posKind(posList[poscnt]), posNum: (posNum === '') ? 0 : Number(posNum)});
  }

  if ((chkStr[2] != ORDER_SPLINE) ||
      (chkStr[2] == ORDER_SPLINE) && g_order_option.indexOf("R904") != -1) {
    var baseId = chk_LJ_type(strArray, chkStr[2]);
  }
  if(baseId) {
    if(iconTbl[baseId] != undefined) {
      var command = cmn_commandCreate(baseId, updatePrg);
    }
    if (command) {
      if(!g_favoriteFlg.favoLoad) {
        for (var cnt = 0; cnt < g_program_data[command].position.length; cnt++) {
          if (posKindList[cnt] !== undefined) {
            g_program_data[command].position[cnt].number = posKindList[cnt].posNum;
            g_program_data[command].position[cnt].kind = posKindList[cnt].kind;
            if(posKindList[cnt].kind == POSKIND_POSREGI) chk_save_posregi(posKindList[cnt].pos);              
          } else {
            break;          
          }
        }
      }
      set_motion_data(command, strArray, posKindList);
      ret = true;
      g_program_data[command].remark = (chkStr[1] == '//');
      chk_favoData_set(command, updatePrg);
    }
  }
  return ret;
}

/*
 =========================================================================
 @function name       : set_program_data_regoutput
 @argument[strArray]  : Analyzed row data
 @argument[arrayNum]  : Array number of strArray
 @argument[updatePrg] : ID before update when adding sample program
 @argument[chkStr]    : "match" result when judging instruction type
 @argument[formedTxt] : Original text
 @description         : Processing of parsing Regi/Output instructions
 @return              : ID Creation Result (true:success)
 =========================================================================
*/
function set_program_data_regoutput(strArray, arrayNum, updatePrg, chkStr, formedTxt) {
  var ret = false;
  var progLine = formedTxt.replace(/(^\s*\d+\:\s*(\/{2})?|\s$)/g, '');
  var cmdChk = chkStr[2] == ORDER_REGI ? 'regi' : 'output';
  var command = cmn_commandCreate(cmdChk, updatePrg);
  if(command) {
    g_program_data[command].param = (cmdChk == 'output') ?
                                      progLine : progLine.replace(new RegExp('\\s{3}$'), '');
    ret = true;
    g_program_data[command].remark = (chkStr[1] == '//');
    chk_favoData_set(command, updatePrg);
  }
  return ret;
}

/*
 =========================================================================
 @function name       : set_program_data_weld
 @argument[strArray]  : Analyzed row data
 @argument[arrayNum]  : Array number of strArray
 @argument[updatePrg] : ID before update when adding sample program
 @argument[chkStr]    : "match" result when judging instruction type
 @argument[formedTxt] : Original text
 @description         : Processing of parsing Weld instructions
 @return              : ID Creation Result (true:success)
 =========================================================================
*/
function set_program_data_weld(strArray, arrayNum, updatePrg, chkStr, formedTxt) {
  var ret = false;
  var progLine = formedTxt.replace(/(^\s*\d+\:\s*(\/{2})?|\s$)/g, '');
  var icon_data = [
    {baseId:'weldstartal', matchStr: new RegExp('^' + ORDER_WELDSTART + '\\[')},
    {baseId:'weldstopal',  matchStr: new RegExp('^' + ORDER_WELDEND + '\\[')},
    {baseId:'laserpow',    matchStr: new RegExp('^' + ORDER_PWC + '\\[')},
    {baseId:'laserpresi',  matchStr: new RegExp('^' + ORDER_PLE_LS)},
    {baseId:'laserlssi',   matchStr: new RegExp('^(' + ORDER_LS + '|' + ORDER_LS_SCH + ')\\[')},
    {baseId:'laserlesi',   matchStr: new RegExp('^' + ORDER_LE + '\\[')},
    {baseId:'laserwirc',   matchStr: new RegExp('^' + ORDER_WIRC + '\\[')}
  ];
  var cmdChk = icon_data.find(function(data) {
    return progLine.match(data.matchStr);
  });
  if(cmdChk) {
    var command = cmn_commandCreate(cmdChk.baseId, updatePrg);
  }
  if(command) {
    ret = true;
    g_program_data[command].param = progLine;
    g_program_data[command].remark = (chkStr[1] == '//');
    chk_favoData_set(command, updatePrg);
  }
  if(cmdChk.baseId === 'weldstopal'){
    var delStr = new RegExp('^' + ORDER_WELDEND + '\\[.+\\,WID\\:|\\]$', 'g');
    var setId = progLine.replace(delStr, '');
  }
  return ret;
}

/*
 =========================================================================
 @function name       : set_program_data_if_for
 @argument[strArray]  : Analyzed row data
 @argument[arrayNum]  : Array number of strArray
 @argument[updatePrg] : ID before update when adding sample program
 @argument[chkStr]    : "match" result when judging instruction type
 @argument[formedTxt] : Original text
 @description         : Processing of parsing IF/FOR/Comment instructions
 @return              : ID Creation Result (true:success)
 =========================================================================
*/
function set_program_data_if_for(strArray, arrayNum, updatePrg, chkStr, formedTxt) {
  var ret = false;
  var progLine = formedTxt.replace(/(^\s*\d+\:\s*(\/{2})?|\s$)/g, '');
  var refLine = parseInt(formedTxt.match(/(^\s*\d+\:\s*)/)[1].replace(/[^0-9]/g, ''));
  var create_endElseCmd = function(baseId, leadId, updatePrg) {
    var command = baseId + getSplitId(leadId);
    iconTbl[baseId].idCnt = iconTbl[g_program_data[leadId].baseId].idCnt;
    g_program_data[command] = set_icon_data(baseId);
    if(updatePrg) updatePrgFunc(command, updatePrg);
    return command;
  };
  switch (chkStr[2]) {
    case "IF":
      if(progLine.match(/THEN$/)) { // Judge if type
        var command = cmn_commandCreate('iflead', updatePrg);
        g_program_data[command].param = progLine.replace(/(^IF\s\(|\)\sTHEN$)/g, '');
      }
      break;
    case "FOR":
      var command = cmn_commandCreate('forlead', updatePrg);
      g_program_data[command].param = progLine;
      break;
    case "ENDFOR":
      var leadchk = set_prog_stretchLeadCheck(SET_PROG_KIND_FOREND, refLine - 1, null, updatePrg);
      if(leadchk != '' && g_program_data[leadchk].remark == (chkStr[1] == '//')) {
        var command = create_endElseCmd('forend', leadchk, updatePrg);
      }
      break;
    case "ELSE":
      var leadchk = set_prog_stretchLeadCheck(SET_PROG_KIND_IFELSE, refLine - 1, null, updatePrg);
      if(leadchk !== '' && g_program_data[leadchk].remark == (chkStr[1] == '//')) {
        var command = create_endElseCmd('ifelse', leadchk, updatePrg);
      }
      break;
    case "ENDIF":
      var leadchk = set_prog_stretchLeadCheck(SET_PROG_KIND_IFEND, refLine - 1, null, updatePrg);
      if (leadchk !== '' && g_program_data[leadchk].remark == (chkStr[1] == '//')) {
        /* A corresponding "else" also exists. */
        var elseId = 'ifelse' + getSplitId(leadchk);
        if(g_program_data[elseId] && g_program_data[elseId].remark == (chkStr[1] == '//')) {
          var command = create_endElseCmd('ifend', leadchk, updatePrg);
        }
      }
      break;
    case "!":
      var command = cmn_commandCreate('comment', updatePrg);
      g_program_data[command].param = progLine.replace(/^!/, '');
      break;
    case "--":  /* Multi-Lang remarks */
      var command = cmn_commandCreate('nosupport', updatePrg);
      g_program_data[command].param = set_program_data_MultiLang_param(refLine, progLine);
      break;
    default:
      break;
  }
  if(command) {
    ret = true;
    g_program_data[command].remark = (chkStr[1] == '//');
    chk_favoData_set(command, updatePrg);
  }
  return ret;
}

/*
 =========================================================================
 @function name      : set_program_data_MultiLang_param
 @argument[refLine]  : Line number of the target line
 @argument[progLine] : Program line
 @description        : Multi-Lang remarks instruction parsing process
 @return             : Value to be retained in local information in the editor
 =========================================================================
*/
function set_program_data_MultiLang_param(refLine, progLine) {
  var ret = progLine;
  var file_data = g_favoriteFlg.favoLoad == false ? ls_file_data : fav_ls_text;
  if(!save_id_array.length) {
    var editArray = file_data.slice(file_data.indexOf('/MN') + 1, file_data.indexOf('/POS'));
    var lineNumChk = function(line) {
      var chk = editArray.find(function(str) {
        return str.match(new RegExp('^\\s*' + line + '\\:'));
      });
      return (chk) ? editArray.indexOf(chk) : -1;
    };
    var endpos = lineNumChk(refLine + 1);
    editArray = (endpos != -1) ? editArray.slice(lineNumChk(refLine), endpos) : editArray.slice(lineNumChk(refLine));
    var matchLang = g_favoriteFlg.favoLoad == false ? currentLang : ( ret.indexOf('--kn:') != -1 ? gcurrentLang : gcurrentJPLang );
    var langchk = editArray.find(function(str) {
      return str.match(new RegExp('\\:\\s*\\-\\-' + matchLang + '\\:'));
    });

    ret = (langchk) ? '--' + langchk.replace(new RegExp('(^\\s*\\d*\\:\\s{2}\\-\\-' + matchLang + '\\:|\\s\\;$)', 'g'), '') : '--';
  }

  return ret;
}

/*
 =========================================================================
 @function name       : set_program_data_call
 @argument[strArray]  : Analyzed row data
 @argument[arrayNum]  : Array number of strArray
 @argument[updatePrg] : ID before update when adding sample program
 @argument[chkStr]    : "match" result when judging instruction type
 @argument[formedTxt] : Original text
 @description         : Processing of parsing Call instructions
 @return              : ID Creation Result (true:success)
 =========================================================================
*/
function set_program_data_call(strArray, arrayNum, updatePrg, chkStr, formedTxt) {
  var ret = false;
  var progname = formedTxt.replace(new RegExp('(^\\s*\\d+\\:\\s*(\/{2})?' + ORDER_CALL + '\\s|\\s$)','g'), '');
  if(progname.indexOf('(') == -1) progname = progname.replace(/\s{3}$/, '');

  var mltAdinChk = function(appName) {
    if(appName.match(/^(MLT)/)) {
      var start = progname.indexOf('('), end = progname.indexOf(',');
      if(start == -1 && end == -1) {
        var prm1 = '', tpName = progname;
      }
      else {
        var prm1 = progname.substring(start + 1, end);
        if(prm1.match(/[']/)) {
          var start1 = prm1.indexOf("'"), end1 = prm1.lastIndexOf("'");
          prm1 = prm1.substring(start1 + 1, end1);
        } else if(prm1.match(/[(]/)) {
          var start1 = prm1.indexOf("("), end1 = prm1.lastIndexOf(")");
          prm1 = prm1.substring(start1 + 1, end1);
        }
        var tpName = progname.substring(0, start, end);
      }
      return (appName == ('MLT' + prm1 + tpName).toUpperCase());
    }
  };

  /* Is there a matching instruction within the Advanced Instruction ? */
  var existChk = g_adin_appName_list.find(function(data) {
    return data.appName == progname.substring(0, progname.indexOf('(')) ||
           data.appName == progname.substring(0, progname.indexOf('(')).toUpperCase() ||
           data.appName == progname ||
           mltAdinChk(data.appName);
  });

  /* Not in g_adin_appName_list[]. */
  if(typeof existChk == 'undefined') {
    /* Call instruction */
    var createCmd = 'call';
    var chkTbl = [
      {matchStr: new RegExp('^INST_VISION'),     cmd: 'noconnect'},
      {matchStr: new RegExp('^\\-INST_PAYLOAD'), cmd: 'payload'},
    ];
    for(var cnt in chkTbl) {
      if(progname.toUpperCase().match(chkTbl[cnt].matchStr)) {
        createCmd = chkTbl[cnt].cmd;
        break;
      }
    }
    var command = createNewId(createCmd);
    g_program_data[command] = set_icon_data(createCmd);
    if(updatePrg){
      updatePrgFunc(command, updatePrg);
      g_program_data[command].id = command;
    }
    g_program_data[command].param = (g_program_data[command].baseId != 'payload') ?
                                       progname : ORDER_CALL + ' ' + progname;
  } else {
    /* Advanced instruction */
    var command = set_program_data_adInst(progname, updatePrg, existChk.baseId, (chkStr[1] == '//'));
  }
  if(command) {
    ret = true;
    g_program_data[command].remark = (chkStr[1] == '//');
    chk_favoData_set(command, updatePrg);
  }
  return ret;
}

/*
 =========================================================================
 @function name       : set_program_data_adInst
 @argument[progName]  : Advanced instruction program name
 @argument[updatePrg] : ID before update when adding sample program
 @argument[baseId]    : Common ID
 @argument[cmntFlg]   : Remarks flag (true:Remarks)
 @description         : Advanced instruction parsing process
 @return              : Creation ID
 =========================================================================
*/
function set_program_data_adInst(progName, updatePrg, baseId, cmntFlg) {
  var command;
  /* bracket end */
  if(baseId.match('bktend')) {
    if(g_favoriteFlg.favoLoad) {
      command = cmn_commandCreate(baseId, updatePrg);
    }
    else {
      var leadId = set_prog_stretchLeadCheck(SET_PROG_KIND_BKTEND, null, iconSortTbl.indexOf(baseId), updatePrg);
      if(leadId != '' && g_program_data[leadId].remark == cmntFlg) {
        command = baseId + getSplitId(leadId);
        iconTbl[baseId].idCnt = iconTbl[g_program_data[leadId].baseId].idCnt;
        g_program_data[command] = set_icon_data(baseId);
        if(updatePrg) updatePrgFunc(command, updatePrg);
      }
    }
  }
  /* "other than bracket" or "bracket lead" */
  else {
    command = cmn_commandCreate(baseId, updatePrg);
    if (progName.match(/^\-INST_ARC_HANDLE_TEACH/) && !g_favoriteFlg.favoLoad) {
      if (g_btnTeaching_list.weldteach.existsTimeline == false) {
        g_btnTeaching_list.weldteach.existsTimeline = true;
        g_btnTeaching_list.weldteach.id = command;
      }
      g_btnTeaching_list.weldteach.count++;
    }
    if (progName.match(/^\-INST_WRIST_BUTTON_TEACH/) && !g_favoriteFlg.favoLoad) {
      if (g_btnTeaching_list.wristteach.existsTimeline == false) {
        g_btnTeaching_list.wristteach.existsTimeline = true;
        g_btnTeaching_list.wristteach.id = command;
      }
      g_btnTeaching_list.wristteach.count++;
    }
  }

  if(g_program_data[command]) {
    /* P[...]/PR[...]/PR[R[...]]/PR[AR[...]] -> P[0]/PR[0]/PR[R[0]]/PR[AR[0]] */
    var tmpProgName = progName.replace(new RegExp(ORDER_POS + '\\[\\.{3}\\]', 'g'), ORDER_POS + '[0]')
                              .replace(new RegExp(ORDER_POSREGI + '\\[\\.{3}\\]', 'g'), ORDER_POSREGI + '[0]')
                              .replace(new RegExp(ORDER_POSREGI + '\\[' + ORDER_REGI + '\\[\\.{3}\\]]', 'g'), ORDER_POSREGI + '[' + ORDER_REGI + '[0]]')
                              .replace(new RegExp(ORDER_POSREGI + '\\[' + ORDER_ARGUMENT + '\\[\\.{3}\\]]', 'g'), ORDER_POSREGI + '[' + ORDER_ARGUMENT + '[0]]');
    /* Extract the name of the program to be called */
    var callProg = tmpProgName.substring(0, tmpProgName.indexOf('('));
    /* Extract arguments and remove comments. */
    var argStr = commentParse(tmpProgName.replace(/(^.*?\(|\)$)/g, ''));
    /* Set parameters in g_program_data[] */
    g_program_data[command].param = callProg + '(' + argStr + ')';
    var posval = argStr.split(',');
    if (typeof posval != 'undefined' && g_favoriteFlg.favoLoad != true) {
      /* Extract positional information. */
      var posStr = posval.filter(function(str) {return posCheck(str)});
      var posInt = '';
      var posLength = g_program_data[command].position.length < posStr.length ? g_program_data[command].position.length : posStr.length;
      for (var posCnt = 0; posCnt < posLength; posCnt++) {
        /* Comments need not be processed. */
        if(posStr[posCnt].match(/^\'/)) continue;
        posInt = posStr[posCnt].match(/(\[\d*\]|\[\.{3}\])/g)[0].replace(/[^0-9]/g, '');
        g_program_data[command].position[posCnt].number = Number(posInt);
        g_program_data[command].position[posCnt].kind = judge_posKind(posStr[posCnt]);
        if (g_program_data[command].position[posCnt].kind == POSKIND_POSREGI) {
          chk_save_posregi(posStr[posCnt]);
        }
      }
      exclamationMarkDispOnOff(command);
    }
  }
  return command;
}

/*
 =========================================================================
 @function name       : set_program_data_control
 @argument[strArray]  : Analyzed row data array
 @argument[arrayNum]  : Array number of strArray
 @argument[updatePrg] : ID before update when adding sample program
 @argument[chkStr]    : "match" result when judging instruction type
 @argument[formedTxt] : Original text
 @description         : Processing of parsing Wait/Jump/Label/Payload instructions
 @return              : ID Creation Result (true:success)
 =========================================================================
*/
function set_program_data_control(strArray, arrayNum, updatePrg, chkStr, formedTxt) {
  var ret = false;
  var progLine = formedTxt.replace(/(^\s*\d+\:\s*(\/{2})?|\s$)/g, '');

  switch (chkStr[2]) {
    case ORDER_WAIT:
      var command = cmn_commandCreate('wait', updatePrg);
      g_program_data[command].param = progLine.replace(new RegExp('(^' + ORDER_WAIT + '\\s*|\\s*$)','g'), '');
      break;
    case ORDER_JUMP:
      if(chk_JMPLBL_type(progLine) === false) {
        var command = cmn_commandCreate('jump', updatePrg);
        g_program_data[command].param = progLine;
      }
      break;
    case ORDER_LABEL:
      var command = cmn_commandCreate('label', updatePrg);
      g_program_data[command].param = outputComment_del(progLine);
      var numChk = g_program_data[command].param.replace(new RegExp('(^' + ORDER_LABEL + '\\[|\\]$)','g'), '');
      if (numChk != '...') {
        if(!numChk.match(/^\*/)) addLabelNumList(parseInt(numChk), null);
      } else {
        g_program_data[command].param = default_data_structure["label"].param;
      }
      break;
    case ORDER_PAYLOAD:
      if(progLine.match(new RegExp(ORDER_PAYLOAD + '\\[GP')) == null) {
        var command = cmn_commandCreate('payload', updatePrg);
        g_program_data[command].param = progLine;
      }
      break;
    default:
      break;
  }
  if(command) {
    ret = true;
    g_program_data[command].remark = (chkStr[1] == '//');
    chk_favoData_set(command, updatePrg);
  }
  return ret;
}

/*
 =========================================================================
 @function name       : set_program_data_uframe
 @argument[strArray]  : Analyzed row data array
 @argument[arrayNum]  : Array number of strArray
 @argument[updatePrg] : ID before update when adding sample program
 @argument[chkStr]    : "match" result when judging instruction type
 @argument[formedTxt] : Original text
 @description         : Processing of parsing Uframe/Utool instructions
 @return              : ID Creation Result (true:success)
 =========================================================================
*/
function set_program_data_uframe(strArray, arrayNum, updatePrg, chkStr, formedTxt) {
  var ret = false;
  var progLine = formedTxt.replace(/(^\s*\d+\:\s*(\/{2})?|\s$)/g, '');
  var param = progLine.split('=');
  var icon_data = [
    {name:"setuframe", chkStr: new RegExp('^' + ORDER_UFRAME + '\\[')},
    {name:"setutool",  chkStr: new RegExp('^' + ORDER_UTOOL + '\\[')},
    {name:"seluframe", chkStr: new RegExp('^' + ORDER_UFRAME_NUM + '$|^' + ORDER_UFRAME_NUM + '\\[')},
    {name:"selutool",  chkStr: new RegExp('^' + ORDER_UTOOL_NUM + '$|^' + ORDER_UTOOL_NUM + '\\[')}
  ];
  var chkKey = icon_data.find((data)=> {
    return param[0].match(data.chkStr);
  });
  if(chkKey) var command = cmn_commandCreate(chkKey.name, updatePrg);
  if(command) {
    ret = true;
    g_program_data[command].param = progLine;
    g_program_data[command].remark = (chkStr[1] == '//');
    if(chkKey.name == "setuframe" || chkKey.name == "setutool") {
      if(param[1] == "...") {
        setParam = param[0] + "=" + ORDER_POSREGI + "[" + param[1] + "]";
        g_program_data[command].param = setParam;
      }
    }
    chk_favoData_set(command, updatePrg);
  }
  return ret;
}

/*
 =========================================================================
 @function name       : set_program_data_new_arc
 @argument[strArray]  : Analyzed row data array
 @argument[arrayNum]  : Array number of strArray
 @argument[updatePrg] : ID before update when adding sample program
 @argument[chkStr]    : "match" result when judging instruction type
 @argument[formedTxt] : Original text
 @description         : Processing of parsing Arc instructions
 @return              : ID Creation Result (true:success)
 =========================================================================
*/
function set_program_data_new_arc(strArray, arrayNum, updatePrg, chkStr, formedTxt){
  var ret = false;
  var progLine = formedTxt.replace(/(^\s*\d+\:\s*(\/{2})?|\s*$)/g, '');
  var icon_data = [
    {chkStr: new RegExp('^' + ORDER_SENSOR + '\\sON\\['),  cmd: 'sensoron'},
    {chkStr: new RegExp('^' + ORDER_SENSOR + '\\sOFF\\['), cmd: 'sensoroff'},
    {chkStr: new RegExp('^' + ORDER_SEARCH + '\\sON\\['),  cmd: 'searchon'},
    {chkStr: new RegExp('^' + ORDER_DETECT_JOINT + '\\[(\\.{3}|\\d+)\\,(\\.{3}|\\d+)\\]$'), cmd: 'detectjoint'},
    {chkStr: new RegExp('^' + ORDER_TRACK_DPM + '\\[(\\.{3}|\\d+|' + ORDER_REGI + '\\[(\\.{3}|\\d+)\\])\\]$'), cmd: 'trackdpm'},
    {chkStr: new RegExp('^' + ORDER_TRACK_END + '$'),      cmd: 'trackend'},
  ];
  var chkKey = icon_data.find((data)=> {
    return progLine.match(data.chkStr);
  });
  if(chkKey) var command = cmn_commandCreate(chkKey.cmd, updatePrg);

  if(command) {
    ret = true;
    g_program_data[command].param = progLine;
    g_program_data[command].remark = (chkStr[1] == '//');
    chk_favoData_set(command, updatePrg);
  }
  return ret;
}

/*
 =========================================================================
 @function name       : set_program_data_macro
 @argument[strArray]  : Analyzed row data array
 @argument[arrayNum]  : Array number of strArray
 @argument[updatePrg] : ID before update when adding sample program
 @argument[chkStr]    : "match" result when judging instruction type
 @argument[formedTxt] : Original text
 @description         : Processing of parsing Macro instructions
 @return              : ID Creation Result (true:success)
 =========================================================================
*/
function set_program_data_macro(strArray, arrayNum, updatePrg, chkStr, formedTxt) {
  var ret = false;
  var chkName = formedTxt.replace(/(^\s*\d+\:\s{2}|\s{3}\s$)/g, '');
  var remarkFlg = (chkName.match(/^\/{2}/)) ? true : false;
  var chkName = chkName.replace(/^\/{2}/, '').replace(/[~!#%&'=`;:,-\/\\^$*+?.()|\[\]{}]/g, '\\\\$&');
  //macro instruction (to be modified)
  var macroChk = macro_list.find(function(name) {
    var replaceName = name.replace(/[~!#%&'=`;:,-\/\\^$*+?.()|\[\]{}]/g, '\\\\$&');
    return chkName === replaceName;
  });
  if(macroChk || g_favoriteFlg.favoLoad) {
    var command = cmn_commandCreate('macro', updatePrg);
    g_program_data[command].param = g_favoriteFlg.favoLoad == false ? macroChk : chkName;
    g_program_data[command].remark = remarkFlg;
    ret = true;
    chk_favoData_set(command, updatePrg);
  }
  return ret;
}

/*
 =========================================================================
 @function name       : cmn_commandCreate
 @argument[baseId]    : Common ID
 @argument[updatePrg] : ID before update when adding sample program
 @description         : Create instruction information.
 @return              : Create id
 =========================================================================
*/
function cmn_commandCreate(baseId, updatePrg) {
  var cmd = (iconSortTbl.includes(baseId)) ? createNewId(baseId) : null;
  if(cmd) {
    g_program_data[cmd] = set_icon_data(baseId);
    if(updatePrg) updatePrgFunc(cmd, updatePrg);
  }
  return cmd;
}

/*
 =========================================================================
 @function name     : createNewId
 @argument[baseId]  : Common ID
 @description       : Create a unique ID based on the baseId.
 @return            : Create id
 =========================================================================
*/
function createNewId(baseId) {
  if(g_favoriteFlg.favoLoad) {
    if(baseId.indexOf('bktend') == -1) {
      var id = g_favoriteList[g_favoriteList.length - 1].indexId;
    }
    else {
      baseId = baseId.substring(baseId.indexOf('-inst') + 6).replace(/\s$/, '')
      var startId = g_favoriteList[g_favoriteList.length - 1].indexId;
      var id = baseId + startId.substring(startId.indexOf('_fav')).replace(/\s$/, '');
    }
  }
  else {
    var id = baseId + iconTbl[baseId].idCnt;
    iconTbl[baseId].idCnt = iconTbl[baseId].idCnt + 1;
  }

  return id;
}

/*
 =========================================================================
 @function name  : updatePrgFunc
 @argument[id]   : Updated ID
 @argument[prg]  : ID before update
 @description    : Sample program added : Overwrite with updated ID
 @return         : none
 =========================================================================
*/
function updatePrgFunc(id, prg) {
  delete g_program_data[prg];
  addId[addInt] = id;
  addInt++;
  var svIdx = g_TL_progInfo.saveProg.indexOf(prg);
  if(svIdx > -1) g_TL_progInfo.saveProg[svIdx] = id;
  var dspIdx = g_TL_progInfo.dispProg.indexOf(prg);
  if(dspIdx > -1) g_TL_progInfo.dispProg[dspIdx] = id;
}

/*
 =========================================================================
 @function name    : del_posComment
 @argument[string] : Program line to be checked
 @description      : Remove comments set in the motion instructions position information.
 @return           : Formed text
 =========================================================================
*/
function del_posComment(string) {
  /* Add a space for adjusting the split result when the number of program lines is more than 4 digits. */
  var retStr = ' ' + string;

  /** function: Delete positional comments **/
  function delCmnt(chkStr, leadStr, kind) {
    var cmntDelStr = chkStr;
    var tmp = chkStr.substring(leadStr.length);
    if(kind == ORDER_POSREGI) {
    }
    else {
      var colonPos = tmp.indexOf(':'), cmtendPos = tmp.indexOf(']');
      cmntDelStr = (colonPos != -1 && colonPos < cmtendPos) ?
                     (leadStr + tmp.substring(0, colonPos) + tmp.substring(cmtendPos)) : cmntDelStr;
    }
    return cmntDelStr;
  }

  var actMatch = new RegExp('^\\s+\\d+:(' + ORDER_LINE + '|' + ORDER_JOINT + '|' + ORDER_CURVE + '|' + ORDER_CIRCLEARC + '|' + ORDER_SPLINE + ')\\s(' + ORDER_POS + '|' + ORDER_POSREGI + ')\\[');
  var posCmntChk = retStr.match(actMatch);
  if(posCmntChk) {
    retStr = delCmnt(retStr, posCmntChk[0], posCmntChk[2]);

    /* Curve: Also check Destination Position */
    if(posCmntChk[1] == ORDER_CURVE) {
      var destPos_match = new RegExp('^\\s+\\d+:' + ORDER_CURVE + '\\s(' + ORDER_POS + '|' + ORDER_POSREGI + ')\\[\\d+\]\\s(' + ORDER_POS + '|' + ORDER_POSREGI + ')\\[');
      var posCmntChk = retStr.match(destPos_match);
      if(posCmntChk) {
        retStr = delCmnt(retStr, posCmntChk[0], posCmntChk[2]);
      }
    }
  }

  return retStr;
}

/*
 =========================================================================
 @function name          : set_motion_data
 @argument[command]      : String to data key.
 @argument[array_string] : Analyzed row data
 @argument[posList]      : Position infomation list.
 @description            : Set the speed, route, and additional instruction to the list.
 @return                 : none
 =========================================================================
*/
function set_motion_data(command, array_string, posList) {
  var regiMatch = new RegExp('^' + ORDER_REGI + '\\[');
  var unitMatch = new RegExp('(mm\\/sec|cm\\/min|inch\\/min|deg\\/sec|sec|msec|\\%)$');
  var editArray = array_string.slice();
  var unitArray = editArray.find(function(str) {
    return str.match(unitMatch);
  });
  /* Multiple positions. */
  if(posList.length >= 2) {
    /* Check for additional motions for each position information. */
    var transitChk = new RegExp('^(' + langResource.ihmieditor_order_offset_c + '|' +
                                       langResource.ihmieditor_order_tool_offset_c + '|' +
                                       langResource.ihmieditor_order_voffset_c + ')');
    for(var chkCnt = 0; chkCnt < posList.length; chkCnt++) {
      var chkIdx = editArray.indexOf(posList[chkCnt].pos);
      /* With offset */
      if(chkIdx > -1 && editArray[chkIdx + 1].match(transitChk)) {
        for(var posCnt = 0; posCnt < g_program_data[command].position.length; posCnt++) {
          /* Add additional motion to the target's position information. */
          if(g_program_data[command].position[posCnt].number == posList[chkCnt].posNum &&
             g_program_data[command].position[posCnt].kind == posList[chkCnt].kind) {
            g_program_data[command].position[posCnt].offsetMotion = editArray[chkIdx + 1];
            break;
          }
        }
      }
    }
  }
  exclamationMarkDispOnOff(command);
  editArray.splice(0, editArray.indexOf(unitArray));
  /* Speed */
  if(unitArray) {  /* Other than weld path */
    var methodMatch = new RegExp('^(' + ORDER_REGI + '\\[' + ORDER_REGI + '\\[|' + ORDER_REGI + '\\[)');
    var methodResult = unitArray.match(methodMatch);
    g_program_data[command].speed.method = (methodResult) ? methodResult[0] : '';
    g_program_data[command].speed.val = outputComment_del(unitArray.replace(unitMatch, '')).replace(/[^0-9.]/g, '');
    g_program_data[command].speed.unit = unitArray.match(unitMatch)[0];
  }
  else {
    g_program_data[command].speed.method = '';
    g_program_data[command].speed.unit = '';
    /* weld path */
    if(editArray.find(function(str) {return str.match(new RegExp('^' + ORDER_WELD_SPEED + '$'));})) {
      g_program_data[command].speed.val = ORDER_WELD_SPEED;
      editArray.splice(0, editArray.indexOf(ORDER_WELD_SPEED));
    }
    else {
      g_program_data[command].speed.val = '';
      editArray.splice(0, editArray.indexOf('...'));
    }
  }
  /* Route */
  editArray.splice(0, 1);
  g_program_data[command].route.stop = editArray[0].replace(/[0-9]/g, '');
  if (g_program_data[command].route.stop === ORDER_CNT || g_program_data[command].route.stop === ORDER_CR) {
    var stopStrChk = editArray[1].match(regiMatch);
    if(stopStrChk) {
      g_program_data[command].route.stop += ' ' + ORDER_REGI;
      g_program_data[command].route.val = outputComment_del(editArray[1]).replace(/[^0-9]/g, '');
      editArray[0] += ' ' + editArray[1];
      editArray.splice(1, 1);
    }
    else {
      g_program_data[command].route.val = editArray[0].replace(/[^0-9]/g, '');
    }
  }
  else {
    g_program_data[command].route.val = editArray[0].replace(/[^0-9]/g, '');
  }
  /* Additional motion */
  if (editArray[1] !== "") {
    editArray.splice(0, 1);
    g_program_data[command].addMotion = chk_LJ_option(editArray);
  }
}

/*
 =========================================================================
 @function name          : chk_LJ_type
 @argument[array_string] : String array to check.
 @argument[orderType]    : Instruction kind
 @description            : Determine the type of instruction.
 @return                 : Result(baseId)
 =========================================================================
*/
function chk_LJ_type(array_string, orderType) {
  var tpTbl = {};
  tpTbl[ORDER_LINE]      = {baseId: 'straight',  tblKey: 'baseId_l'};
  tpTbl[ORDER_JOINT]     = {baseId: 'kakujiku',  tblKey: 'baseId_j'};
  tpTbl[ORDER_CURVE]     = {baseId: 'curve',     tblKey: 'baseId_c'};
  tpTbl[ORDER_CIRCLEARC] = {baseId: 'circlearc', tblKey: 'baseId_a'};
  tpTbl[ORDER_SPLINE]    = {baseId: 'spline',    tblKey: 'baseId_s'};

  var typeConvertTbl = {};
  typeConvertTbl[TYPE_NORMAL_LJ]   = {baseId_l: 'straight',    baseId_j: 'kakujiku',   baseId_c: 'curve',     baseId_a: 'circlearc',   baseId_s: 'spline'};
  typeConvertTbl[TYPE_VISION_LJ]   = {baseId_l: 'vsnline',     baseId_j: 'vsnjoint',   baseId_c: 'curve',     baseId_a: 'circlearc',   baseId_s: 'spline'};
  typeConvertTbl[TYPE_PLELS_LJ]    = {baseId_l: 'laserpre',    baseId_j: 'laserkpre',  baseId_c: 'curve',     baseId_a: 'circlearc',   baseId_s: 'spline'};
  typeConvertTbl[TYPE_LS_LJ]       = {baseId_l: 'laserls',     baseId_j: 'laserkls',   baseId_c: 'lasercls',  baseId_a: 'lasercals',   baseId_s: 'lasersls'};
  typeConvertTbl[TYPE_LE_LJ]       = {baseId_l: 'laserle',     baseId_j: 'laserkle',   baseId_c: 'lasercle',  baseId_a: 'lasercale',   baseId_s: 'lasersle'};
  typeConvertTbl[TYPE_ARCSTART_LJ] = {baseId_l: 'weldstartml', baseId_j: 'kakujiku',   baseId_c: 'curve',     baseId_a: 'weldstartca',   baseId_s: 'spline'};
  typeConvertTbl[TYPE_ARCEND_LJ]   = {baseId_l: 'weldstopml',  baseId_j: 'kakujiku',   baseId_c: 'curve',     baseId_a: 'weldstopca',   baseId_s: 'spline'};

  var ret = tpTbl[orderType].baseId;
  for (var index = 0; index < iconPriorityTable.length; index++) {
    var iconType = array_string.find(element => iconPriorityTable[index].searchStr.test(element));
    if (iconType !== undefined && iconPriorityTable[index].supportChk(orderType)) {
      ret = typeConvertTbl[iconPriorityTable[index].type][tpTbl[orderType].tblKey];
      if(ret != tpTbl[orderType].baseId) break;
    }
  }

  return ret;
}

/*
 =========================================================================
 @function name    : chk_LJ_option
 @argument[string] : String array to check.
 @description      : Create a list of additional instructions.
 @return           : Array to be stored in g_program_data[].addMotion
 =========================================================================
*/
function chk_LJ_option(string) {
  var chkStr = new RegExp('(' + langResource.ihmieditor_order_ta_c + '|' + langResource.ihmieditor_order_tb_c + '|' + langResource.ihmieditor_order_db_c + ')');
  var chkRegiStr = new RegExp('^(' + ORDER_REGI + '|' + ORDER_POSREGI + '|' + ORDER_ARGUMENT + '|AR|PR|R)\\[');
  var optArray = [];
  var newArrStrList = string.slice();
  for(var cnt = 0; cnt < newArrStrList.length; cnt++) {
    if((newArrStrList[cnt + 1] != undefined) &&
       ((newArrStrList[cnt + 1].match(chkRegiStr)) ||  (newArrStrList[cnt + 1].match(/(mm|sec)/)) || (newArrStrList[cnt + 1] == '...'))) {
      newArrStrList[cnt] = newArrStrList[cnt] + ' ' + newArrStrList[cnt + 1];
      newArrStrList.splice(cnt + 1, 1);
      cnt -= 1;
    }
  }
  if (string[string.length - 1].trim() == '') { newArrStrList.pop(); }
  for (var optCnt = 0; optCnt < newArrStrList.length; optCnt++) {
    if(newArrStrList[optCnt].match(chkStr)) {
      if((newArrStrList[optCnt + 1] != undefined) && (newArrStrList[optCnt].match(new RegExp(ORDER_CALL + '$')))) {
        newArrStrList[optCnt] = newArrStrList[optCnt] + ' ' + newArrStrList[optCnt + 1];
        newArrStrList.splice(optCnt + 1, 1);
      }
    }
    else if(newArrStrList[optCnt] === 'PR_CALL' || newArrStrList[optCnt] === 'RampTo(') {
      var cmbStr = newArrStrList[optCnt] === 'PR_CALL' ? ' ' + newArrStrList[optCnt + 1] : newArrStrList[optCnt + 1];
      newArrStrList[optCnt] = newArrStrList[optCnt] + cmbStr;
      newArrStrList.splice(optCnt + 1, 1);
    }
    else {
    }
    optArray.push(newArrStrList[optCnt]);
  }
  return optArray;
}

/*
 =========================================================================
 @function name      : chk_JMPLBL_type
 @argument[progLine] : Program line to check.
 @description        : Confirm the argument type of the label instruction.
 @return             : Result(true : The argument is a register / false : Direct)
 =========================================================================
*/
function chk_JMPLBL_type(progLine) {
  var chk_str = new RegExp(ORDER_LABEL + '\\[(' + ORDER_REGI + '|' + ORDER_ARGUMENT + ')\\[');
  return (progLine.match(chk_str)) ? true : false;
}

/*
 =========================================================================
 @function name : judge_posKind
 @argument[str] : String to be checked
 @description   : check position data kind
 @return        : position data has indirect index or not
 =========================================================================
*/
function judge_posKind(str) {
  var kindChk = [
    {chkStr: new RegExp('^' + ORDER_POSREGI + '\\[' + ORDER_REGI),     retkind: POSKIND_POSREGI_REGI},
    {chkStr: new RegExp('^' + ORDER_POSREGI + '\\[' + ORDER_ARGUMENT), retkind: POSKIND_POSREGI_AR  },
    {chkStr: new RegExp('^' + ORDER_POSREGI + '\\['),                  retkind: POSKIND_POSREGI     },
  ];
  var chkResult = kindChk.find(function(data) {
    return str.match(data.chkStr);
  });

  return (chkResult) ? chkResult.retkind : POSKIND_POSNUM;
}

/*
 =========================================================================
 @function name          : repair_g_program_data
 @argument[array_string] : String array to repair.
 @description            : Restore strings erroneously split by spaces.
 @return                 : Repair string array
 =========================================================================
*/
function repair_g_program_data(array_string) {
  var chkArcList = [ORDER_WELDSTART.split(/\s+/), ORDER_WELDEND.split(/\s+/)];

  // check arc
  for(var arcCnt = 0; arcCnt < chkArcList.length; arcCnt++) {
    if(chkArcList[arcCnt].length < 2) continue;
    var strExistChk = array_string.indexOf(chkArcList[arcCnt][0]);
    if(strExistChk < 0) continue;
    for(var cnt = strExistChk; cnt < array_string.length; cnt++) {
      if(array_string[cnt] == chkArcList[arcCnt][0]) {
        var chkArcStr = new RegExp('^' + chkArcList[arcCnt][1] + '\\[');
        if(array_string[cnt + 1].match(chkArcStr)){
          array_string[cnt] = array_string[cnt] + ' ' + array_string[cnt + 1];
          array_string.splice(cnt + 1, 1);
          cnt -= 1;
        }
      }
    }
  }
  return array_string;
}

/*
 =========================================================================
 @function name          : chk_save_posregi
 @argument[array_string] : String to be checked
 @description            : Stores empty position register information.
 @return                 : none
 =========================================================================
*/
function chk_save_posregi(array_string) {
  var regi_val = ((array_string.match(/:/)) ? array_string.substring(0, array_string.indexOf(":")) : array_string);
  var setRegiData = {};
  for (var i = 0; i < getGroupCount(); i++){
    setRegiData[(i + 1) + ',' + parseInt(regi_val.replace(/[^0-9]/g, ''))] = DEF_POSREGI_VAL;
  }
  // Inserts temporary data and keeps a history of updates.
  // If there are multiple groups, record the values in all groups to avoid errors.
  set_position_regi_data(setRegiData);
}

/*
 =========================================================================
 @function name          : noSupport_replace
 @argument[array_string] : Array of TP strings.
 @argument[setparam]     : String to set for param.
 @description            : Create instruction information as textcode.
 @return                 : The assigned textcode ID.
 =========================================================================
*/
function noSupport_replace(array_string, setparam) {
  var param = "";
  if(g_favoriteFlg.favoLoad) {
    var command = g_favoriteList[g_favoriteList.length - 1].indexId;
  }
  else {
    var command = 'nosupport' + iconTbl['nosupport'].idCnt;
    iconTbl['nosupport'].idCnt = iconTbl['nosupport'].idCnt + 1;
  }
  g_program_data[command] = set_icon_data("nosupport");
  if(array_string !== null) {
    for (var cnt = 1; cnt < array_string.length; cnt++) {
      if(cnt === 1) {
        param += array_string[cnt].replace(/^\d+:/, "") + " ";
      }
      else {
        if(array_string[cnt].match(/^\/{2}/)) g_program_data[command].remark = true;
        param += ((array_string[cnt].trim() != '') ? (array_string[cnt] + " ") : '');
      }
    }
  }
  else {
    param = setparam;
  }
  g_program_data[command].param += param.trim();
  if(g_program_data[command].remark) g_program_data[command].param = g_program_data[command].param.replace(/^\/{2}/, '');

  return command;
}

/*
 =========================================================================
 @function name          : set_prog_stretchLeadCheck
 @argument[kind]         : Kind to check
 @argument[refPos]       : Check start point
 @argument[sortTblIndex] : Index of iconSortTbl
 @argument[updatePrg]    : ID before update when adding sample program
 @description            : Verify that the g_program_data[] has a pair ID.
 @return                 : ID to be paired (If not present, '')
 =========================================================================
*/
var SET_PROG_KIND_IFELSE = 1;
var SET_PROG_KIND_IFEND = 2;
var SET_PROG_KIND_FOREND = 3;
var SET_PROG_KIND_BKTEND = 4;
function set_prog_stretchLeadCheck(kind, refPos, sortTblIndex, updatePrg) {
  var ret = '';
  var leadId = '';
  /** function: Kind Check **/
  var kindChk = function(kind, chkId) {
    return (kind == SET_PROG_KIND_IFELSE) ?
            chkId.startsWith('ifelse') :
            stretch_idStrChk(STRETCH_ID_CHK_END, chkId);
  };
  /* When adding sample programs, when loading TP? */
  var chkBktArray = updatePrg ? addId : g_TL_progInfo.bktSaveProg;
  var sortProgKey = chkBktArray.filter(function(key) {
    return (stretch_idStrChk(STRETCH_ID_CHK_LEAD, key) || kindChk(kind, key));
  });

  var chk_kind = (kind === SET_PROG_KIND_FOREND) ? 'forlead' :
                   (kind === SET_PROG_KIND_BKTEND) ? iconSortTbl[sortTblIndex - 1] : 'iflead';

  for(var cnt = sortProgKey.length - 1; cnt >= 0; cnt--) {
    /* g_program_data[] kind:END or ELSE */
    if(kindChk(kind, sortProgKey[cnt])) {
      /* Search for the beginning. */
      leadId = get_stretch_pairId(sortProgKey[cnt], REQ_ID_KIND_LEAD, null);
      /* Lead ID exists. */
      if(g_program_data[leadId] != undefined) {
        /* Adjust counter. */
        var chkIndex = sortProgKey.indexOf(leadId);
        cnt = (chkIndex != -1) ? chkIndex : 0;
      }
    }
    
    if((leadId !== sortProgKey[cnt]) && (g_program_data[sortProgKey[cnt]].baseId === chk_kind)) {
      ret = sortProgKey[cnt];
      break;
    }
  }

  return ret;
}

/*
 =========================================================================
 @function name         : set_prog_nosupportReplace
 @argument[replaceData] : ID of the instruction to be replaced by textcode
 @description           : Replace with textcode instructions
 @return                : The assigned textcode ID.
 =========================================================================
*/
function set_prog_nosupportReplace(replaceData) {
  var tmpData = JSON.parse(JSON.stringify(g_program_data[replaceData]));
  var retId = '';
  var tmpparam = tmpData.param;
  if(stretch_idStrChk(STRETCH_ID_CHK_BKT, replaceData) && tmpparam.match(new RegExp('^' + ORDER_CALL)) == null) {
    tmpparam = ORDER_CALL + ' ' + tmpparam;
  }

  /* Get textcode ID */
  retId = noSupport_replace(null, tmpparam);
  /* Update array information */
  g_TL_progInfo.saveProg[g_TL_progInfo.saveProg.indexOf(replaceData)] = retId;

  /* The instruction before replacement is a label instruction. */
  if((g_program_data[replaceData] != undefined) && (g_program_data[replaceData].baseId === 'label')) {
    /* Get label number & Delete from list */
    var delNum = g_program_data[replaceData].param.replace(new RegExp('(^' + ORDER_LABEL + '\\[|\\]$)','g'), '');
    if(!delNum.match(/^\*/)) delLabelNumList(parseInt(delNum));
  }
  /* Adding attached instructions */
  if(g_adin_state.adinstAttachedFlg){
    for(var i = 0; i < addId.length; i++){
      if(addId[i] == replaceData) addId[i] = retId;
    }
  }

  /* Save remark information */
  var remarkFlg = g_program_data[replaceData].remark;
  /* Delete information before replacement */
  delete g_program_data[replaceData];

  if(tmpData.baseId === 'iflead') {
    var setParam = 'IF (' + tmpData.param + ') THEN';
  }
  /* replaceData update */
  replaceData = retId;
  if(setParam != undefined) {
    g_program_data[retId].param = setParam;
  }
  g_program_data[retId].remark = remarkFlg;

  return retId;
}

/*
 =========================================================================
 @function name   : check_progOrder
 @argument        : none
 @description     : Check to see if bracket instructions are paired.
 @return          : none
 =========================================================================
*/
function check_progOrder() {
  var leadId = '', endId = '', elseId = '';
  var bktArray = g_TL_progInfo.bktSaveProg.slice();

  /** function: Data replace **/
  var tcReplace = function(replaceId) {
    /* Replaced by textcode */
    var newId = set_prog_nosupportReplace(replaceId);
    var idx = bktArray.indexOf(replaceId);
    if(idx != -1) bktArray[idx] = newId;
    var bktIdx = g_TL_progInfo.bktSaveProg.indexOf(replaceId);
    if(bktIdx != -1) g_TL_progInfo.bktSaveProg.splice(bktIdx, 1);
  };

  /** function: Sequence check **/
  var seqChk = function(start, endId) {
    var chkCounter = [];
    for(var cnt2 = start; bktArray[cnt2] != endId; cnt2++) {
      /* lead ID */
      if(stretch_idStrChk(STRETCH_ID_CHK_LEAD, bktArray[cnt2])) {
        /* Save ID */
        chkCounter[bktArray[cnt2]] = bktArray[cnt2];
      }
      /* end ID */
      else if(stretch_idStrChk(STRETCH_ID_CHK_END, bktArray[cnt2])) {
        var leadId = get_stretch_pairId(bktArray[cnt2], REQ_ID_KIND_LEAD, null);
        /* ID is stored. */
        if(chkCounter[leadId] != undefined) {
          /* Delete ID information */
          delete chkCounter[leadId];
        }
        /* Does not hold lead ID -> A pair is not formed */
        else {
          /* Replaced by textcode */
          var bktIdx = g_TL_progInfo.bktSaveProg.indexOf(bktArray[cnt2]);
          if(bktIdx != -1) g_TL_progInfo.bktSaveProg.splice(bktIdx, 1);
          bktArray[cnt2] = set_prog_nosupportReplace(bktArray[cnt2]);
        }
      }
    }
    /* ID information remains in chkCounter[] */
    for(var delkey in chkCounter) {
      /* Replace with textcode if end side information exists */
      var endId = get_stretch_pairId(delkey, REQ_ID_KIND_END, null);
      if(g_program_data[endId]) tcReplace(endId);
      /* For "IF", also check "else" */
      if(stretch_idStrChk(STRETCH_ID_CHK_IF, delkey)) {
        var elseId = get_stretch_pairId(delkey, REQ_ID_KIND_ELSE, null);
        if(g_program_data[elseId]) tcReplace(elseId);
      }
      /* Replace lead side information with textcode */
      tcReplace(delkey);
      delete chkCounter[delkey];
    }
  };

  for(var cnt = 0; cnt < bktArray.length; cnt++) {
    leadId = '', endId = '', elseId = '';
    /* bracket lead */
    if(stretch_idStrChk(STRETCH_ID_CHK_LEAD, bktArray[cnt])) {
      leadId = bktArray[cnt];
      endId = get_stretch_pairId(bktArray[cnt], REQ_ID_KIND_END, null);
      /* There is no paired end ID. */
      if(g_program_data[endId] == undefined) {
        /* iflead */
        if(stretch_idStrChk(STRETCH_ID_CHK_IF, leadId)) {
          /* Obtain an else ID. */
          elseId = get_stretch_pairId(leadId, REQ_ID_KIND_ELSE, null);
          /* Replaces g_program_data[] in the else instruction, if present. */
          if(g_program_data[elseId]) tcReplace(elseId);
        }
        /* Replaces the lead side. */
        bktArray[cnt] = set_prog_nosupportReplace(bktArray[cnt]);
        var bktIdx = g_TL_progInfo.bktSaveProg.indexOf(leadId);
        if(bktIdx != -1) g_TL_progInfo.bktSaveProg.splice(bktIdx, 1);
        continue;
      }
      /* leadId is 'iflead' */
      if(g_program_data[leadId].baseId == 'iflead') {
        elseId = get_stretch_pairId(bktArray[cnt], REQ_ID_KIND_ELSE, null);
        /* There is no paired ID or The order of "else" and "end" is incorrect. */
        if(g_program_data[elseId] == undefined ||
           (g_program_data[elseId] != undefined &&
            g_TL_progInfo.saveProg.indexOf(elseId) > g_TL_progInfo.saveProg.indexOf(endId))) {
          /* Replace the corresponding instruction. */
          bktArray[cnt] = set_prog_nosupportReplace(bktArray[cnt]);
          var bktIdx = g_TL_progInfo.bktSaveProg.indexOf(leadId);
          if(bktIdx != -1) g_TL_progInfo.bktSaveProg.splice(bktIdx, 1);
          tcReplace(endId);
          if(g_program_data[elseId]) tcReplace(elseId);
          continue;
        }
      }

      /* Check the sequence */
      seqChk(cnt + 1, elseId ? elseId : endId);
    }
    /* bracket end */
    else if(stretch_idStrChk(STRETCH_ID_CHK_END, bktArray[cnt])) {
      leadId = get_stretch_pairId(bktArray[cnt], REQ_ID_KIND_LEAD, null);
      /* There is no paired ID. */
      if(g_program_data[leadId] == undefined) {
        /* Replaces the lead side. */
        var bktIdx = g_TL_progInfo.bktSaveProg.indexOf(bktArray[cnt]);
        if(bktIdx != -1) g_TL_progInfo.bktSaveProg.splice(bktIdx, 1);
        bktArray[cnt] = set_prog_nosupportReplace(bktArray[cnt]);
      }
    }
    /* ifelse */
    else if(bktArray[cnt].startsWith('ifelse') == true) {
      leadId = get_stretch_pairId(bktArray[cnt], REQ_ID_KIND_LEAD, null);
      endId = get_stretch_pairId(bktArray[cnt], REQ_ID_KIND_END, null);
      /* There is no paired ID. */
      if(g_program_data[leadId] == undefined || g_program_data[endId] == undefined) {
        /* Replace the corresponding instruction. */
        var bktIdx = g_TL_progInfo.bktSaveProg.indexOf(bktArray[cnt]);
        if(bktIdx != -1) g_TL_progInfo.bktSaveProg.splice(bktIdx, 1);
        bktArray[cnt] = set_prog_nosupportReplace(bktArray[cnt]);
        if(g_program_data[leadId]) tcReplace(leadId);
        if(g_program_data[endId]) tcReplace(endId);
        continue;
      }
      /* Check the sequence */
      seqChk(cnt + 1, endId);
    }
  }
}

/*
 =========================================================================
 @function name   : check_remainGhost
 @argument        : none
 @description     : If there are ghosts left from the last time it was displayed, delete them.
 @return          : none
 =========================================================================
*/
function check_remainGhost() {
	var remain = scrlWrpElm.getElementsByClassName('sortable-drag');
	for(var cnt = 0; cnt < remain.length; cnt++) {
		remain[cnt].remove();
	}
}

/*
 =========================================================================
 @function name       : analizePosition
 @argument[line]      : Program text.
 @argument[status]    : Location type
 @argument[posArray]  : An array containing the positions
 @description         : Set to display structure
 @return[prgchk_flg]  : Analysis of position data string
 =========================================================================
*/
function analizePosition(line, status, posArray) {
  // When the position data is '***', there is a bug just before the expansion axis.
  // (The comma at the end of the line is missing.)
  // Normally it is analysis of group, but analysis of extend axis is necessary.
  if ((status.type == POSGROUP) && (line.indexOf('GP') < 0)) {
    if (line.indexOf(';') < 0) { // No terminate position data.
      status.type = POSPOSITION;
    }
  }
  switch (status.type) {
    case POSCAPTION: // Position number
      // pickup number of [n]
      var sqBraLf = line.indexOf('[');
      var sqBraRi = line.indexOf(']', sqBraLf);
      if ((sqBraLf == -1) || (sqBraRi == -1)) {
        return -1;
      }
      var numStr = line.substring(sqBraLf + 1, sqBraRi);
      var cmntStr = '';
      var cmntPos = numStr.indexOf(':');
      if (cmntPos >= 0) { // comment is exist
        cmntStr = numStr.substr(cmntPos + 1).slice(1, -1); // Remove quotes around it
        numStr = numStr.substring(0, cmntPos);
      }
      var posNum = parseInt(numStr);
      var posData = {};
      posData.posNumber = posNum;
      posData.Comment = cmntStr;
      posArray[posArray.length] = posData;
      status.type = POSGROUP;
      status.posNum = posNum;
      break;
    case POSGROUP: // Group number
      // pickup number of GPn:
      var grpPos = line.indexOf('GP');
      var grpEnd = line.indexOf(':', grpPos);
      if ((grpPos == -1) || (grpEnd == -1)) {
        return {type: POSCAPTION, posNum: 0, grpNum: 0}; // May be close position [};]. Back to position top.
      }
      var grpStr = line.substring(grpPos + 'GP'.length, grpEnd);
      var grpNum = parseInt(grpStr);
      var grpData = {};
      grpData = {
        'groupNumber': grpNum
      };
      var posDatas = posArray[posArray.length - 1].posData;
      if (posDatas == undefined) { // 1st group
        posDatas = [];
      }
      var posGrpIndex = posDatas.length;
      posDatas[posGrpIndex] = grpData;
      posArray[posArray.length - 1].posData = posDatas;
      status.type = POSCOORDINATE;
      status.grpNum = grpNum;
      break;
    case POSCOORDINATE: // Coordinate data
      var posDatas = posArray[posArray.length - 1].posData;
      var posIndex = posDatas.length - 1;
      // Analyze UF, UT, CONFIG...
      var crds = line.split(','); // Split for each comma
      for (index in crds) {
        var crd = crds[index].split(':'); // Split by colon
        if (crd[0].trim() == 'UF') {
          var ufVal = parseInt(crd[1].trim());
          if (isNaN(ufVal)) {
            ufVal = '';
          }
          posArray[posArray.length - 1].posData[posIndex].ufVal = ufVal;
        } else if (crd[0].trim() == 'UT') {
          var utVal = parseInt(crd[1].trim());
          if (isNaN(utVal)) {
            utVal = '';
          }
          posArray[posArray.length - 1].posData[posIndex].utVal = utVal;
        } else if (crd[0].trim().length > 0) { // if any string is exist, set as ('CONFIG').
          var confPos = line.lastIndexOf(':');
          var confStr = line.substr(confPos + 1);
          var confSta = confStr.indexOf("'");
          var confEnd = confStr.lastIndexOf("'");
          confStr = confStr.substring(confSta + 1, confEnd);
          posArray[posArray.length - 1].posData[posIndex].configStr = confStr;
          break; // Do not analyze any more...
        }
      }
      status.type = POSPOSITION;
      break;
    case POSPOSITION: // Position raw data
      var untaughtFlg = false;
      var posDatas = posArray[posArray.length - 1].posData;
      var posIndex = posDatas.length - 1;
      var posElem = line.split(','); // Split for each comma
      for (index in posElem) {
        var elem = posElem[index]; // 1 item
        if (elem.length == 0) {
          continue;
        }
        var keys = elem.split('='); // Split by equal
        var keyPair = {};
        var keyStr = keys[0].trim()
        if (keyStr.startsWith('E')) {
          var realKey = 'EXT' + (keyStr.substr(1));
          keyStr = realKey;
        }
        keyPair.key = keyStr;
        keyPair.val = parseFloat(keys[1]);
        if (isNaN(keyPair.val)) {
          keyPair.val = 0;
          untaughtFlg = true;
        }
        var poskeys = posArray[posArray.length - 1].posData[posIndex].poskey;
        if (poskeys == undefined) {
          poskeys = [];
        }
        var pkindex = poskeys.length;
        poskeys[pkindex] = keyPair;
        posArray[posArray.length - 1].posData[posIndex].poskey = poskeys;
      }
      if (line.charAt(line.length - 1) != ',') { // line mode continue...
        status.type = POSGROUP;
        /* Search for position number. */
        var chkPosNum = posArray.find(function(data) { return data.posNumber == status.posNum; });
        if(chkPosNum) {
          /* Search for group number. */
          var targetGrp = chkPosNum.posData.find(function(pData) { return pData.groupNumber == status.grpNum; });
          if(targetGrp) {
            targetGrp.empty = untaughtFlg;
            if(!untaughtFlg) targetGrp.rep = (targetGrp.poskey.find(function(data) { return data.key == 'X' })) ?
                                               FORMAT_CART : FORMAT_JOINT;
          }
        }
      }
      break;
    default:
      // especially none
      break;
  }
  return status;
}
/*
 =========================================================================
 @function name  : display_program_data
 @argument       : none.
 @description    : Processing to display icons etc. on the screen
 @return         : none
 =========================================================================
*/
function display_program_data() {
  if(g_TL_elm.children.length > TL_PROG_LEAD_POS) {
    /* initialize */
    clear_timeline();
    $('#exe_column').addClass('clm_active');
  }
  create_dispIconArray();
  var strchCntArray = get_progList_bktlead();
  for(var nestLineCnt = 0; nestLineCnt < strchCntArray.length; nestLineCnt++) {
//    order_nestChk(strchCntArray[nestLineCnt]);
    /* Preserve IDs in brackets */
    rd_stretch_dataSet(strchCntArray[nestLineCnt]);
    var endId = get_stretch_pairId(strchCntArray[nestLineCnt], REQ_ID_KIND_END, null);
    g_program_data[endId].nest.num = g_program_data[strchCntArray[nestLineCnt]].nest.num;
  }
  /* Timeline nested update */
  timeLine_nestUpdate();
  /* g_program_data[]Update array number */
  g_program_arrayNumSave();
  /* Scale update */
  draw_TLscale(false);
  tl_adjust_dispRange();
}

/*
 =========================================================================
 @function name  : tl_adjust_dispRange
 @arg[]          : none
 @description    : Determine the display range.
 @return         : none
 =========================================================================
*/
function tl_adjust_dispRange() {
  if(g_TL_scrolling) return;
  var setWidth = '', setHeight = '';
  /* Vertival scroll view */
  if(g_tlScroll_direction == TL_SCRL_VRTCL) {
    setHeight = $(TLspacerElm).css('height');
    /* Calculate the upper row to be displayed */
    var tmpTopRow = ~~((scrlWrpElm.scrollTop - (BASE_VERTICAL_TL_HEIGHT * 2)) / BASE_VERTICAL_TL_HEIGHT);
    if(tmpTopRow < 0) tmpTopRow = 0;
    /* Calculate the display start position in the program */
    var tmpLeft = (tmpTopRow * get_dispWidth_iconNum());
    /* Scroll direction */
    g_TL_progInfo.scrollDist = (tmpLeft < g_TL_progInfo.dispRange.left) ? 'top' : 'bottom';
    /* Store display range */
    g_TL_progInfo.dispRange.left = tmpLeft;
    var dispInRow = Math.ceil((parts_block.clientHeight - (scrlWrpElm.offsetTop + HANDLERESIZE_HEIGHT)) / BASE_VERTICAL_TL_HEIGHT);
    g_TL_progInfo.dispRange.right = tmpLeft + (dispInRow + 2) * get_dispWidth_iconNum();
    setHeight = tmpTopRow * BASE_VERTICAL_TL_HEIGHT;
  }
  /* Horizontal scroll view */
  else {
    setWidth = $(TLspacerElm).css('width');
    var padding = Number($(g_TL_elm).css('padding-left').replace(/[^0-9.]/g,"")) - 20;
    /* Calculate the amount of scrolling. ("5" is the adjusted value for iPad Pro.) */
    var calcSrclLeft = (scrlWrpElm.scrollLeft - 5) < padding ? 0 : Math.floor(scrlWrpElm.scrollLeft - padding);
    if(calcSrclLeft <= (g_TL_elm.scrollWidth - window.innerWidth) - padding) {
      /* Calculate the display start position in the program */
      var tmpLeft = ~~((calcSrclLeft - (TL_ICON_WIDTH_OUTER * 5)) / TL_ICON_WIDTH_OUTER);
      if(tmpLeft < 0) tmpLeft = 0;
      /* Store display range */
      g_TL_progInfo.dispRange.left = tmpLeft;
      g_TL_progInfo.dispRange.right = tmpLeft + get_dispWidth_iconNum() + 10;
      var creStartPos = (calcSrclLeft / TL_ICON_WIDTH_OUTER | 0) - 5;
      setWidth = TL_ICON_WIDTH_OUTER * ((creStartPos < 0) ? 0 : creStartPos);
    }
  }
  $(TLspacerElm).css({'width': setWidth, 'height': setHeight});
  tl_dispRange();
}

/*
 =========================================================================
 @function name  : tl_dispRange
 @arg[]          : none
 @description    : Icon drawing within the display range.
 @return         : none
 =========================================================================
*/
function tl_dispRange() {
  var delChkLength = TL_PROG_LEAD_POS;
  var dragElm = null;
  var dragging = null;
  var refIdx = 5;
  /* Check for the presence of ghost elements and elements in drag. */
  var dragData = Array.from(g_TL_elm.children).filter(function(data) {
    return data.classList.contains('sortable-chosen');
  });
  for(var idx in dragData) {
    if(dragData[idx].classList.contains('sortable-ghost')) {
      dragElm = dragData[idx];
      refIdx = Array.from(g_TL_elm.children).indexOf(dragElm);
      refIdx = (refIdx >= 0) ? refIdx - TL_PROG_LEAD_POS : 5;
    }
    else {
      dragging = dragData[idx];
    }
  }
  /* Deletes all elements except the ghost element and the element being dragged. */
  while(g_TL_elm.children.length > delChkLength) {
    if(g_TL_elm.children[delChkLength].classList.contains('sortable-chosen')) {
      delChkLength++;
      continue;
    }
    if(!g_TL_elm.children[delChkLength]) break;
    g_TL_elm.removeChild(g_TL_elm.children[delChkLength]);
  }

  var addElm = '';
  var stretchClass = '';
  var apndCnt = 0;
  var fragment_before = document.createDocumentFragment();
  var fragment_after = document.createDocumentFragment();
  var addComment = [];
  /* Icon creation within the display range */
  for(var cnt = g_TL_progInfo.dispRange.left; cnt < g_TL_progInfo.dispRange.right; cnt++) {
    if(!g_TL_progInfo.dispProg[cnt] || !g_program_data[g_TL_progInfo.dispProg[cnt]]) break;
    if(dragElm && dragElm.id == g_TL_progInfo.dispProg[cnt]) continue;

    if(g_columnRelationInfo.columnId == '' || g_columnRelationInfo.dispPosId == '') {  /* fail safe */
      g_columnRelationInfo.columnId = g_columnRelationInfo.dispPosId = g_TL_progInfo.dispProg[0];
    }
    var dispProgId = g_TL_progInfo.dispProg[cnt];
    stretchClass = g_program_data[dispProgId].stretch ? g_program_data[dispProgId].stretch.state : '';
    addElm = addIcon_create(dispProgId, stretchClass);
    /* Handle teach */
    if(g_program_data[dispProgId].baseId === '-INST_ARC_HANDLE_TEACH') {
      progdata_addClassCheck(addElm.id, 'excl_mark');
      /* Arc Teach=classadd "weldingteach" */
      progdata_addClassCheck(addElm.id, 'weldingteach');
      /* fail safe */
      if (g_btnTeaching_list.weldteach.existsTimeline == false) {
        g_btnTeaching_list.weldteach.existsTimeline = true;
        g_btnTeaching_list.weldteach.id = addElm.id;
        g_btnTeaching_list.weldteach.count++;
      }
    }
    if(g_program_data[addElm.id].remark) {
      progdata_addClassCheck(addElm.id, 'remarked');
    }
    tl_dispRange_assignClass(addElm);
    /* Draws elements within the display range. */
    tl_dispRange_addNest(addElm);
    
    /* Add to fragment */
    if(!dragElm || apndCnt > refIdx) {
      /* Add after the ghost element. */
      fragment_after.appendChild(addElm);
    }
    else {
      /* Add before ghost element. */
      fragment_before.appendChild(addElm);
    }
    apndCnt++;
    
    /* Comment is set. */
    if(g_program_data[addElm.id].baseId === 'comment' && g_program_data[addElm.id].param != '') {
      addComment.push(addElm);
    }
  }

  if(fragment_before.children.length) $(TLspacerElm).after(fragment_before);
  if(fragment_after.children.length) {
    if(dragging) {
      $(dragging).before(fragment_after);
    }
    else {
      g_TL_elm.appendChild(fragment_after);
    }
  }
  /* Draw nestline */
  tl_dispRange_drawnest();
  /* Draw comments */
  for(var cmntCnt = 0; cmntCnt < addComment.length; cmntCnt++) {
    addCmntFeeder(addComment[cmntCnt]);
  }
  /* Hide the nest line while dragging. */
  if(dragElm || g_tlmove_ghost != '') nestCurveHidden('hidden');
}

/*
 =========================================================================
 @function name  : tl_dispRange_assignClass
 @arg[elm]       : Target Element
 @description    : Assign a class to the instruction element.
 @return         : none
 =========================================================================
*/
function tl_dispRange_assignClass(elm) {
  var assign = g_program_data[elm.id].select;
  for(var cnt = 0; cnt < g_program_data[elm.id].assignClass.length; cnt++) {
    assign += (' ' + g_program_data[elm.id].assignClass[cnt]);
  }
  if(assign) $(elm).addClass(assign);
}

/*
 =========================================================================
 @function name  : tl_dispRange_addNest
 @arg[elm]       : Target Element
 @description    : Add the necessary nestline elements to the instruction element.
 @return         : none
 =========================================================================
*/
function tl_dispRange_addNest(elm) {
  if(g_program_data[elm.id].nest.layer.length) {
    var layernest = null, addnest = null, classStr;
    var def_nest = document.createElement('div');
    $(def_nest).addClass('layer_nestline');
    var nestparts = document.createElement('div');
    $(nestparts).addClass('split_nestline');

    var maxNum = (g_tlScroll_direction == TL_SCRL_VRTCL) ? MAX_NESTLINE_NUM_VRTCL : MAX_NESTLINE_NUM;
    layernest = def_nest.cloneNode(true);
    for(var nestCnt = 0; nestCnt < g_program_data[elm.id].nest.layer.length; nestCnt++) {
      if(g_program_data[elm.id].nest.layer[nestCnt].row <= maxNum) {
        addnest = nestparts.cloneNode(true);
        classStr = 'nestlayer_' + g_program_data[elm.id].nest.layer[nestCnt].row +
                      ((g_program_data[elm.id].nest.layer[nestCnt].color != '') ? (' ' + g_program_data[elm.id].nest.layer[nestCnt].color) : '');
        $(addnest).addClass(classStr);
        /* The subject Bracket Instruction has been remarked on. */
        if(g_program_data[g_program_data[elm.id].nest.layer[nestCnt].leadId].remark) {
          $(addnest).addClass('remarked');
        }
        $(layernest).append(addnest);
      }
    }
    $(elm).append(layernest);
  }
}

/*
 =========================================================================
 @function name  : tl_dispRange_drawnest
 @arg[]          : none
 @description    : Nestline drawing within the display range.
 @return         : none
 =========================================================================
*/
function tl_dispRange_drawnest() {
  var bktArray = Array.from(g_TL_elm.children).filter(function(elm) {
    return (g_program_data[elm.id] &&
            (g_program_data[elm.id].stretch && g_program_data[elm.id].stretch.state == 'stretch_open') ||
             stretch_idStrChk(STRETCH_ID_CHK_N_LEAD, elm.id));
  });
  for(var bktCnt = 0; bktCnt < bktArray.length; bktCnt++) {
    set_order_nestCss(bktArray[bktCnt].id, TARGET_ASSIGNED_ID);
    nestLineColorChange(get_stretch_pairId(bktArray[bktCnt].id, REQ_ID_KIND_LEAD, null), g_program_data[bktArray[bktCnt].id].select);
  }
  /* When displayed in vertical orientation, nest lines are drawn to the edge of the screen. */
  if(g_tlScroll_direction == TL_SCRL_VRTCL) {
    for (var edgeCnt = TL_PROG_LEAD_POS; edgeCnt < g_TL_elm.children.length; edgeCnt++) {
      /* Right edge of screen */
      if(chkScrnEdge(g_TL_elm.children[edgeCnt].id, 'right')) {
        var leftWidth = parts_block.clientWidth - 10 - (g_TL_elm.children[edgeCnt].offsetLeft + TL_ICON_WIDTH + 10);
        /* Draw a nest line to the edge of the screen. */
        $(g_TL_elm.children[edgeCnt]).find('.layer_nestline').css('width', 'calc(100% + ' + leftWidth + 'px)');
        if(stretch_idStrChk(STRETCH_ID_CHK_N_END, g_TL_elm.children[edgeCnt].id)) {
          var bktnest = $(g_TL_elm.children[edgeCnt]).find('.nestline');
          for(var nestcnt = 0; nestcnt < bktnest.length; nestcnt++) {
            if(bktnest[nestcnt].classList.contains('leftside') == false) {
              $(bktnest[nestcnt]).css('width', (bktnest[0].clientWidth + leftWidth) + 'px');
            }
          }
        }
      }
      /* Left edge of screen */
      else if(chkScrnEdge(g_TL_elm.children[edgeCnt].id, 'left')) {
        /* Draw a nest line to the edge of the screen. */
        $(g_TL_elm.children[edgeCnt]).find('.layer_nestline').addClass('vrtcl_leftedge');
        if(stretch_idStrChk(STRETCH_ID_CHK_N_LEAD, g_TL_elm.children[edgeCnt].id)) {
          $(g_TL_elm.children[edgeCnt]).find('.leftside').addClass('vrtcl_leftedge');
        }
      }
      else {}
    }
  }
}

/*
 =========================================================================
 @function name  : get_dispWidth_iconNum
 @argument       : none.
 @description    : [When vertical view] Get the number of icons that can be displayed in the timeline.
 @return         : Number of icons to display.
 =========================================================================
*/
function get_dispWidth_iconNum() {
  var adjustVal = g_tlScroll_direction == TL_SCRL_VRTCL ? 30 : 50;
  return Math.floor((parts_block.clientWidth - adjustVal) / TL_ICON_WIDTH_OUTER);
}

/*
 =========================================================================
 @function name      : create_timeline
 @argument[creatNum] : Number to create
 @argument[startNum] : Number of additional starting rows
 @description        : Create timeline elements for allview.
 @return             : none
 =========================================================================
*/
var BASE_COLUMN_TOP = 7;
var BASE_VERTICAL_TL_HEIGHT = 209;
var $g_def_TL_background = '';
function create_timeline(creatNum, startNum) {
  var fragment = document.createDocumentFragment();
  var clmElm = [];

  for(var cnt = 0; cnt < creatNum; cnt++) {
    /* timeline */
    if($g_def_TL_background == '') {
      $g_def_TL_background = $('<div>', {class: 'allViewTL'});
      $g_def_TL_background.html('<canvas class="TL_scale" id="TL_scale"></canvas><div class="TL_backline add_allview_line" id="TL_backline_row"></div>' +
                                '<div class="exe_column allViewTL_column" id="exe_column_"></div>');
    }
    var $newTL = $g_def_TL_background.clone();
    $newTL[0].id = 'scalBackground' + (startNum + cnt);
    $('#TL_scale', $newTL[0])[0].id = 'TL_scale' + (startNum + cnt);
    $('#TL_backline_row', $newTL[0])[0].id = 'TL_backline_row' + (startNum + cnt);
    clmElm.push($('#exe_column_', $newTL[0])[0]);
    clmElm[clmElm.length - 1].id = 'exe_column_' + (startNum + cnt);
    $(fragment).append($newTL);
  }
  $('#TL_background').append(fragment);

  for(var clmCnt = 0; clmCnt < clmElm.length; clmCnt++) {
    /* column settig */
    exe_column_setting(clmElm[clmCnt]);
  }
}

/*
 =========================================================================
 @function name           : add_sampleprg_data
 @argument[sampleProgFlg] : To be set when the sample program is added.
 @description             : Processing to display the icon of the sample program on the screen
 @return                  : ID list of instructions to be added in the sample program
 =========================================================================
*/
function add_sampleprg_data(sampleProgFlg) {
  var addElm = '';
  var saveId = [];
  for(var cnt = 0; cnt < addProgId.length; cnt++) {
    if(!dropIdReplaceFlg && addProgId[cnt] == addProgId.dropId){
      addId.splice(cnt, 0, addProgId[cnt]);
    }else if(dropIdReplaceFlg && addProgId[cnt] == addProgId.dropId){
      addId.splice(cnt, 0, addProgId.retId);
    }else if(!dropIdReplaceFlg && addProgId[cnt] == addProgId.endId){
      addId.splice(cnt, 0, addProgId[cnt]);
    }else if(dropIdReplaceFlg && addProgId[cnt] == addProgId.endId){
      addId.splice(cnt, 0, addProgId.retEndId);
    }else{}

    if(g_adintarget == addId[cnt]){
      for(var i in addPrgSaveId.idList){
        if(addPrgSaveId.idList[i] == g_adintarget){
          addPrgSaveId.idList.splice(i,1);
          dropRecordCnt--;
        }
      }
    }
    addPrgSaveId.idList[dropRecordCnt] = addId[cnt];
    addPrgSaveId.sampleAddFlg = sampleProgFlg;
    addRecordId[cnt] = addId[cnt];
    saveId[cnt] = addId[cnt];
    dropRecordCnt++;
    /* The read instruction is "stretch" */
    if(stretch_idStrChk(STRETCH_ID_CHK_LEAD, addId[cnt]) === true) {
      order_nestChk(addId[cnt]);
      /* Preserve IDs in brackets */
      rd_stretch_dataSet(addId[cnt]);
      /* Added element for nest line */
    }
  }
  /* Undo data at the time of addition is deleted once in order to make */
  /* instruction addition and sample program addition as one Undo data. */
  for(var tlCnt = 0; tlCnt < timeline_record.operation_array.length; tlCnt++){
    if(typeof timeline_record.operation_array[tlCnt].id != "undefined"){
      if(timeline_record.operation_array[tlCnt].id[0] == addProgId.dropId){
        timeline_record.operation_array.splice(tlCnt,1);
        break;
      }
    }
  }
  if(typeof addProgId.retEndId != "undefined"){
    addProgId.endId = addProgId.retEndId;
  }
  if(typeof addProgId.retId != "undefined"){
    addProgId.dropId = addProgId.retId;
  }
  if(dropProgEndNum){
    saveId.splice(dropProgEndNum-1,1);
  }
  if(dropProgNum > 0){
    saveId.splice(dropProgNum-1,1);
  }
  addId = [];
  addInt = 0;
  dropProgEndNum = "";
  dropIdReplaceFlg = false;
  /* Timeline nested update */
  timeLine_nestUpdate();
  /* g_program_data[]Update array number */
  g_program_arrayNumSave();
  /* Scale update */
  draw_TLscale(false);
  tl_adjust_dispRange();
  return saveId;
}

/*
 =========================================================================
 @function name       : rd_stretch_dataSet
 @argument[leadElem]  : Icon ID
 @description         : When reading bracket icon, subsequent instruction g_program_data[].stretch.idList retention processing
 @return              : none
 =========================================================================
*/
function rd_stretch_dataSet(leadElemId) {
  var nestNum = g_program_data[leadElemId].nest.num;
  var leadIdx = g_TL_progInfo.saveProg.indexOf(leadElemId);
  var endId = get_stretch_pairId(leadElemId, REQ_ID_KIND_END, null);
  var endIdx = g_TL_progInfo.saveProg.indexOf(endId);

  /* Set information to g_program_data[].stretch */
  g_program_data[leadElemId].stretch = {state:((g_TL_progInfo.dispProg.includes(endId)) ? 'stretch_open' : 'stretch_close'), idList:[]};
  var dataIdx = 0;
  for(var cnt = leadIdx; cnt <= endIdx; cnt++, dataIdx++) {
    var nestDataFlg = stretch_idStrChk(STRETCH_ID_CHK_ALL, g_TL_progInfo.saveProg[cnt]);
    /* Information set */
    g_program_data[leadElemId].stretch.idList[dataIdx] = JSON.parse(JSON.stringify(def_stretchData_struct));
    g_program_data[leadElemId].stretch.idList[dataIdx].id = g_TL_progInfo.saveProg[cnt];
    if(nestDataFlg) g_program_data[leadElemId].stretch.idList[dataIdx].nestNum = nestNum;
  }
}

/*
 =========================================================================
 @function name      : getAttribute
 @argument           : none
 @description        : Returns an attribute data object
 @return[attribute]  : attribute data object
 =========================================================================
*/
var attribute = [];
function getAttribute() {
  return attribute;
}
/*
 =========================================================================
 @function name      : initAttribute
 @argument           : none
 @description        : Initialize the attribute data object
 @return[attribute]  : none
 =========================================================================
*/
function initAttribute() {
  attribute.length = 0;
}
/*
 =========================================================================
 @function name  : getApplData
 @argument       : none
 @description    : Returns an APPL data object
 @return         : APPL data object
 =========================================================================
*/
var applData = [];
function getApplData() {
  return applData;
}

/*
 =========================================================================
 @function name  : initApplData
 @argument       : none
 @description    : Initialize APPL data object
 @return         : none
 =========================================================================
*/
function initApplData() {
  applData.length = 0;
  lineTrackingConfig = {};
}

/*
 =========================================================================
 @function name  : getPosDataArray
 @argument       : none
 @description    : Return position data object
 @return         : Position data object
 =========================================================================
*/
var position = [];
var g_position_regi = [];
function getPosDataArray() {
  return position;
}

/*
 =========================================================================
 @function name   : getPosDataElement
 @argument[index] : Index of position[]
 @description     : Returns position data at the specified index
 @return          : Position data
 =========================================================================
*/
function getPosDataElement(index) {
  return position[index];
}

/*
 =========================================================================
 @function name  : initPosition
 @argument       : none
 @description    : Initialize position data object
 @return         : none
 =========================================================================
*/
function initPosition() {
  position.length = 0;
}

/*
 =========================================================================
 @function name : tlPopupDisplayReq
 @argument[str] : The string to display.
 @description   : Layer on the timeline and display a pop-up.
 @return        : none
 =========================================================================
*/
function tlPopupDisplayReq(str) {
  g_timelinepopDispFlg = true;
  overlayRistrict(SITUATION_TIMELINE, true);
  document.getElementById('messageArea').innerHTML = str;
  $('#timelinePop').addClass('tlPopup_active');
}

/*
 =========================================================================
 @function name : tlPopupDisplayResetReq
 @argument[]    : none
 @description   : Clear the timeline pop-up.
 @return        : none
 =========================================================================
*/
function tlPopupDisplayResetReq() {
  g_timelinepopDispFlg = false;
  $('#timelinePop').removeClass('tlPopup_active tl_popup_notDisplayable');
  document.getElementById('messageArea').innerHTML = '';
  overlayRistrict(SITUATION_TIMELINE, false);
}

/*
 =========================================================================
 @function name : initLineCountInfo
 @argument[]    : none
 @description   : Initialize LineCount information
 @return        : none
 =========================================================================
*/
function initLineCountInfo() {
  g_lineCountOver_base['sub'] = {overflg:false};
}

/*
 =========================================================================
 @function name   : checkTagName
 @argument[name]  : String to check
 @description     : Check tag name.
 @return[]        : Tag group (Returns -1 if no match)
 =========================================================================
*/
function checkTagName(name) {
  var tabChk = tagNameList.find(function(data) {return data.name == name;});
  if(tabChk) return tabChk.group;

  debug(DBGERROR, 'Illegal tag name(' + name + ')');
  return -1; // Illegal tag name
}

/*
 =========================================================================
 @function name  : setLineTrack
 @argument       : none
 @description    : Set linetrack information
 @return         : none
 =========================================================================
*/
var lineTrackingConfig = {};
function setLineTrack() {
  var appl = getApplData();
  var lang = (gcurrentJPLang == 'jp' || gcurrentJPLang == 'kn') ? 'jp' : 'eg';
  for (var i = 0; i < appl.length; i++) {
    var param = lineTrackList[lang][appl[i].key]
    if (param) {
      lineTrackingConfig[param] = appl[i].val.indexOf(";") > 0 ? appl[i].val.substring(0, appl[i].val.length - 1) : appl[i].val;
    }
  }
}
/*
 * Management of Group Count.
 */
function getGroupCount() {
  return top.irprogapi.getGroupCount();
}

/*
 =========================================================================
 @function name  : getCurrentGroupNum
 @argument       : none
 @description    : Get current group number
 @return         : Current group number
 =========================================================================
*/
var currentGrpNum = 1;
function getCurrentGroupNum() {
  return currentGrpNum;
}

/*
 =========================================================================
 @function name  : setCurrentGroupNum
 @argument[num]  : Group number to set
 @description    : Set current group number
 @return         : none
 =========================================================================
*/
function setCurrentGroupNum(num) {
  currentGrpNum = num;
}

/* =======================================================================
 @function name        : getUfUt
 @argument[callBack]   : Callback that returns ut uf values
 @description          : Get uf ut values
 @return               : none
 ======================================================================= */
function getUfUt(callBack) {
  var ufUtValArray = [];
  for(var grpCnt = 1; grpCnt <= getGroupCount(); grpCnt++) {
    ufUtValArray.push('$MNUFRAMENUM[' + grpCnt + ']');
    ufUtValArray.push('$MNUTOOLNUM[' + grpCnt + ']');
  }
  getSysValXHR(ufUtValArray, getUfUtCallBack, callBack);
}

/* =======================================================================
 @function name        : getUfUtCallBack
 @argument[status]     : Result
 @argument[getText]    : Acquired text data
 @argument[callback]   : Callback that returns ut uf values
 @description          : Get uf ut values callback
 @return               : none
 ======================================================================= */
var ufutSystemValues = [];      // ufutVal = {grp: grpnum, UF: ufval, UT: utval} grp is based 1.
function getUfUtCallBack(status, getText, callBack) {
  if(status == IO_SUCCESS) {
    if (ufutSystemValues.length === 0) {
      for (var grpCnt = 0; grpCnt < getGroupCount(); grpCnt++) {
        ufutSystemValues.push({grp: grpCnt + 1, UF: 0, UT: 0});
      }
    }
    var sysValArray = getSysValXmlData(getText, 'ARRAY').getElementsByTagName('ARRAY');
    for (var arrayCnt = 0; arrayCnt < sysValArray.length; arrayCnt++) {
      var valName = sysValArray[arrayCnt].getAttribute('name');
      var setIndex = ufutSystemValues.findIndex(arrayData => arrayData.grp === Number(valName.match(/\d+/)));
      switch(true) {
        case (/MNUFRAMENUM/).test(valName) :
          ufutSystemValues[setIndex].UF = Number(sysValArray[arrayCnt].textContent);
        break;
        case (/MNUTOOLNUM/).test(valName) :
          ufutSystemValues[setIndex].UT = Number(sysValArray[arrayCnt].textContent);
          break;
        default :
          break;
      }
    }
  }
  callBack(ufutSystemValues);
}

/* =======================================================================
 @function name  : get_currentprogname
 ======================================================================= */
function get_currentprogname(callback) {
  //File reading
  top.rpcmc_getVar(top.SYSNAME_C, '$TP_DEFPROG', callback);
}

//=============================================================================
// Get current position data
//=============================================================================

var POSTBLKIND_REGS = 1; // position table kind = register
var POSTBLKIND_DATA = 0; // position table kind = data
var POS_REG_UT_VAL = 1;
var POS_REG_UF_VAL = 0;

/*
 =========================================================================
 @function name         : get_positiondata
 @argument[positionNum] : Number of Positional data to be obtained
 @description           : Obtain position data
 @return                : none
 =========================================================================
*/
function get_positiondata(positionNum) {
  /* Only the coordinates of joint are used for teaching. */
  if(g_sysval["$JPOSREC_ENB"].value == 1) {
    savePosConvJoint(positionNum);
  }
  else {
    /* Cart position teaching for HANDLETEACH */
    if(g_MTGData.savingTeachPosFlg) {
      weldingTeachPosInfo(positionNum, COORDINATECART);
    } else if (g_wbtData.savingTeachPosFlg) {
      wristTeachPosInfo(positionNum, COORDINATECART);
    }
    else{
      /* joint convert check */
      checkConvCartJointBeforeRecPos(positionNum, checkConvComp);
    }
  }
}

/*
 =========================================================================
 @function name            : showConvertPosChkToast
 @argument[popText]        : String to display on toast
 @description              : Notify untaught save
 @return                   :
 =========================================================================
*/
function showConvertPosChkToast(popText) {
  toast.show(popText);
  if(popText == langResource.ihmieditor_pop_pos_convert_ng_c) {
    /* Untaught */
    unsetPosTeach(save_iconId);
    save_multiline(IO_SUCCESS);
    /* Joint position teaching of EASYARC in case of HANDLETEACH */
    if(g_MTGData.teachEasyArcFlg) {
      g_MTGData.teachEasyArcFlg = false;
    }
    else{
      g_MTGData.savingTeachPosFlg = false;
    }
  }
}
/*
 =========================================================================
 @function name      : checkConvComp
 @argument[posItem]  : 
 @argument[exchgRec] : 
 @description        : Conversion check completion process
 @return             : none
 =========================================================================
*/
function checkConvComp(posItem, exchgRec){
  /* Compare each axis, if they are different, save untaught, if they are the same, save orthogonally */
  var cbArg = {};
  var position_format;
  /* Robot is not CRX, or Root with true conversion check */
  if(!top.g_crx || posConvChk(posItem, exchgRec)) {
    /* Cart position teaching for HANDLETEACH */
    if(g_MTGData.savingTeachPosFlg) {
      weldingTeach_editPos(posItem, COORDINATECART);
    } else if (g_wbtData.savingTeachPosFlg) {
      wristTeach_editPos(posItem, COORDINATECART);
    }
    else{
      if(g_adin_state.adinstAttachedFlg) g_adin_state.continuousRep = posItem.cbArg.posType;
      /* The type you were originally trying to save */
      position_format = posItem.cbArg.posType;
      cbArg.posNo = posItem.posNumber;
      top.recPos_multi(current_prog_name, posItem.posNumber, position_format, top.TXML_TP_REC_TYPE, 0, recpos_callback, cbArg);
    }
  }
  else {
    savePosConvJoint(posItem.posNumber);
  }
}
/*
 =========================================================================
 @function name        : savePosConvJoint
 @argument[posNumber]  : save position number
 @description          : Save joint or untaught
 @return               : none
 =========================================================================
*/
function savePosConvJoint(posNumber) {
  var cbArg = {};
  cbArg.tblKind = POSTBLKIND_REGS;
  cbArg.posNo = posNumber;
  /* "Orthogonal only instructions" or "lineTracking" */
  if((cart_only_order.indexOf(g_program_data[save_iconId].baseId) != -1) ||
     (lineTrackingConfig.lineschedule > 0)) {
    /* Untaught route */
    showConvertPosChkToast(langResource.ihmieditor_pop_pos_convert_ng_c);
  }
  else {
    showConvertPosChkToast(langResource.ihmieditor_pop_pos_cart_only_c, false);
    /* Joint position teaching for HANDLETEACH */
    if(g_MTGData.savingTeachPosFlg){ /*Joint position teaching for HANDLETEACH*/
      weldingTeachPosInfo(posNumber, COORDINATEJOINT);
    } else if (g_wbtData.savingTeachPosFlg) {/* Cart position teaching for WRISTBUTTONTEACH */
      wristTeachPosInfo(posNumber, COORDINATEJOINT);
    }
    else{
      if(g_adin_state.adinstAttachedFlg) g_adin_state.continuousRep = FORMAT_JOINT;
      /* acquisition request */
      top.recPos_multi(current_prog_name, posNumber, FORMAT_JOINT, top.TXML_TP_REC_TYPE, 0, recpos_callback, cbArg);
    }
  }
}
/*
 =========================================================================
 @function name     : posConvChk
 @argument[posItem] : Value before conversion
 @argument[exchgRec]: Value after conversion
 @description       : Check for conversion errors.
 @return            : Check Result (true : Error margin is acceptable)
 =========================================================================
*/
function posConvChk(posItem, exchgRec){
  var oldJoint = 0.0;
  var newJoint = 0.0;
  var difJoint = 0.0;
  /* Compare only joint */
  for(var i in posItem.joint){
    /* Cast Float */
    oldJoint = posItem.joint[i] * 1000000;
    newJoint = exchgRec[i] * 1000000;
    difJoint = Math.abs(oldJoint-newJoint) / 1000000;
    /* Large error */
    if(difJoint > 0.1) { 
      return false;
    }
  }
  return true;
}

/*
 =========================================================================
 @function name     : prepareExchgInfo
 @argument[posData] : Data to be converted
 @description       : Convert A and B text data to objects
 @return            : Data formed into a format for conversion
 =========================================================================
*/
function prepareExchgInfo(posData) {
  var posRec = {};
  posRec.rep = posData.rep;
  posRec.frame = posData.frame;
  posRec.UF = posData.uf;
  posRec.UT = posData.ut;
  posRec.Config = posData.conf;
  var cartKeys = top.IHMIComponents.position.posDef['CARTESIANKEY'];
  for (var iCart = 0; iCart < cartKeys.length; iCart++) {
    posRec[cartKeys[iCart]] = posData.cart[cartKeys[iCart]];
  }
  var exExtendAxes = getExtendAxesCount(posData.group);
  var exRobotAxes = top.irprogapi.getAxisData();
  for (var iJoint = 0; iJoint < exRobotAxes["robot"][1]; iJoint++) {
    var jointName = 'J' + (iJoint + 1);
    posRec[jointName] = posData.joint[jointName];
  }
  for (var iExt = 0; iExt < exExtendAxes; iExt++) {
    posRec['EXT' + (iExt + 1)] = posData.ext['E' + (iExt + 1)];
  }
  var exchgInfo = {};
  exchgInfo.srcRec = posRec;
  exchgInfo.grp = posData.group;
  exchgInfo.ext = exExtendAxes;
  exchgInfo.robot = exRobotAxes.robot[1];
  exchgInfo.UTVal = posData.ut;
  exchgInfo.UFVal = posData.uf;
  exchgInfo.unit = top.irprogapi.global.axisData.unit[posData.group];
  return exchgInfo;
}

/*
 =========================================================================
 @function name   : getRepKind
 @argument[frame] : coordinate system
 @argument[group] : Group number
 @description     : Determine rep from the coordinate system
 @return          : Rep kind
 =========================================================================
*/
function getRepKind(frame, group) { // frame to rep
  var repKind = (frame == COORDINATEJOINT) ? FORMAT_JOINT :
      (getExtendAxesCount(group) > 0) ? FORMAT_CART_ADD : FORMAT_CART;
  return repKind;
}

/*
 =========================================================================
 @function name     : checkConvCartJointBeforeRecPos
 @argument[posNo]   : save position number
 @argument[callback]: Callback function on completion of processing
 @description       : Call get_curang to get the current axis coordinates
 @return            : none
 =========================================================================
*/
function checkConvCartJointBeforeRecPos(posNo, callback) {
  var cbArg = {};
  cbArg.posNo = posNo;
  cbArg.call = callback;
  cbArg.group = 1;
  // cbArg.group = getCurrentGroupNum();
  cbArg.posType = ((getGroupCount() > 1) ? FORMAT_MULTI : ((getExtendAxesCount(1) > 0) ? FORMAT_CART_ADD : FORMAT_CART));
  cbArg.tblKind = POSTBLKIND_REGS;
  cbArg.rec = top.IHMIComponents.position.createRecord.get();
  top.get_curang(cbArg.group, getCurrentJointPosCallback, cbArg);
}


/*
 =========================================================================
 @function name     : getCurrentJointPosCallback
 @argument[grpNum]  : Group number
 @argument[str]     : Current axis coordinates
 @argument[cbArg]   : Object that stores information at the time of drop
 @description       : After analyzing each acquired axis coordinate, call the API to convert it orthogonally.
 @return            : none
 =========================================================================
*/
function getCurrentJointPosCallback(grpNum, str, cbArg) {
  var defJoint = COORDINATEJOINT;
  var posAnl = top.irprogapi.analyzePositionStr(defJoint, str, cbArg.rec);
  var posJoint = top.IHMIComponents.position.createRecord.get();
  posJoint.posNumber = cbArg.posNo; // Position number created by drop operation
  posJoint.frame = defJoint;
  posJoint.group = grpNum;
  posJoint.conf = posAnl.Config;
  posJoint.rep = FORMAT_JOINT;
  // posJoint.force = cbArg.force;
  posJoint.joint.J1 = posAnl.J1;
  posJoint.joint.J2 = posAnl.J2;
  posJoint.joint.J3 = posAnl.J3;
  posJoint.joint.J4 = posAnl.J4;
  posJoint.joint.J5 = posAnl.J5;
  posJoint.joint.J6 = posAnl.J6;
  posJoint.ext.E1 = posAnl.EXT1;
  posJoint.ext.E2 = posAnl.EXT2;
  posJoint.ext.E3 = posAnl.EXT3;
  posJoint.empty = false;
  posJoint.cbArg = cbArg;
  /* Orthogonal transformation using the first value for each axis */
  convertPositionFormat(posJoint);
}

/*
 =========================================================================
 @function name     : convertPositionFormat
 @argument[posItem] : Acquired axis coordinates
 @description       : Perform coordinate transformation
 @return            : none
 =========================================================================
*/
function convertPositionFormat(posItem) {
  // Get and set format conversion data
  var exchgInfo = prepareExchgInfo(posItem);
  exchgInfo.exchgTo    = (posItem.frame == COORDINATECART) ? COORDINATEJOINT: COORDINATECART;
  exchgInfo.comp       = (posItem.frame == COORDINATECART) ? true : false;
  exchgInfo.posNum     = (posItem.posKind != top.IHMIComponents.position.posDef['POSKIND_REG']) ? posItem.posNumber: posItem.posRegNum;
  exchgInfo.posRec     = posItem;
  var posStr = top.irprogapi.constructExchangePosText(exchgInfo);
  top.rpcmc_mnchgrep(posStr, exchgPosCallback, exchgInfo); // rpcmc
}
/*
 =========================================================================
 @function name       : exchgPosCallback
 @argument[status]    : result
 @argument[posStr]    : Text data of coordinates
 @argument[exchgInfo] : Data under conversion
 @description         : After storing the orthogonal value in the object, call the API to convert to each axis.
                      : The first call stores the orthogonal value in the object and converts each axis.
                      : The second call is to the comparison process
 @return              : none
 =========================================================================
*/
function exchgPosCallback(status, posStr, exchgInfo) {
  var exchgRec = top.IHMIComponents.position.createRecord.get();  // Create new record for analyze exchanged data.
  var posItem = exchgInfo.posRec; // pickup target position record.
  // Exchange data analyze when succeed.
  if ((status == IO_SUCCESS) && (posStr != undefined) && (posStr.length > 0)) {
    exchgRec = top.irprogapi.analyzePositionStr(exchgInfo.exchgTo, posStr, exchgRec);
    /* root complete */
    if(exchgInfo.comp === true) {
      posItem.cbArg.call(posItem, exchgRec);
      return;
    }
    if (exchgInfo.exchgTo == COORDINATECART) {
      posItem.conf = exchgRec.Config;
      posItem.cart.X = exchgRec.X;
      posItem.cart.Y = exchgRec.Y;
      posItem.cart.Z = exchgRec.Z;
      posItem.cart.W = exchgRec.W;
      posItem.cart.P = exchgRec.P;
      posItem.cart.R = exchgRec.R;
      posItem.frame = COORDINATECART;
    }
    else { // JOINT
      posItem.force = true;
      posItem.joint.J1 = exchgRec.J1;
      posItem.joint.J2 = exchgRec.J2;
      posItem.joint.J3 = exchgRec.J3;
      posItem.joint.J4 = exchgRec.J4;
      posItem.joint.J5 = exchgRec.J5;
      posItem.joint.J6 = exchgRec.J6;
      posItem.frame = COORDINATEJOINT;
    }
    var robotAxes = top.irprogapi.getAxisData();
    posItem.axes = robotAxes.robot[posItem.group];
    posItem.rep = getRepKind(posItem.frame, posItem.group);

    /* Converts orthogonality to each axis */
    convertPositionFormat(posItem);
  }
  else {  // Conversion failed.
    console.log('[ERROR] exchgPosCallback: Exchange data analysis failed. (status=' + status +'.)');
    savePosConvJoint(posItem.posNumber);
  }
}

/*
 =========================================================================
 @function name      : recpos_callback
 @argument[status]   : result
 @argument[progname] : Target Program Name
 @argument[str]      : String of position coordinates
 @argument[cbArg]    : Arguments of the callback function set at request
 @return             : none
 =========================================================================
*/
function recpos_callback(status, progname, str, cbArg,) {
  if (status !== IO_SUCCESS) {
    display_popupmsg_confirm(top, langResource.ihmieditor_pop_error_reload_c, cb_closepopup_location_reload);
    if((g_adin_state.pkgSampleProgAdding) && ((typeof g_setTpOrderCallBack === "function"))) {
      g_setTpOrderCallBack(EDITER_API_ERROR);
    }
    return;
  }
  var analyzePos = top.irprogapi.analyzeMultiPositionStr(str);
  var posJson = { "Comment": "", "posNumber": 0, "rep": FORMAT_CART, "posData": [] };

  for (var i = 0; i < analyzePos.length; i++){
    var searchPosAxis = ((analyzePos[i].rep == FORMAT_JOINT) ? [].concat(top.REF_POS_JOINT) : [].concat(top.REF_POS_CART)).concat(top.REF_POS_EXT);
    posJson["posData"].push({ "poskey": [], "groupNumber": analyzePos[i].GP });
    posJson["posData"][i].ufVal = analyzePos[i].UF || 0; // UF
    posJson["posData"][i].utVal = analyzePos[i].UT || 1; // UT
    posJson["posData"][i].empty = false;
    if (analyzePos[i].Config) {
      posJson["posData"][i].configStr = analyzePos[i].Config; // CONFIG
    }
    for (var j = 0; j < searchPosAxis.length; j++){ // POSITION
      if (typeof analyzePos[i][searchPosAxis[j]] === 'undefined') { continue; }
      posJson["posData"][i]["poskey"].push({ "key": searchPosAxis[j], "val": analyzePos[i][searchPosAxis[j]] });
    }
  }
  set_position_dataj(posJson, cbArg);
  
  if (!g_adin_state.pkgSampleProgAdding &&           /* Not in the process of adding package instructions. */
      !save_id_array.length &&                       /* No unsaved TP information. */
      save_position_num == save_icon_position_cnt) { /* Position information teaching in the instruction has been completed. */
    /* Add sample programs */
    if(addPrgSaveId.sampleAddFlg) {
      /* Overwrite Undo Data */
      position_record.array_overwrite(position);
    }
    else {
      /* Add to Undo Data */
      position_record.array_add(position);
    }
  }
  save_icon_position_data(save_iconId);
}

/*
 =========================================================================
 @function name       : getUfUtSystemValue
 @argument[groupNum]  : group name
 @description         : Returns the group number UF/UT 
 @return              : UF/UT value
 =========================================================================
*/
function getUfUtSystemValue(groupNum) {
  return ufutSystemValues[groupNum - 1];
}

/*
 =========================================================================
 @function name         : updateUfUtValue
 @argument[grp]         : group number
 @argument[frameIndex]  : frame index
 @argument[frameNum]    : frame number
 @description           : Update UF/UT Value
 @return                : none
 =========================================================================
*/
function updateUfUtValue(grp, frameIndex, frameNum) {
  var ufutVal = ufutSystemValues[grp - 1];
  var ufutFrm = parseInt(frameNum, 10);
  if (frameIndex == FRMVAL_USER) {
    ufutVal.UF = ufutFrm;
  } else if (frameIndex == FRMVAL_TOOL) {
    ufutVal.UT = ufutFrm;
  }
  ufutSystemValues[grp - 1] = ufutVal;
}


/*
 =========================================================================
 @function name    : analyzeCartesianPosition
 @argument[str]    : String
 @description      : Current position analysis
 @return           : positon 
 =========================================================================
*/
function analyzeCartesianPosition(str) {
  // var posJson = cbArg.rec;
  var posJson = {};
  posJson.Comment ="";
  posJson.posData = [];
  posJson.posData[posJson.posData.length] = {};
  posJson.posData[posJson.posData.length-1].poskey = [];
  posJson.posData[posJson.posData.length-1].ufVal = ufutSystemValues[currentGrpNum-1].UF;
  posJson.posData[posJson.posData.length-1].utVal = ufutSystemValues[currentGrpNum-1].UT;
  // initialize rep
  // var cartRep = POS_REP_CART;
  var cartRep = 2;
  // Position data analize.
  var targetWord = ''; // Target word
  // Repeat for the number of characters
  var chIndex = skipToSpecChar(0, str, 'G');
  for (; chIndex < str.length; chIndex++) {
    chIndex = skipWhileSpecChar(chIndex, str, ' '); // Skip ' '
    // Extract up to ':'
    var strInfo = {};
    var ch = str.charAt(chIndex);
    if (ch == ':') {
      chIndex++;
      if (targetWord == 'Group') {
        chIndex = skipWhileSpecChar(chIndex, str, ' '); // Skip ' '
        strInfo = extractChars(chIndex, str); // Extract characters
        // posJson.GP = parseInt(strInfo.word); // Set group number
        posJson.posData[posJson.posData.length-1].groupNumber = parseInt(strInfo.word); // Set group number
        chIndex = strInfo.chIndex; // Update index
      } else if (targetWord == 'Config') {
        // Retrieve up to the next ':' and return from ':' to ' '.
        var chStart = chIndex;
        chIndex = skipToSpecChar(chIndex, str, ':');
        chIndex = backToSpecChar(chIndex - 1, str, ' ');
        // Make the extracted string to string of 'Config'
        // posJson.Config = str.substring(chStart, chIndex).trim();
        posJson.posData[posJson.posData.length-1].configStr = str.substring(chStart, chIndex).trim();
      } else if (targetWord.startsWith('EXT')) {	// Extend axes data exist.
        // cartRep = POS_REP_BOTH;
        cartRep = 6;
        chIndex = skipWhileSpecChar(chIndex, str, ' '); // Skip ' '
        strInfo = extractChars(chIndex, str); // Extract characters
        if (targetWord.indexOf(':') < 0) {
          targetWord = targetWord + ':';
        }
        var targetKey = convertExtElem(targetWord);
      // posJson[targetKey] = parseFloat(strInfo.word);
      posJson.posData[posJson.posData.length-1].poskey[posJson.posData[posJson.posData.length-1].poskey.length] = {key:targetKey,val:parseFloat(strInfo.word)};
        chIndex = strInfo.chIndex + 1;
        chIndex = skipToSpecChar(chIndex, str, ' ') + 1;	// Skip unit
      } else { // X to R
        chIndex = skipWhileSpecChar(chIndex, str, ' '); // Skip ' '
        strInfo = extractChars(chIndex, str); // Extract characters
        // posJson[targetWord] = parseFloat(strInfo.word);
        if (targetWord == 'UT') {
          posJson.posData[posJson.posData.length-1].utVal = parseFloat(strInfo.word);
        } else if (targetWord == 'UF') {
          posJson.posData[posJson.posData.length-1].ufVal = parseFloat(strInfo.word);
        } else {
          posJson.posData[posJson.posData.length-1].poskey[posJson.posData[posJson.posData.length-1].poskey.length] = {key:targetWord,val:parseFloat(strInfo.word)};
        }
        chIndex = strInfo.chIndex;
      }
      targetWord = '';
    } else {
      targetWord += ch;
    }
  }
  posJson.rep = cartRep;
  return posJson;
}
/**
 * Callback function of get joint position data.
 * (IN) grp_num : group number (1, 2, ...)
 * (IN) str     : Position data
 *                 ex) 'Group: 1 J1 = 0.000 deg J2 = 0.000 deg J3 = 0.000 deg '+
 *                     'J4 = 0.000 deg J5 = 0.000 deg J6 = 0.000 deg'
 */
// Converts the received element name to the usage name.
function convertExtElem(word) {
  return (word.startsWith('EXT')) ? word.slice(0, -1): word;
}

/*
 =========================================================================
 @function name      : skipToSpecChar
 @argument[chIndex]  : string index
 @argument[str]      : Characters to specify
 @argument[toChar]   : Target string
 @description        : Skip to the specified character
 @return             : chIndex
 =========================================================================
*/
function skipToSpecChar(chIndex, str, toChar) {
  for (; chIndex < str.length; chIndex++) {
    if (str.charAt(chIndex) == toChar) break;
  }
  return chIndex;
}
/*
 =========================================================================
 @function name      : skipWhileSpecChar
 @argument[chIndex]  : string index
 @argument[str]      : Characters to specify
 @argument[toChar]   : Target string
 @description        : Skip while the specified character appears
 @return             : chIndex
 =========================================================================
*/
function skipWhileSpecChar(chIndex, str, toChar) {
  for (; chIndex < str.length; chIndex++) {
    if (str.charAt(chIndex) != toChar) break;
  }
  return chIndex;
}
/*
 =========================================================================
 @function name      : extractChars
 @argument[chIndex]  : string index
 @argument[str]      : Target string
 @description        : Extract character strings up to blank
 @return             : chIndex word
 =========================================================================
*/
function extractChars(chIndex, str) {
  var extWord = '';
  for (; chIndex < str.length; chIndex++) {
    var targetChar = str.charAt(chIndex);
    if (targetChar == ' ') break;
    extWord += targetChar;
  }
  var strInfo = {};
  strInfo.chIndex = chIndex;
  strInfo.word = extWord;
  return strInfo;
}
/*
 =========================================================================
 @function name      : backToSpecChar
 @argument[chIndex]  : string index
 @argument[str]      : Characters to specify
 @argument[toChar]   : Target string
 @description        : Back to the specified character
 @return             : chIndex
 =========================================================================
*/
function backToSpecChar(chIndex, str, toChar) {
  for (; chIndex > 0; chIndex--) {
    if (str.charAt(chIndex) == toChar) break;
  }
  return chIndex;
}
/*
 =========================================================================
 @function name    : set_position_dataj
 @argument[data]   : position data
 @argument[cbArg]  : Arg
 @description      : Set the position[].
 @return           : none
 =========================================================================
*/
function set_position_dataj(data, cbArg) {
  data.posNumber = cbArg.posNo;
  position[position.length] = JSON.parse(JSON.stringify(data));
}

/*
 =========================================================================
 @function name          : set_position_regi_data
 @argument[pos_reg_data] : Position register information to be stored
 @description            : Stores position register information.
 @return                 : none
 =========================================================================
*/
function set_position_regi_data(pos_reg_data) {
  var keyArr = Object.keys(pos_reg_data);
  for (var i = 0; i < keyArr.length; i++){
    g_position_regi[keyArr[i]] = (JSON.parse(JSON.stringify(pos_reg_data[keyArr[i]])));
  }
}

/**
 * Build Program dropdown list.
 */
var editProgramFiles = [];	// Edit Program file list
var programFileList = [];
var karelProgramFileList = [];

// use attribute configuration
var subTypeArray = [
  { arg: top.MM_SUB_UNDEF_C, type: 'attrSubNone' },
  { arg: top.MM_SUB_MACRO_C, type: 'attrSubMacro' },
  { arg: top.MM_SUB_COND_C, type: 'attrSubCond' }
];
var subTypeIndex = 0;
/*
 =========================================================================
 @function name       : prgListInitCallback
 @argument[datatype]  : datatype
 @argument[prglist]   : program list
 @argument[listNum]   : list Number
 @description         : Callback function for program list initialization.
 @return              : none
 =========================================================================
*/
var prgname_list = [];
function prgListInitCallback(datatype, prglist, listNum) {
  prgname_list += prglist;
  var result = makeProgramListArray(prglist, prgListInitCallback);
  if (!result) return;
  getKarelProgramList(top.MM_SUB_UNDEF_C, getKarelProgramListCB);
}

/*
 =========================================================================
 @function name             : makeProgramListArray
 @argument[prglist]         : program list
 @argument[subTypeCallback] : Callback function to be called when not completed
 @description               : Create program file list
 @return                    : acquisition state (true:completed)
 =========================================================================
*/
function makeProgramListArray(prglist, subTypeCallback) {
  // Insert to list.
  // Preprocessing of list construction
  for (var i = 0; i < prglist.length; i++) {
    var regularName = prglist[i];
    if (regularName.startsWith('*')) {
      // Save to edit program file list
      editProgramFiles[editProgramFiles.length] = regularName;
      // Extract product file name
      regularName = prglist[i].substr(1);
      // Existing edit-file and no regular program.
      if ($.inArray(regularName, prglist) < 0) {	// Not found in array
        // add regular program to list
        if (inProgramList(regularName) < 0) {	// Not found in array
          var allProgList = {};
          var type;
          switch(subTypeIndex) {
            case 0:
              type = langResource.ihmieditor_detail_none_c
              break;
            case 1:
              type = langResource.ihmieditor_title_macro_c
              break;
            case 2:
              type = langResource.ihmieditor_detail_condition_c
              break;
          }
          if (!regularName.match(/^IPL_.*/)) {
            allProgList['name'] = regularName;
            allProgList['type'] = type;
            programFileList[programFileList.length] = allProgList;
          }
        }
      }
    } else if (regularName.length > 0) {
      if (inProgramList(regularName) < 0) {	// Not found in array
        // add regular program to list
        var allProgList = {};
        var type;
        switch(subTypeIndex) {
          case 0:
            type = langResource.ihmieditor_detail_none_c
            break;
          case 1:
            type = langResource.ihmieditor_title_macro_c
            break;
          case 2:
            type = langResource.ihmieditor_detail_condition_c
            break;
        }
        if (!regularName.match(/^IPL_.*/)) {
          allProgList['name'] = regularName;
          allProgList['type'] = type;
          programFileList[programFileList.length] = allProgList;
        }
      }
    }
  }
  subTypeIndex++;
  if (subTypeIndex < subTypeArray.length) {
    getProgramList(subTypeArray[subTypeIndex].arg, subTypeCallback);	// robotapi
    return false;	// May be need.
  } else {
    // Sort
    sortProgramList();
    return true;
  }
}
/*
 =========================================================================
 @function name        : getMacroListCB
 @argument[status]     : datatype
 @argument[macroList]  : macro list
 @argument[listNum]    : List length
 @description          : Get recent top macro name.
 @return               : none
 =========================================================================
*/
var macro_list = [];
function getMacroListCB(status, macroList, listNum) {
  macro_list = macroList;
  if (!(macro_list[macro_list.length - 1])) {
    macro_list.pop();
  }
  /* If called by changed_protect_attr() */
  if(getMacroListAfterCall.funcname.name == 'dispOffWaiting') {
    /* Get the status as the list has been updated. */
    getStatProgInfoVal();
    /* Resume Monitoring */
    getCurProgModifyTime(startMonitorCurProgModify);
    if(activeTarget != '') {
      var actId = activeTarget;
      icon_inactive();
      icon_active(actId, ACTIVE_DETAIL_NECESSARY);
    }
  }
  getMacroListAfterCall.funcname();
  getMacroListAfterCall.funcname = null;
  // recentTopPrgCallback();
}
/*
 =========================================================================
 @function name  : getProgramFileList
 @argument       : none
 @description    : Get program file list
 @return         : none
 =========================================================================
*/
function getProgramFileList() {
  return programFileList;
}
/*
 =========================================================================
 @function name  : inProgramList
 @argument[none] : none
 @description    : Check if the argument program exists in the list
 @return         : Index value of the list (If not listed, -1)
 =========================================================================
*/
function inProgramList(name) {
  for (var i = 0; i < programFileList.length; i++) {
    /* exists */
    if (name == programFileList[i].name) {
      return i;
    }
  }
  return -1;
}
/*
 =========================================================================
 @function name  : sortProgramList
 @argument[none] : none
 @description    : sort Program List
 @return         : none
 =========================================================================
*/
function sortProgramList() {
  programFileList.sort(function (one, two) {	// Sort object.
    return (one.name < two.name) ? -1 : 1;
  });
}
/* =======================================================================
 @function name  : getProgramType
 ======================================================================= */
function getProgramType(progName) {
  var progIndex = inProgramList(progName);
  if (progIndex >= 0) {
    return programFileList[progIndex].type;
  }
  return '';
}

/*
 =========================================================================
 @function name      : get_fileprotect_attr
 @argument[prog]     : A program to obtain protection attributes.
 @argument[callback] : Callback function to be called after the attribute is obtained.
 @description        : Get the protection attributes of a file.
 @return             : none
 =========================================================================
*/
function get_fileprotect_attr(prog, callback) {
  getProgAttr(prog, top.MM_PROTECT_C, callback); // io.js
}

/*
 =========================================================================
 @function name       : getFileAttrPrtctCB
 @argument[status]    : result
 @argument[progName]  : Target program name
 @argument[mmVarName] : Attribute type
 @argument[mmValue]   : Attribute value
 @description         : Processing when acquiring attribute values
 @return              : none
 =========================================================================
*/
var FILE_ATTR_READWRITE = '1';
var FILE_ATTR_READ      = '2';
function getFileAttrPrtctCB(status, progName, mmVarName, mmValue) {
  if (status != IO_SUCCESS) { // get attribute OK?
    debug(DBGERROR, 'getFileAttrCmntCB: progName=' + progName + '; status=' + status);
  }
  /* read only */
  if (mmValue === FILE_ATTR_READ) {
    g_RO_flg = true;
  }
  /* other (Also here for mmValue != FILE_ATTR_READWRITE) */
  else {
    g_RO_flg = false;
    /* read/write setting */
    readwrite_setting();
  }
  if (mmValue === FILE_ATTR_READWRITE || mmValue === FILE_ATTR_READ) {
    file_read();
  } else {
    //Error popup
    dispOffWaiting();
    display_popupmsg_confirm(window, langResource.ihmieditor_pop_loaderr_c + '<br>' + langResource.ihmieditor_pop_moveprglist_c, cb_closepopup_move_prglist);
    /* Initialization of reloading flag */
    g_editor_status.tl_loading = false;
  }
}
/* =======================================================================
 @function name  : getFileAttrMotionGroup
 ======================================================================= */
function getFileAttrMotionGroup(cbArgs) {
  getProgAttr(cbArgs.prg, top.MM_DEF_GROUP_C, getFileAttrMotionGroupCB, cbArgs); // io.js
}
/* =======================================================================
 @function name  : getFileAttrMotionGroupCB
 ======================================================================= */
function getFileAttrMotionGroupCB(status, progName, mmVarName, mmValue, cbArgs) {
  if(status != IO_SUCCESS) {
    dispOffWaiting();
    /* Initialization of reloading flag */
    g_editor_status.tl_loading = false;
    getStatProgInfoVal();
    /* boot */
    if(cbArgs.callfunc === getFileAttrPrtctCB) {
      popup_notDisplayable(NO_DISPLAYABLE_POP_FULL);
    }
    /* during program execution */
    else if(cbArgs.callfunc === chg_runProg_prtctAttr ||
            cbArgs.callfunc === changed_protect_attr) {
      /* When acquisition fails, a popup is displayed and the process ends. */
      /* If the text is garbled and cannot be read, etc. */
      popup_notDisplayable(NO_DISPLAYABLE_POP_TIMELINE);
      read_tpprog_finish_flg = true;
    } else {}
    return;
  }

  var oldVal = g_motion_group;
  setMotionGroup(parseInt(mmValue));
  if(cbArgs.callfunc === changed_protect_attr && oldVal != g_motion_group) {
    rebuild_timeline();
    return;
  }
  get_fileprotect_attr(cbArgs.prg, cbArgs.callfunc);
  get_program_modified(tp_prog_name, set_program_modified);
}
/* =======================================================================
 @function name  : setMotionGroup
 ======================================================================= */
var g_motion_group = null;
var g_motion_group_array = [];
function setMotionGroup(val) {
  g_motion_group = val;
  g_motion_group_array = setMotionGroup_array(val);
}
/* =======================================================================
 @function name  : setMotionGroup_array
 ======================================================================= */
function setMotionGroup_array(motionGrp) {
  var motionGrpArray = [];
  for (var i = 0; i < 8; i++) {
    motionGrpArray[i] = ((motionGrp & (1 << i)) != 0);
  }
  return motionGrpArray;
}
/* =======================================================================
 @function name  : getMotionGroup
 ======================================================================= */
function getMotionGroup() {
  return g_motion_group;
}
/* =======================================================================
 @function name  : getMotionGroupArray
 ======================================================================= */
function getMotionGroupArray() {
  return g_motion_group_array.slice();
}

/*
=========================================================================
@function name     : getCurrProg_mnemonic
@argument          : none
@description       : Get the program data of the currently displayed program.
@return            : current program data
=========================================================================
*/
/* for iRProgrammer only */
function getCurrProg_mnemonic() {
  var arr = [];
  var sortprog = sort_g_program_data_key();
  for(var cnt = 0; cnt < sortprog.length; cnt++) {
    arr[cnt] = {"order":sortprog[cnt] , "num":g_program_data[sortprog[cnt]].array_num};
  }
  make_lsfile_data(arr);
  return tp_text_array.slice();
}

/*
 =========================================================================
 @function name  : create_dispIconArray
 @argument[]     : none
 @description    : Generate saveProg[] and dispProg[] arrays
 @return         : none
 =========================================================================
*/
function create_dispIconArray() {
  var clsChk = false;
  g_TL_progInfo.dispProg = [];
  for(var cnt = 0; cnt < g_TL_progInfo.saveProg.length; cnt++) {
    if(g_program_data[g_TL_progInfo.saveProg[cnt]] == undefined) continue;
    clsChk = false;
    if(g_program_data[g_TL_progInfo.saveProg[cnt]].baseId === 'bktlead-inst_path_start') {
      var instPath_leadId = g_TL_progInfo.saveProg[cnt];
      clsChk = true;
      /* 'Handle Teach' instruction exists in the program. */
      if(g_btnTeaching_list.weldteach.existsTimeline == true || g_btnTeaching_list.wristteach.existsTimeline == true) {
        /* Extract 'Path Teach' bracket section */
        var instPath_endId = get_stretch_pairId(instPath_leadId, REQ_ID_KIND_END, null);
        var endIdx = g_TL_progInfo.saveProg.indexOf(instPath_endId);
        var chkArray = (endIdx != -1) ?
                         g_TL_progInfo.saveProg.slice(g_TL_progInfo.saveProg.indexOf(instPath_leadId), endIdx) :
                         g_TL_progInfo.saveProg.slice(g_TL_progInfo.saveProg.indexOf(instPath_leadId));
        /* Check to see if 'Handle Teach' is present in 'Path Teach'. */
        var wtChk = chkArray.find(function(key) {return g_program_data[key].baseId === '-INST_ARC_HANDLE_TEACH'});
        if(wtChk) clsChk = false;
      }
    }
    g_TL_progInfo.dispProg.push(g_TL_progInfo.saveProg[cnt]);
    /* The read instruction is "stretch" */
    if(stretch_idStrChk(STRETCH_ID_CHK_LEAD, g_TL_progInfo.saveProg[cnt])) {
      if(clsChk) {
        var endId = get_stretch_pairId(g_TL_progInfo.saveProg[cnt], REQ_ID_KIND_END, null);
        var bktendIdx = g_TL_progInfo.saveProg.indexOf(endId);
        cnt = (bktendIdx != -1) ? bktendIdx : g_TL_progInfo.saveProg.length;
      }
    }
  }
}
             // Use jQuery
/*
 * jQuery JavaScript Library
 * https://jquery.com/
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
*/


var tp_text_array = [];
var editAttrValue = {};
var CODECRLF = '\r\n';
var CODECR = '\r';
var CODELF = '\n';
var CODETAB = '\t';
// Compose program file.
var positionObj = [];
//=============================================================================

//=============================================================================

var startTime;
var endtime;

var baseInst_lsChkTbl = {
  'straight'    :{func: make_lsfile_data_motion, tp: langResource.ihmieditor_order_l_c},
  'kakujiku'    :{func: make_lsfile_data_motion, tp: langResource.ihmieditor_order_j_c},
  'curve'       :{func: make_lsfile_data_motion, tp: langResource.ihmieditor_order_c_c},
  'circlearc'   :{func: make_lsfile_data_motion, tp: langResource.ihmieditor_order_a_c},
  'spline'      :{func: make_lsfile_data_motion, tp: langResource.ihmieditor_order_s_c},
  'output'      :{func: make_lsfile_data_common, tp: ''},
  'regi'        :{func: make_lsfile_data_common, tp: ''},
  'macro'       :{func: make_lsfile_data_common, tp: ''},
  'call'        :{func: make_lsfile_data_call,   tp: ''},
  'noconnect'   :{func: make_lsfile_data_call,   tp: ''},
  'forlead'     :{func: make_lsfile_data_common, tp: ''},
  'forend'      :{func: make_lsfile_data_common, tp: ''},
  'wait'        :{func: make_lsfile_data_wait,   tp: ''},
  'iflead'      :{func: make_lsfile_data_if,     tp: ''},
  'ifelse'      :{func: make_lsfile_data_if,     tp: ''},
  'ifend'       :{func: make_lsfile_data_if,     tp: ''},
  'comment'     :{func: make_lsfile_data_comment,tp: ''},
  'vsnline'     :{func: make_lsfile_data_motion, tp: langResource.ihmieditor_order_l_c},
  'vsnjoint'    :{func: make_lsfile_data_motion, tp: langResource.ihmieditor_order_j_c},
  'jump'        :{func: make_lsfile_data_common, tp: ''},
  'label'       :{func: make_lsfile_data_common, tp: ''},
  'payload'     :{func: make_lsfile_data_common, tp: ''},
  'setuframe'   :{func: make_lsfile_data_common, tp: ''},
  'setutool'    :{func: make_lsfile_data_common, tp: ''},
  'seluframe'   :{func: make_lsfile_data_common, tp: ''},
  'selutool'    :{func: make_lsfile_data_common, tp: ''},
  'nosupport'   :{func: make_lsfile_data_common, tp: ''},
  'laserpre'    :{func: make_lsfile_data_motion, tp: langResource.ihmieditor_order_l_c},
  'laserkpre'   :{func: make_lsfile_data_motion, tp: langResource.ihmieditor_order_j_c},
  'laserls'     :{func: make_lsfile_data_motion, tp: langResource.ihmieditor_order_l_c},
  'laserkls'    :{func: make_lsfile_data_motion, tp: langResource.ihmieditor_order_j_c},
  'lasercls'    :{func: make_lsfile_data_motion, tp: langResource.ihmieditor_order_c_c},
  'lasercals'   :{func: make_lsfile_data_motion, tp: langResource.ihmieditor_order_a_c},
  'lasersls'    :{func: make_lsfile_data_motion, tp: langResource.ihmieditor_order_s_c},
  'laserle'     :{func: make_lsfile_data_motion, tp: langResource.ihmieditor_order_l_c},
  'laserkle'    :{func: make_lsfile_data_motion, tp: langResource.ihmieditor_order_j_c},
  'lasercle'    :{func: make_lsfile_data_motion, tp: langResource.ihmieditor_order_c_c},
  'lasercale'   :{func: make_lsfile_data_motion, tp: langResource.ihmieditor_order_a_c},
  'lasersle'    :{func: make_lsfile_data_motion, tp: langResource.ihmieditor_order_s_c},
  'laserpow'    :{func: make_lsfile_data_common, tp: ''},
  'laserwirc'   :{func: make_lsfile_data_common, tp: ''},
  'laserpresi'  :{func: make_lsfile_data_common, tp: ''},
  'laserlssi'   :{func: make_lsfile_data_common, tp: ''},
  'laserlesi'   :{func: make_lsfile_data_common, tp: ''},
  'weldstartml' :{func: make_lsfile_data_motion, tp: langResource.ihmieditor_order_l_c},
  'weldstopml'  :{func: make_lsfile_data_motion, tp: langResource.ihmieditor_order_l_c},
  'weldstartal' :{func: make_lsfile_data_common, tp: ''},
  'weldstopal'  :{func: make_lsfile_data_common, tp: ''},
  'weldstartca' :{func: make_lsfile_data_motion, tp: langResource.ihmieditor_order_a_c},
  'weldstopca'  :{func: make_lsfile_data_motion, tp: langResource.ihmieditor_order_a_c},
  'sensoron'    :{func: make_lsfile_data_common, tp: ''},
  'sensoroff'   :{func: make_lsfile_data_common, tp: ''},
  'searchon'    :{func: make_lsfile_data_common, tp: ''},
  'detectjoint' :{func: make_lsfile_data_common, tp: ''},
  'trackdpm'    :{func: make_lsfile_data_common, tp: ''},
  'trackend'    :{func: make_lsfile_data_common, tp: ''},
};

/*
 =========================================================================
 @function name : make_lsfile_data
 @argument[arr] : data array
 @description   : Create content to save as ls file.
 @return        : none
 =========================================================================
*/
function make_lsfile_data(arr) {
  var ls_data = '', func = null;

  tp_text_array.length = 0;
  for (var i = 0; i < arr.length; i++) {
    ls_data = (g_program_data[arr[i].order].remark) ? '// ' : ' ';
    func = (baseInst_lsChkTbl[g_program_data[arr[i].order].baseId]) ?
              baseInst_lsChkTbl[g_program_data[arr[i].order].baseId].func : make_lsfile_data_adinst;
    ls_data += func(arr[i].order);
    /* P[0]/PR[0]/PR[R[0]]/PR[AR[0]] -> P[...]/PR[...]/PR[R[...]]/PR[AR[...]] */
    ls_data = ls_data.replace(new RegExp(ORDER_POS + '\\[0]', 'g'), ORDER_POS + '[...]')
                     .replace(new RegExp(ORDER_POSREGI + '\\[0]', 'g'), ORDER_POSREGI + '[...]')
                     .replace(new RegExp(ORDER_POSREGI + '\\[' + ORDER_REGI + '\\[0]]', 'g'), ORDER_POSREGI + '[' + ORDER_REGI + '[...]]')
                     .replace(new RegExp(ORDER_POSREGI + '\\[' + ORDER_ARGUMENT + '\\[0]]', 'g'), ORDER_POSREGI + '[' + ORDER_ARGUMENT + '[...]]');
    tp_text_array.push(ls_data);
  }
}

/*
 =========================================================================
 @function name     : make_lsfile_data_motion
 =========================================================================
*/
function make_lsfile_data_motion(order) {
  return baseInst_lsChkTbl[g_program_data[order].baseId].tp + ' ' + instruction_convert(order) + ' ;';
}
/*
 =========================================================================
 @function name     : make_lsfile_data_call
 =========================================================================
*/
function make_lsfile_data_call(order) {
  /* Check for the presence of '(' */
  if (g_program_data[order].param.match(/\(/)) {
    /* Extract the string in parentheses. */
    var paramStart = g_program_data[order].param.indexOf('(');
    var paramEnd = g_program_data[order].param.lastIndexOf(')');
    var pramStr = g_program_data[order].param.substring(paramStart + 1, paramEnd);
    var pramCallname = g_program_data[order].param.substring(0, paramStart + 1);
    /* Separate them with commas. */
    var adinArg = pramStr.split(',');
    g_program_data[order].param = '';
    for (var argNum = 0; adinArg.length > argNum; argNum++) {
      /* Insert a comma between them. */
      if (g_program_data[order].param != '') g_program_data[order].param += ',';
      /* Numbers */
      if (!isNaN(Number(adinArg[argNum]))) {
        /* Check for negative numbers. */
        g_program_data[order].param += (Number(adinArg[argNum]) < 0) ?
                                         '(' + adinArg[argNum] + ')' : adinArg[argNum];
      }
      /* Not numbers */
      else {
        g_program_data[order].param += adinArg[argNum];
      }
    }
    /* Give the name of the program to be called. */
    g_program_data[order].param = pramCallname + g_program_data[order].param + ')';
  }

  return langResource.ihmieditor_order_call_c + ' ' + g_program_data[order].param + ' ;';
}
/*
 =========================================================================
 @function name     : make_lsfile_data_if
 =========================================================================
*/
function make_lsfile_data_if(order) {
  return (g_program_data[order].baseId == 'iflead') ?
             'IF (' + g_program_data[order].param + ') THEN ;' : g_program_data[order].param + ' ;';
}
/*
 =========================================================================
 @function name     : make_lsfile_data_wait
 =========================================================================
*/
function make_lsfile_data_wait(order) {
  return langResource.ihmieditor_order_wait_c + ' ' + g_program_data[order].param + ' ;';
}
/*
 =========================================================================
 @function name     : make_lsfile_data_comment
 =========================================================================
*/
function make_lsfile_data_comment(order) {
  return '!' + g_program_data[order].param + ' ;';
}
/*
 =========================================================================
 @function name     : make_lsfile_data_common
 =========================================================================
*/
function make_lsfile_data_common(order) {
  return g_program_data[order].param + ' ;';
}
/*
 =========================================================================
 @function name     : make_lsfile_data_adinst
 =========================================================================
*/
function make_lsfile_data_adinst(order) {
  /* Check for the presence of '(' */
  if (g_program_data[order].param.match(/\(/)) {
    /* Extract the string in parentheses. */
    var paramStart = g_program_data[order].param.indexOf('(');
    var paramEnd = g_program_data[order].param.lastIndexOf(')');
    var pramStr = g_program_data[order].param.substring(paramStart + 1, paramEnd);
    var pramCallname = g_program_data[order].param.substring(0, paramStart + 1);
    /* Separate them with commas. */
    var adinArg = pramStr.split(',');
    var posCount = 0;
    g_program_data[order].param = '';
    for (var argNum = 0; adinArg.length > argNum; argNum++) {
      /* Insert a comma between them. */
      if (g_program_data[order].param != '') g_program_data[order].param += ',';
      /* P[] or PR[] */
      if (posCheck(adinArg[argNum])) {
        var cmtChk = commentParse(adinArg[argNum]);
        var start = cmtChk.indexOf('[');
        var end = cmtChk.indexOf(']');
        if (!valIntCheck(cmtChk.substring(start + 1, end)) && posCheck(cmtChk) || g_favoriteFlg.tlAdd || g_favoriteFlg.progAdd) {
          var adinResult = cmtChk.substring(0, start + 1);
          /* favorite save position is [...]. */
          adinResult += (g_favoriteFlg.tlAdd || g_favoriteFlg.progAdd) ? '...' : g_program_data[order].position[posCount].number;
          adinResult += cmtChk.substring(end);
          g_program_data[order].param += adinResult;
          posCount++;
        } else {
          g_program_data[order].param += adinArg[argNum];
        }

      }
      /* Numbers */
      else if (!isNaN(Number(adinArg[argNum]))) {
        /* Numbers are enclosed in parentheses. */
        g_program_data[order].param += '(' + adinArg[argNum] + ')';

      }
      /* Not numbers and position and position register. */
      else {
        g_program_data[order].param += adinArg[argNum];
      }
    }
    /* Give the name of the program to be called. */
    g_program_data[order].param = pramCallname + setLangConvJpEng(g_program_data[order].param) + ')';
  }

  return langResource.ihmieditor_order_call_c + ' ' + g_program_data[order].param + ' ;';
}

/*
 =========================================================================
 @function name     : adinInitOnload
 @argument[insAdin] : ID of target instruction
 @argument[str]     : program string
 @argument[key]     : base ID of the target instruction
 @description       : adinstruction Initial value setting.
 @return            : none
 =========================================================================
*/
function adinInitOnload(insAdin, str, key){
  if(g_xml_data[key].func == "") { return; }
  /* Extract parameter part */
  var start = str.indexOf( "(" );
  var end = str.lastIndexOf( ")" );
  str = str.substring( start+1,end )

  if(typeof g_adinDropList[0] != 'undefined'){
    for(var cnt = 0; cnt < g_adinDropList.length; cnt++) {
      if((g_adinDropList[cnt][0] === insAdin) && (g_adinDropList[cnt][3] == 0)){
        g_adinDropList[cnt][1] = str;
        g_adinDropList[cnt][3] = 1;
        break;
      }
    }
    if(g_adinDropList[0][0] === insAdin) {
      create_detailhtml_addinst(key, insAdin);
      $('#adin_'+g_adinDropList[0][0]).on('load', evalFunctionCall);
      g_adintarget = insAdin;
    }
  }
}
/*
 =========================================================================
 @function name     : adinInitFunc
 @argument[insAdin] : id
 @description       : adinstruction Initial value setting.
 @return            : none
 =========================================================================
*/
function adinInitFunc(insAdin){
  if(typeof g_xml_data[g_program_data[insAdin].baseId]=='undefined'){
    return;
  }
  if(g_xml_data[g_program_data[insAdin].baseId].func == ""){
    return;
  }
  var instObj = g_inst_obj[g_program_data[insAdin].baseId];
  if(typeof g_adinDropList[0] != 'undefined'){
    var idx = g_adinDropList.length;
    g_adinDropList[idx] = [];
    g_adinDropList[idx][0] =insAdin;
    g_adinDropList[idx][1] ="";
    g_adinDropList[idx][2] =g_program_data[insAdin].baseId;
    g_adinDropList[idx][3] =0;
  }else{
    g_adinDropList[0] = [];
    g_adinDropList[0][0] =insAdin;
    g_adinDropList[0][1] ="";
    g_adinDropList[0][2] =g_program_data[insAdin].baseId;
    g_adinDropList[0][3] =0;
    g_adintarget = insAdin;
  }
}


function valIntCheck(val){
  var pattern = /^([1-9]\d*|0)$/;
  return ( pattern.test(val) ) ? true : false;

}
/*
 =========================================================================
 @function name : instruction_convert
 @argument[id]  : iconId Name
 @description   : Create a TP program
 @return        : none
 =========================================================================
*/
function instruction_convert(id) {
  var instruction = "";
  for (var pos = 0; pos < g_program_data[id].position.length; pos++) {
    if(g_favoriteFlg.tlAdd || g_favoriteFlg.progAdd || g_favoriteFlg.favoEdit) { /* If favorite save mode, position is [...]. */
      instruction += ORDER_POS + '[...] ';
    }
    else {
      switch(g_program_data[id].position[pos].kind) {
        case POSKIND_POSREGI:
          instruction += ORDER_POSREGI + '[' + g_program_data[id].position[pos].number + '] ';
          break;
        case POSKIND_POSREGI_REGI:
          instruction += ORDER_POSREGI + '[' + ORDER_REGI + '[' + g_program_data[id].position[pos].number + ']] ';
          break;
        case POSKIND_POSREGI_AR:
          instruction += ORDER_POSREGI + '[' + ORDER_ARGUMENT + '[' + g_program_data[id].position[pos].number + ']] ';
          break;
        case POSKIND_POSNUM:
        default:
          instruction += ORDER_POS + '[' + g_program_data[id].position[pos].number + '] ';
          break;
      }
    }
    if(g_program_data[id].position[pos].offsetMotion) instruction += g_program_data[id].position[pos].offsetMotion + ' ';
  } 
  instruction += g_program_data[id].speed.method + g_program_data[id].speed.val;
  if(g_program_data[id].speed.method != '') {
    instruction += (g_program_data[id].speed.method == ORDER_REGI + '[' + ORDER_REGI + '[') ? ']]' : ']';
  }
  instruction += g_program_data[id].speed.unit;
  switch(g_program_data[id].route.stop) {
    case ORDER_FINE:
      instruction += ' ' + g_program_data[id].route.stop;
      break;
    case ORDER_CNT + ' ' + ORDER_REGI:
      instruction += ' ' + g_program_data[id].route.stop + '[' + g_program_data[id].route.val + ']';
      break;
    case ORDER_CNT:
    case ORDER_CR:
      instruction += ' ' + g_program_data[id].route.stop + g_program_data[id].route.val;
      break;
  }
  
  for (var cnt = 0; cnt < g_program_data[id].addMotion.length; cnt++) {
    if(g_program_data[id].baseId == 'laserls' || g_program_data[id].baseId == 'laserkls' ||
       g_program_data[id].baseId == 'lasercls' || g_program_data[id].baseId == 'lasercals' ||
       g_program_data[id].baseId == 'lasersls') {
      var writeAddMotion = g_program_data[id].addMotion[cnt];
      if(writeAddMotion.match(/^LS\[/) && ls_ini[15] == '3') {
        var v_param = writeAddMotion.slice(writeAddMotion.indexOf('V=') + 2, writeAddMotion.lastIndexOf(']'));
        if(v_param.includes(ORDER_REGI) == false) {
          var cnvVal = String(Number(v_param) * 10);
          writeAddMotion = writeAddMotion.slice(0, writeAddMotion.indexOf('V=') + 2) + cnvVal + ']';
        }
      }
      instruction += ' ' + writeAddMotion;
    }
    else {
      instruction += ' ' + g_program_data[id].addMotion[cnt];
    }
  }
  return instruction + ' ';
}
/*
 =========================================================================
 @description   : Location information system.
 =========================================================================
*/
function updatePositionObj(i) {
  // Since we don't know for sure that A is an array, we store the index in a variable as insurance.
  var trgtPos = position[i].posData;
  var trgtPosIdx = ((Array.isArray(trgtPos)) ? [0, 1, 2, 3, 4, 5, 6, 7].slice(0, trgtPos.length) : Object.keys(trgtPos));

  for (var j = 0; j < trgtPosIdx.length; j++){
    var trgtPosData = trgtPos[trgtPosIdx[j]];
    var settingPos = { comment: position[i].Comment, posNumber: position[i].posNumber };

    // If the UF / UT value has already been set, it use the set value.
    // Otherwise, the default value is used.
    settingPos.group = trgtPosData.groupNumber;
    settingPos.uf = ((trgtPosData.ufVal !== '') ? trgtPosData.ufVal : 0);
    settingPos.ut = ((trgtPosData.utVal !== '') ? trgtPosData.utVal : 1);
    settingPos.empty = trgtPosData.empty;

    // Either rec.X or rec.J1 may be used for judgment.
    if (trgtPosData.configStr || trgtPosData.empty) {
      settingPos.conf = trgtPosData.configStr;
      settingPos.cart = {};
    } else {
      settingPos.joint = {};
    }
    settingPos.ext = {};

    // position data
    for (var k = 0; k < trgtPosData.poskey.length; k++){
      var trgtArrKey = ((top.REF_POS_CART.indexOf(trgtPosData.poskey[k].key) > -1) ? 'cart' :
                       ((top.REF_POS_JOINT.indexOf(trgtPosData.poskey[k].key) > -1) ? 'joint' : 'ext'));
      // X: 0.000000
      settingPos[trgtArrKey][trgtPosData.poskey[k].key] = trgtPosData.poskey[k].val;
    }
    settingPos.rep = ((trgtPosData.configStr || trgtPosData.empty) ?
                           ((getExtendAxesCount(trgtPosData.groupNumber) > 0) ? top.POS_REP_BOTH : top.POS_REP_CART) : top.POS_REP_JOINT);
    positionObj[positionObj.length] = settingPos;
  }
}
  
/*
 * Float value to String (x.xxx)
 */
function convertFtoA(fVal) {
  if (fVal === '') {
    return ' ****.******';
  }
  // 'toFixed' is only Number, so convert if it is a string.
  if (typeof fVal === 'string') {
    fVal = parseFloat(fVal);
  }
  var fStr = " " + fVal.toFixed(6); // Rounded to 6 decimal places
  return fStr;
}

function getPosTextArray() {
  return positionObj;
}
// Construct Extend Axis Position data.
function constructExtendAxis(index, trgtGrp) {
  var extText = '';
  var extAxes = getExtendAxesCount(trgtGrp);
  if (extAxes > 0) {
    extText += ',' + CODECRLF;
    for (var ext = 1; ext <= extAxes; ext++) {
      if (ext > 1) {
        extText += ',';
      }
      extText += CODETAB + 'E' + ext + '= ' + convertFtoA(position[index].posData[0].poskey[ext + 5].val) + ' ' + getJointUnitStr(trgtGrp, ext + 5);
    }
  }
  return extText;
}


/* - Get Joint Axes Unit String. - */
function getJointUnitStr(grp, axes) {
  var posAxesUnit = top.irprogapi.getAxisData();
  var axesUnits = posAxesUnit['unit'][grp];
  if ((axesUnits) && (Object.keys(axesUnits).length > axes)) {
    return axesUnits[axes];
  }
  // If the unit is not the acquisition target, it returns the default unit.
  return 'mm';
}
/* 

/*
 =========================================================================
 @function name      : save_tporder
 @argument[id]       : Target instruction ID
 @argument[opt_num]  : Write mode
 @argument[callback] : A callback function to receive status.
 @argument[cbarg]    : Any object to pass to the callback function.
 @description        : Save the program line
 @return             : none
 =========================================================================
*/
var EDIT_PRG_OPT_OVERWRITE    = 0;  /* Overwrite */
var EDIT_PRG_OPT_INSERT       = 1;  /* Insert to specified line */
var EDIT_PRG_OPT_INSERT_AFTER = 2;  /* Insert after specified line */
function save_tporder(id, opt_num, callback, cbarg) {
  var arr = [{"order":id , "num":g_program_data[id].array_num}];
  dispOnWaiting(0);
  /* Stop the Modified time monitoring monitor.*/
  stopMonitorCurProgModify();

  make_lsfile_data(arr);
  var tp_line_num = g_program_data[id].array_num + 1;
  if (opt_num != EDIT_PRG_OPT_OVERWRITE) {
    opt_num = (tp_line_num == 1) ? EDIT_PRG_OPT_INSERT : EDIT_PRG_OPT_INSERT_AFTER;
    if (opt_num == EDIT_PRG_OPT_INSERT_AFTER) { tp_line_num += -1; }
  }

  /* iRP I/F call */
  var tp_text = tp_text_array[0];
  top.editPrg(current_prog_name, urlEncode(tp_text), tp_line_num, opt_num, editPrg_CB, cbarg);

  /** callback function **/
  /*  status    : Status
   *  progName  : Program name */
  function editPrg_CB(status, progName, arg) {
    callback(status, progName, arg, tp_text);
  }
}

/** function: Encode symbols **/
function urlEncode(str) {
  return str.replace(/%/g, '%25').replace(/!/g, '%21').replace(/#/g, '%23').
             replace(/\+/g, '%2B').replace(/ /g, '%20').replace(/</g, '%3C').replace(/>/g, '%3E');
}

/*
 =========================================================================
 @function name      : save_tporder_callback
 @argument[state]    : Result
 @argument[name]     : Program name
 @argument[id]       : ID of instruction
 @argument[save_str] : Program statement at request
 @description        : Callback processing when saving
 @return             : none
 =========================================================================
*/
var save_failed_data = {};
function save_tporder_callback(state, name, id, save_str) {
  // console.log(state);
  save_result = state;

  /* Edit Detail Screen */
  if(active_elem && id != null) {
    save_tporder_callback_paramEdit(state, id, save_str);
  }
  /* Edit Timeline */
  else {
    save_tporder_callback_timeline(state, id);
  }

  if(state === IO_SUCCESS) {
    save_failed_data = {};
    /** function : Save position information. **/
    var savePosData = function(id) {
      save_icon_position_cnt = 0;
      save_icon_position_data(id);
    };
    exclamationMarkDispOnOff(id);
    /* need to save the location data. */
    if(need_position_save_flg &&
       g_program_data[id].position.length > 0 &&
       g_program_data[id].position[0].kind == POSKIND_POSNUM) {
      var advPosTeachFlg = g_xml_data[g_program_data[id].baseId];
      /* XML data exists => Advanced instruction */
      if(typeof advPosTeachFlg != "undefined") {
        /* Position at drop not yet teached */
        if(dropSaveFlg && advPosTeachFlg.dropPosTeach == 'false') {
          unsetPosTeach(id);
          save_multiline(state);
        } else {
          savePosData(id);
        }
      }
      /* basic instruction */
      else {
        dropSaveFlg = false;
        savePosData(id);
      }
    } else {
      savePosData(id);
      // save_multiline(state);
      dropSaveFlg = false;
    }
  }
}
/*
 =========================================================================
 @function name      : save_tporder_callbackWithCB
 @argument[state]    : Result
 @argument[name]     : Program name
 @argument[cbarg]    : Argument object set at request (callback function / id)
 @argument[save_str] : Program statement at request
 @description        : Callback processing when saving
 @return             : none
 =========================================================================
*/
function save_tporder_callbackWithCB(state, name, cbarg, save_str) {
  var id = (typeof cbarg === 'object') ? cbarg.id : cbarg;
  // console.log(state);
  save_result = state;

  /* Edit Detail Screen */
  if(active_elem && id != null) {
    save_tporder_callback_paramEdit(state, id, save_str);
  }
  /* Edit Timeline */
  else {
    save_tporder_callback_timeline(state, id);
  }

  if(state === IO_SUCCESS) {
    save_failed_data = {};
    /** function : Save position information. **/
    var savePosData = function(id) {
      save_icon_position_cnt = 0;
      save_icon_position_data(id);
    };
    exclamationMarkDispOnOff(id);
    /* need to save the location data. */
    if(need_position_save_flg &&
       g_program_data[id].position.length > 0 &&
       g_program_data[id].position[0].kind == POSKIND_POSNUM) {
      var advPosTeachFlg = g_xml_data[g_program_data[id].baseId];
      /* XML data exists => Advanced instruction */
      if(typeof advPosTeachFlg != "undefined") {
        /* Position at drop not yet teached */
        if(dropSaveFlg && advPosTeachFlg.dropPosTeach == 'false') {
          unsetPosTeach(id);
          save_multiline(state);
        } else {
          savePosData(id);
        }
      }
      /* basic instruction */
      else {
        dropSaveFlg = false;
        savePosData(id);
      }
    } else {
      savePosData(id);
      // save_multiline(state);
      dropSaveFlg = false;
    }
  }
  if (typeof cbarg === 'object' && typeof cbarg.callback === 'function') cbarg.callback(state, cbarg);
}

/*
 =========================================================================
 @function name    : chk_labelNum_add_del
 @argument[newNum] : Label number to be added
 @argument[oldNum] : Label number to be deleted
 @description      : Confirm and execute label number addition/deletion
 @return           : none
 =========================================================================
*/
function chk_labelNum_add_del(newNum, oldNum) {
  /* Temporary label number to be added */
  if(newNum.match(/^\*/)) {
    /* Delete if AAA is a definite value */
    if(!oldNum.match(/^\*/)) delLabelNumList(parseInt(oldNum))
  }
  /* Label number to be added is a definite number */
  else {
    addLabelNumList(parseInt(newNum), (oldNum.match(/^\*/) ? null : parseInt(oldNum)));
  }
}

/*
 =========================================================================
 @function name      : save_tporder_callback_paramEdit
 @argument[state]    : Result
 @argument[id]       : ID of instruction
 @argument[save_str] : Program statement at request
 @description        : Callback processing when editing detail screen.
 @return             : none
 =========================================================================
*/
function save_tporder_callback_paramEdit(state, id, save_str) {
  var dtfrm = document.getElementById(get_detail_frm_id(activeTarget)).contentWindow;
  if(active_elem.split(/[0-9]*$/g)[0] == 'addmotion_select_'){
    var elmId = active_elem.match(/[0-9]*$/g)[0];
    active_elem = 'addmotion_' + elmId;
    dtfrm.document.getElementById("addmotion_select_"+elmId+".label").refresh([""], 0, null, false);
  }
  
  /* Successfully saved */
  if(state === IO_SUCCESS) {
    save_failed_data = {};
    dtfrm.document.getElementById(active_elem).style.color = "";
    if(g_program_data[id].baseId === 'label') {
      dtfrm.document.getElementById('setreq_str').style.display = '';
      if(data_before_change.param != undefined) {
        var newNum = g_program_data[id].param.replace(new RegExp('(^' + ORDER_LABEL + '\\[|\\]$)','g'), '');
        var oldNum = data_before_change.param.replace(new RegExp('(^' + ORDER_LABEL + '\\[|\\]$)','g'), '');
        chk_labelNum_add_del(newNum, oldNum);
      }
    }
    /* Need a warning for speed clamping? */
    if(g_cobot_flg && need_show_popup_flg && need_warning_speedclamp(save_str)) {
      //popup speed clamp
      display_popupmsg_speed_clamp();
    }
    if (updInstFlg) {
      //alert [The version of this instruction has been updated.]
      display_popupmsg_alert(DEF_POPUP_SCRN_TYP.ALERT, langResource.ihmieditor_pop_inst_upd_c, DISP_CLOSE_BTN);
      updInstFlg = false;
    }
    if(chk_basicInstruction(g_program_data[activeTarget].baseId) &&
       iconTbl[g_program_data[activeTarget].baseId].iconType == 'posTeach') {
       var addMotionList = dtfrm.document.getElementsByClassName('input-form-list-row');
       for(var key = 0; key < addMotionList.length; key++) {
         $(addMotionList[key]).find('input').css('color', '');
       }
    }
    /* Not support instruction */
    if(g_program_data[id].baseId === 'nosupport') {
      nosupport_remarkChk(id, dtfrm.document.getElementById(active_elem));
    }
  }
  /* Failed to save */
  else {
    /* Update modified time. */
    getCurProgModifyTime(startMonitorCurProgModify);
    var edtElm = dtfrm.document.getElementById(active_elem);
    if(edtElm.classList.contains("radio-button")) edtElm = get_radioSelected_elm(edtElm);
    if(edtElm) {
      if(edtElm.tagName === 'INPUT') edtElm.style.color = "rgb(230, 0, 18)";
      if(edtElm.tagName === 'SPAN') {
        edtElm.style.color = "rgb(230, 0, 18)";
      }
      else {
        $(edtElm.getElementsByTagName('INPUT')).css('color', 'rgb(230, 0, 18)');
      }
    }
    if(g_program_data[id].baseId === 'label') {
      dtfrm.document.getElementById('setreq_str').style.display = 'block';
    }
    save_failed_data = JSON.parse(JSON.stringify(g_program_data[id]));
    g_program_data[id] = JSON.parse(JSON.stringify(data_before_change));
      if(g_program_data[id].position.length) {
        redraw_posInfoPin(id);
      }
    data_before_change = {};
    dispOffWaiting();
  }
  active_elem = "";
}

/************************
** nosupport_remarkChk **
*************************/
function nosupport_remarkChk(id, actElm) {
  var remarkChk = g_program_data[id].param.match(/^\/{2}\s*/);
  if(remarkChk) {
    g_program_data[id].remark = true;
    g_program_data[id].param = g_program_data[id].param.replace(remarkChk[0], '');
    if(activeTarget != '') icon_inactive();
    /* Update detail screen display. */
    icon_active(id);
    if(detailDispElmKeepCheck(id)) actElm.blur(); /* Focus out of the input field. */
  }
  else {
    $('#detail_act').removeClass('detail_noEdit');
    $('#detailRestrict').off('click');
  }
  if(id && document.getElementById(id)) {
    var execFunc = g_program_data[id].remark ? progdata_addClassCheck : progdata_rmvClassCheck;
    execFunc(id, 'remarked');
  }
}

/*
 =========================================================================
 @function name   : save_tporder_callback_timeline
 @argument[state] : Result
 @argument[id]    : ID of instruction
 @description     : Callback processing when editing timeline.
 @return          : none
 =========================================================================
*/
function save_tporder_callback_timeline(state, id) {
  /* Successfully saved */
  if(state === IO_SUCCESS) {
    /* Label */
    if((id != undefined) && (g_program_data[id].baseId === 'label')) {
      if(data_before_change.param != undefined) {
        var newNum = g_program_data[id].param.replace(new RegExp('(^' + ORDER_LABEL + '\\[|\\]$)','g'), '');
        var oldNum = data_before_change.param.replace(new RegExp('(^' + ORDER_LABEL + '\\[|\\]$)','g'), '');
        chk_labelNum_add_del(newNum, oldNum);
      }
    }
  }
  /* Failed to save */
  else {
    /* HandleTeaching */
    if(g_wt_longPress_state.addStartElmId == id || g_wt_longPress_state.addEndElmId == id) {
      if(g_TL_progInfo.saveProg.indexOf(id) != -1 && g_program_data[id] != undefined) {
        delete_multiicon(g_program_data[id].array_num, g_program_data[id].array_num, false);
        draw_TLscale(false);
      }
      if(g_wt_longPress_state.state == 'startAdding') {
        g_wt_longPress_state = {state: '', addStartElmId: '', addEndElmId: ''};
      }
      else if(g_wt_longPress_state.state == 'endAdding') {
        g_wt_longPress_state.state = 'startSaved';
      } else {}
    }

    /* Delete the progress of the preservation. */
    delete_splitSaveProgress();
    /* Initializes the flag for adding a sample program due to a package instruction. */
    g_adin_state.pkgSampleProgAdding = false;
    toggleNode_whileSaving(false);
    if (typeof g_setTpOrderCallBack === 'function') {
      display_popupmsg_confirm(top, langResource.ihmieditor_pop_error_reload_c, cb_closepopup_location_reload);
      g_setTpOrderCallBack(EDITER_API_ERROR);
      return;
    }

    if(id != undefined) {
      // console.log('Save failed:active_elm null');
      dispOffWaiting();
      /* Update modified time. */
      getCurProgModifyTime(startMonitorCurProgModify);
    }
    else {
      display_popupmsg_confirm(top, langResource.ihmieditor_pop_error_reload_c, cb_closepopup_location_reload);
    }
  }
}

/*
 =========================================================================
 @function name : unsetPosTeach
 @argument[id]  : ID of target instruction
 @descriptio    : Sets data for untaught position numbers
 @return        : none
 =========================================================================
*/
function unsetPosTeach(id){
  var str = "Group: 1 Config: N D B, 0, 0, 0 X:'' Y:'' Z:'' W:'' P:'' R:'' ";
  ufutSystemValues[0] = {grp: 1, UF: 'F', UT: 'F'};
  var noSave = false;
  for(var cnt = 0; cnt <  g_program_data[id].position.length; cnt++){
    for(var i = 0; i < position.length; i++){
      if(g_program_data[id].position[cnt].number == position[i].posNumber){
          noSave = true;
          break;
      }
    }
    if(!noSave){
      var arg = {tblKind: 1, posNo: g_program_data[id].position[cnt].number};
      var posJson = analyzeCartesianPosition(str);
      posJson.empty = true;
      set_position_dataj(posJson, arg);
    }
    noSave = false;
  }
  if(g_adin_state.setInstTempFlg){
    position_record.array_overwrite(position);
  }else{
    position_record.array_add(position);
  }
}
/*
 =========================================================================
 @function name : updatePosTeach
 @argument[id]  : ID of target instruction
 @descriptio    : Update position information for the specified instruction.
 @return        : none
 =========================================================================
*/
function updatePosTeach(id){
  var robotPos;
  var bktEnd = (id.startsWith("bktend") == true);  /* get endPosition */

  for(var i = 0; i < top.home.length; i++){
    if(top.home[i].wizardPageContents != undefined){
      /* get wizard frame */
      robotPos = $(top.home[i].wizardPageContents).contents().find(".position");
      if(robotPos == undefined) { return; }
      if(g_adin_state.setInstTempFlg){
        unsetPosTeach(id);
      }
      if(bktEnd){
        wizard_posFix(id);
      }else{
        wizard_posFix();
      }
      break;
    }
  }
}

/*
 =========================================================================
 @function name    : save_icon_position_data
 @argument[iconId] : ID of target instruction
 @descriptio       : Obtain current position coordinates.
 @return           : none
 =========================================================================
*/
var save_iconId = "";
var save_icon_position_cnt = 0;
var save_position_num = 0;
function save_icon_position_data(iconId) {
  var positionSetFlg = false;
  save_iconId = iconId;
  if(g_program_data[iconId] != undefined && need_position_save_flg) {
    /* Holds the number of positions. */
    save_position_num = g_program_data[iconId].position.length;

    for (var cnt = save_icon_position_cnt; cnt < g_program_data[iconId].position.length; cnt++) {
      for (var i = 0; i < position.length; i++) {
        /* Match the position information number held in the program, or the position information number has not been set. */
        if (position[i].posNumber == g_program_data[iconId].position[cnt].number || g_program_data[iconId].position[cnt].number == 0) {
          positionSetFlg = true;
          /* Teaching groups exist. */
          if(position[i].posData.find(function(data) {return data.empty == false})) {
            save_posdata(i, editPosCallback);
            save_icon_position_cnt++;
            return;
          }
        }
      }
      save_icon_position_cnt++;
      /* If there is no position information for the position number, it shall be taught. */
      if(!positionSetFlg && g_program_data[iconId].position[cnt].kind == 1 && g_program_data[iconId].position[cnt].number != 0) {
        //In case of continuous sample program addition,do recPos() with continuousRep
        if ((g_adin_state.adinstAttachedFlg) && (g_adin_state.continuousRep !== null)) {
          top.recPos_multi(current_prog_name, g_program_data[iconId].position[cnt].number, g_adin_state.continuousRep, top.TXML_TP_REC_TYPE, 0, recpos_callback, {posNo: g_program_data[iconId].position[cnt].number});
        }
        else {
          getUfUt(function (ufuTValues) {
            get_positiondata(g_program_data[iconId].position[cnt].number);
          });
        }
        return;
      }
      positionSetFlg = false;
    }
  }
  /* Teaching of the position is complete. */
  save_icon_position_cnt = 0;
  save_position_num = 0;
  save_iconId = "";
  /* Pending processing on the lead side */
  if(setEndParamPos.endId != '' && setEndParamPos.endId == iconId && setEndParamPos.func != null) {
    var delayfunc = setEndParamPos.func;
    var tmpParam = [];
    for(var argcnt = 0; argcnt < setEndParamPos.arg.length; argcnt++) {
      tmpParam.push(setEndParamPos.arg[argcnt]);
    }
    var bktUndo = JSON.parse(JSON.stringify(setEndParamPos.bktUndoInfo));
    setEndParamPos = {endId:'', func:null, arg:[], bktUndoInfo: {hold: false, withoutRegist: null}};
    /* With callback. */
    if(delayfunc == setInstParamWithCB) {
      delayfunc(tmpParam[0], tmpParam[1], tmpParam[2]);
    }
    else {
      delayfunc(tmpParam[0]);
    }
    if(bktUndo.hold) bracketArg_addRecord(bktUndo.withoutRegist);
  }
  else {
    save_multiline(IO_SUCCESS);
  }
}
/*
 =========================================================================
 @function name    : get_radioSelected_elm
 @argument[chkElm] : Elements of a radio button
 @descriptio       : Returns the target element from the selected position.
 @return           : target element
 =========================================================================
*/
function get_radioSelected_elm(chkElm) {
  var dtfrm = document.getElementById(get_detail_frm_id(activeTarget)).contentWindow;
  var radio_item = dtfrm.document.getElementsByClassName('radioItem');
  /* Find the selected position. */
  var itemIdx = Number($(chkElm).find('.selected')[0].dataset.value) - 1;
  
  return (itemIdx >= 0) ? radio_item[itemIdx] : null;
}

/*
 =========================================================================
 @function name      : set_bktend_param
 @argument[bktEndId] : ID of target instruction
 @descriptio         : Set parameters for the end instruction of a bracket instruction
 @return             : none
 =========================================================================
*/
function set_bktend_param(bktEndId) {
  if(typeof g_program_data[bktEndId].param == "undefined") adinInitFunc(bktEndId);

  /* Check for the presence of '(' */
  if(g_program_data[bktEndId].param.match( /\(/ )) {
    var paramStart = g_program_data[bktEndId].param.indexOf('(');
    var paramEnd = g_program_data[bktEndId].param.lastIndexOf(')');
    var pramStr = g_program_data[bktEndId].param.substring(paramStart + 1, paramEnd);
    var pramCallname = g_program_data[bktEndId].param.substring(0, paramStart + 1);
    /* Separate them with commas. */
    var adinArg = pramStr.split(',');
    g_program_data[bktEndId].param = '';
    var posCnt = 0;
    for(var argNum = 0;adinArg.length > argNum ;argNum++) {
      /* Insert a comma between them. */
      if(g_program_data[bktEndId].param != '') g_program_data[bktEndId].param += ',';
      /* P[] or PR[] */
      if(posCheck(adinArg[argNum])) {
        var start = adinArg[argNum].indexOf('[');
        var end = adinArg[argNum].indexOf(']');
        /* P[N] or PR[N] */
        if(!valIntCheck(adinArg[argNum].substring(start + 1, end))) {
          g_program_data[bktEndId].position[posCnt].number = (g_program_data[bktEndId].position[posCnt].kind == POSKIND_POSNUM) ?
                                                                posIndex_get() : 1;
        }
        var adinResult = adinArg[argNum].substring(0, start + 1);
        adinResult += g_program_data[bktEndId].position[posCnt].number + ']';
        g_program_data[bktEndId].param += adinResult;
        posCnt++;
      }
      /* Neither P[] nor PR[]. */
      else {
        g_program_data[bktEndId].param += adinArg[argNum];
      }
    }

    g_program_data[bktEndId].param = pramCallname + setLangConvJpEng(g_program_data[bktEndId].param) + ')';
  }
}
/*
 =========================================================================
 @function name         : delLine_callback
 @argument[state]       : Result
 @argument[progName]    : Program name
 @argument[linenum]     : Delete line number
 @argument[deleteline]  : Number of lines deleted
 @argument[delcontents] : UndoRedo data
 @descriptio            : Callback processing for deletion
 @return                : none
 =========================================================================
*/
function delLine_callback(state, progName, linenum, deleteline, delcontents) {
  /* Check if '-INST_ARC_HANDLE_TEACH' exists within delcontents */
  var chk = (delcontents != undefined) ? cntntsChk_baseId(delcontents, '-INST_ARC_HANDLE_TEACH') : false;
  if(chk) {
    var cntnts = [];
    cntnts.push(delcontents[0]);
    top.delLine(current_prog_name, cntnts[0].array_num + 1, 1, delLine_callback, cntnts);
  }
  else {
    // console.log(state);
    dispOffWaiting();
    /* Update modified time. */
    getCurProgModifyTime(startMonitorCurProgModify);
  }
}
/*
 =========================================================================
 @function name   : save_multiline
 @argument[state] : Result
 @descriptio      : Row-by-row processing upon completion of saving
 @return          : none
 =========================================================================
*/
var notice_list = [];
function save_multiline(state) {
  if(state !== IO_SUCCESS) {
    display_popupmsg_confirm(top, langResource.ihmieditor_pop_error_reload_c, cb_closepopup_location_reload);
    dispOffWaiting();
    toggleNode_whileSaving(false);
    delete_splitSaveProgress();
    if((g_adin_state.pkgSampleProgAdding) && ((typeof g_setTpOrderCallBack === "function"))) {
      g_setTpOrderCallBack(EDITER_API_ERROR);
    }
    return;
  }
  if(g_program_data[save_id_array[0]] != undefined && g_program_data[save_id_array[0]].baseId === 'label') {
    addLabelNumList(parseInt(g_program_data[save_id_array[0]].param.replace(/[^0-9]/g, '')), null);
  }

  /** function : Common storage processing in this function **/
  var save_tp = function(callback) {
    /* Copy Event Notification. */
    if(g_adin_state.copyNoticeEvent) {
      g_adin_state.setAdinstArgFlg = false;
      save_tporder_copyNotice();
    }
    /* Sort Event Notification. */
    else if(g_adin_state.sortNoticeEvent) {
      g_adin_state.setAdinstArgFlg = false;
      save_tporder_sortNotice();
    }
    else {
      /* Save status is being displayed. */
      if(g_prog_saveProgress.lines) {
        /* Update Display */
        g_prog_saveProgress.saveLines++;
        splitSave_progressUpdate();
      }
      save_tporder(save_id_array[0], EDIT_PRG_OPT_INSERT_AFTER, callback, save_id_array.shift());
    }
  };

  /* There is data to be saved. */
  if(save_id_array.length) {
    /* need to save the location data. */
    if(g_program_data[save_id_array[0]].position.length &&
       g_program_data[save_id_array[0]].position[0].kind == POSKIND_POSNUM) {
        save_tp(save_tporder_callback);
    }
    /* The data to be saved is HandleTeach. */
    else if(g_program_data[save_id_array[0]] != undefined && g_program_data[save_id_array[0]].baseId === '-INST_ARC_HANDLE_TEACH') {
      save_id_array.shift();
      save_multiline(IO_SUCCESS);
    }
    else {
      if(g_adin_state.adinstAttachedFlg) {
        save_tporder(save_id_array[0], EDIT_PRG_OPT_INSERT_AFTER, save_tporder_callback, save_id_array.shift());
      } else {
        save_tp(save_multiline);
      }
    }
  }
  /* There is no data to be saved. */
  else {
    /* Copy Event Notification. */
    if(g_adin_state.copyNoticeEvent) {
      g_adin_state.setAdinstArgFlg = false;
      save_tporder_copyNotice();
    }
    /* Sort Event Notification. */
    else if(g_adin_state.sortNoticeEvent) {
      g_adin_state.setAdinstArgFlg = false;
      save_tporder_sortNotice();
    } else {}
    if(active_elem != "" && active_elem != undefined) {
      var dtfrm = document.getElementById(get_detail_frm_id(activeTarget)).contentWindow;
      dtfrm.document.getElementById(active_elem).style.color = "rgb(230, 0, 18)";
      active_elem = "";
    }
    notice_list.length = 0;
    save_id_array.length = 0;
    /* Update progress bar during the save process. */
    if(g_prog_saveProgress.lines) {
      g_prog_saveProgress.saveLines++;
      splitSave_progressUpdate();
      delete_splitSaveProgress();
    }
    if(g_adinDropList.length && !g_adin_state.setInstTempFlg) {
      adinInitOnload(g_adinDropList[0][0], g_program_data[g_adinDropList[0][0]].param, g_program_data[g_adinDropList[0][0]].baseId);
    }
    /* After the drop is completed, the sample addition process is executed. */
    if(addProg.length > 0 && g_adintarget != "") {
      addSampleProgTp(g_adintarget, true);
    }
    if(g_adin_state.adinstAttachedFlg) {
      if(addProgId.dropId != null) {
        save_tporder(addProgId.dropId, write_mode, save_tporder_callback, addProgId.dropId);
      }
      if(samplePrg_status.dropFunc) {
        addprgDropFunc();
        samplePrg_status.dropFunc = false;
        if(g_adinDropList.length && !g_adin_state.setInstTempFlg) {
          adinInitOnload(g_adinDropList[0][0], g_program_data[g_adinDropList[0][0]].param, g_program_data[g_adinDropList[0][0]].baseId);
        }
      }
    }
    /* There is a sample addition flag, and if the drop is complete and
       use setParamTemp func, the sample addition is complete */
    if((g_adin_state.adinstAttachedFlg && !g_adinDropList.length) ||
       (g_adin_state.adinstAttachedFlg && g_adinDropList.length && g_adin_state.setInstTempFlg)) {
      addprgRecord();
    }
    // console.log("dispOffWaiting");
    if(g_adinDropList.length == 0) {
      g_adin_state.continuousRep = null;
      dispOffWaiting();
      setEndParamPos = {endId:'', func:null, arg:[], bktUndoInfo: {hold: false, withoutRegist: null}};
      /* Update modified time. */
      getCurProgModifyTime(startMonitorCurProgModify);
      /* Completed the addition of the sample program due to the package instruction. */
      if(g_adin_state.pkgSampleProgAdding) {
        position_record.array_add(position);
        positionregi_record.array_add(g_position_regi);
        g_adin_state.pkgSampleProgAdding = false;
        if (typeof g_setTpOrderCallBack === 'function') {
          g_setTpOrderCallBack(EDITER_API_SUCCESS);
        }
      }
    }
    /* History Update */
    if(g_latest_registBaseId != '') {
      latestCommand_check(g_latest_registBaseId);
      g_latest_registBaseId = '';
    }
    toggleNode_whileSaving(false);
  }
}

/*
 =========================================================================
 @function name      : save_posdata
 @argument[saveline] : position[] index number
 @argument[callback] : Callback function to be called after editMergePositionData()
 @descriptio         : Save position information
 @return             : 
 =========================================================================
*/
function save_posdata(saveline, callback) {
  updatePositionObj(saveline);	// each position to array
  var posLineObj = getPosTextArray(); // fileio
  /* [Temporary Fix] Since the data has already been merged, set the same thing in the updated data. */
  var mergeArgs = {baseData: posLineObj, mergeData: posLineObj, armType: g_config.armType};
  // I/F call
  top.irprogapi.editMergePositionData(current_prog_name, mergeArgs, callback);
  positionObj = [];
}

/*
 =========================================================================
 @function name      : editPosCallback
 @argument[status]   : Result
 @descriptio         : Get coordinates after coordinate merge
 @return             : none
 =========================================================================
*/
function editPosCallback(status){
  save_icon_position_data(save_iconId);
}

/*
 =========================================================================
 @function name      : save_pasteLine
 @argument[mvStart]  : Start line number.
 @argument[mvEnd]    : End line number.
 @argument[insLine]  : Line number to paste.
 @argument[opeType]  : Operation Type( 0:copy / 1:cut)
 @argument[callback] : The callback function to which the result of the operation is notified.
 @argument[cbArg1]   : Arguments to be passed to callback function.
 @argument[cbArg2]   : Arguments to be passed to callback function.
 @descriptio         : Copy or move the specified line.
 @return             : none
 =========================================================================
*/
function save_pasteLine(mvStart, mvEnd, insLine, opeType, callback, cbArg1, cbArg2) {
  /* Stop the Modified time monitoring monitor.*/
  stopMonitorCurProgModify();
  g_prog_saveProgress.lines = save_id_array.length;
  /* If the number of operation lines exceeds the threshold, a progress bar is displayed. */
  if(save_id_array.length > SAVE_SPLIT_REF_VAL_PASTELINE) display_splitSaveProgress();

  /* Paste destination is within the selection */
  if((mvStart <= insLine) && (mvEnd > insLine)) {
    splitSaveInfo.splitSaveInsId = g_TL_progInfo.saveProg[insLine - 1];
  }
  splitSaveInfo.idArray = save_id_array.slice();
  splitSaveInfo.pasteDirection = (mvStart > insLine) ? 'negative' : 'positive';
  splitSaveInfo.startPos = mvStart;
  splitSaveInfo.refPos = insLine;
  splitSaveInfo.opeType = opeType;
  save_pasteLine_split(cbArg1, cbArg2)
}

/*=========================================================================
 @function name : save_pasteLine_split
 @return        : none
 =========================================================================*/
var splitSaveInfo = JSON.parse(JSON.stringify(def_splitSaveInfo));
function save_pasteLine_split(cbArg1, cbArg2) {
  if(splitSaveInfo.idArray.length > SAVE_SPLIT_REF_VAL_PASTELINE) {
    var chkArray = splitSaveInfo.baseArray.slice(0, SAVE_SPLIT_REF_VAL_PASTELINE);
    var endAdjustVal = SAVE_SPLIT_REF_VAL_PASTELINE - 1;
  }
  else {
    var chkArray = splitSaveInfo.baseArray.slice(0, splitSaveInfo.baseArray.length);
    var endAdjustVal = splitSaveInfo.idArray.length - 1;
  }
  var chkIdx = chkArray.indexOf(splitSaveInfo.splitSaveInsId);
  var endPos = (chkIdx > -1) ? chkIdx : endAdjustVal;
  splitSaveInfo.splitRefVal = (chkIdx > -1) ? chkIdx + 1 : SAVE_SPLIT_REF_VAL_PASTELINE;
  top.pasteLine(current_prog_name,
                splitSaveInfo.startPos,
                splitSaveInfo.startPos + endPos,
                splitSaveInfo.refPos,
                splitSaveInfo.opeType,
                save_pasteLine_split_callback,
                cbArg1,
                cbArg2);
}

/*
 =========================================================================
 @function name      : save_pasteLine_callback
 @argument[status]   : Result.( 0:success / other:error)
 @argument[err_line] : Line number at the end of the error.
 @argument[cbArg1]   : Arguments.
 @argument[cbArg2]   : Arguments.
 @descriptio         : Receive save result.
 @return             : none
 =========================================================================
*/
function save_pasteLine_callback(status, err_line, cbArg1, cbArg2) {
  if (status !== IO_SUCCESS) {
    display_popupmsg_confirm(top, langResource.ihmieditor_pop_error_reload_c, cb_closepopup_location_reload);
  }
  if (typeof g_adin_state.temp.type != "undefined") {
    save_id_array = [];
    save_id_array = g_adin_state.temp.evtId;
    notice_list = g_adin_state.temp.evtId;
    /* Sort Event Notification. */
    if(g_adin_state.temp.type == OPERATION_SORT || g_adin_state.temp.type == OPERATION_SORT_EDIT) {
      g_adin_state.sortNoticeEvent = true;
      save_tporder_sortNotice();
    }
    /* Copy Event Notification. */
    else {
      g_adin_state.copyNoticeEvent = true;
      save_tporder_copyNotice();
    }
  }
  if (!g_adin_state.copyNoticeEvent && !g_adin_state.sortNoticeEvent) {
    save_id_array.length = 0;
  }
  /* Update progress bar during the save process. */
  g_prog_saveProgress.saveLines = g_prog_saveProgress.lines;
  splitSave_progressUpdate();
  delete_splitSaveProgress();
  splitSaveInfo = JSON.parse(JSON.stringify(def_splitSaveInfo));
  dispOffWaiting();
  /* Update modified time. */
  getCurProgModifyTime(startMonitorCurProgModify);
}

/*=========================================================================
 @function name : save_pasteLine_split_callback
 @return        : none
 =========================================================================*/
function save_pasteLine_split_callback(status, err_line, cbArg1, cbArg2) {
  if (status !== IO_SUCCESS) {
    delete_splitSaveProgress();
    display_popupmsg_confirm(top, langResource.ihmieditor_pop_error_reload_c, cb_closepopup_location_reload);
    splitSaveInfo = JSON.parse(JSON.stringify(def_splitSaveInfo));
    save_id_array.length = 0;
    dispOffWaiting();
    return;
  }
  /* Update the number of lines saved. */
  g_prog_saveProgress.saveLines += (splitSaveInfo.idArray.length > splitSaveInfo.splitRefVal) ?
                                     splitSaveInfo.splitRefVal : splitSaveInfo.idArray.length;
  /* Progress updates. */
  splitSave_progressUpdate();

  var splitEdgeId = splitSaveInfo.idArray[splitSaveInfo.splitRefVal - 1];
  splitSaveInfo.idArray.splice(0, splitSaveInfo.splitRefVal);
  /* Saved data exists */
  if(splitSaveInfo.idArray.length) {
    splitSaveInfo.refPos = (splitSaveInfo.baseArray.length == 0 && splitSaveInfo.pasteDirection == 'positive') ?
                                splitSaveInfo.refPos : g_TL_progInfo.saveProg.indexOf(splitEdgeId) + 1;
    if(splitSaveInfo.baseArray.length) {
      splitSaveInfo.baseArray.splice(0, splitSaveInfo.splitRefVal);
      var idx = g_TL_progInfo.saveProg.indexOf(splitSaveInfo.baseArray[0]);
      splitSaveInfo.startPos = (splitSaveInfo.pasteDirection == 'positive' && splitSaveInfo.refPos > idx) ?
                                 idx + 1 : idx - splitSaveInfo.baseArray.length + 1;
    }
    else {
      splitSaveInfo.startPos = (splitSaveInfo.pasteDirection == 'positive') ?
                                  splitSaveInfo.startPos : splitSaveInfo.startPos + SAVE_SPLIT_REF_VAL_PASTELINE;
    }
    save_pasteLine_split(cbArg1, cbArg2);
  }
  /* All saved data is complete */
  else {
    save_pasteLine_callback(status, err_line, cbArg1, cbArg2);
  }
}

/*
 =========================================================================
 @function name : display_splitSaveProgress
 @argument      : none
 @description   : Show progress bar during saving
 @return        : none
 =========================================================================
*/
function display_splitSaveProgress() {
  var topRestrictFrm = document.createElement('div');
  topRestrictFrm.id = 'saveRestrict';
  $(topRestrictFrm).css({'position':'absolute', 'top':'0', 'left':'0', 'height':'100%', 'width':'100%', 'background-color':'rgba(0, 0, 0, 0.5)', 'z-index':'10000'});
  var popStyle = 'style="position: relative; top: 40%; height:115px; width: 65%; background-color: rgb(230, 230, 230); margin:0 auto; box-shadow:0 0 3px 1px black;"';
  var strStyle = 'style="position: relative; display: block; top: 17%; color: rgb(60, 60, 60); text-align: center;"';
  var progressStyle = 'style="position: relative; top: 30%; height: 28px; background-color: rgb(60, 60, 60); margin: 0 50px; padding: 1px; box-sizing: border-box;"';
  var progInnerStyle = 'style="height: 100%; width: 0%; background-color: rgb(35, 172, 56);"';
  $(topRestrictFrm).html(
    '<div id="save_progress" ' + popStyle + '>' + '<span id="save_str" ' + strStyle + '">' + langResource.ihmieditor_pop_saving_c + '</span>' +
    '<div id="progress" ' + progressStyle + '"><div id="progress_inner" ' + progInnerStyle + '></div></div></div>'
  );
  $(top.document.getElementById('root')).append(topRestrictFrm);
}

/*
 =========================================================================
 @function name : delete_splitSaveProgress
 @argument      : none
 @description   : Erase the progress bar
 @return        : none
 =========================================================================
*/
function delete_splitSaveProgress() {
  if($('#saveRestrict', top.document).length > 0) $('#saveRestrict', top.document).remove();
  g_prog_saveProgress = {lines: 0, saveLines: 0};
}

/*
 =========================================================================
 @function name : splitSave_progressUpdate
 @argument      : none
 @description   : Update progress bar
 @return        : none
 =========================================================================
*/
function splitSave_progressUpdate() {
  if($('#saveRestrict', top.document).length > 0) {
    var progress = ~~((g_prog_saveProgress.saveLines/g_prog_saveProgress.lines) * 100);
    $('#progress_inner', top.document).css('width', ((progress > 100) ? 100 : progress) + '%');
  }
}

/*
 =========================================================================
 @function name      : chk_copy_notice_event
 @argument[record]   : Operation Information.
 @argument[undo_flg] : UndoRedo type. (true:redo / false:undo)
 @description        : notification event registration check
 @return             : none
 =========================================================================
*/
function chk_copy_notice_event(record, undo_flg) {
  var copy_save_id_array = [];
  var before_data = [];
  var set_record = {
    'allData'  : [],
    'evtData'  : [],
    'allId'    : [],
    'evtId'    : [],
    'type'     : "",
    'unredo'   : "",
    'base'     : [],
    'beforeParam': [],
  }
  g_adin_state.array_add(set_record);
  if(undo_flg === true) {
    /* Update parameters when moving and get old parameters when undo redo */
    g_adin_state.temp.unredo = 'undo';
    before_data = g_adin_state.temp.allData = record.base;
  }
  else {
    g_adin_state.temp.unredo = (undo_flg === false) ? 'redo' : '';
    before_data = record.base;
    g_adin_state.temp.allData = record.contents;
  }
  for(var i in record.id) {
    var copyFunc = chkInstObj(record.id[i], "m_copyfunc");
    if(copyFunc.flg) {
      copy_save_id_array.push(record.id[i]);
      g_adin_state.temp.beforeParam.push(before_data[i].g_prog_data);
      g_adin_state.temp.evtData.push(copyFunc);
      g_adin_state.temp.evtId.push(record.id[i]);
    }
  }
  if(copy_save_id_array.length == 0) {
    g_adin_state.init();
    return;
  }
  g_adin_state.temp.type = record.type;
  g_adin_state.temp.place1 = record.place1;
  $.extend(true, g_adin_state.temp.base, before_data);
  $.extend(true, g_adin_state.temp.allId, record.id);
}
/*
 =========================================================================
 @function name      : chk_sort_notice_event
 @argument[record]   : Operation Information.
 @argument[undo_flg] : UndoRedo type. (true:redo / false:undo)
 @description        : notification event registration check
 @return             : none
 =========================================================================
*/
function chk_sort_notice_event(record, undo_flg) {
  var sort_save_id_array = [];
  var before_data = [];
  var rec_data;
  var set_record = {
    'allData'  : [],
    'evtData'  : [],
    'allId'    : [],
    'evtId'    : [],
    'type'     : "",
    'unredo'   : "",
    'base'     : [],
    'place1'   : "",
    'beforeParam': [],
  }
  g_adin_state.array_add(set_record);
  if(undo_flg === true || undo_flg === false) {
    /* param1/2 not present during UndoRedo operation. */
    if((undo_flg == true && typeof record.param1 == "undefined") ||
       (undo_flg == false && typeof record.param2 == "undefined")) {
      /* If no parameters are updated after the notification event, the process is terminated. */
      g_adin_state.init();
      return;
    }
    /* Update parameters when moving and get old parameters when undo redo */
    g_adin_state.temp.unredo = (undo_flg === true) ? "undo" : "redo";
    g_adin_state.temp.allData = (undo_flg === true) ? record.param1 : record.param2;
    before_data = (undo_flg === true) ?  record.param2 : record.param1;
    rec_data = Object.entries(record.param1);
  }
  else {
    before_data = g_adin_state.temp.allData = record.contents;
    rec_data = Object.entries(record.contents);
  }
  for(var i in record.id) {
    var sortFunc = chkInstObj(record.id[i], "m_sortfunc");
    if(sortFunc.flg) {
      g_adin_state.temp.beforeParam.push(before_data[i]);
      sort_save_id_array.push(record.id[i]);
      g_adin_state.temp.evtData.push(sortFunc);
      g_adin_state.temp.evtId.push(record.id[i]);
    }
  }
  if(sort_save_id_array.length == 0) {
    g_adin_state.init();
    return;
  }
  g_adin_state.temp.type = record.type;
  g_adin_state.temp.place1 = record.place1;
  $.extend(true, g_adin_state.temp.base, before_data);
  $.extend(true, g_adin_state.temp.allId, record.id);
}
/*
 =========================================================================
 @function name : save_tporder_copyNotice
 @argument      : none
 @description   : Event execution after copy notification event is registered
 @return        : none
 =========================================================================
*/
function save_tporder_copyNotice() {
  /** function : Execute copy notification **/
  var notice_exec = function() {
    var data = g_adin_state.temp.evtData.find(function(data) {return data.id == notice_list[0]});
    if(!(data.id.startsWith("bktend"))) {
      posTemporary = [];
      posRegTemporary = [];
      var noticeObject = {
        line: data.num[0],
        arg:  data.arg[0],
      };
      if(data.id.startsWith("bktlead")) {
        noticeObject.endLine = data.num[1];
        noticeObject.endArg =  data.arg[1];
      }
      g_inst_obj[data.order].funcList.m_copyfunc(noticeObject);
      notice_list.splice(notice_list.indexOf(data.id), 1);
      /* If there is no argument change, the next notification check */
      if(!g_adin_state.setAdinstArgFlg) {
        save_tporder_copyNotice();
      }
      else {
        /* Change the type if there is even one parameter update */
        g_adin_state.temp.type = OPERATION_COPY_EDIT;
      }
    }
    /* Do nothing in endID of copyEvent*/
    else {
      notice_list.splice(notice_list.indexOf(data.id), 1);
      save_tporder_copyNotice();
    }
  }

  /** function : Notification on Undo/Redo **/
  var notice_unredo = function() {
    var data = g_adin_state.temp.evtData.find(function(data) {return data.id == notice_list[0]});
    var idx = g_adin_state.temp.evtData.indexOf(data);
    var b_param = g_adin_state.temp.beforeParam[idx];
    /* End route if no argument is updated during undorid */
    if(g_adin_state.temp.type == OPERATION_PASTE) {
      notice_list.splice(notice_list.indexOf(data.id), 1);
      save_tporder_copyNotice();
    }
    else {
      var chk_bkt_type = (!data.id.startsWith("bktend")) ? 0 : 1;
      var nowArg = data.arg[chk_bkt_type];
      var beforeArg = split_param_call(b_param.param)[1];
      var num = g_program_data[notice_list[0]].array_num+1;
      beforeArg = commentParse(langConvEng(adinstArg_rmvParen(beforeArg)));
      notice_list.splice(notice_list.indexOf(data.id), 1);
      /* copy + undo redo root*/
      if(beforeArg == nowArg) {
        save_tporder_copyNotice();
      }
      /* copy + edit param + undo redo root
         Only the argument of the copy source is saved, so save the argument again.*/
      else {
        editorAPI.funcs.setAdinstArg(num, nowArg);
      }
    }
  }

  /** function : Notification Complete **/
  var notice_comp = function() {
    /* When parameter update and non-update instructions are mixed, flag again for record update */
    if(g_adin_state.temp.type == OPERATION_COPY_EDIT && !g_adin_state.setAdinstArgFlg) {
      g_adin_state.setAdinstArgFlg = true;
    }
    /* If there is an argument update, record generation here  */
    if (g_adin_state.setAdinstArgFlg && g_adin_state.temp.unredo == "") {
      var record_data = {
        id:g_adin_state.temp.allId,
        contents: g_adin_state.temp.allData,
        place1: g_program_data[g_adin_state.temp.allId[0]].array_num,
        place2: g_program_data[g_adin_state.temp.allId[g_adin_state.temp.allId.length - 1]].array_num,
        base: g_adin_state.temp.base,
        type: g_adin_state.temp.type
      }
      del_unused_posno();
      timeline_record.array_overwrite(record_data);
      position_record.array_overwrite(position);
      positionregi_record.array_overwrite(g_position_regi);
      check_undoredo_active();
    }
    g_adin_state.init();
    save_id_array = [];
    notice_list = [];
    dispOffWaiting();
//    save_multiline(IO_SUCCESS);
  }

  /* notice complete */
  if (notice_list.length === 0) {
    notice_comp();
    return;
  }
  /* call notice event*/
  if(g_adin_state.temp.unredo == "") {
    notice_exec();
  }
  /* undo redo root */
  else {
    notice_unredo();
  }
}
/*
 =========================================================================
 @function name : save_tporder_sortNotice
 @argument      : none
 @description   : Event execution after sort notification event is registered
 @return        : none
 =========================================================================
*/
function save_tporder_sortNotice() {
  /** function : Execute sort notification **/
  var notice_exec = function() {
    var data = g_adin_state.temp.evtData.find(function(data) {return data.id == notice_list[0]});
    if(!(data.id.startsWith("bktend"))) {
      posTemporary = [];
      posRegTemporary = [];
      var noticeObject = {
        line: data.num[0],
        arg:  data.arg[0],
      };
      if(data.id.startsWith("bktlead")) {
        noticeObject.endLine = data.num[1];
        noticeObject.endArg =  data.arg[1];
      }
      g_inst_obj[data.order].funcList.m_sortfunc(noticeObject);
      notice_list.splice(notice_list.indexOf(data.id), 1);
      /* If there is no argument change, the next notification check */
      if(!g_adin_state.setAdinstArgFlg) {
        save_tporder_sortNotice();
      }
      else {
        /* Change the type if there is even one parameter update */
        g_adin_state.temp.type = OPERATION_SORT_EDIT;
      }
    }
    /* Do nothing in endID of sortEvent*/
    else {
      notice_list.splice(notice_list.indexOf(data.id), 1);
      save_tporder_sortNotice();
    }
  }

  /** function : Notification on Undo/Redo **/
  var notice_unredo = function() {
    var data = g_adin_state.temp.evtData.find(function(data) {return data.id == notice_list[0]});
    var idx = g_adin_state.temp.evtData.indexOf(data);
    var b_param = g_adin_state.temp.beforeParam[idx];
    /* End route if no argument is updated during undorid */
    if(g_adin_state.temp.type == OPERATION_SORT) {
      save_tporder_sortNotice();
    }
    else {
      var chk_bkt_type = (!data.id.startsWith("bktend")) ? 0 : 1;
      var nowArg = data.arg[chk_bkt_type];
      var beforeArg = split_param_call(b_param.param)[1];
      var num = g_program_data[notice_list[0]].array_num+1;
      beforeArg = commentParse(langConvEng(adinstArg_rmvParen(beforeArg)));
      notice_list.splice(notice_list.indexOf(data.id), 1);
      /* sort + undo redo root*/
      if(beforeArg == nowArg) {
        save_tporder_sortNotice();
      }
      /* sort + edit param + undo redo root
      Only the argument of the sort source is saved, so save the argument again.*/
      else {
        editorAPI.funcs.setAdinstArg(num, nowArg);
      }
    }
  }

  /** function : Notification Complete **/
  var notice_comp = function() {
    /* When parameter update and non-update instructions are mixed, flag again for record update */
    if(g_adin_state.temp.type == OPERATION_SORT_EDIT && !g_adin_state.setAdinstArgFlg) {
      g_adin_state.setAdinstArgFlg = true;
    }
    /* If there is an argument update, record generation here  */
    if (g_adin_state.setAdinstArgFlg && g_adin_state.temp.unredo == "") {
      var record_data = {
        id:g_adin_state.temp.allId,
        contents: g_adin_state.temp.allData,
        place1: g_adin_state.temp.place1,
        place2: g_program_data[g_adin_state.temp.allId[0]].array_num,
        param1: g_adin_state.temp.base,
        param2: g_adin_state.temp.allData,
        type: g_adin_state.temp.type
      }
      del_unused_posno();
      timeline_record.array_overwrite(record_data);
      position_record.array_overwrite(position);
      positionregi_record.array_overwrite(g_position_regi);
      check_undoredo_active();
    }
    g_adin_state.init();
    save_id_array = [];
    notice_list = [];
    dispOffWaiting();
//    save_multiline(IO_SUCCESS);
  }

  /* notice complete */
  if (notice_list.length === 0) {
    notice_comp();
    return;
  }
  /* call sort notice event*/
  if(g_adin_state.temp.unredo == "") {
    notice_exec();
  }
  /* undo redo root */
  else {
    notice_unredo();
  }
}

/*
 =========================================================================
 @function name : addprgDropFunc
 @argument[]    : none
 @descriptio    : add sample program Put in the process of drop function
 @return        : none
 =========================================================================
*/
function addprgDropFunc(){
  for(var k in addRecordId){
    var split_SaveId = "";
    if (addRecordId[k].startsWith("bktlead")) {
      split_SaveId = addRecordId[k].split("bktlead")[1];
    } else if (addRecordId[k].startsWith("bktend")) {
      split_SaveId = addRecordId[k].split("bktend")[1];
    } else {
      split_SaveId = addRecordId[k];
    }
    if((addRecordId[k] != addProgId.dropId && addRecordId[k] != g_adintarget) &&
       (split_SaveId.toUpperCase().startsWith("IPL_") || split_SaveId.toUpperCase().startsWith("-INST"))) {
      adinInitFunc(addRecordId[k]);
    }
  }
}

/*
 =========================================================================
 @function name : addprgRecord
 @argument[]    : none
 @descriptio    : sample program add record data
 @return        : none
 =========================================================================
*/
function addprgRecord(){
  var dropFuncRecord = [];
  var saveId = [];
  var g_prog_record = [];
  for(var k in addPrgSaveId.idList){
    if(typeof g_program_data[addPrgSaveId.idList[k]] != "undefined"){
      if(typeof g_program_data[addPrgSaveId.idList[k]].id == "undefined"){
        g_program_data[addPrgSaveId.idList[k]].id = addPrgSaveId.idList[k];
      }
    }
    g_prog_record.push(g_program_data[addPrgSaveId.idList[k]]);
  }
  g_prog_record.sort(function (a, b) {
    return a.array_num - b.array_num;
  });
  var firstId = g_prog_record[0].id;
  var lastId = g_prog_record[g_prog_record.length-1].id;
  var addIdFlg = false;
  var startIdx = g_TL_progInfo.dispProg.indexOf(firstId);
  if(startIdx >= 0) {
    for(var cnt = startIdx; cnt < g_TL_progInfo.dispProg.length; cnt++) {
      if(g_TL_progInfo.dispProg[cnt] == firstId || addIdFlg) {
        saveId.push(g_TL_progInfo.dispProg[cnt]);
        addIdFlg = true;
      }
      if(g_TL_progInfo.dispProg[cnt] == lastId) break;
    }
  }
  var tmp;
  for(var i in saveId) {
    tmp = JSON.parse(JSON.stringify(g_program_data[saveId[i]]));
    tmp.select = '';
    dropFuncRecord.push(tmp);
  }
  var record_data = {
    id:saveId,
    contents: dropFuncRecord,
    place1: g_program_data[saveId[0]].array_num,
    place2: g_program_data[saveId[saveId.length-1]].array_num,
    type: OPERATION_ADD_MULTI
  }
  /* weldingTeach */
  if(g_wt_longPress_state.addStartElmId == saveId[0] || g_wt_longPress_state.addEndElmId == saveId[0]) {
    record_data.wt_longPress_state = addprgRecord_wt_longPress_state(saveId[0]);
  }
  timeline_record.array_add(record_data);
  /* Check for overwriting. */
  if(addPrgSaveId.sampleAddFlg) {
    position_record.array_overwrite(position);
    positionregi_record.array_overwrite(g_position_regi);
  }
  else {
  }
  addPrgSaveId = {sampleAddFlg:false, idList:[]};
  addRecordId = [];
  addProgId = [];
  samplePrg_status.dropFunc = false;
  dropRecordCnt = 0;
  check_undoredo_active();
  g_adin_state.adinstAttachedFlg = false;
}

/*
 =========================================================================
 @function name       : cntntsChk_baseId
 @argument[contents]  : Content to check.
 @argument[chkBaseId] : Compare baseId.
 @descriptio          : Check for the presence of the specified baseId in the content.
 @return              : Check result. (true : Exist)
 =========================================================================
*/
function cntntsChk_baseId(contents, chkBaseId) {
  var chk = contents.filter(function(data) {
    return data.baseId == chkBaseId;
  });
  return (chk.length) ? true : false;
}

/*
 =========================================================================
 @function name    : save_remarkLine
 @argument[start]  : Start line number.
 @argument[end]    : End line number.
 @argument[remark] : Remark or Unremark. (0:unremark / 1:remark)
 @argument[cbArg]  : Arguments to be passed to callback function.
 @descriptio       : Toggle between remark and unremark.
 @return           : none
 =========================================================================
*/
var SAVE_REQ_UNREMARK = 0;
var SAVE_REQ_REMARK   = 1;
function save_remarkLine(remark) {
  /* Stop the Modified time monitoring monitor.*/
  stopMonitorCurProgModify();
  var cbArg = {remark: remark, execLineNum: 0};
  /* If the number of operation lines exceeds the threshold, a progress bar is displayed. */
  if(save_id_array.length > SAVE_SPLIT_REF_VAL_PASTELINE) {
    if(g_prog_saveProgress.lines == 0) g_prog_saveProgress.lines = save_id_array.length;
    /* Saving progress is not shown. */
    if($('#saveRestrict', top.document).length == 0) display_splitSaveProgress();
    cbArg.execLineNum = SAVE_SPLIT_REF_VAL_PASTELINE;
  }
  else {
    cbArg.execLineNum = save_id_array.length;
  }

  var start = g_TL_progInfo.saveProg.indexOf(save_id_array[0]) + 1;
  var end = start + (cbArg.execLineNum - 1);
  /* Toggle between remark and unremark. */
  top.remarkLine(current_prog_name, start, end, remark ? SAVE_REQ_REMARK : SAVE_REQ_UNREMARK, remarkLine_cb, cbArg);

  /***********************/
  /** callback function **/
  /***********************/
  function remarkLine_cb(status, err_line, cbArg) {
    /* Remarked Success */
    if(status == IO_SUCCESS) {
      for(var cnt = 0; cnt < cbArg.execLineNum; cnt++) {
        g_program_data[save_id_array[cnt]].remark = cbArg.remark;
        if(g_program_data[save_id_array[cnt]].remark == false) progdata_rmvClassCheck(save_id_array[cnt], 'remarked');
        /* The detail screen of the target instruction is displayed. */
        if(save_id_array[cnt] == activeTarget) {
          icon_inactive();
          icon_active(save_id_array[cnt]);
          if(g_program_data[save_id_array[cnt]].remark == false) {
            $('#detail_act').removeClass('detail_noEdit');
            $('#detailRestrict').off('click');
          }
        }
        /* Label instruction */
        if(g_program_data[save_id_array[cnt]].baseId == 'label') {
          var lblNum = Number(g_program_data[save_id_array[cnt]].param.replace(/[^0-9]/g, ''));
          if(lblNum != 0) {
            /* remarked */
            if(cbArg.remark) {
              if(g_program_data[save_id_array[cnt]].param.indexOf('\*') == -1) {
                delLabelNumList(lblNum);
                g_program_data[save_id_array[cnt]].param =
                         g_program_data[save_id_array[cnt]].param.replace(String(lblNum), '*$&');
              }
            }
            /* Unremarked */
            else {
              if(g_labelNumList.indexOf(lblNum) == -1) {
                addLabelNumList(lblNum);
                g_program_data[save_id_array[cnt]].param =
                         g_program_data[save_id_array[cnt]].param.replace(new RegExp('\\*' + lblNum), String(lblNum));
              }
            }
          }
        }
      }
      save_id_array.splice(0, cbArg.execLineNum);
      /* Save status is being displayed. */
      if(g_prog_saveProgress.lines) {
        /* Update Display */
        g_prog_saveProgress.saveLines += cbArg.execLineNum;
        splitSave_progressUpdate();
      }
      if(save_id_array.length) {
        save_remarkLine(cbArg.remark);
        return;
      }
      else {
        /* dispNest update */
        g_program_arrayNumSave();
        tl_adjust_dispRange();
        /* Update modified time. */
        getCurProgModifyTime(startMonitorCurProgModify);
      }
    }
    /* failure */
    else {
      display_popupmsg_confirm(top, langResource.ihmieditor_pop_error_reload_c, cb_closepopup_location_reload);
    }
    delete_splitSaveProgress();
    save_id_array.length = 0;
    dispOffWaiting();
  }
}

/*
 =========================================================================
 @function name : save_undo_remark
 @argument[]    : none
 @descriptio    : Undo remark operations.
 @return        : none
 =========================================================================
*/
function save_undo_remark() {
  /* Stop the Modified time monitoring monitor.*/
  stopMonitorCurProgModify();
  if(g_prog_saveProgress.lines == 0) g_prog_saveProgress.lines = save_id_array.length;
  /* Saving progress is not shown. */
  if($('#saveRestrict', top.document).length == 0) display_splitSaveProgress();

  write_mode = EDIT_PRG_OPT_OVERWRITE;
  save_tporder(save_id_array[0], write_mode, save_undo_remark_cb, save_id_array[0]);


  /***********************/
  /** callback function **/
  /***********************/
  function save_undo_remark_cb(status, err_line, cbArg) {
    /* success */
    if(status == IO_SUCCESS) {
      /* The detail screen of the target instruction is displayed. */
      if(cbArg == activeTarget) {
        icon_inactive();
        icon_active(cbArg);
        if(g_program_data[cbArg].remark == false) {
          $('#detail_act').removeClass('detail_noEdit');
          $('#detailRestrict').off('click');
        }
      }
      save_id_array.shift();
      /* with continuous data */
      if(save_id_array.length) {
        /* Save status is being displayed. */
        if(g_prog_saveProgress.lines) {
          /* Update Display */
          g_prog_saveProgress.saveLines++;
          splitSave_progressUpdate();
        }
        save_undo_remark();
        return;
      }
      else {
        /* dispNest update */
        g_program_arrayNumSave();
        tl_adjust_dispRange();
        /* Update modified time. */
        getCurProgModifyTime(startMonitorCurProgModify);
      }
    }
    /* failure */
    else {
      display_popupmsg_confirm(top, langResource.ihmieditor_pop_error_reload_c, cb_closepopup_location_reload);
    }
    delete_splitSaveProgress();
    save_id_array.length = 0;
    dispOffWaiting();
  }
}

  /*
  =========================================================================
  @function name            : setPosition
  @argument[rcvPos]         : set Postion data
  @argument[callBack]       : callback that returns result
  @description              : set position
  @return                   : none
  =========================================================================
  */
function setPosition(rcvPos, callBack){

  var isTrackingProg = (lineTrackingConfig.lineschedule > 0) ? true : false;
  var editPosMultiCallBack = function (response) {
    var state = (typeof response === 'object') ? response.status : response;
    if (state === IO_SUCCESS) {
      callBack(EDITER_API_SUCCESS);
    }
    else {
      position[foundIndex] = backUpEditorPos;
      callBack(EDITER_API_ERROR);
    }
  }
  var setEditorPos = function(setPos) {
    var extAxes = top.irprogapi.getAxisData().ext[Number(rcvPos.group)];
    if (setPos.rep === FORMAT_JOINT) {
      if (isTrackingProg) {
        callBack(EDITER_API_ERROR);
        return;
      }
      for (var i = 0; i < COORD_KEY.JOINT.length; i++) {
        editorPos.poskey[i] = {key: COORD_KEY.JOINT[i], val: setPos.joint[COORD_KEY.JOINT[i]]};
      }
      for (var i = 0; i < extAxes; i++) {
        if ((setPos.ext !== undefined) && (setPos.ext[COORD_KEY.EXT[i]] !== undefined)) {
          editorPos.poskey[i + COORD_KEY.JOINT.length] = {key: EDITOR_POS_EXT_KEY[i], val: setPos.ext[COORD_KEY.EXT[i]]};
        }
      }
      editorPos.configStr = '';  //To use updatePosition() in joint data.
    }
    else if ((setPos.rep === FORMAT_CART) || (setPos.rep === FORMAT_CART_ADD)) {
      for (var i = 0; i < COORD_KEY.CART.length; i++) {
        editorPos.poskey[i] = {key: COORD_KEY.CART[i], val: setPos.cart[COORD_KEY.CART[i]]};
      }
      for (var i = 0; i < extAxes; i++) {
        if ((setPos.ext !== undefined) && (setPos.ext[COORD_KEY.EXT[i]] !== undefined)) {
          editorPos.poskey[(i + COORD_KEY.CART.length)] = {key: EDITOR_POS_EXT_KEY[i], val: setPos.ext[COORD_KEY.EXT[i]]};
        }
      }
      if (setPos.conf !== undefined) editorPos.configStr = setPos.conf;
      setPos.rep = (extAxes > 0) ? FORMAT_CART_ADD : FORMAT_CART;
    }
    else {
      callBack(EDITER_API_ERROR);
      return;
    }
    position[foundIndex].rep = setPos.rep;
    if (setPos.uf !== undefined) editorPos.ufVal = setPos.uf;
    if (setPos.ut !== undefined) editorPos.utVal = setPos.ut;
    if (setPos.comment !== undefined) position[foundIndex].Comment = setPos.comment;
    save_posdata(foundIndex, editPosMultiCallBack);
  };

  //Check for presence of required parameter values
  if ((rcvPos.posNumber === undefined) || (rcvPos.group === undefined) || (rcvPos.rep === undefined)) {
    callBack(EDITER_API_ERROR);
    return;
  }
  var foundIndex = position.findIndex(function(data) {return data.posNumber == rcvPos.posNumber;});
  if (foundIndex === -1) {
    callBack(EDITER_API_ERROR);
    return;
  }
  /* Search for the target Group number */
  var editorPos = position[foundIndex].posData.find(function(data) {return data.groupNumber == rcvPos.group;});
  /* No data matched by Group number. */
  if(editorPos == undefined) {
    callBack(EDITER_API_ERROR);
    return;
  }
  var backUpEditorPos = JSON.parse(JSON.stringify(position[foundIndex])); //Position data to restore when EditPosMulti() fails
  getReachablePos(rcvPos, function (reachablePos) {
    setEditorPos(reachablePos);
  });
}

/*
=========================================================================
@function name                      : getReachablePos
@argument[originalPos]              : position to check reachable
@argument[callback]                 : callback that returns result
@description                        : get reachable position
@return                             : reachable position
=========================================================================
*/
function getReachablePos(originalPos, callback) {
  var firstJoint = null;
  var posToText = top.irprogapi.constructExchangePosText;
  var exchgPosFrameCallback = function (status, posStr) {
    var exchgedPos = top.IHMIComponents.position.createRecord.get();// Create new record for analyze exchanged data.
    if ((status == IO_SUCCESS) && (posStr != undefined) && (posStr.length > 0)) {
      if (inProgressPos.frame == COORDINATECART) {
        exchgedPos = top.irprogapi.analyzePositionStr(COORDINATEJOINT, posStr, exchgedPos);
        if (firstJoint === null) {
          inProgressPos.frame = COORDINATEJOINT;
          inProgressPos.rep = exchgedPos.rep;
          for (var i = 0; i < COORD_KEY.JOINT.length; i++) {
            inProgressPos.joint[COORD_KEY.JOINT[i]] = exchgedPos[COORD_KEY.JOINT[i]];
          }
          firstJoint = JSON.parse(JSON.stringify(inProgressPos));
        }
        else {
          if(posConvChk(firstJoint, exchgedPos)) {
            callback(backup);
          }
          else {
            callback(firstJoint);
          }
          return;
        }
      }
      //exchanged cart
      else {
        exchgedPos = top.irprogapi.analyzePositionStr(COORDINATECART, posStr, exchgedPos);
        inProgressPos.conf = exchgedPos.Config;
        inProgressPos.frame = COORDINATECART;
        inProgressPos.rep = exchgedPos.rep;
        for (var i = 0; i < COORD_KEY.CART.length; i++) {
          inProgressPos.cart[COORD_KEY.CART[i]] = exchgedPos[COORD_KEY.CART[i]];
        }
      }
      top.rpcmc_mnchgrep(posToText(prepareExchgInfo(inProgressPos)), exchgPosFrameCallback);
    }
    else {
      callback(backup);
    }
  };
  var foundIndex = position.findIndex(function(data) {return data.posNumber == originalPos.posNumber;});
  var editorPos = position[foundIndex].posData.find(function(data) {return data.groupNumber == originalPos.group;});
  var inProgressPos = top.IHMIComponents.position.createRecord.get(); //Create a format for position data
  inProgressPos = Object.assign(inProgressPos, originalPos);
  //Fill in the missing position data
  if (originalPos.comment === undefined) inProgressPos.comment = position[foundIndex].Comment;
  for (var i = 0; i < COORD_KEY.EXT.length; i++) {
    if ((originalPos.ext === undefined) || (originalPos.ext[COORD_KEY.EXT[i]] === undefined)) {
      inProgressPos.ext[COORD_KEY.EXT[i]] = (editorPos.poskey[i + COORD_KEY.CART.length] === undefined) ? 0 : editorPos.poskey[i + COORD_KEY.CART.length].val ;
    }
  }
  if (originalPos.rep === FORMAT_JOINT) {
    for (var i = 0; i < COORD_KEY.JOINT.length; i++) {
      if((originalPos.joint === undefined) || (originalPos.joint[COORD_KEY.JOINT[i]] === undefined)) {
        inProgressPos.joint[COORD_KEY.JOINT[i]] = ((editorPos.poskey[i] !== undefined) && (editorPos.poskey[i].key === COORD_KEY.JOINT[i])) ? editorPos.poskey[i].val : 0;
      } 
    }
    callback(inProgressPos);
    return;
  }
  if (originalPos.conf === undefined) inProgressPos.conf = editorPos.configStr;
  if (originalPos.ut === undefined) inProgressPos.ut = editorPos.utVal;
  if (originalPos.uf === undefined) inProgressPos.uf = editorPos.ufVal;
  inProgressPos.frame = COORDINATECART;
  for (var i =0; i < COORD_KEY.CART.length; i++) {
    if ((originalPos.cart === undefined) || (originalPos.cart[COORD_KEY.CART[i]] === undefined)) {
      inProgressPos.cart[COORD_KEY.CART[i]] = ((editorPos.poskey[i] !== undefined) && (editorPos.poskey[i].key === COORD_KEY.CART[i])) ? editorPos.poskey[i].val : 0;
    }
  }
  var backup = JSON.parse(JSON.stringify(inProgressPos));
  top.rpcmc_mnchgrep(posToText(prepareExchgInfo(inProgressPos)), exchgPosFrameCallback);
}                                                                                                                                                                 // Use jQuery
/*
 * jQuery JavaScript Library
 * https://jquery.com/
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
*/
/*
==================================================================
return XML
<?xml version="1.0" encoding="Shift_JIS"?>
<XMLVAR version="V9.4058       1/21/2021">
 <PROG name="*SYSTEM*">
  <ARRAY name = "$IHMI_EDIT.$FAVORITE[1]" prot ="RW">12</ARRAY>
  <ARRAY name = "$IHMI_EDIT.$FAVORITE[2]" prot ="RW">11</ARRAY>
  <ARRAY name = "$IHMI_EDIT.$FAVORITE[3]" prot ="RW">21</ARRAY>
  <ARRAY name = "$IHMI_EDIT.$FAVORITE[4]" prot ="RW">22</ARRAY>
  <ARRAY name = "$IHMI_EDIT.$FAVORITE[5]" prot ="RW">23</ARRAY>
  <ARRAY name = "$IHMI_EDIT.$HIST[1]" prot ="RW">34</ARRAY>
  <ARRAY name = "$IHMI_EDIT.$HIST[2]" prot ="RW">23</ARRAY>
  <ARRAY name = "$IHMI_EDIT.$HIST[3]" prot ="RW">12</ARRAY>
  <ARRAY name = "$IHMI_EDIT.$HIST[4]" prot ="RW">IPL_noposIcon</ARRAY>
  <ARRAY name = "$IHMI_EDIT.$HIST[5]" prot ="RW">-inst_progressIcon</ARRAY>
 </PROG>
</XMLVAR>
=================================================================
*/

/*
 =========================================================================
 @function name : ihmieditor_init
 @argument      : none
 @description   : 
 @return        : none
 =========================================================================
*/
function ihmieditor_init() {
  var argObj = {};
  getSystemData(readCartPosXvr, argObj);
  if(g_order_option.indexOf("S555") != -1 || g_order_option.indexOf("J922") != -1){
    read_prels_init(readCartPosXvr, argObj);
  }
}
function readCartPosXvr(argObj) {
}
var IO_TYPE_DI = 1;
var IO_TYPE_DO = 2;
var IO_TYPE_AI = 3;
var IO_TYPE_AO = 4;
var IO_TYPE_RI = 8;
var IO_TYPE_RO = 9;
var IO_TYPE_SI = 11;
var IO_TYPE_SO = 12;
var IO_TYPE_GI = 18;
var IO_TYPE_GO = 19;
var IO_TYPE_UI = 20;
var IO_TYPE_UO = 21;
var IO_TYPE_F  = 35;

function getSystemData( callback, argObj) {
  var lang = top.irprogapi.getCurrentLanguage();
  var axesNum = getGroupCount();
  var frameXml = "";
  frameXml += '<?xml version="1.0" encoding="' + parent.langEncoding[lang] + '"?>\r';
  frameXml += '<XMLCFG>\r';
  frameXml +=   '<PROG name="*SYSTEM*">\r';
  frameXml +=     '<VAR name="$IHMI_EDIT.$FAVORITE[1]" />\r'; // add system value name
  frameXml +=     '<VAR name="$IHMI_EDIT.$FAVORITE[2]" />\r'; // add system value name
  frameXml +=     '<VAR name="$IHMI_EDIT.$FAVORITE[3]" />\r'; // add system value name
  frameXml +=     '<VAR name="$IHMI_EDIT.$FAVORITE[4]" />\r'; // add system value name
  frameXml +=     '<VAR name="$IHMI_EDIT.$FAVORITE[5]" />\r'; // add system value name
  frameXml +=     '<VAR name="$IHMI_EDIT.$HIST[1]" />\r';     // add system value name
  frameXml +=     '<VAR name="$IHMI_EDIT.$HIST[2]" />\r';     // add system value name
  frameXml +=     '<VAR name="$IHMI_EDIT.$HIST[3]" />\r';     // add system value name
  frameXml +=     '<VAR name="$IHMI_EDIT.$HIST[4]" />\r';     // add system value name
  frameXml +=     '<VAR name="$IHMI_EDIT.$HIST[5]" />\r';     // add system value name
  frameXml +=     '<VAR name="$IHMI_EDIT.$HIST[6]" />\r';     // add system value name
  frameXml +=     '<VAR name="$IHMI_EDIT.$HIST[7]" />\r';     // add system value name
  frameXml +=     '<VAR name="$IHMI_EDIT.$HIST[8]" />\r';     // add system value name
  frameXml +=     '<VAR name="$IHMI_EDIT.$HIST[9]" />\r';     // add system value name
  frameXml +=     '<VAR name="$IHMI_EDIT.$HIST[10]" />\r';     // add system value name
  frameXml +=     '<VAR name="$IHMI_EDIT.$FULL_VIEW" />\r';   // add system value name
  frameXml +=     '<VAR name="$IHMI_EDIT.$DRAG_LOCK" />\r';   // add system value name
  frameXml +=     '<VAR name="$PLST_SCHNUM" />\r';            // add system value name
  frameXml +=     '<VAR name="$MAX_DIG_PRT" />\r';            // add system value name
  frameXml +=     '<VAR name="$MIX_LOGIC.$NUM_FLG" />\r';     // add system value name
  frameXml +=     '<VAR name="$PG_DEFSPD.$AP_DEF_SPD" />\r';  // add system value name
  frameXml +=     '<VAR name="$PG_DEFSPD.$AP_DEF_UNIT" />\r'; // add system value name
  frameXml +=     '<VAR name="$AWSCFG.$WELD_ID_ENA" />\r';    // add system value name
  for(var axesCnt = 1; axesCnt <= axesNum; axesCnt++) {
    frameXml +=     '<VAR name="$SCR_GRP[%%GROUPNUM%%].$ARM_TYPE" />\r'.replace('%%GROUPNUM%%', axesCnt);     // add system value name
  }
  frameXml +=     '<VAR name="$SCR.$MAXNUMUFRAM" />\r';       // add system value name
  frameXml +=     '<VAR name="$SCR.$MAXNUMUTOOL" />\r';       // add system value name
  frameXml +=     '<VAR name="$VISION_CFG.$NUM_VR" />\r';     // add system value name
  frameXml +=     '<VAR name="$JPOSREC_ENB" />\r';            // add system value name
  frameXml +=   '</PROG>\r'
  frameXml +=   '<PROG name="*NUMREG*">\r';
  frameXml +=     '<VAR name="$MAXREGNUM" />\r';              // add system value name
  frameXml +=   '</PROG>\r';
  frameXml +=   '<PROG name="*POSREG*">\r';
  frameXml +=     '<VAR name="$MAXPREGNUM" />\r';             // add system value name
  frameXml += '</PROG>\r';
  frameXml += '</XMLCFG>';

  // Create Blob frame CVR
  var fileCvr = new Blob([frameXml], { type: "text/plain" });
  var cbArgs = {};
  cbArgs.sysIndex = 1;
  cbArgs.cbFunc = callback;
  cbArgs.cbObj = argObj;
  top.getXHR('crxeditorinit.cvr', fileCvr, getSystemDataCallback, cbArgs);
}

function getSystemDataCallback(status, getText, cbArgs) {
  var cnt;
  var nodes;
  if(status != 0){ return;}
  //alert(getText);
  var XmlObj = getSysValXmlData(getText, 'ARRAY');
  
  for( cnt = 0; cnt < 15; cnt++ ){
    nodes = XmlObj.getElementsByTagName("ARRAY")[cnt];
    g_XMLVal.push(nodes.textContent);
  }
  getFavoriteHistry();
  var convData = extractRcvXHRData(XmlObj, "VAR");
  g_tlScroll_direction = (convData['$IHMI_EDIT.$FULL_VIEW'] == "FALSE") ? TL_SCRL_HRZN : TL_SCRL_VRTCL;
  g_tl_dragLock = (convData['$IHMI_EDIT.$DRAG_LOCK'] == "TRUE");
  g_payload_schnum = Number(convData["$PLST_SCHNUM"]);
  g_regIOlimit_val[ORDER_REGI] = {max: Number(convData["$MAXREGNUM"]), min: 1};
  g_regIOlimit_val[ORDER_POSREGI] = {max: Number(convData["$MAXPREGNUM"]), min: 1}
  g_regIOlimit_val['UFRAME'] = {max: Number(convData["$SCR.$MAXNUMUFRAM"]), min: 1};
  g_regIOlimit_val['UTOOL'] = {max: Number(convData["$SCR.$MAXNUMUTOOL"]), min: 1};
  g_regIOlimit_val['DO'].max = g_regIOlimit_val['DI'].max = Number(convData['$MAX_DIG_PRT']);
  g_regIOlimit_val['F'].max = Number(convData['$MIX_LOGIC.$NUM_FLG']);
  if (g_insOption.vision) g_sysval['$VISION_CFG.$NUM_VR'] = {value: Number(convData['$VISION_CFG.$NUM_VR'])};
  g_sysval['$JPOSREC_ENB'] = {value: Number(convData['$JPOSREC_ENB'])};
  g_sysval['$AWSCFG.$WELD_ID_ENA'] = {value: (convData['$AWSCFG.$WELD_ID_ENA'] == 'TRUE') ? true : false};
  var matchStr = new RegExp('\\$SCR_GRP\\[(\\d)\\].\\$ARM_TYPE');
  for(var j in convData) {
    matchRes = j.match(matchStr);
    if(matchRes != null) {
      g_config['armType'][Number(matchRes[1])] = Number(convData[j]);
    }
  }
  g_weldSpeed.val  = convData["$PG_DEFSPD.$AP_DEF_SPD"];
  g_weldSpeed.unit = weldSpeedUnit[convData["$PG_DEFSPD.$AP_DEF_UNIT"]] ? weldSpeedUnit[convData["$PG_DEFSPD.$AP_DEF_UNIT"]] : "nounit";
  get_RI_RO_max();

  //=============================================================================
  // Apply system variables status.
  //=============================================================================
  /* vertical view */
  if(g_tlScroll_direction == TL_SCRL_VRTCL) {
    /* Set class */
    document.getElementById('viewchange').classList.add('vrtclview');
    tl_viewChange(IO_SUCCESS);
    parts_handleresize_area.refresh({firstAreaSize: DEF_GRAPHIC_AREA_HEIGHT_RATE * 100});
    adjustUpLowElem();
  }
  /* drag lock */
  if(g_tl_dragLock) {
    /* Set class */
    document.getElementById('tl_dragLock').classList.add('drag_lock');
    tl_dragLock_toggle(IO_SUCCESS);
  }
  /* Weld Id available */
  if(g_sysval['$AWSCFG.$WELD_ID_ENA'].value) {
    default_data_structure['weldstopml'].addMotion = [langResource.ihmieditor_order_weldend_c + '[...,...,WID:0]'];
    default_data_structure['weldstopal'].param = langResource.ihmieditor_order_weldend_c + '[...,...,WID:0]';
    default_data_structure['weldstopca'].addMotion = [langResource.ihmieditor_order_weldend_c + '[...,...,WID:0]'];
  }

}

function getSysValXmlData(getText, tagName) {
  var xmlObj = null;
  var dom = new DOMParser();
  try {
    xmlObj = dom.parseFromString(getText, 'text/xml');
  } catch (e) {
    debug(DBGERROR, e);
    alert('getXML err');
  }
  if (xmlObj != null) {
    if(xmlObj.getElementsByTagName('parsererror').length > 0) {
      debug(DBGERROR, 'xml parse error');
    }
    // success get xml data.
    if(xmlObj.getElementsByTagName(tagName).length == 0) {
      xmlObj = null; // Illegal XML data.
    }
  }
  return xmlObj;
}

/*
 =========================================================================
 @function name     : extractRcvXHRData
 @argument[xmlObj]  : 
 @argument[tagName] : 
 @description       : 
 @return            : 
 =========================================================================
*/
function extractRcvXHRData(xmlObj, tagName) {
  var dataArr = xmlObj.getElementsByTagName(tagName);
  var convData = {}; // for temporary storage of data during xml object analysis.

  for (var i = 0; i < dataArr.length; i++) {
    var valName = $(dataArr[i]).attr('name'); // system value name
    convData[valName] = $(dataArr[i]).text(); // system value
  }

  return convData;
}

/*
 =========================================================================
 @function name     : get_RI_RO_max
 @argument[xmlObj]  : 
 @argument[tagName] : 
 @description       : 
 @return            : 
 =========================================================================
*/
function get_RI_RO_max() {
  var iolist = {
    'RI'     : {type:IO_TYPE_RI, start:1, end: g_regIOlimit_val['RI'].max   },
    'RO'     : {type:IO_TYPE_RO, start:1, end: g_regIOlimit_val['RO'].max   },
  };

  for(var key in iolist) {
    /* Get IO value. */
    top.get_ioall(iolist[key].type, iolist[key].start, iolist[key].end, getIOallCB, null, null);
  }
}

/*
 =========================================================================
 @function name     : getIOallCB
 @argument[status]  : Result.
 @argument[iotype]  : Type of the specified IO.
 @argument[index]   : The specified start position.
 @argument[count]   : Number acquired.
 @argument[value]   : IO value
 @argument[cb_arg1] : Argument specified by get_ioall().
 @argument[cb_arg2] : Argument specified by get_ioall().
 @description       : 
 @return            : 
 =========================================================================
*/
function getIOallCB(status, iotype, index, count, value, cb_arg1, cb_arg2) {
  if(status != '0x0') {
    console.log('getIOall err! io[' + iotype + '] status[' + status + ']');
    return false;
  }
  var tmp = value.filter(function(data) {return data.val != '';});
  if(tmp.length > 0) {
    switch(iotype) {
      case IO_TYPE_RI:
        g_regIOlimit_val['RI'].max = Number(tmp[tmp.length - 1].index);
        break;
      case IO_TYPE_RO:
        g_regIOlimit_val['RO'].max = Number(tmp[tmp.length - 1].index);
        break;
      default:
        break;
    }
  }
}
/*
=========================================================================
@function name    : read_prels_init 
@argument[]       :
@descriptio       : read the prels initial value
@return[ret]      :
=========================================================================
*/ 
function read_prels_init(callback, argObj){
 var lang = top.irprogapi.getCurrentLanguage();
 var frameXml = "";
 frameXml += '<?xml version="1.0" encoding="' + top.irprogapi.global.langEncoding[lang] + '"?>\r';
 frameXml += '<XMLCFG>\r<PROG name="*SYSTEM*">\r';
 frameXml += '<VAR name="$FFLSETUP.$LASER_MODEL" />\r';  // add system value name
 frameXml += '<VAR name="$LIFSET.$BM_SW_CH_SW" />\r';    // add system value name
 frameXml += '<VAR name="$FFLSETUP.$VAR_LCRQ" />\r';     // add system value name
 frameXml += '<VAR name="$APCSTIT1.$DEF_VALUE[2]" />\r'; // add system value name
 frameXml += '<VAR name="$APCSTIT1.$MIN_VALUE[2]" />\r'; // add system value name
 frameXml += '<VAR name="$APCSTIT1.$MAX_VALUE[2]" />\r'; // add system value name
 frameXml += '</PROG>\r</XMLCFG>';
  
 // Create Blob frame CVR
 var fileCvr = new Blob([frameXml], { type: "text/plain" });
 var cbArgs = {};
 cbArgs.sysIndex = 1;
 cbArgs.cbFunc = callback;
 cbArgs.cbObj = argObj;
 top.getXHR('crxeditorinit.cvr', fileCvr, set_prels_data, cbArgs);
 
}
 
/*
=========================================================================
@function name    : set_prels_data
@argument[]       :
@descriptio       : set the prels initial value in editing ls data
@return[ret]      :
=========================================================================
*/ 
function set_prels_data(status, getText, cbArgs){
 var argObj = {};
 var laser_order;
 var laser_chanel;
 if(status != 0){ return;}
  
 var XmlObj = getSysValXmlData(getText, 'ARRAY');
  
 pre_ls_ini[0] = parseInt(XmlObj.getElementsByTagName("VAR")[0].textContent, 10);
 pre_ls_ini[1] = JSON.parse(XmlObj.getElementsByTagName("VAR")[1].textContent.toLowerCase());
 pre_ls_ini[2] = XmlObj.getElementsByTagName("ARRAY")[0].textContent;
 pre_ls_ini[3] = XmlObj.getElementsByTagName("ARRAY")[1].textContent;
 pre_ls_ini[4] = XmlObj.getElementsByTagName("ARRAY")[2].textContent;
 
 default_data_structure["laserpre"].addMotion.push(langResource.ihmieditor_order_laser_pre_ls_c);
 default_data_structure["laserkpre"].addMotion.push(langResource.ihmieditor_order_laser_pre_ls_c);
 default_data_structure["laserpresi"].param = langResource.ihmieditor_order_laser_pre_ls_c;
 if(pre_ls_ini[1] == true){
   var index = default_data_structure["laserpre"].addMotion.length - 1;
   default_data_structure["laserpre"].addMotion[index] += "[" + langResource.ihmieditor_order_laser_chanel_c + "=" + pre_ls_ini[2] + "]";
   index = default_data_structure["laserkpre"].addMotion.length - 1;
   default_data_structure["laserkpre"].addMotion[index] += "[" + langResource.ihmieditor_order_laser_chanel_c + "=" + pre_ls_ini[2] + "]";
   default_data_structure["laserpresi"].param += "[" + langResource.ihmieditor_order_laser_chanel_c + "=" + pre_ls_ini[2] + "]";
 }
 read_ls_init(readCartPosXvr, argObj);
}
 
/*
=========================================================================
@function name    : read_ls_init
@argument[]       :
@descriptio       : read the ls initial value
@return[ret]      :
=========================================================================
*/ 
function read_ls_init(callback, argObj){
 var lang = top.irprogapi.getCurrentLanguage();
 var frameXml = "";
 frameXml += '<?xml version="1.0" encoding="' + top.irprogapi.global.langEncoding[lang] + '"?>\r';
 frameXml += '<XMLCFG>\r<PROG name="*SYSTEM*">\r';
 frameXml += '<VAR name="$APCSTIT2.$DEF_VALUE[2]" />\r'; // add system value name
 frameXml += '<VAR name="$APCSTIT2.$DEF_VALUE[3]" />\r'; // add system value name
 frameXml += '<VAR name="$APCSTIT2.$DEF_VALUE[4]" />\r'; // add system value name
 frameXml += '<VAR name="$APCSTIT2.$DEF_VALUE[5]" />\r'; // add system value name
 frameXml += '<VAR name="$APCSTIT2.$DEF_VALUE[7]" />\r'; // add system value name
 frameXml += '<VAR name="$APCSTIT2.$MIN_VALUE[2]" />\r'; // add system value name
 frameXml += '<VAR name="$APCSTIT2.$MAX_VALUE[2]" />\r'; // add system value name
 frameXml += '<VAR name="$APCSTIT2.$MIN_VALUE[3]" />\r'; // add system value name
 frameXml += '<VAR name="$APCSTIT2.$MAX_VALUE[3]" />\r'; // add system value name
 frameXml += '<VAR name="$APCSTIT2.$MIN_VALUE[4]" />\r'; // add system value name
 frameXml += '<VAR name="$APCSTIT2.$MAX_VALUE[4]" />\r'; // add system value name
 frameXml += '<VAR name="$APCSTIT2.$MIN_VALUE[5]" />\r'; // add system value name
 frameXml += '<VAR name="$APCSTIT2.$MAX_VALUE[5]" />\r'; // add system value name
 frameXml += '<VAR name="$APCSTIT2.$MIN_VALUE[7]" />\r'; // add system value name
 frameXml += '<VAR name="$APCSTIT2.$MAX_VALUE[7]" />\r'; // add system value name
 frameXml += '<VAR name="$FFLSETUP.$DEF_SPD_UNI"   />\r'; // add system value name
 frameXml += '<VAR name="$APCSTIT4.$DEF_VALUE[12]" />\r'; // add system value name
 frameXml += '<VAR name="$APCSTIT4.$MIN_VALUE[12]" />\r'; // add system value name
 frameXml += '<VAR name="$APCSTIT4.$MAX_VALUE[12]" />\r'; // add system value name
 if(g_order_option.indexOf("S555") != -1){
   frameXml += '<VAR name="$LIFSET.$HD[1].$CMND_OUT_IF" />\r'; // add system value name
 }
 frameXml += '</PROG>\r</XMLCFG>';
  
 // Create Blob frame CVR
 var fileCvr = new Blob([frameXml], { type: "text/plain" });
 var cbArgs = {};
 cbArgs.sysIndex = 1;
 cbArgs.cbFunc = callback;
 cbArgs.cbObj = argObj;
 top.getXHR('crxeditorinit.cvr', fileCvr, set_ls_data, cbArgs);
 
}
 
/*
=========================================================================
@function name    : set_ls_data
@argument[]       :
@descriptio       : set the ls initial value in editing ls data
@return[ret]      :
=========================================================================
*/ 
function set_ls_data(status, getText, cbArgs){
 var argObj = {};
 if(status != 0){ return;}
  
 var XmlObj = getSysValXmlData(getText, 'ARRAY');
 
 ls_ini[0] = XmlObj.getElementsByTagName("ARRAY")[0].textContent;
 ls_ini[1] = XmlObj.getElementsByTagName("ARRAY")[1].textContent;
 ls_ini[2] = XmlObj.getElementsByTagName("ARRAY")[2].textContent;
 ls_ini[3] = XmlObj.getElementsByTagName("ARRAY")[3].textContent;
 ls_ini[4] = XmlObj.getElementsByTagName("ARRAY")[4].textContent;
 ls_ini[5] = XmlObj.getElementsByTagName("ARRAY")[5].textContent;
 ls_ini[6] = XmlObj.getElementsByTagName("ARRAY")[6].textContent;
 ls_ini[7] = XmlObj.getElementsByTagName("ARRAY")[7].textContent;
 ls_ini[8] = XmlObj.getElementsByTagName("ARRAY")[8].textContent;
 ls_ini[9] = XmlObj.getElementsByTagName("ARRAY")[9].textContent;
 ls_ini[10] = XmlObj.getElementsByTagName("ARRAY")[10].textContent;
 ls_ini[11] = XmlObj.getElementsByTagName("ARRAY")[11].textContent;
 ls_ini[12] = XmlObj.getElementsByTagName("ARRAY")[12].textContent;
 ls_ini[13] = XmlObj.getElementsByTagName("ARRAY")[13].textContent;
 ls_ini[14] = XmlObj.getElementsByTagName("ARRAY")[14].textContent;
 ls_ini[15] = XmlObj.getElementsByTagName("VAR")[0].textContent
 ls_ini[16] = XmlObj.getElementsByTagName("ARRAY")[15].textContent;
 ls_ini[17] = XmlObj.getElementsByTagName("ARRAY")[16].textContent;
 ls_ini[18] = XmlObj.getElementsByTagName("ARRAY")[17].textContent;
 if(g_order_option.indexOf("S555") != -1){
   ls_ini[19] = XmlObj.getElementsByTagName("VAR")[1].textContent;
 }
 
 var vValDef = (ls_ini[15] != '3') ? ls_ini[4] : String(Number(ls_ini[4]) / 10);

 if(g_order_option.indexOf("S555") != -1){
   if(ls_ini[19] == '4'){
     ls_out_flg = true;
   }else{
     ls_out_flg = false;
   }
 }else{
   ls_out_flg = false;
 }

 var setTxt;

 if(ls_out_flg == false){
   setTxt = langResource.ihmieditor_order_laser_ls_c + "[S=" + ls_ini[0] + ",L=" + ls_ini[1]  + ",P=" + ls_ini[2] + ",Q=" + ls_ini[3] + ",V=" + vValDef + "]";
 }else{
   setTxt = langResource.ihmieditor_order_laser_ls_c + "[0]";
 }
 
 default_data_structure["laserls"].addMotion.push(setTxt);
 default_data_structure["laserkls"].addMotion.push(setTxt);
 default_data_structure["lasercls"].addMotion.push(setTxt);
 default_data_structure["lasercals"].addMotion.push(setTxt);
 default_data_structure["lasersls"].addMotion.push(setTxt);
 default_data_structure["laserlssi"].param = setTxt;
 
 read_le_init(readCartPosXvr, argObj);
}
 
/*
=========================================================================
@function name    : read_le_init
@argument[]       :
@descriptio       : read the le initial value
@return[ret]      :
=========================================================================
*/ 
function read_le_init(callback, argObj){
 var lang = top.irprogapi.getCurrentLanguage();
 var frameXml = "";
 frameXml += '<?xml version="1.0" encoding="' + top.irprogapi.global.langEncoding[lang] + '"?>\r';
 frameXml += '<XMLCFG>\r<PROG name="*SYSTEM*">\r';
 frameXml += '<VAR name="$APCEDIT3.$DEF_VALUE[1]" />\r'; // add system value name
 frameXml += '<VAR name="$APCEDIT3.$DEF_VALUE[2]" />\r'; // add system value name
 frameXml += '<VAR name="$APCEDIT3.$DEF_VALUE[3]" />\r'; // add system value name
 frameXml += '<VAR name="$APCEDIT3.$MIN_VALUE[1]" />\r'; // add system value name
 frameXml += '<VAR name="$APCEDIT3.$MAX_VALUE[1]" />\r'; // add system value name
 frameXml += '<VAR name="$APCEDIT3.$MIN_VALUE[2]" />\r'; // add system value name
 frameXml += '<VAR name="$APCEDIT3.$MAX_VALUE[2]" />\r'; // add system value name
 frameXml += '<VAR name="$APCEDIT3.$MIN_VALUE[3]" />\r'; // add system value name
 frameXml += '<VAR name="$APCEDIT3.$MAX_VALUE[3]" />\r'; // add system value name
 frameXml += '</PROG>\r</XMLCFG>';
  
 // Create Blob frame CVR
 var fileCvr = new Blob([frameXml], { type: "text/plain" });
 var cbArgs = {};
 cbArgs.sysIndex = 1;
 cbArgs.cbFunc = callback;
 cbArgs.cbObj = argObj;
 top.getXHR('crxeditorinit.cvr', fileCvr, set_le_data, cbArgs);
 
}
 
/*
=========================================================================
@function name    : set_le_data
@argument[]       :
@descriptio       : set the le initial value in editing ls data
@return[ret]      :
=========================================================================
*/ 
function set_le_data(status, getText, cbArgs){
 if(status != 0){ return;}
  
 var XmlObj = getSysValXmlData(getText, 'ARRAY');
 
 le_ini[0] = XmlObj.getElementsByTagName("ARRAY")[0].textContent;
 le_ini[1] = XmlObj.getElementsByTagName("ARRAY")[1].textContent;
 le_ini[2] = XmlObj.getElementsByTagName("ARRAY")[2].textContent;
 le_ini[3] = XmlObj.getElementsByTagName("ARRAY")[3].textContent;
 le_ini[4] = XmlObj.getElementsByTagName("ARRAY")[4].textContent;
 le_ini[5] = XmlObj.getElementsByTagName("ARRAY")[5].textContent;
 le_ini[6] = XmlObj.getElementsByTagName("ARRAY")[6].textContent;
 le_ini[7] = XmlObj.getElementsByTagName("ARRAY")[7].textContent;
 le_ini[8] = XmlObj.getElementsByTagName("ARRAY")[8].textContent;
 
 if(pre_ls_ini[0] == 14){
   var setTxt = langResource.ihmieditor_order_laser_le_c + "[AT=" + le_ini[0] + ",LOF=" + le_ini[2] + "]";
   default_data_structure["laserle"].addMotion.push(setTxt);
   default_data_structure["laserkle"].addMotion.push(setTxt);
   default_data_structure["lasercle"].addMotion.push(setTxt);
   default_data_structure["lasercale"].addMotion.push(setTxt);
   default_data_structure["lasersle"].addMotion.push(setTxt);
   default_data_structure["laserlesi"].param = setTxt;
 }
 else {
   var setTxt = langResource.ihmieditor_order_laser_le_c + "[AT=" + le_ini[0] + ",ST=" + le_ini[1] + ",SOF=" + le_ini[2] + "]";
   default_data_structure["laserle"].addMotion.push(setTxt);
   default_data_structure["laserkle"].addMotion.push(setTxt);
   default_data_structure["lasercle"].addMotion.push(setTxt);
   default_data_structure["lasercale"].addMotion.push(setTxt);
   default_data_structure["lasersle"].addMotion.push(setTxt);
   default_data_structure["laserlesi"].param = setTxt;
 }
}
                                                                                                                                                                                                                                                                                                        /**
 * ihmieditor Editor I/O control
 * Created: 2019/04/19 FSI
 */

// Use jQuery
/*
 * jQuery JavaScript Library
 * https://jquery.com/
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
*/

/*
 =========================================================================
 @description  : Definition of I/F status.
 =========================================================================
*/
var IO_SUCCESS = top.IO_SUCCESS; // Define success status

/*
 =========================================================================
 @function name       : getProgAttr
 @argument[prog_name] : Program name
 @argument[attrType]  : Attribute type
 @argument[callback]  : A callback function to receive status.
 @argument[arg]       : Any object to pass to the callback function.
 @description         : Get the attribute value of program.
 @return              : none
 =========================================================================
*/
function getProgAttr(prog_name, attrType, callback, arg) {
  /* iRP I/F call */
  top.getAttr(prog_name, attrType, getAttr_CB);

  /** callback function **/
  /*  status    : Status
   *  progName  : Program name
   *  attrType  : Attribute type
   *  attrValue : Attrubute value */
  function getAttr_CB(status, progName, attrType, attrValue) {
    callback(status, progName, attrType, attrValue, arg);
  }
}
                                                                                                                           IHMIE~10JS    MjXX  MjX_  BI N . J S      I H M I E  D I T O R _   M A IHMIE~11JS    MjXX  MjX= BR A C T .  J S     I H M I E  D I T O R _   S T IHMIE~12JS    MjXX  MjX:  BL D . J S      I H M I E  D I T O R _   W E IHMIE~13JS    MjXX  MjX
e  BI . J S      I H M I E  D I T O R _   A P IHMIE~14JS    MjXX  MjXsz  CS    c  S I D E N  cT _ L I S T   . J I H M I E  cD I T O R _   R E /**
 * LightrobotUI Detail screen display function
 * Created: 2019/04/19 FSI
 */

// Use jQuery
/*
 * jQuery JavaScript Library
 * https://jquery.com/
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
*/

var div_detailData = [];

/*
 =========================================================================
 @function name : create_detailhtml
 @argument      : none
 @description   : 
 @return        : none
 =========================================================================
*/
function create_detailhtml() {
	var setDtlPath = '';
	for(var cnt = 0; cnt < iconSortTbl.length; cnt++) {
		if(iconTbl[iconSortTbl[cnt]].dtlPath != '') {
			setDtlPath = iconTbl[iconSortTbl[cnt]].dtlPath + (chk_basicInstruction(iconSortTbl[cnt]) ? (gcurrentLang + '.html') : '');
			div_detailData['detail_' + cnt] = { html: '<iframe src="' + setDtlPath + '" class="detail_frm" id="detail_frm_' + cnt + '" name="detail_frm" frameborder="0" width="100%" height="100%" scrolling="yes"></iframe>' };
		}
	}
}

/*
 =========================================================================
 @function name  : append_detailhtml
 @argument[base] : Base ID of the instruction that displays the detail screen.
 @description    : 
 @return         : none
 =========================================================================
*/
function append_detailhtml(base) {
	var createDivId = 'detail_' + iconSortTbl.indexOf(base)
	if(document.getElementById(createDivId) && g_favoriteFlg.progAdd == false && g_favoriteFlg.favoEdit == false) { /*If favorite save mode of progTab or edit, default param.*/
		document.getElementById(createDivId).classList.add('active_disp');
	}
	else {
		var divArea = $('<div>', { class: 'detail_actSet', id: createDivId });
		divArea.html(div_detailData[createDivId].html);
		$('#detail_act').prepend(divArea);
		divArea[0].classList.add('active_disp');
	}
}

/*=========================================================================
 @function name  : append_helphtml
 =========================================================================*/
function append_helphtml(appendHelpId) {
	$("#helpArea").html(div_helpDisp[appendHelpId].html + '<div id="helpArea_restrict"></div>');
}

var div_helpDisp = [];
div_helpDisp['help_vision'] = { html: '<iframe src="/frh/vision/crxvision/help_vision.stm" id="help_frm_vision" frameborder="0" width="100%" height="100%" scrolling="yes"></iframe>' };
div_helpDisp['help_paste']  = { html: '<div id="help_container"><div class="explanation"><div>' + langResource.ihmieditor_help_paste_1_c + '</div><img id="paste_seq_img" src="./img/help/pastehelp.png"><div>' + langResource.ihmieditor_help_paste_2_c + '</div></div></div>' };

/*
 =========================================================================
 @function name : create_editorScreen
 @argument      : none
 @description   : 
 @return        : none
 =========================================================================
*/
function create_editorScreen() {
	/* Timeline */
	create_editorScreen_timeline();
	/* Programming area */
	create_editorScreen_progTab();
}

/*
 =========================================================================
 @function name : create_editorScreen_timeline
 @argument      : none
 @description   : 
 @return        : none
 =========================================================================
*/
function create_editorScreen_timeline() {
	$(parts_timeline).html(
		'<div id="timelinePop" class="msgpopup"><div id="tlPopMesArea" disabled><div id="messageArea"></div></div></div>' +
		'<div class="restrictionLayer" id="timelineRestrict"></div>' +
		'<div class="selectMode" id="iconSelectMenu">' +
			'<button type="button" class="selectMenu" id="selectMenu_del"><span>' + langResource.ihmieditor_submenu_del_c + '</span></button>' +
			'<button type="button" class="selectMenu" id="selectMenu_cpy"><span>' + langResource.ihmieditor_submenu_copy_c + '</span></button>' +
			'<button type="button" class="selectMenu" id="selectMenu_cut"><span>' + langResource.ihmieditor_submenu_cut_c + '</span></button>' +
			'<button type="button" class="selectMenu" id="selectMenu_favo"><span>' + langResource.ihmieditor_submenu_favorite_c + '</span></button>' +
			'<button type="button" class="selectMenu" id="selectMenu_stretch"><span>' + langResource.ihmieditor_submenu_shrink_c + '</span></button>' +
			'<button type="button" class="selectMenu" id="selectMenu_replace"><span>' + langResource.ihmieditor_submenu_replace_c + '</span></button>' +
			'<button type="button" class="selectMenu" id="selectMenu_remark"><span>' + langResource.ihmieditor_submenu_remark_c + '</span></button>' +
		'</div>' +
		'<div id="tl_dispOption">' +
			'<div id=overlay_tl_dispOption></div>' +
			'<div id="dispOpt_leftSide">' +
				'<div id=dispProgName></div>' +
			'</div>' +
			'<div id="dispOpt_rightSide">' +
				'<div class="option_func_area" id="drag_lock_area">' +
					'<button type="button" class="tl_dispOption_btn" id="tl_dragLock" onclick = "tl_dragLock_control(event)"></button>' +
				'</div>' +
				'<div class="option_func_area" id="viewchange_area">' +
					'<div id="overlay_viewchange"></div>' +
					'<button class="tl_dispOption_btn" id="viewchange"></button>' +
				'</div>' +
				'<div class="option_func_area" id="undoredo_area">' +
					'<div id="overlay_undoredo"></div>' +
					'<button class="tl_dispOption_btn undoredo" id="undo"></button>' +
					'<button class="tl_dispOption_btn undoredo" id="redo"></button>' +
				'</div>' +
			'</div>' +
		'</div>' +
		'<div class="scrl_track scrl_hrzn" id="TL_scrollbar"><div class="scrl_thumb" id="TLscrl_thumb"></div></div>' +
		'<div class="scrl_track scrl_vrtcl" id="TL_scrollbar_vrtcl"><div class="scrl_thumb" id="TLscrl_vrtcl_thumb"></div></div>' +
		'<div id="scrollWrap">' +
			'<div id="scrollContainer">' +
				'<div class="TimeLineArea TL_SyncScroll" id="TimeLineArea">' +
					'<div class="column_container">' +
						'<div class="exe_column_width" id="exe_column_width"></div>' +
						'<div class="exe_column clm_active" id="exe_column"></div>' +
					'</div>' +
					'<div id="TL_background">' +
						'<canvas class="TL_scale" id="TL_scale"></canvas>' +
						'<div class="TL_backline" id="TL_backline"></div>' +
						'<div class="timeLineBottom vtclscrl row1"></div>' +
					'</div>' +
					'<div class="TL_spacer" id="TL_spacer"></div>' +
				'</div>' +
			'</div>' +
		'</div>' +
		'<div class="timeLineBottom" id="timeLineBottom"></div>'
	);
	g_TL_elm = document.getElementById('TimeLineArea');
	scrlWrpElm = document.getElementById('scrollWrap');
	TLspacerElm = document.getElementById('TL_spacer');

	if(device === 'pc') {
		setScrollbooster();
	}
}

/*
 =========================================================================
 @function name : create_editorScreen_progTab
 @argument      : none
 @description   : 
 @return        : none
 =========================================================================
*/
function create_editorScreen_progTab() {
	var progTab = {
		'progTab_1_fav': {
			tab	: '<div class="paletteTab" id="progTab_1_fav"><span class="paletteTab_txt" id="palette_txt_fav">' +langResource.ihmieditor_title_favorite_c + '</span></div>',
			area: '<div class="prg_icon" id="cat_fav"></div>'
		},
		'progTab_1_his': {
			tab	: '<div class="paletteTab" id="progTab_1_his"><span class="paletteTab_txt" id="palette_txt_his">' + langResource.ihmieditor_title_history_c + '</span></div><div class="tab_border"><div class="tab_border_line"></div></div>',
			area: '<div class="prg_icon" id="cat_his"></div>'
		},
		'progTab_1_1': {
			tab	: '<div class="paletteTab" id="progTab_1_1"><span class="paletteTab_txt" id="palette_txt_all">' + langResource.ihmieditor_title_all_c + '</span></div>',
			area: '<div class="prg_icon" id="cat_all"></div>'
		},
		'progTab_1_2': {
			tab	: '<div class="paletteTab" id="progTab_1_2"><span class="paletteTab_txt" id="palette_txt_motion">' + langResource.ihmieditor_title_action_c + '</span></div>',
			area: '<div class="prg_icon" id="cat_motion"></div>'
		},
		'progTab_1_3': {
			tab	: '<div class="paletteTab" id="progTab_1_3"><span class="paletteTab_txt" id="palette_txt_ctrl">' + langResource.ihmieditor_title_control_c + '</span></div>',
			area: '<div class="prg_icon" id="cat_ctrl"></div>'
		},
		'progTab_1_4': {
			tab	: '<div class="paletteTab" id="progTab_1_4"><span class="paletteTab_txt" id="palette_txt_io">' + langResource.ihmieditor_title_IO_c + '</span></div>',
			area: '<div class="prg_icon" id="cat_io"></div>'
		},
		'progTab_1_5': {
			tab	: '<div class="paletteTab" id="progTab_1_5"><span class="paletteTab_txt" id="palette_txt_other">' + langResource.ihmieditor_title_other_c + '</span></div>',
			area: '<div class="prg_icon" id="cat_other"></div>'
		},
		'progTab_1_6': {	/* vision */
			tab	: '<div class="paletteTab" id="progTab_1_6"><span class="paletteTab_txt" id="palette_txt_vision">' + langResource.ihmieditor_title_Vision_c + '</span></div>',
			area: '<div class="prg_icon" id="cat_vision"><div class="prg_subcat" id="vis_subcat_1"></div><br><div class="prg_subcat" id="vis_subcat_2"><div class="prg_subcat_title" id="vis_subcat2_title">' + langResource.ihmieditor_title_motion_vision_c + '</div></div></div>',
		},
		'progTab_1_7': {	/* force control */
			tab	: '<div class="paletteTab" id="progTab_1_7"><span class="paletteTab_txt" id="palette_txt_force">' + langResource.ihmieditor_title_forceCtrl_c + '</span></div>',
			area: '<div class="prg_icon" id="cat_force"></div>'
		},
		'progTab_1_8': {	/* arc tool */
			tab	: '<div class="paletteTab" id="progTab_1_8"><span class="paletteTab_txt" id="palette_txt_arc">' + langResource.ihmieditor_title_arcTool_c + '</span></div>',
			area: '<div class="prg_icon" id="cat_arc"></div>',
		},
		'progTab_1_10': {	/* laser tool */
			tab	: '<div class="paletteTab" id="progTab_1_10"><span class="paletteTab_txt" id="palette_txt_laser">' + langResource.ihmieditor_laser_title_c + '</span></div>',
			area: '<div class="prg_icon" id="cat_laser"></div>',
		},
	}
	
	if(g_order_option.indexOf("R881") != -1) {
		for(var key in iconTbl_ex1) {
			iconTbl[key] = iconTbl_ex1[key];
			iconSortTbl.push(key);
		}
	}
	if(g_order_option.indexOf("R739") != -1) {
		for(var key in iconTbl_ex2) {
			iconTbl[key] = iconTbl_ex2[key];
			iconSortTbl.push(key);
		}
	}

	/* vision */
	if(g_insOption.vision) addVisionTab();
	/* force control */
	if(g_insOption.FCtrl) addForceCtrlTab();
	/* arc tool */
	if(g_insOption.arcTool) addArcToolTab();
	/* laser tool */
	if(g_insOption.laser) addLaserTab();
	
	$(parts_lowwer).html(
		'<div class="restrictionLayer" id="progRestrict"></div>' +
		'<div class="progAreaTab">' +
			'<div class="progTab" id="progTab_1">' +
				'<span class="progTab_txt" id="progTab_txt_prog">' + langResource.ihmieditor_title_programming_c + '</span>' +
			'</div>' +
			'<div class="progTab" id="progTab_2">' +
				'<span class="progTab_txt" id="progTab_txt_detail">' + langResource.ihmieditor_title_details_c + '</span>' +
			'</div>' +
		'</div>' +
		'<div class="progArea" id="progArea_1">' +
			'<div class="paletteTabArea">' +
				'<div id="progTab_paste">' +
					'<span class="paletteTab_txt" id="palette_txt_fav">' + langResource.ihmieditor_icon_paste_c + '</span>' +
				'</div>' +
			'</div>' +
			'<div class="prgicon_area">' +
				'<div class="multiCopyArea prg_icon" id="multiCopyArea">' +
					'<div class="teachIcon">' +
						'<div class="normal" id="sel_data">' +
							'<div class="iconBackground"></div>' +
						'</div>' +
						'<span class="iconName">' + langResource.ihmieditor_icon_paste_c + '</span>' +
					'</div>' +
				'</div>' + 
				'<div class="tabSelectMode"id="progPopMenu">' +
					'<button class="progMenu" id="favorite_add"></button>' +
					'<button class="progMenu" id="favorite_del"></button>' +
					'<button class="progMenu" id="favorite_edit"></button>' + 
				'</div>' +
				'<div id="helpArea">' +
					'<div id="helpArea_restrict"></div>' +
				'</div>' +
				'<div class="scrl_track scrl_vrtcl" id="progicon_scrl_track"><div class="scrl_thumb" id="progicon_scrl_thumb"></div></div>' +
			'</div>' +
		'</div>' +
		'<div class="progArea" id="progArea_2">' +
			'<div class="detailTab" id="detail_act">' +
				'<div class="restrictContainer">' +
					'<div class="restrictionLayer" id="detailRestrict"></div>' +
				'</div>' +
				'<div class="scrl_track scrl_vrtcl" id="detail_scrlTrack_vrtcl"><div class="scrl_thumb" id="dtl_scrlThumb_vrtcl"></div></div>' +
				'<div class="scrl_track scrl_hrzn" id="detail_scrlTrack_hrzn"><div class="scrl_thumb" id="dtl_scrlThumb_hrzn"></div></div>' +
			'</div>' +
			'<div class="detailTab" id="detail_adin"></div>' +
			'<div class="detailTab" id="detail_version"></div>' +
		'</div>'
	);
	var tabBaseElm = document.getElementById('progArea_1').getElementsByClassName('paletteTabArea')[0];
	var iconRefElm = document.getElementById('progPopMenu');
	var objKeys = Object.keys(progtabId);
	/* 'cnt == 0' is excluded because it is for pasting. */
	for(var cnt = 1; cnt < objKeys.length; cnt++) {
		(tabBaseElm.lastElementChild.id != 'progTab_1_5') ? $(tabBaseElm).append(progTab[objKeys[cnt]].tab) : $('#progTab_1_5').before(progTab[objKeys[cnt]].tab);
		(iconRefElm.previousElementSibling != null && iconRefElm.previousElementSibling.id == 'cat_other') ?
				$('#cat_other').before(progTab[objKeys[cnt]].area) : $(iconRefElm).before(progTab[objKeys[cnt]].area);
	}
	$('.paletteTab').css({'height':'calc((100%  - 4px) / ' +  (7 + getInsOptionCount()) + ')'});
	$('body').on('click', '#viewRestrict, #progRestrict', multiSelect_tapEvent);
}

/*
 =========================================================================
 @function name : addVisionTab
 @argument      : none
 @description   : 
 @return        : none
 =========================================================================
*/
function addVisionTab() {
	var iconTbl_vsn = {
		'vsnline'	:	{ category:	'cat_vision/subcat_2',	iconType: 'posTeach',	dispName: langResource.ihmieditor_icon_vision_L_c,	imgPath: 'img/flow/add_vision_line.png',	idCnt: 1,	iconNo: ICON_NO_VSN_LINE,	dtlPath: 'iframe/detail_liner_vis'	},
		'vsnjoint'	:	{ category:	'cat_vision/subcat_2',	iconType: 'posTeach',	dispName: langResource.ihmieditor_icon_vision_J_c,	imgPath: 'img/flow/add_vision_joint.png',	idCnt: 1,	iconNo: ICON_NO_VSN_JOINT,	dtlPath: 'iframe/detail_joint_vis'	},
	};
	
	for(var key in iconTbl_vsn) {
		iconTbl[key] = iconTbl_vsn[key];
		iconSortTbl.push(key);
	}
	progtabId['progTab_1_6'] = {'iconAreaId':'cat_vision'};
}

/*
 =========================================================================
 @function name : addForceCtrlTab
 @argument      : none
 @description   : 
 @return        : none
 =========================================================================
*/
function addForceCtrlTab() {
	progtabId['progTab_1_7'] = {'iconAreaId':'cat_force'};
}

/*
 =========================================================================
 @function name : addArcToolTab
 @argument      : none
 @description   : 
 @return        : none
 =========================================================================
*/
function addArcToolTab() {
	var iconTbl_arc = {
		'weldstartml':	{ category:	'cat_arc',	iconType: 'posTeach',	dispName: langResource.ihmieditor_icon_arcstartml_c,	imgPath: 'img/flow/add_arc_start_mo.png',	idCnt: 1,	iconNo: ICON_NO_WELD_START_MO,	dtlPath: 'iframe/detail_arc_start_mo'	},
		'weldstopml' :	{ category:	'cat_arc',	iconType: 'posTeach',	dispName: langResource.ihmieditor_icon_arcstopml_c,		imgPath: 'img/flow/add_arc_stop_mo.png',	idCnt: 1,	iconNo: ICON_NO_ARC_STOP_MO,	dtlPath: 'iframe/detail_arc_stop_mo'	},
		'weldstartca':	{ category:	'cat_arc',	iconType: 'posTeach',	dispName: langResource.ihmieditor_icon_arcstartca_c,	imgPath: 'img/flow/add_arc_start_ca.png',	idCnt: 1,	iconNo: ICON_NO_WELD_START_CA,	dtlPath: 'iframe/detail_arc_start_ca_mo'},
		'weldstopca' :	{ category:	'cat_arc',	iconType: 'posTeach',	dispName: langResource.ihmieditor_icon_arcstopca_c,		imgPath: 'img/flow/add_arc_stop_ca.png',	idCnt: 1,	iconNo: ICON_NO_ARC_STOP_CA,	dtlPath: 'iframe/detail_arc_stop_ca_mo'	},
		'weldstartal':	{ category:	'cat_arc',	iconType: 'normal',		dispName: langResource.ihmieditor_icon_arcstartal_c,	imgPath: 'img/flow/add_arc_start_al.png',	idCnt: 1,	iconNo: ICON_NO_WELD_START_AL,	dtlPath: 'iframe/detail_arc_start_al'	},
		'weldstopal' :	{ category:	'cat_arc',	iconType: 'normal',		dispName: langResource.ihmieditor_icon_arcstopal_c,		imgPath: 'img/flow/add_arc_stop_al.png',	idCnt: 1,	iconNo: ICON_NO_ARC_STOP_AL,	dtlPath: 'iframe/detail_arc_stop_al'	},
	};
	
	for(var key in iconTbl_arc) {
		iconTbl[key] = iconTbl_arc[key];
		iconSortTbl.push(key);
	}
	if(g_order_option.indexOf("R881") != -1) {
		for(var exKey in iconTab_arc_ex_l) {
			iconTbl[exKey] = iconTab_arc_ex_l[exKey];
			iconSortTbl.push(exKey);
		}
	}
	progtabId['progTab_1_8'] = {'iconAreaId':'cat_arc'};
}

/*
 =========================================================================
 @function name : addLaserTab
 @argument      : none
 @description   : 
 @return        : none
 =========================================================================
*/
function addLaserTab() {
	var iconTbl_laser = {
		'laserpre'	:	{ category:	'cat_laser',	iconType: 'posTeach',	dispName: langResource.ihmieditor_laser_pre_ls_icon_c,	imgPath: 'img/flow/lsr_prels_mo.png',	idCnt: 1,	iconNo: ICON_NO_LASER_PRE,		dtlPath: 'iframe/detail_laser_pre'	},
		'laserls'	:	{ category:	'cat_laser',	iconType: 'posTeach',	dispName: langResource.ihmieditor_laser_ls_icon_c,		imgPath: 'img/flow/lsr_ls_mo.png',		idCnt: 1,	iconNo: ICON_NO_LASER_LS,		dtlPath: 'iframe/detail_laser_ls'	},
		'laserle'	:	{ category:	'cat_laser',	iconType: 'posTeach',	dispName: langResource.ihmieditor_laser_le_icon_c,		imgPath: 'img/flow/lsr_le_mo.png',		idCnt: 1,	iconNo: ICON_NO_LASER_LE,		dtlPath: 'iframe/detail_laser_le'	},
		'laserpresi':	{ category:	'cat_laser',	iconType: 'normal',		dispName: langResource.ihmieditor_laser_pre_ls_sicon_c,	imgPath: 'img/flow/lsr_prels_sa.png',	idCnt: 1,	iconNo: ICON_NO_LASER_PRE_SI,	dtlPath: 'iframe/detail_laser_pres'	},
		'laserlssi'	:	{ category:	'cat_laser',	iconType: 'normal',		dispName: langResource.ihmieditor_laser_ls_sicon_c,		imgPath: 'img/flow/lsr_ls_sa.png',		idCnt: 1,	iconNo: ICON_NO_LASER_LS_SI,	dtlPath: 'iframe/detail_laser_lss'	},
		'laserlesi'	:	{ category:	'cat_laser',	iconType: 'normal',		dispName: langResource.ihmieditor_laser_le_sicon_c,		imgPath: 'img/flow/lsr_le_sa.png',		idCnt: 1,	iconNo: ICON_NO_LASER_LE_SI,	dtlPath: 'iframe/detail_laser_les'	},
		'laserpow'	:	{ category:	'cat_laser',	iconType: 'normal',		dispName: langResource.ihmieditor_laser_powc_name_c,	imgPath: 'img/flow/lsr_pwrctrl_sa.png',	idCnt: 1,	iconNo: ICON_NO_LASER_PWC,		dtlPath: 'iframe/detail_laser_pwc'	},
		'laserkpre'	:	{ category:	'cat_laser',	iconType: 'posTeach',	dispName: langResource.ihmieditor_laser_k_pre_ls_icon_c,imgPath: 'img/flow/lsr_prels_mo_j.png',	idCnt: 1,	iconNo: ICON_NO_LASER_K_PRE,	dtlPath: 'iframe/detail_laser_k_pre'},
		'laserkls'	:	{ category:	'cat_laser',	iconType: 'posTeach',	dispName: langResource.ihmieditor_laser_k_ls_icon_c,	imgPath: 'img/flow/lsr_ls_mo_j.png',	idCnt: 1,	iconNo: ICON_NO_LASER_K_LS,		dtlPath: 'iframe/detail_laser_k_ls'	},
		'laserkle'	:	{ category:	'cat_laser',	iconType: 'posTeach',	dispName: langResource.ihmieditor_laser_k_le_icon_c,	imgPath: 'img/flow/lsr_le_mo_j.png',	idCnt: 1,	iconNo: ICON_NO_LASER_K_LE,		dtlPath: 'iframe/detail_laser_k_le'	},
		'lasercls'	:	{ category:	'cat_laser',	iconType: 'posTeach',	dispName: langResource.ihmieditor_laser_c_ls_icon_c,	imgPath: 'img/flow/lsr_ls_mo_c.png',	idCnt: 1,	iconNo: ICON_NO_LASER_LS,		dtlPath: 'iframe/detail_laser_c_ls'	},
		'lasercle'	:	{ category:	'cat_laser',	iconType: 'posTeach',	dispName: langResource.ihmieditor_laser_c_le_icon_c,	imgPath: 'img/flow/lsr_le_mo_c.png',	idCnt: 1,	iconNo: ICON_NO_LASER_LE,		dtlPath: 'iframe/detail_laser_c_le'	},
		'lasercals'	:	{ category: 'cat_laser',	iconType: 'posTeach',	dispName: langResource.ihmieditor_laser_ca_ls_icon_c,	imgPath: 'img/flow/lsr_ls_mo_ca.png',	idCnt: 1,	iconNo: ICON_NO_LASER_LS,		dtlPath: 'iframe/detail_laser_ca_ls'},
		'lasercale'	:	{ category: 'cat_laser',	iconType: 'posTeach',	dispName: langResource.ihmieditor_laser_ca_le_icon_c,	imgPath: 'img/flow/lsr_le_mo_ca.png',	idCnt: 1,	iconNo: ICON_NO_LASER_LE,		dtlPath: 'iframe/detail_laser_ca_le'},
		'laserwirc'	:	{ category:	'cat_laser',	iconType: 'normal',		dispName: langResource.ihmieditor_laser_wirc_name_c,	imgPath: 'img/flow/lsr_wirctrl_sa.png',	idCnt: 1,	iconNo: ICON_NO_LASER_WIRC,		dtlPath: 'iframe/detail_laser_wirc'	},
	};
	var iconTbl_laser_ex_s = {
		'lasersls': { category: 'cat_laser', iconType: 'posTeach', dispName: langResource.ihmieditor_laser_s_ls_icon_c, imgPath: 'img/flow/lsr_ls_mo_s.png', idCnt: 1, iconNo: ICON_NO_LASER_LS, dtlPath: 'iframe/detail_laser_s_ls' },
		'lasersle': { category: 'cat_laser', iconType: 'posTeach', dispName: langResource.ihmieditor_laser_s_le_icon_c, imgPath: 'img/flow/lsr_le_mo_s.png', idCnt: 1, iconNo: ICON_NO_LASER_LE, dtlPath: 'iframe/detail_laser_s_le' },
	};
	for(var key in iconTbl_laser) {
		iconTbl[key] = iconTbl_laser[key];
		iconSortTbl.push(key);
	}
	if (g_order_option.indexOf("R904") != -1) {
		var lasercaleIdx = iconSortTbl.indexOf('lasercale') + 1;
		for (var exKey in iconTbl_laser_ex_s) {
			iconTbl[exKey] = iconTbl_laser_ex_s[exKey];
			iconSortTbl.splice(lasercaleIdx++, 0, exKey);
		}
	}
	progtabId['progTab_1_10'] = {'iconAreaId':'cat_laser'};
}

/*
 =========================================================================
 @function name : addPruginTab
 @argument      : none
 @description   : 
 @return        : none
 =========================================================================
*/
function addPluginTab() {
	var div_plugin_tab = '<div class="paletteTab" id="progTab_1_9"><span class="paletteTab_txt" id="palette_txt_plugin">' + langResource.ihmieditor_title_plugin_c + '</span></div>';
	var div_plugin_area = '<div class="prg_icon" id="cat_plugin"></div>';
	
	$('#progTab_1_5').before(div_plugin_tab);
	$('#cat_other').before(div_plugin_area);
	$('.paletteTab').css({'height':'calc((100%  - 4px) / ' +  (7 + getInsOptionCount()) + ')'});
	progtabId['progTab_1_9'] = {'iconAreaId':'cat_plugin'};
}

/*
 =========================================================================
 @function name : favorite_formDisp
 @argument      : none
 @description   : Favorite form popup is create. 
 @return        : Favorite popup form.
 =========================================================================
*/
function favorite_formDisp() {
	var inputTextName = "";
	/*favorite add icon is inst icon. */
	if(g_favoriteFlg.favoEdit == true) {
		inputTextName = g_favoriteList[g_favoTargetData.listIndex].setName;
	}
	else {
		inputTextName = create_dispfavoName(g_addFavoData[0].oldName);
	}
	/*favorite image display position setting.*/
	var favoriteform =  '<div class="favoriteform">';
	favoriteform += '<button id="favoFormCloseBtn" class="favoformCloseBtn" onclick = "multiSelect_tapEvent(event)"></button>';
	favoriteform += '<div style="text-align: center;margin-top: -30px;margin-left: 15px;">';
	favoriteform +=	'<div class = "teachIcon" style="position: absolute; margin-top: 18px;margin-left: -10px;"><div class="posTeach" style="margin-top: 15px;">'
	favoriteform += '<div class="iconBackground" style="background-image: url('+ iconTbl[g_addFavoData[0].oldName].imgPath + ');"></div></div>';
	favoriteform += '<div style="position: relative;"><span class=favoImage style="top:-65px;"></span><p class="iconName" style="margin-top: 5px;">' + iconTbl[g_addFavoData[0].oldName].dispName + '</p></div></div>';
	favoriteform += '<p style="font-size:18px; margin: 12px 0px 3px 0px; line-height: 24px;">' + langResource.ihmieditor_pop_favorite_form_text1_c + '</p>';
	favoriteform += '<input type="text" id="setIconName" class="textbox touch favotextBox" value="' + inputTextName + '"style="height: 32px; line-height: 32px;" onkeyup="favoRegistNameChk();">';
	favoriteform += '<p id = "alertName" style="color:rgba(0,0,0,0);font-size:14px;display:block; margin: 4px 0px 6px 0px;line-height: 11px;">' + langResource.ihmieditor_pop_favorite_form_text2_c + '</p>';
	favoriteform += '<button id = "saveBtn" class="button favoSaveBtn" onclick="create_favoSaveData();">'+ langResource.ihmieditor_pop_favorite_form_regist_c +'</button></div></div>';

	return favoriteform; 
}
                            // Use jQuery
/*
 * jQuery JavaScript Library
 * https://jquery.com/
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
*/
// Use jQuery UI
/*
 * jQuery UI Widget
 * http://jqueryui.com
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//=============================================================================
// define
//=============================================================================
//=============================================================================
// Global variable
//=============================================================================
var touchId = "";		// Touch operation target.id
var g_tlmove_ghost = "";	// Target when dragging the icon on the timeline
var g_delReady_flg = '';
var pressEvent = "";	// Event information when displaying a submenu with a long tap
var g_program_data = [];

var g_editor_status = {
	detail_inputFocus  : false,
	tl_loading         : false,
	pathTeachInfo      : {wizDisp : false, targetProg : '', clampErr : ''},
}
var g_TL_progInfo = {	/* TP program information displayed on the timeline. */
  dispRange     :{left:0, right:0},		/* Current display range */
  dispProg      :[],					/* Program information to be displayed */
  saveProg      :[],					/* Saved program information */
  bktSaveProg   :[],					/* Saved bracket program information */
  scrollDist    :'',					/* Scroll direction */
  sort_dragging :false,	
}
var g_latest_command = [];
var g_switchProg_bkup = {
  program_data:{},
  TL_progInfo:{},
  iconTbl:{},
  position:[],
  labelNumList:[],
  attribute:[],
  applData:[],
};

var g_TL_selectModeFlg = false;

var navUA = navigator.userAgent.toLowerCase();
var isAndroid = (navUA.indexOf('android') >= 0) && (navUA.indexOf('mobile') < 0);
var save_id_array = [];

var read_tpprog_finish_flg = false;
var create_screen_finish_flg = false;
var write_mode = 0;
var active_elem = "";

var LATEST_CMD_MAX = 10;
var edit_posregi_notRestore_flg = false;
var edit_pos_notRestore_flg = false;
var position_format = FORMAT_CART;
var need_position_save_flg = false;
var sameCnt = 0;
var addProg = [];
var addId = [];
var addPrgSaveId = {sampleAddFlg:false, idList:[]};
var addRecordId = [];
var dropRecordCnt = 0;
var posRegTemporary = [];
var posTemporary = [];
var addProgId = [];
var adinObservFlag = false;
var g_RO_flg = false;
var g_TPenbl_flg = false;
var g_cobot_flg = false;
var g_btnTeaching_list = {
	'weldteach': { existsTimeline: false, id: null, count: 0 },
	'wristteach': { existsTimeline: false, id: null, count: 0 },
};
//var targetNestNum = 0;
var need_show_popup_flg = true;
var updInstFlg = false;
var parts_block = '';
var parts_upper = '';
var parts_handleresize_area = '';
var parts_timeline = '';
var parts_lowwer = '';
var g_TL_elm = '';			/* The timeline. */
var scrlWrpElm = '';		/* The parent element to scroll the timeline. */
var TLspacerElm = '';
var VISION_FIND_ORDER = "^INST_VISION$";
var dropSaveFlg = false;
var g_adintarget = "";
var g_adinDropList = [];
var g_lineCountOver_base = {
	'main' : {overflg:false},
	'sub'  : {overflg:false}
};
var g_lineCountOver = g_lineCountOver_base['main'];
var samplePrg_status = {
	'dropFunc' : false
};
var g_payload_schnum = 1;
var extend_IOlimit_val = {};
var g_config = {
	'armType'   : [],
	'localReg' : [],  /* reg, position reg, string reg */
}
var LOCAL_REG_MIN = 10001;
var g_sysval = {};
var g_order_sysVal = {};
var g_order_karelVal = {};
var g_order_option = [];
var g_weldSpeed = {};
var g_progModifyInfo = {
	main : {name: '', time: 0},
	sub  : {name: '', time: 0},
	runMonitor : false,
	initializing : false,
	frcStop : false,
};

$(window).on('unload', function (evt) {
	/* IO event unbind */
	top.jQuery.varlis.unbind('VarEvent', rcvVarEvent);
	top.jQuery.iolis.unbind("IOBooleanEvent", rcvIOevent);
});
var javascriptError = [];
window.onerror = function(message, source, lineno, colno, error) {
	javascriptError.push(message + '/' + source + ':' + lineno);
}
/*
 =========================================================================
 @function name : window.onload
 @argument      : none
 @description   : Processing when loading HTML. Upper menu icon display, program screen display
 @return        : none
 =========================================================================
*/
var scrollFrom = '';	/* For caller memory */
var timeoutId = 0;		/* For discarding timeout */
var hrznScrlEndChk = 0;	/* For horizontal scroll end check */
var vrtclScrlEndChk = 0;	/* For vertical scroll end check */
var g_insOption = {vision:false, FCtrl:false, arcTool:false, laser:false, plugin:false};

window.onload = function () {
	dispOnWaiting(0);
	getCmnElm();
	startProgStatInfoMonitor();

	/* IO event bind */
	top.jQuery.varlis.bind('VarEvent', null, rcvVarEvent);
	top.jQuery.iolis.bind("IOBooleanEvent", null, rcvIOevent);
	/* Get the current TP state. */
	var statwindow = top.document.getElementById('statbar').contentWindow;
	if(statwindow != null) {
		g_TPenbl_flg = false;
		if(statwindow.document.getElementById('tpEnableImg')) {
			g_TPenbl_flg = statwindow.document.getElementById('tpEnableImg').getAttribute('src') === "tp_on.png" ? true : false;
		}
		else {
			g_TPenbl_flg = statwindow.document.getElementsByClassName('tpenabled').length != 0 ? true : false;
		}
	}

	// If I have not acquired the language type yet, I will go get it.
	//1st Get current language ($DICT_CONFIG.$LANG_SUFFIX)
	/*get robot option */
	var getOrderSysVal = ["$feature.$mod", "$APPLICATION[2]", "$DICT_CONFIG.$LANG_SUFFIX"];
	getSysValXHR(getOrderSysVal, getOrderXVRCallback);
}

/*
 =========================================================================
 @function name : getOrderXVRCallback
 @argument      : none
 @description   : Get order option in XVR
 @return        : none
 =========================================================================
*/
function getOrderXVRCallback(status, getText) {
	if(status != IO_SUCCESS) {
		initialsetting();
		return;
	}
	var XmlObj = getSysValXmlData(getText, 'VAR');
	var valList = XmlObj.getElementsByTagName('VAR');
	var order = valList[0].children;
	for(var loop = 0; loop < order.length; loop++){
		if(order[loop].textContent == '********') {break;}
		g_order_option[loop] = order[loop].textContent;
	}

	if (g_order_option.indexOf("R904") != -1) {
		var circlearcIdx = iconSortTbl.indexOf('circlearc') + 1;
		iconSortTbl.splice(circlearcIdx, 0, 'spline');
		iconTbl['spline'] = iconTbl_spline;
	}

	if(g_order_option.indexOf("CVSU") != -1){ /* vision */
		g_insOption.vision = true;
	}
	if(g_order_option.indexOf("CCSU") != -1){ /* force control */
		g_insOption.FCtrl = true;
	}
	if(g_order_option.indexOf("H541") != -1 || g_order_option.indexOf("H574") != -1){ /* arc tool */
		g_insOption.arcTool = true;
	}
	if(g_order_option.indexOf("S555") != -1 || g_order_option.indexOf("J922") != -1){ /* laser tool */
		g_insOption.laser = true;
	}

	/* "$DICT_CONFIG.$LANG_SUFFIX" */
	var convData = extractRcvXHRData(XmlObj, 'VAR');
	currentLang = (convData['$DICT_CONFIG.$LANG_SUFFIX'] != null) ? convData['$DICT_CONFIG.$LANG_SUFFIX'] : 'eg';
	gcurrentLang = (currentLang == 'jp') ? 'kn' : currentLang;
	gcurrentJPLang = (currentLang == 'kn') ? 'jp' : currentLang;
	/* "$APPLICATION[2]" */
	var nodelist = XmlObj.getElementsByTagName("ARRAY");
	if("V9.40P/09 " == nodelist[nodelist.length - 1].textContent) {
		alert('Requires V9.40P/10 or later.');
	}

	create_editorScreen();

	makeAdvInst();
}

/*
 =========================================================================
 @function name : getSysValXHR
 @argument      : none
 @description   : Get system variables in XVR
 @return        : none
 =========================================================================
*/
function getSysValXHR(sysValArr, callback, arg) {
  var frameXml = "";

  frameXml += '<?xml version="1.0" encoding="' + parent.langEncoding[gcurrentJPLang] + '"?>\r';
  frameXml += '<XMLCFG>\r<PROG name="*SYSTEM*">\r';
  frameXml += '<VAR name="' + sysValArr.join('" />\r<VAR name="') + '" />\r';
  frameXml += '</PROG>\r</XMLCFG>';

  // Create Blob frame CVR
  var fileCvr = new Blob([frameXml], { type: 'text/plain' });
  top.getXHR('ihmiSysVal.cvr', fileCvr, callback, arg);
}

/*
 =========================================================================
 @function name : getSysKarelValXHR
 @argument      : none
 @description   : Get system variables and karel variables in XVR
 @return        : none
 =========================================================================
*/
function getSysKarelValXHR(sysValArr, karelValArr, callback, arg) {
	var frameXml = "";
	var klProgList = Object.keys(karelValArr);

	frameXml += '<?xml version="1.0" encoding="' + parent.langEncoding[gcurrentJPLang] + '"?>\r';
	frameXml += '<XMLCFG>\r';
	if(klProgList.length != 0){
		for(var loop=0; loop < klProgList.length; loop++) {
			frameXml += '<PROG name="'+ klProgList[loop] +'">\r';
			frameXml += '<VAR name="' + karelValArr[klProgList[loop]].join('" />\r<VAR name="') + '" />\r';
			frameXml += '</PROG>\r';
		}
	}
	if(sysValArr.length != 0){
		frameXml += '<PROG name="*SYSTEM*">\r';
		frameXml += '<VAR name="' + sysValArr.join('" />\r<VAR name="') + '" />\r';
		frameXml += '</PROG>';
	}
	frameXml += '</XMLCFG>';
	// Create Blob frame CVR
	var fileCvr = new Blob([frameXml], { type: 'text/plain' });
	top.getXHR('ihmiSysVal.cvr', fileCvr, callback, arg);
}

/*
 =========================================================================
 @function name : makeSysValArr
 @argument      : none
 @description   : Returns the name of the system variable to be acquired in the form of an array.
 @return        : Array
 =========================================================================
*/


/*
 =========================================================================
 @function name : getCmnElm
 @argument      : none
 @description   : 
 @return        : none
 =========================================================================
*/
function getCmnElm() {
	parts_block = document.getElementsByClassName('parts-block')[0];
	parts_upper = document.getElementById('parts-upper');
	parts_handleresize_area = document.getElementById('parts-handleresize');
	parts_timeline = document.getElementById('parts-timeline');
	parts_lowwer = document.getElementById('parts-lowwer');
}

/*
 =========================================================================
 @function name : createVisionCamFrm
 @argument      : none
 @description   : 
 @return        : none
 =========================================================================
*/
function createVisionCamFrm() {
    var popfrm = $('<div>', { id: 'adin4Dfrm', class: 'hide' });
	
	popfrm.html('<div class="adin4Dfrm_poparea">' +
				'<div id="adin4Dfrm_title">' +
				'<button id="adin4DfrmCls">' +
				'</button></div>' +
				'<div id="adin4Dfrm_contents"></div>' +
				'</div>');
	
	$('#upperDisp_4d').prepend(popfrm);
	
	$('#adin4DfrmCls').on('click', function() {
		instFrameHide();
	});
}

/*
 =========================================================================
 @function name      : instFrameDisp
 @argument[dispPath] : iframe path
 @description        : 
 @return             : none
 =========================================================================
*/
function instFrameDisp(dispPath) {
  var contFrame = document.getElementById("adin4Dfrm_contents");
  if (typeof dispPath != 'undefined') {
    var frame = contFrame.firstElementChild;
    if (frame != null) {
      var frmhref = frame.contentDocument.location.href;
      if (frmhref.indexOf(dispPath) == -1) {
        frame.contentDocument.location.href = dispPath;
      }
    }
    else {
      var append_frm = document.createElement("iframe");
      append_frm.id = "visInstFrm";
      append_frm.frameborder = "0";
      append_frm.width = "100%";
      append_frm.height = "100%";
      append_frm.scrolling = "yes";
      append_frm.src = dispPath;
      contFrame.appendChild(append_frm);
      frame = contFrame.firstElementChild;
    }
    ihmif.removeClass(document.getElementById("adin4Dfrm"), "hide");
  }
  else {
    ihmif.addClass(document.getElementById("adin4Dfrm"), "hide");
  }
}

/*
 =========================================================================
 @function name : instFrameHide
 @argument[]    : none
 @description   : 
 @return        : none
 =========================================================================
*/
function instFrameHide() {
  ihmif.addClass(document.getElementById("adin4Dfrm"), "hide");
  document.getElementById('adin4Dfrm_contents').textContent = "";
}

/*
 =========================================================================
 @function name : getInsOptionCount
 @argument      : none
 @description   : 
 @return        : Number of installed options.
 =========================================================================
*/
function getInsOptionCount() {
	var optCnt = 0;
	Object.keys(g_insOption).forEach( function(key) {
		if(g_insOption[key]) optCnt++;
	});
	return optCnt;
}

/*
 =========================================================================
 @function name : initialsetting
 @argument      : none
 @description   : Initial setting process
 @return        : none
 =========================================================================
*/
function initialsetting() {
	ihmieditor_init();

	/* icon initial creation */
	create_icon_default();
	
	/* "Programming" tab generation */
	create_ProgramingTab();
	/* "4D/Monitor" area generation */
	create_4d_Monitor_Area();
	/* Specify width according to screen width */
	lateralResizeFunc();
	/* For option instruction detail screen. Set up functions for loading and saving. */
	detailDisp_funcSetting();

	/* Check screen orientation */
	if((device === 'smt') && (window.top.innerHeight <= window.top.innerWidth)) {
		// console.log('[init doc]height:' + window.top.innerHeight + ' width:' + window.top.innerWidth);
		g_disp_orientation.rotate = DISP_LANDSCAPE;
		landscape_dispSlide(true);
	}
	
	/* Timeline programming area Sortable setting */
	timeLine_setting();
	
	handleResizeAreaSetting();

	/* Timeline event registration Event processing */
	timeLine_Event();
	
	/* "Programing Area" event registration and event processing */
	programingArea_Event();
	
	/* Timeline Selected state Submenu processing */
	timeLine_selectMode_subMenu();
	
	/* "Programing Area" submenu processing */
	programingArea_subMenu();
	
	/* Create HTML for the detail screen. */
	create_detailhtml();

	//=============================================================================
	// Undo/Redo control.
	//=============================================================================
	undoredo_control();
	
	//=============================================================================
	// View change control.
	//=============================================================================
	viewchange_control();
	
	/* Register window size change event */
	$(window).on("resize", function(event) {
		resizeFunc(event);
	});
	
	//=============================================================================
	// Scroll bar control
	//=============================================================================
	timeline_scrollControl();
	progicon_scrlCtrl();
	
	//iHMI component initialization
	top.IHMIComponents.cf.KeyEvent.attachHandlers(window);
	
	/* Get speed limit */
	get_speedLimit();

	// Get time out value
	get_timeOutVal();

	/* Check alignment status */
	alignment_check();

	create_screen_finish_flg = true;
	check_read_complete();
	
	version_disp();

	getProgramText(g_favoriteSaveProg, 1, load_fav_tp_callback);
}

/*
 =========================================================================
 @function name  : get_speedLimit
 @argument       : none
 @description    : Get the speed limit value.
 @return         : none
 =========================================================================
*/
function get_speedLimit() {
	/* Get speed limit */
	top.rpcmc_chkkey(null, top.mor_ss_c, top.SYSNAME_C, '$CF_LIM_GRP[1].$SPEEDLIM', getSpeedLimitCallback, '$CF_LIM_GRP[1].$SPEEDLIM');
	top.rpcmc_chkkey(null, top.mor_ss_c, top.SYSNAME_C, '$MRR_GRP[1].$ROTSPEEDLIM', getSpeedLimitCallback, '$MRR_GRP[1].$ROTSPEEDLIM');
}
/*
 =========================================================================
 @function name  : get_timeOutVal
 @argument       : none
 @description    : Get the time out value.
 @return         : none
 =========================================================================
*/
function get_timeOutVal() {
	// Get time out value
	top.rpcmc_getVar(top.SYSNAME_C, '$WAITTMOUT', getTimeOutValCallback);
}

/*
 =========================================================================
 @function name  : alignment_check
 @argument       : none
 @description    : Obtain current position information and check alignment status.
 @return         : none
 =========================================================================
*/
var g_alinment_complete = false;
function alignment_check() {
	var grpNum = 1;
	var arg = {};
	var alignmentCB = function(pos_rep, pos_type, grp_num, str, cbArg) {
		g_alinment_complete = (cbArg.status === IO_SUCCESS);
		if(g_alinment_complete) {
			if(activeTarget) icon_inactive();
			/* Clear the pop-up of the component. */
			del_allDetailFrm();
		}
	}
	/* Get the current position. (The group number is fixed at 1.) */
	if(!g_alinment_complete) top.get_curpos(top.KXYZWPR, top.TXML_TP_REC_TYPE, grpNum, alignmentCB, arg);
}

/*
 =========================================================================
 @function name  : create_ProgramingTab
 @argument       : none
 @description    : "Programming" tab generation
 @return         : none
 =========================================================================
*/
function create_ProgramingTab() {
	/*arc motion icon generation.*/
	if(g_insOption.arcTool) {
		for(var key in arcMotionTbl)
			programingArea_addIcon(key, 'cat_arc');
	}
	/* Instruction icon generation */
	for(var cnt=0; cnt < iconSortTbl.length; cnt++) {
		if((iconTbl[iconSortTbl[cnt]].category !== '') &&
		   (stretch_idStrChk(STRETCH_ID_CHK_N_LEAD_N_EQ, iconSortTbl[cnt]) === true)) {
			/* tab1 */
			programingArea_addIcon(iconSortTbl[cnt], 'cat_all');
			/* tab2-5 */
			programingArea_addIcon(iconSortTbl[cnt], iconTbl[iconSortTbl[cnt]].category);
		}
	}
}

/*
 =========================================================================
 @function name  : create_4d_Monitor_Area
 @argument       : none
 @description    : 4D/IO area generation
 @return         : none
 =========================================================================
*/
function create_4d_Monitor_Area() {
	var upperDivArea = $('<div>', {class: 'upperDispArea', id: 'upperDispArea'});
	upperDivArea.html('<div class="upperDisp" id="upperDisp_4d"></div>' +
				'<div class="upperDisp" id="upperDisp_moni"></div>');
	parts_upper.insertBefore(upperDivArea[0], document.getElementById('viewRestrict'));
	
	$('#upperDisp_4d').addClass('upperDisp_active');
	if(isCRXeditorActive && document.getElementById("webgl") == null) {
		addframe4dGraph();
	}
	
	if(g_insOption.vision == true) {
		createVisionCamFrm();
	}
}

/*
 =========================================================================
 @function name : handleResizeAreaSetting
 @argument      : none
 @description   : 
 @return        : none
 =========================================================================
*/
function handleResizeAreaSetting() {
	const topEdge = 'first';
	parts_handleresize_area.refresh({firstAreaSize: DEF_GRAPHIC_AREA_HEIGHT_RATE * 100});
	parts_lowwer.style.height = "calc(100% - " + parts_timeline.offsetHeight + "px)";
	$(".progArea").css('height', 'calc(100% - ' + PROG_AREA_TAB_HEIGHT +'px)');
	$("#progicon_scrl_track").css({'top': PROG_AREA_TAB_HEIGHT + 'px', 'height': 'calc(100% - ' + PROG_AREA_TAB_HEIGHT +'px)'});
	adjustUpLowElem();
	parts_handleresize_area.addEventListener("ihcp-hr-start", function(event) {
		/* Display a transparent element on the iframe to enable smooth dragging */
		$('#progRestrict, #viewRestrict, #timelineRestrict').addClass('divide_dragging');
	});	
	parts_handleresize_area.addEventListener("ihcp-hr-moving", function(event) {
		adjustUpLowElem();
	});
	parts_handleresize_area.addEventListener("ihcp-hr-moveEnd", function(event) {
		/* Restore transparent element */
		$('#progRestrict, #viewRestrict, #timelineRestrict').removeClass('divide_dragging');
		adjustUpLowElem();
		/* Initialize the arrow position retained when the detail screen is displayed. */
		vrtcl_act_arrowPos_prcnt = '';
	})
	parts_handleresize_area.addEventListener("ihcp-hr-leaveEdge", function(event) {
		if (event.detail.which === topEdge) {
			touch_firstEdge(HANDLERESIZE_LEAVE);
		}
	});
	parts_handleresize_area.addEventListener("ihcp-hr-reachEdge", function(event) {
		if (event.detail.isFirstEdge) {
			touch_firstEdge(HANDLERESIZE_REACH);
		}
	});
}

/*
 =========================================================================
 @function name    : touch_firstEdge
 @argument[reachLeave] : Reach or Leave (reach : HANDLERESIZE_REACH)
 @description      : Reach or Leave the handleResize.
 @return           : none
 =========================================================================
*/
var HANDLERESIZE_LEAVE = 0;
var HANDLERESIZE_REACH = 1;
function touch_firstEdge(reachLeave) {
	var vtclViewChk = g_tlScroll_direction == TL_SCRL_VRTCL;
	if(reachLeave == HANDLERESIZE_REACH) {
		parts_handleresize_area.refresh({firstAreaSize: 0});
		$('.parts-upper, #parts-handleresize').addClass('upperEdge_reach');
	}
	else {
		$('.parts-upper, #parts-handleresize').removeClass('upperEdge_reach');
	}
	if(document.getElementById('upperDisp_4d').classList.contains('upperDisp_active') == true) {
		if(!vtclViewChk) {
			if(!parts_upper.classList.contains('upperEdge_reach')) {
				addframe4dGraph()
			}
			else {
				remove4dGraph();
			}
		}
	}
}

/*
 =========================================================================
 @function name  : getFavoritHistry
 @argument[]     : 
 @description    : 
 @return         : g_progFavorite_command,g_latest_command
 =========================================================================
*/
function getFavoriteHistry(){
	var cnt;
	var commndPush = function(target, chkVal) {
		if(target == 'favorite') {
			if(iconTbl[chkVal] != undefined) {
				g_progFavorite_command.push(chkVal);
			}
			else {
				var noChk = get_iconTbl_iconNumIndex(chkVal);
				if(noChk != '') g_progFavorite_command.push(noChk);
			}
		}
		else {
			if(String(adin_boot_chk.hide_list).indexOf(chkVal) == -1) {
				if(iconTbl[chkVal] != undefined) {
					g_latest_command.push(chkVal);
				}
				else if(chkVal.indexOf('_fav') != -1 || arcMotionTbl[chkVal]) {
					g_latest_command.push(chkVal);
				}
				else {
					var noChk = get_iconTbl_iconNumIndex(chkVal);
					if(noChk != '') g_latest_command.push(noChk);
				}
			}
		}
	};
	for(cnt = 0; cnt < 5; cnt++) {
		commndPush('favorite', g_XMLVal[cnt]);
	}
	for(cnt = 5; cnt < 15; cnt++) {
		commndPush('history', g_XMLVal[cnt]);
	}
}

/*
 =========================================================================
 @function name  : favoriteTab_dispOnOff
 @argument[]     : 
 @description    : 
 @return         : g_progFavorite_command,g_latest_command
 =========================================================================
*/
function favoriteTab_dispOnOff(){
	var cnt;
	var commndPush = function(chkVal) {
		if(String(adin_boot_chk.hide_list).indexOf(chkVal) == -1) {
			if(iconTbl[chkVal] != undefined) {
				g_favoriteList[cnt].disp = 'ON';
			}
			else {
				g_favoriteList[cnt].disp = 'OFF';
				g_favoNoDispList.push(cnt);
			}
		}
		else {
			g_favoriteList[cnt].disp = 'OFF';
			g_favoNoDispList.push(cnt);
		}
	};
	for(cnt = 0; cnt < FAVORITE_CMD_MAX; cnt++) {
		if(!g_favoriteList[cnt]) break;
		commndPush(g_favoriteList[cnt].iconName);
	}
}

/*
 =========================================================================
 @function name      : programingArea_addIcon
 @argument[baseId]   : 
 @argument[addTabId] : 
 @description        : "Programming" tab command icon add.
 @return             : none
 =========================================================================
*/
function programingArea_addIcon(baseId, addTabId) {
	var createIconId = (addTabId == 'cat_all') ? baseId + '_all' :
						(addTabId == 'cat_his') ? baseId + '_history' :
						baseId;
	var splitId = addTabId.split("/");
	var addIcon = $('<div>', {class: 'teachIcon'});

	var baseElm = document.getElementById(splitId[0]);
	if(splitId.length > 1) {
		if(splitId[0] === 'cat_vision') {
			if(splitId.indexOf('subcat_1') != -1) {
				$('#vis_subcat_1').append(addIcon[0]);
			}
			else if(splitId.indexOf('subcat_2') != -1) {
				$('#vis_subcat_2').append(addIcon[0]);
			}
			else {}
		}
	}
	else {
		var addChk = $(baseElm).find('.prg_subcat');
		if(addChk.length == 0) {
			baseElm.appendChild(addIcon[0]);
		}
		else {
			$(addIcon[0]).insertBefore(addChk[0]);
		}
	}
	/*iconTbl is exist icon table , arcMotionTable is arc motion icon table. */
	var targetTbl = arcMotionTbl[baseId] ? arcMotionTbl : iconTbl;
	if(targetTbl[baseId] != undefined) {
		var addIconElm = g_def_iconElm.cloneNode(true);
		addIconElm.id = createIconId;
		addIconElm.classList.add(targetTbl[baseId].iconType);
		$(addIconElm.firstElementChild).css('background-image', 'url(' + targetTbl[baseId].imgPath + ')');
		$(addIcon[0]).append(addIconElm);

		/* Added name span */
		var addContents = '<span class=iconName>' + targetTbl[baseId].dispName + '</span>';
		$(addIcon[0]).append(addContents);
	}
}

/*
 =========================================================================
 @function name  : timeLine_setting
 @argument       : none
 @description    : Timeline and programming area settings
 @return         : none
 =========================================================================
*/
function timeLine_setting() {
	if(!g_RO_flg && g_TPenbl_flg) {
		/* Sortable setting */
		sortable_setting();
	}
	
	TLdrawAreaBufferResize();
	
	/* Programming area Tab selection display processing */
	registTab_tabSelect();
	/* Programming area icon type tab selection display processing */
	registTab_iconTabSelect();
	
	exe_column_setting($('#exe_column')[0]);
}

/*
 =========================================================================
 @function name  : sortable_setting
 @argument       : none
 @description    : Timeline and programming area sortable settings
 @return         : none
 =========================================================================
*/
var sortableTimeLine = '';
var sortableReadOnly_prgArea = "";
var sortableReadOnly_timeline  = "";
var sortableReadOnly_detailArea = "";
var sortablePrograming = [];
var g_moveTrans_elm = '';
function sortable_setting() {
	/* Discard previous sortable setting */
	sortable_destroy();
	if(g_RO_flg || !g_TPenbl_flg) {
		sortableReadOnly();
		return;
	}
	
	//Moving to the programming area in the timeline area is prohibited
	var dragLock = g_tl_dragLock ?
					'#TimeLineArea .posTeach, #TimeLineArea .normal' : '.if_else, .if_end, .for_end, .bkt_end, .wt_nodrag';
	//Sorting on the timeline is possible
	sortableTimeLine = new Sortable.create(TimeLineArea, {
		group: 'TimeLine',
		animation: 300,
		draggable: "#TimeLineArea .posTeach, #TimeLineArea .normal",
		multiDrag: false,
		selectedClass: "multiselected",
		delay: 10,
		touchStartThreshold: 15,
//		swapThreshold  : 0.50,
		filter: dragLock,
		// Update complete
		onSort: function(event) {
			if(dropAreaChk(event)) {
				return false;
			}
			tl_onSort_func(event);
			if(g_TL_selectModeFlg) {
				change_TLselectMode(SELECT_MODE_NONE);
			}
		},
		onUnchoose: function(event) {
			g_moveTrans_elm = event.item;
			iconRemove_drop(event);
			document.removeEventListener(moveEventTouch, iconRemove_move, false);
			document.removeEventListener(moveEventMouse, iconRemove_move, false);
			document.removeEventListener(moveEventTouch, timeline_multiTouch_event, false);
			g_tlmove_ghost = '';
			$(parts_timeline).removeClass('tlScrollFix');
			
			/* Restore transparent element */
			$(parts_block).removeClass('prog_dragging');
			g_TL_progInfo.sort_dragging = false;
			if(g_moveTrans_elm !== '') {
				/* Display nest line. */
				nestCurveHidden('', event.items.length > 0 ? 250 : '');
				g_moveTrans_elm = '';
			}
		},
		onChoose: function(event) {
		},
		onStart: function(event) {
			/* Hide the nest line. */
			nestCurveHidden('hidden');
			/* Hold drag element */
			var dragElm = Array.from(g_TL_elm.children).find(function(data) {
				return data.classList.contains('sortable-drag');
			});
			if(dragElm) {
				if(g_TL_selectModeFlg && document.getElementById('iconSelectMenu').classList.contains('menu_active')) {
					dragElm.remove();
				}
				else {
					g_tlmove_ghost = dragElm;
					$(g_tlmove_ghost).css({'opacity':1}).removeClass('tlBottomOver');
					$(g_tlmove_ghost).find('.stretchBackground.cond_open').removeClass('dispnest_1 dispnest_2 dispnest_3 dispnest_4 dispnest_5 dispnest_6 ' +
																						'dispnest_7 dispnest_8 dispnest_9 dispnest_10 dispnest_11 dispnest_12 ' +
																						'dispnest_13 dispnest_14 dispnest_15 dispnest_16 dispnest_17 dispnest_18 dispnest_19 dispnest_20')
																		  .addClass('dispnest_1');
					$(g_tlmove_ghost).find('.commentText').removeClass('commentOmit').css('width', '');
				}
			}
		},
		onClone: function(event) {
			$(parts_block).addClass('prog_dragging');
			g_TL_progInfo.sort_dragging = true;
			document.addEventListener(moveEventTouch, iconRemove_move, false);
			document.addEventListener(moveEventMouse, iconRemove_move, false);
			document.addEventListener(moveEventTouch, timeline_multiTouch_event, false);
		},
		onMove: function(event) {
		},
		onEnd: function(event) {
			if(g_TL_selectModeFlg) {
				/* multi select operation is CUT and sort position is the same */
				if((multiSelect_opeType === OPETYPE_CUT) && (event.newDraggableIndex === event.oldDraggableIndex)) {
					change_TLselectMode(SELECT_MODE_NONE);
				}
			}
		},
		onSelect: function(event) {
		},
		onDeselect: function(event) {
		},
		onAdd: function(event) {
		},
		onUpdate: function(event) {
		},
		onRemove: function(event) {
		},
		onFilter: function(event) {
			if(event.item.classList.contains('wt_nodrag') && !event.item.classList.contains('include_wbt') &&
			   stretch_idStrChk(STRETCH_ID_CHK_N_LEAD_N_EQ, event.item.id)) {
				scrlWrpElm.addEventListener('click', onFilter_endEvent, false);
				scrlWrpElm.addEventListener('pointerleave', onFilter_endEvent, false);
			}
		},
		onChange: function(event) {
		},
	});

	var dragCancelItem = ""; // subject to restrictions
	if (g_setWristButton == RI_NO_SETTING) {
		dragCancelItem += '#-INST_WRIST_BUTTON_TEACH, #-INST_WRIST_BUTTON_TEACH_all, #-INST_WRIST_BUTTON_TEACH_history';
	}
    if (getMotionGroup() != 1) {
    var dropRestId = getDropRestIconList();
    dragCancelItem += "#" + dropRestId.join(", #");
    for (var i = 0; i < ICON_AREA_KEY.length; i++){
      dragCancelItem += ", #" + dropRestId.join(ICON_AREA_KEY[i] + ", #") + ICON_AREA_KEY[i];
    }
    if (getMotionGroup() == 0) {
      dragCancelItem += ", .teachIcon .posTeach";
	  };
	}

	//The programming area (icon placement area) can be dragged to the timeline and movement within the programming area is prohibited
	var tmpStr = document.getElementsByClassName("teachIcon");
	for(var cnt = 0; cnt < tmpStr.length; cnt++) {
		sortablePrograming[cnt] = new Sortable.create(tmpStr[cnt], {
			group: {
				name: 'TimeLine',
				pull: 'clone',
				put : false,
			},
			animation: 200,
//			delay: 400,
			touchStartThreshold: 15,
			draggable: ".teachIcon .posTeach, .teachIcon .normal",
			sort: false,
			filter: dragCancelItem,
			onStart: function (event) {
				/* Hide the nest line. */
				nestCurveHidden('hidden');
				// Holds drag source ID name
				touchId = event.item.id;
				/* Hold drag element */
				var dragElm = Array.from(event.from.children).find(function(data) {
					return data.classList.contains('sortable-drag');
				});
				if(dragElm) {
					g_tlmove_ghost = dragElm;
					$(g_tlmove_ghost).css({'opacity':1, 'height':'54px', 'width':'54px'});
					$(g_tlmove_ghost).find('.iconBackground').css({'background-color':'rgb(60, 60, 60)',
																   'background-size':'52.8px',
																   'height':'66px',
																   'width':'66px'});
				}
			},
			onEnd: function(event) {
				//Initialization
				touchId = '';
			},
			onChoose: function (event) {
				$(g_TL_elm).css({'overflow-y':'hidden'});
			},
			onUnchoose: function(event) {
				if(g_TL_selectModeFlg) {
					iconRemove_drop(event);
					document.removeEventListener(moveEventTouch, iconRemove_move, false);
					document.removeEventListener(moveEventMouse, iconRemove_move, false);
					document.removeEventListener(moveEventTouch, progArea_multiTouch_event, false);
				}
				else {
					document.removeEventListener(moveEventTouch, progArea_move, false);
					document.removeEventListener(moveEventMouse, progArea_move, false);
					document.removeEventListener(moveEventTouch, progArea_multiTouch_event, false);
				}
				g_tlmove_ghost = '';

				cancel_autoScroll('all');

				$(g_TL_elm).css({'overflow-y':''});
				/* Display nest line. */
				nestCurveHidden('');
				var progiconScrlTrack = document.getElementById('progicon_scrl_track');
				progiconScrlTrack.style.height =  'calc(100% - ' + PROG_AREA_TAB_HEIGHT + 'px)';
				progiconScrlTrack.style.top = PROG_AREA_TAB_HEIGHT + 'px';
				$(parts_block).removeClass('prog_adding');
				if (document.getElementById('progPopMenu').classList.contains('menu_active')) {
					progPopMenu_dispUpdate(PROG_SEL_MENU_ICON_UD_01, event.item);
				}
			},
			onSort: function(event) {
			},
			onClone: function(event) {
				if(document.getElementById('progPopMenu').classList.contains('menu_active')) {
					progPopMenu_dispUpdate(PROG_SEL_MENU_ICON_UD_00);
				}
				$(parts_block).addClass('prog_adding');
				var prgiconAreaMargin = (parts_block.classList.contains('vtclscrlView')) ? PROG_AREA_TAB_HEIGHT : parts_timeline.offsetHeight + PROG_AREA_TAB_HEIGHT;
				var progiconScrlTrack = document.getElementById('progicon_scrl_track');
				progiconScrlTrack.style.height =  'calc(100% - ' + prgiconAreaMargin + 'px)';
				progiconScrlTrack.style.top = prgiconAreaMargin + 'px';
				if(g_TL_selectModeFlg) {
					document.addEventListener(moveEventTouch, iconRemove_move, false);
					document.addEventListener(moveEventMouse, iconRemove_move, false);
					document.addEventListener(moveEventTouch, progArea_multiTouch_event, false);
				}
				else {
					document.addEventListener(moveEventTouch, progArea_move, false);
					document.addEventListener(moveEventMouse, progArea_move, false);
					document.addEventListener(moveEventTouch, progArea_multiTouch_event, false);
				}
			},
			onMove: function(event) {
			},
			onAdd: function(event) {
			},
			onUpdate: function(event) {
			},
			onRemove: function(event) {
			},
			onFilter: function (event) {
				var alartPopStr = ((isDropRestIcon(event.item.id)) ?
										langResource.ihmieditor_pop_can_not_use_cmd_c :
										langResource.ihmieditor_pop_can_not_teach_move_c);
				if (event.item.id.indexOf("-INST_WRIST_BUTTON_TEACH") !== -1) {
					toast.show(langResource.ihmieditor_pop_wristbuttonteach_set_c);
					return false;
				}
				display_popupmsg_alert(DEF_POPUP_SCRN_TYP.ALERT, alartPopStr, DISP_CLOSE_BTN);
				event.preventDefault();
				return false;
			},
			onChange: function(event) {
			},
		});
	}

	if(g_program_data[activeTarget] && g_program_data[activeTarget].remark) {
		if(!sortableReadOnly_detailArea) {
		    $('#detail_act').addClass('detail_noEdit');
			set_sortableReadOnly_detailArea();
		}
	}
}

/*
=========================================================================
@function name   : dropAreaChk
@argument[event] : onSort event.
@description     : Get the position (line number) of the drop in the timeline.
@return          : Range check result. (true: Out of range / false: in range)
=========================================================================
*/
function dropAreaChk(event) {
	var ret = false;
	if(document.getElementById(event.item.id)) {
		/* Drag end outside the timeline area */
		if(!tlAreaChk(event.originalEvent)) {
			if(event.from.classList.contains('TimeLineArea')) {
				if(g_tlScroll_direction == TL_SCRL_VRTCL) {
					/* Redraw to restore. */
					tl_dispRange();
				}
			}
			/* Dragging from a source other than the timeline */
			else {
				event.item.parentElement.removeChild(event.item);
			}
			ret = true;
		}
	}
	else {
		ret = true;
	}
	return ret;
}
/*
=========================================================================
@function name   : tlAreaChk
@argument[event] : 
@description     : Determine if the specified position is within the area.
@return          : Area check result. (true: In area / false: Out of area)
=========================================================================
*/
function tlAreaChk(event) {
	var areaOffset = scrlWrpElm.getBoundingClientRect();
	var opeEvt = (event.changedTouches != undefined) ? event.changedTouches[0] : event;

	if(activeTiming_chk.flg) {
		return (activeTiming_chk.offsetParam.top <= opeEvt.pageY && activeTiming_chk.offsetParam.bottom >= opeEvt.pageY);
	}
	else {
		return (areaOffset.top <= opeEvt.pageY && areaOffset.bottom >= opeEvt.pageY);
	}
}

/*
=========================================================================
@function name  : getDropLine
@argument       : Drop element
@description    : Get the position (line number) of the drop in the timeline.
@return         : Line number
=========================================================================
*/
function getDropLine(dropElm){
  var tlElm = dropElm.parentElement;
  var dropLineNum = 1;

  if(Array.prototype.indexOf.call(tlElm.children, dropElm) != -1) {
    /* Get the previous element of the dropped element. */
    var prevElm = dropElm.previousElementSibling;
    if(prevElm.id != 'TL_spacer') {
      var prevId = (prevElm.classList.contains('stretch_close')) ?
                      get_stretch_pairId(prevElm.id, REQ_ID_KIND_END, null) : prevElm.id;
      /* Get the line number of the dropped element from the array number of the previous element. */
      dropLineNum = g_program_data[prevId].array_num + 2;
    }
  }
  return dropLineNum;
}

/*
 =========================================================================
 @function name  : sortable_destroy
 @argument       : none
 @description    : Timeline and programming area sortable object destory.
 @return         : none
 =========================================================================
*/
function sortable_destroy() {
	/* Delete ghosts in drag if any exist. */
	$('.sortable-drag').remove();
	nestCurveHidden('');
	g_tlmove_ghost = '', g_delReady_flg = '';

	/* Delete classes added by Sortable. */
	$('.normal, .posTeach').removeClass('sortable-chosen sortable-ghost');
	$('#progRestrict, #viewRestrict, #overlay_viewchange, #overlay_undoredo').removeClass('dragging');

	if(sortableTimeLine !== '') {
		sortableTimeLine.destroy();
		sortableTimeLine = '';
	}
	
	if(sortablePrograming.length > 0) {
		for(var cnt in sortablePrograming) {
			sortablePrograming[cnt].destroy();
		}
		sortablePrograming = [];
	}
	
	if(sortableReadOnly_prgArea !== '') {
		sortableReadOnly_prgArea.destroy();
		sortableReadOnly_prgArea = "";
	}
	if(sortableReadOnly_timeline !== '') {
		sortableReadOnly_timeline.destroy();
		sortableReadOnly_timeline = "";
	}
	if(sortableReadOnly_detailArea !== '') {
		sortableReadOnly_detailArea.destroy();
		sortableReadOnly_detailArea = "";
	}
}

/*
 =========================================================================
 @function name  : multiTouch_timeline
 @argument       : none
 @description    : Timeline area sort at multi touch.
 @return         : none
 =========================================================================
*/
function timeline_multiTouch_event(event) {
	if(event.touches.length > 1) cancel_timeline_sortable();
}

/*
 =========================================================================
 @function name  : progArea_multiTouch_event
 @argument       : none
 @description    : progArea area sort at multi touch.
 @return         : none
 =========================================================================
*/
function progArea_multiTouch_event(event) {
	if(event.touches.length > 1) cancel_progArea_sortable();
}

/*
 =========================================================================
 @function name  : cancel_timeline_sortable
 @argument       : none
 @description    : Cancel Timeline area sort.
 @return         : none
 =========================================================================
*/
function cancel_timeline_sortable() {
	//sortable onUnchoose process.
	document.removeEventListener(moveEventTouch, iconRemove_move, false);
	document.removeEventListener(moveEventMouse, iconRemove_move, false);
	document.removeEventListener(moveEventTouch, cancel_timeline_sortable, false);
	$(parts_timeline).removeClass('tlScrollFix');
	$(parts_block).removeClass('prog_dragging');
	nestCurveHidden('');
	g_TL_progInfo.sort_dragging = false;
	//Cancel sort process & redraw timeline.
	if(g_TL_selectModeFlg) change_TLselectMode(SELECT_MODE_NONE);
	sortable_setting();
	tl_dispRange();
	timeLine_Event();
}

/*
 =========================================================================
 @function name  : cancel_progArea_sortable
 @argument       : none
 @description    : Cancel programming area sort.
 @return         : none
 =========================================================================
*/
function cancel_progArea_sortable() {
	//sortable onUnchoose process.
	document.removeEventListener(moveEventTouch, progArea_move, false);
	document.removeEventListener(moveEventMouse, progArea_move, false);
	document.removeEventListener(moveEventTouch, cancel_progArea_sortable, false);
	nestCurveHidden('');
	var progiconScrlTrack = document.getElementById('progicon_scrl_track');
	progiconScrlTrack.style.height =  'calc(100% - ' + PROG_AREA_TAB_HEIGHT + 'px)';
	progiconScrlTrack.style.top = PROG_AREA_TAB_HEIGHT + 'px';
	$(parts_block).removeClass('prog_adding');
	//sortable onEnd process.
	touchId = '';
	//Cancel sort process & redraw timeline.
	if(g_TL_selectModeFlg) change_TLselectMode(SELECT_MODE_NONE);
	sortable_setting();
	tl_dispRange();
	programingArea_Event();
}
/*
 =========================================================================
 @function name  : sortable_disable
 @argument[val]  : true:sortable disable / false:sortable enable
 @description    : Timeline and programming area sortable object disable/enable change.
 @return         : none
 =========================================================================
*/
function sortable_disable(val) {
	if(sortableTimeLine !== '') {
		sortableTimeLine.option('disabled', val);
	}
	
	if(sortablePrograming.length > 0) {
		for(var cnt in sortablePrograming) {
			sortablePrograming[cnt].option('disabled', val);
		}
	}
}

/*
 =========================================================================
 @function name : progArea_move
 @argument[]    : none
 @description   : programingArea icon dragMove event process
 @return        : none
 =========================================================================
*/
function progArea_move(event) {
	event.preventDefault();

	if(g_tlmove_ghost != '') {
		/* auto scroll check */
		dragging_tlScrollChk(null, g_tlmove_ghost.getBoundingClientRect());
	}

	if(document.getElementById('progPopMenu').classList.contains('menu_active')) {
		progPopMenu_dispUpdate(PROG_SEL_MENU_ICON_UD_00);
	}
}

/*
 =========================================================================
 @function name  : onFilter_endEvent
 @argument[evt]  : 
 @description    : 
 @return         : none
 =========================================================================
*/
function onFilter_endEvent(evt) {
	var targetElm = search_eventTarget(evt.target, EVT_TARGET_KIND_ELM);
	var disp = toastStr_notEdit();
	toast.show(disp);
	evt.preventDefault();
	scrlWrpElm.removeEventListener('click', onFilter_endEvent, false);
	scrlWrpElm.removeEventListener('pointerleave', onFilter_endEvent, false);
}
/*
 =========================================================================
 @function name  : readOnly_onFilter_endEvent
 @argument[evt]  : 
 @description    : 
 @return         : none
 =========================================================================
*/
function readOnly_onFilter_endEvent(evt) {
	var targetElm = search_eventTarget(evt.target, EVT_TARGET_KIND_ELM);
	if(stretch_idStrChk(STRETCH_ID_CHK_ALL, targetElm.id)) {
		/*toast is not displayed when bracketIcon*/
	}else{
		var disp = toastStr_notEdit(activeTarget);
		toast.show(disp);
	}
	evt.preventDefault();
	scrlWrpElm.removeEventListener('click', readOnly_onFilter_endEvent, false);
	scrlWrpElm.removeEventListener('pointerleave', readOnly_onFilter_endEvent, false);
	$(".prgicon_area")[0].removeEventListener('click', readOnly_onFilter_endEvent, false);
	$(".prgicon_area")[0].removeEventListener('pointerleave', readOnly_onFilter_endEvent, false);
	$(".restrictContainer")[0].removeEventListener('click', readOnly_onFilter_endEvent, false);
}

/*
 =========================================================================
 @function name : sortableReadOnly
 @argument[]    : none
 @description   : 
 @return[]      : none
 =========================================================================
*/
function sortableReadOnly() {
	var prgArea = $(".prgicon_area")[0];
	sortableReadOnly_prgArea = new Sortable.create(prgArea, {
		draggable: ".prgicon_area .prg_icon .teachIcon .normal, .prgicon_area .prg_icon .teachIcon .posTeach",
		multiDrag: false,
		selectedClass: "multiselected",
		filter: ".normal, .posTeach",
		onFilter: function() {
			prgArea.addEventListener('click', readOnly_onFilter_endEvent, false);
			prgArea.addEventListener('pointerleave', readOnly_onFilter_endEvent, false);
		},
	});
	if(!sortableReadOnly_detailArea) {
		set_sortableReadOnly_detailArea();
	}
	sortableReadOnly_timeline = new Sortable.create(scrlWrpElm, {
		draggable: ".TimeLineArea .normal, .TimeLineArea .posTeach",
		multiDrag: false,
		selectedClass: "multiselected",
		filter: ".normal, .posTeach",
		onFilter: function() {
			if(!g_TPenbl_flg ||
			   (g_RO_flg && !g_tl_dragLock)) {
				scrlWrpElm.addEventListener('click', readOnly_onFilter_endEvent, false);
				scrlWrpElm.addEventListener('pointerleave', readOnly_onFilter_endEvent, false);
			}
		},
	});
}

function set_sortableReadOnly_detailArea() {
	var detailArea = $(".restrictContainer")[0];
	sortableReadOnly_detailArea = new Sortable.create(detailArea, {
		draggable: ".restrictContainer",
		multiDrag: false,
		selectedClass: "multiselected",
		filter: "#detailRestrict",
		onFilter: function() {
			detailArea.addEventListener('click', readOnly_onFilter_endEvent, false);
		},
	});
}

/*
 =========================================================================
 @function name     : tl_onSort_func
 @argument[event]   : 
 @description       : Timeline  onSort processing
 @return            : none
 =========================================================================
*/
function tl_onSort_func(event) {
	dispOnWaiting(0);
	var prgName = touchId;
	if(prgName != "") {
		/* Cut out the name of the instruction. */
		var rexp;
		for(var i in ICON_AREA_KEY) {
			if(prgName.endsWith(ICON_AREA_KEY[i])) {
				rexp = new RegExp(ICON_AREA_KEY[i]+"$");
				prgName = prgName.split(rexp)[0];
			}
		}
		for(var loop = 0; loop < g_favoriteList.length; loop++) {
			if(prgName === g_favoriteList[loop].indexId) {
				prgName = g_favoriteList[loop].iconName;
				/* drop icon for favorite tab. */
				g_favoriteFlg.favoDrop = favoParamSaveCheck(prgName);
				if(g_favoriteFlg.favoDrop) {
					g_favoTargetData.listIndex = loop;
					g_favoTargetData.dataId = g_favoriteList[loop].indexId;
				}
				break;
			}
		}
	}
	var tlOpe_flg = false;
	var scrlTargetId = '';
	var afterProcChk = false;
	/* The relevant Advanced Instruction exists. */
	if(typeof g_inst_obj[prgName] != "undefined") {
		afterProcChk = tl_onSort_adinst_func(event, prgName, (loop != undefined && loop != g_favoriteList.length) ? g_favoriteList[loop].indexId : null);
	}
	/* The added instruction is "path teach". */
	if(prgName === "bktlead-inst_path_start") {
		tl_onSort_add_instPath(event.item, (loop != undefined && loop != g_favoriteList.length) ? g_favoriteList[loop].indexId : prgName);
		afterProcChk = true;
	}
	/* The added instruction is "handle teach". */
	if (event.item.id.substr(0, "-INST_ARC_HANDLE_TEACH".length) === "-INST_ARC_HANDLE_TEACH" ||
		event.item.id.substr(0, "-INST_WRIST_BUTTON_TEACH".length) === "-INST_WRIST_BUTTON_TEACH") {
		afterProcChk = tl_onSort_btnTeaching(event);
	}

	if(!afterProcChk) {
		/* Obtains the element ID of the add position. */
		var refElmId = (!event.item.nextElementSibling && g_TL_progInfo.dispProg.length) ?	/* Check if the added position is the last. */
							g_TL_progInfo.dispProg[g_TL_progInfo.dispProg.length - 1] : event.item.previousElementSibling.id;
		if(refElmId == event.item.id) {
			dispOffWaiting();
			return false;
		}
		/* The previous element is a closed bracket instruction */
		if(stretch_idStrChk(STRETCH_ID_CHK_LEAD, refElmId) && g_program_data[refElmId].stretch.state == 'stretch_close') {
			/* Update to the ID of the END element. */
			refElmId = get_stretch_pairId(refElmId, REQ_ID_KIND_END, null);
		}
		/* Copy or Cut */
		if(event.item.id == 'sel_data') {
			var paste_index = get_pasteIndex(refElmId);
			/* Copy */
			if(multiSelect_opeType == OPETYPE_COPY) {
				tlOpe_flg = true;
				var lead_id_num = [];
				var base = [];
				$.extend(true, base, g_multiSelectArray);
				g_multiSelectArray = [];
				var sData = [];
				var newId = '';
				for(var cnt = 0; cnt < base.length; cnt++) {
					if(iconTbl[base[cnt].g_prog_data.baseId] != undefined) {
						if(stretch_idStrChk(STRETCH_ID_CHK_LEAD, base[cnt].g_prog_data.baseId)) {
							lead_id_num.push(iconTbl[base[cnt].g_prog_data.baseId].idCnt);
						}
						var data = {id:'', g_prog_data:''};
						/* Bracket end or if-else */
						if(stretch_idStrChk(STRETCH_ID_CHK_N_LEAD, base[cnt].g_prog_data.baseId)) {
							/* id generation */
							newId = base[cnt].g_prog_data.baseId + lead_id_num[lead_id_num.length - 1];
							if(iconTbl[base[cnt].g_prog_data.baseId].idCnt < lead_id_num[lead_id_num.length - 1]) {
								iconTbl[base[cnt].g_prog_data.baseId].idCnt = lead_id_num[lead_id_num.length - 1];
							}
							if(stretch_idStrChk(STRETCH_ID_CHK_END, base[cnt].g_prog_data.baseId)) lead_id_num.pop();
						}
						/* Bracket lead or not bracket */
						else {
							/* id generation */
							newId = base[cnt].g_prog_data.baseId + iconTbl[base[cnt].g_prog_data.baseId].idCnt;
							iconTbl[base[cnt].g_prog_data.baseId].idCnt = iconTbl[base[cnt].g_prog_data.baseId].idCnt + 1;
						}
						g_program_data[newId] = JSON.parse(JSON.stringify(base[cnt].g_prog_data));
						if(g_program_data[newId].baseId === 'label') {
							/* Initialize the parameters because the copy fails if it is left as it is. */
							var cpLblNum = g_program_data[newId].param.replace(/[^0-9]/g, '');
							cpLblNum = cpLblNum != '0' ? '*' + cpLblNum : cpLblNum;
							g_program_data[newId].param = ORDER_LABEL + '[' + cpLblNum + ']';
						}
						data.id = newId;
						data.g_prog_data = JSON.parse(JSON.stringify(g_program_data[newId]));
						data.g_prog_data.select = '';
						for(var nestcnt = 0; nestcnt < data.g_prog_data.nest.layer.length; nestcnt++) {
							data.g_prog_data.nest.layer[nestcnt].color = '';
						}
						
						if(stretch_idStrChk(STRETCH_ID_CHK_LEAD, newId)) { sData.push(newId); }
						g_multiSelectArray.push(data);
					}
				}
				for(var dCnt = 0; dCnt < sData.length; dCnt++) {
					var idx = g_multiSelectArray.indexOf(g_multiSelectArray.find(function(data) {return data.id == sData[dCnt]}));
					for(var cnt = 0; cnt < g_multiSelectArray[idx].g_prog_data.stretch.idList.length; cnt++/*, idx++*/) {
						g_multiSelectArray[idx].g_prog_data.stretch.idList[cnt].id = g_multiSelectArray[idx + cnt].id;
					}
				}
				scrlTargetId = onSort_progInfo_update('copy', refElmId);
				event.item.remove();
				/* Nested update of timeline */
				timeLine_nestUpdate();
				/* g_program_data[]Update array number */
				g_program_arrayNumSave();
				for(var key in g_multiSelectArray) {
					clear_selectInfo(g_multiSelectArray[key].id);
				}
				onSortSave_copy(paste_index, base);
			}
			/* Cut */
			else {
				event.item.remove();
				/* Needs to be updated by sorting. */
				if(progSortChk(paste_index, g_multiSelectArray[0].id)) {
					tlOpe_flg = true;
					var before_index = g_multiSelectArray[0].g_prog_data.array_num + 1;
					scrlTargetId = onSort_progInfo_update('cut', refElmId);
					/* Nested update of timeline */
					timeLine_nestUpdate();
					/* g_program_data[]Update array number */
					g_program_arrayNumSave();
					onSortSave_cut(before_index, paste_index);
				}
				/* No update is required. */
				else {
					clear_selectData();
					tl_dispRange();
				}
			}
			/* Scale update */
			draw_TLscale(false);
		}
		/* Add */
		else if(event.from.id != 'TimeLineArea') {
			/* Timeline icon drop processing */
			tlOpe_flg = programIcon_drop(event.item);
			if(tlOpe_flg) {
				var addElm = event.item;
				scrlTargetId = onSort_progInfo_update('add', refElmId, addElm.id);
				/* Nested update of timeline */
				timeLine_nestUpdate();
				/* g_program_data[]Update array number */
				g_program_arrayNumSave();
				onSortSave_add(addElm, before_index);
				if (g_btnTeaching_list.weldteach.existsTimeline == true && g_program_data[addElm.id].baseId === '-INST_ARC_HANDLE_TEACH') {
					toast.show(langResource.ihmieditor_pop_weldingteach_undoredo_init_c);
				} else if (g_btnTeaching_list.wristteach.existsTimeline == true && g_program_data[addElm.id].baseId === '-INST_WRIST_BUTTON_TEACH') {
					toast.show(langResource.ihmieditor_pop_start_wristteach_c);
				}
				/* Check to make it active when you add it. */
				addingActiveCheck(addElm.id);
				/* Scale update */
				draw_TLscale(false);
			}
		}
		/* Sort */
		else {
			var sortElm = event.item;
			var paste_index = get_pasteIndex(refElmId);
			/* Needs to be updated by sorting. */
			if(progSortChk(paste_index, sortElm.id)) {
				tlOpe_flg = true;
				var before_index = g_program_data[sortElm.id].array_num + 1;
				scrlTargetId = onSort_progInfo_update('sort', refElmId, sortElm.id);
				/* Nested update of timeline */
				timeLine_nestUpdate();
				/* g_program_data[]Update array number */
				g_program_arrayNumSave();
				onSortSave_sort(sortElm.id, before_index, paste_index);
				/* Scale update */
				draw_TLscale(false);
			}
			/* No update is required. */
			else {
				/* In the case of bracket lead instruction, redraw to restore the order. */
				if(stretch_idStrChk(STRETCH_ID_CHK_LEAD, sortElm.id)) tl_dispRange();
			}
		}
		tl_adjust_dispRange();
		/* Timeline scroll processing */
		if(scrlTargetId != '') iconDrop_TLScroll(scrlTargetId);
	}
	
	if(!tlOpe_flg) dispOffWaiting();
}

/*
 =========================================================================
 @function name     : tl_onSort_adinst_func
 @argument[event]   : 
 @argument[prgName] : 
 @description       : 
 @return            : 
 =========================================================================
*/
function tl_onSort_adinst_func(event, prgName, favId) {
	if(typeof g_inst_obj[prgName].funcList != "undefined") {
		/* notice event */
		if(g_inst_obj[prgName].funcList.m_dropfunc != null) {
			var noticeObject = {
				line: getTlLineConvertPrgLine(event.item.previousElementSibling.id),
				event: event
			};
			g_inst_obj[prgName].funcList.m_dropfunc(noticeObject);
			event.item.remove();
			latestCommand_check(favId == null ? prgName : favId);
			return true;
		}
	}
	return false;
}

/*
 =========================================================================
 @function name     : tl_onSort_add_instPath
 @argument[elm]     : Sorted element
 @argument[prgName] : 
 @description       : 
 @return            : none
 =========================================================================
*/
function tl_onSort_add_instPath(elm, prgName) {
	if(g_TL_progInfo.saveProg.length + TEDT_ADDLINE_DEFAULT > MAX_LINE_COUNT) {
		/* Pop-up display due to excessive number of lines. */
		popup_lineCountMax();
	}
	else {
		var MOVESCREENPATH = "/frh/inst/path_teach/";
		var fileName = "path_teachwizard.stm";
		var screenPath = MOVESCREENPATH + fileName;
		var customizeObj = {};
		var closeCallback = function(editProg) {
			if(editProg == current_prog_name) {
				create_screen_finish_flg = true;
				modifyProgReload(editProg, null);
			} else {
				if(g_editor_status.pathTeachInfo.clampErr != '') {
					display_popupmsg_alert(DEF_POPUP_SCRN_TYP.ALERT, g_editor_status.pathTeachInfo.clampErr, DISP_CLOSE_BTN);
					g_editor_status.pathTeachInfo.clampErr = '';
				}
			}
			g_editor_status.pathTeachInfo.wizDisp = false;
			g_editor_status.pathTeachInfo.targetProg = '';
		}
		customizeObj.appendCbArg = ""; //to wizardpage param
		customizeObj.popupPos = 1;
		g_editor_status.pathTeachInfo = {wizDisp : true, targetProg : current_prog_name, clampErr : ''};
		top.IHMIComponents.cf.appendWizardFrm(screenPath, closeCallback, window, customizeObj);
		/* Line number of the element one element before the dropped element. */
		var line_number = getDropLine(elm) - 1;
		top.rpcmc_setVar(top.SYSNAME_C, '$ted_tch.$prog_name', current_prog_name );
		top.rpcmc_setVar(top.SYSNAME_C, '$ted_tch.$line_num', line_number );
	}

	latestCommand_check(prgName);
	elm.remove();
}

/*
 =========================================================================
 @function name   : tl_onSort_btnTeaching
 @argument[event] : onSort event
 @description     : Check if the sorted instruction is Arc Handle Teach instruction.
 @return          : Check result. (true:The sorted instruction is Arc Handle Teach instruction.)
 =========================================================================
*/
function tl_onSort_btnTeaching(event) {
	if (g_btnTeaching_list.weldteach.existsTimeline == true && event.item.id.indexOf("-INST_ARC_HANDLE_TEACH") !== -1) {
		if(event.oldIndex == 0) {
			toast.show(langResource.ihmieditor_pop_already_weldteaching_c);
			event.item.remove();
		}
		else {
			var newIndex = event.item.previousElementSibling.id == 'TL_spacer' ?
							-1 : g_TL_progInfo.dispProg.indexOf(event.item.previousElementSibling.id) + 1;
			if(g_TL_progInfo.dispProg.indexOf(event.item.id) != newIndex) {
				toast.show(langResource.ihmieditor_pop_weldingteach_not_sortable_c);
				/* Redraw to restore. */
				tl_dispRange();
			}
		}
		return true;
	} else if (g_btnTeaching_list.wristteach.existsTimeline == true && event.item.id.indexOf("-INST_WRIST_BUTTON_TEACH") !== -1 && event.oldIndex == 0) {
		toast.show(langResource.ihmieditor_pop_already_wristteaching_c);
		event.item.remove();
		return true;
	}
	return false;
}

/*
 =========================================================================
 @function name      : addingActiveCheck
 @argument[addElmId] : 
 @description        : 
 @return             : none
 =========================================================================
*/
function addingActiveCheck(addElmId) {
	var progtabId = [
		'-INST_ARC_HANDLE_TEACH',
		'-INST_WRIST_BUTTON_TEACH'
	];

	if(progtabId.indexOf(g_program_data[addElmId].baseId) != -1) {
		icon_activeChk(addElmId);
	}
}

/*
 =========================================================================
 @function name    : get_pasteIndex
 @argument[chkElm] : 
 @description      : 
 @return           : none
 =========================================================================
*/
function get_pasteIndex(chkElmId) {
	var index = 0;
	if(chkElmId != 'TL_spacer') {
		var id = (stretch_idStrChk(STRETCH_ID_CHK_LEAD, chkElmId) && g_program_data[chkElmId].stretch.state == 'stretch_close') ?
					get_stretch_pairId(chkElmId, REQ_ID_KIND_END, null) : chkElmId;
		index = g_program_data[id].array_num + 1;
	}
	return index;
}

/*
 =========================================================================
 @function name    : progSortChk
 @argument[sortId] : 
 @description      : 
 @return           : result(true: Sorted/ false: Not sorted)
 =========================================================================
*/
function progSortChk(refLineNum, sortId) {
	var tmpSaveProg = g_TL_progInfo.saveProg.slice();
	var prevElmId = (refLineNum == 0) ? 'TL_spacer' : tmpSaveProg[refLineNum - 1];
	var sortInst = [];
	sortInst.push(sortId);
	if(g_multiSelectArray.length) {
		if(g_multiSelectArray.find(function(data) {return data.id == prevElmId})) return false;
		for(var cnt = 1; cnt < g_multiSelectArray.length; cnt++) {
			sortInst.push(g_multiSelectArray[cnt].id);
		}
	}
	else {
		if(stretch_idStrChk(STRETCH_ID_CHK_LEAD, sortId)) {
			if(g_program_data[sortId].stretch.state == 'stretch_open') {
				/* Dropped in brackets and not sorted. */
				if(g_program_data[sortId].stretch.idList.find(function(data) {return data.id == prevElmId;})) return false;
			}
			for(var cnt = 1; cnt < g_program_data[sortId].stretch.idList.length; cnt++) {
				sortInst.push(g_program_data[sortId].stretch.idList[cnt].id);
			}
		}
	}
	for(var sortCnt = sortInst.length - 1; sortCnt >= 0; sortCnt--) {
		tmpSaveProg.splice(tmpSaveProg.indexOf(sortInst[sortCnt]), 1);
		var sortIndex = (prevElmId == 'TL_spacer') ?
							0 : (stretch_idStrChk(STRETCH_ID_CHK_LEAD, prevElmId) && g_program_data[prevElmId].stretch.state == 'stretch_close') ?
									tmpSaveProg.indexOf(get_stretch_pairId(prevElmId, REQ_ID_KIND_END, null)) + 1 :
									tmpSaveProg.indexOf(prevElmId) + 1;
		tmpSaveProg.splice(sortIndex, 0, sortInst[sortCnt]);
	}
	return (tmpSaveProg.indexOf(sortId) != g_program_data[sortId].array_num) ? true : false;
}

/*
 =========================================================================
 @function name       : onSort_progInfo_update
 @argument[opetype]   : Operation type
 @argument[prevElmId] : Previous element ID
 @argument[opeId]     : ID of the operated element
 @description         : Update g_TL_progInfo.saveProg / dispProg
 @return              : Scroll target element ID
 =========================================================================
*/
function onSort_progInfo_update(opetype, prevElmId, opeId) {
	var scrlId = '';
	switch(opetype) {
		case 'add':
		case 'copy':
			var addInst = [];
			var addInst_disp = [];
			/* add */
			if(opetype === 'add') {
				addInst.push(opeId);
				if(stretch_idStrChk(STRETCH_ID_CHK_LEAD, opeId)) {
					for(var cnt = 1; cnt < g_program_data[opeId].stretch.idList.length; cnt++) {
						addInst.push(g_program_data[opeId].stretch.idList[cnt].id);
					}
				}
			}
			/* Copy */
			else {
				for(var cnt = 0; cnt < g_multiSelectArray.length; cnt++) {
					addInst.push(g_multiSelectArray[cnt].id);
				}
			}
			/* saveProg & dispProg update */
			addInst_disp = progInfo_update(prevElmId, addInst, false);
			if(addInst_disp.length) scrlId = addInst_disp[addInst_disp.length - 1];
			break;
		case 'sort':
		case 'cut':
			var sortInst = [];
			/* sort */
			if(opetype === 'sort') {
				sortInst.push(opeId);
				if(stretch_idStrChk(STRETCH_ID_CHK_LEAD, opeId)) {
					for(var cnt = 1; cnt < g_program_data[opeId].stretch.idList.length; cnt++) {
						sortInst.push(g_program_data[opeId].stretch.idList[cnt].id);
					}
				}
			}
			else {
				for(var cnt = 0; cnt < g_multiSelectArray.length; cnt++) {
					sortInst.push(g_multiSelectArray[cnt].id);
				}
			}
			/* saveProg & dispProg update */
			sort_dispInst = progInfo_update(prevElmId, sortInst, true);

			if(sort_dispInst.length) scrlId = sort_dispInst[sort_dispInst.length - 1];
			break;
		default:
			break;
	}

	return scrlId;
}

/*
 =========================================================================
 @function name          : onSortSave_sort
 @argument[sortElmId]    : Sorted element ID
 @argument[before_index] : Index before sorting
 @argument[paste_index]  : The index of the instruction that is the reference for pasting.
 @description            : The saving process when sort operation.
 @return                 : none
 =========================================================================
*/
function onSortSave_sort(sortElmId, before_index, paste_index) {
	position_record.array_add(position);
	positionregi_record.array_add(g_position_regi);
	
	save_id_array = [];
	save_id_array.push(sortElmId);
	var contents = [];
	contents.push(JSON.parse(JSON.stringify(g_program_data[sortElmId])));
	if (stretch_idStrChk(STRETCH_ID_CHK_LEAD, sortElmId)) {
		for(var cnt = 1; cnt < g_program_data[sortElmId].stretch.idList.length; cnt++) {
			save_id_array.push(g_program_data[sortElmId].stretch.idList[cnt].id);
			contents.push(JSON.parse(JSON.stringify(g_program_data[g_program_data[sortElmId].stretch.idList[cnt].id])));
		}
	}
	var record_data = {
		id: save_id_array.slice(),
		contents: contents,
		place1: before_index - 1,
		place2: g_program_data[sortElmId].array_num,
		type: OPERATION_SORT,
	}
	/* check notice event */
	chk_sort_notice_event(record_data);
	save_pasteLine(before_index, before_index + contents.length - 1, paste_index, 1, save_pasteLine_callback, save_id_array[0]);
	timeline_record.array_add(record_data);
	check_undoredo_active();
}

/*
 =========================================================================
 @function name          : onSortSave_cut
 @argument[event]        : onSort event
 @argument[before_index] : Index before sorting
 @argument[paste_index]  : The index of the instruction that is the reference for pasting.
 @description            : The saving process when cutting operation.
 @return                 : none
 =========================================================================
*/
function onSortSave_cut(before_index, paste_index) {
	position_record.array_add(position);
	positionregi_record.array_add(g_position_regi);
	
	var contents = [];
	save_id_array = [];
	var tmp = '';
	for(var cnt = 0; cnt < g_multiSelectArray.length; cnt++) {
		save_id_array.push(g_multiSelectArray[cnt].id);
		tmp = JSON.parse(JSON.stringify(g_program_data[g_multiSelectArray[cnt].id]));
		tmp.select = '';
		contents.push(tmp);
	}
	var tmpOldArray = before_index - 1;
	var tmpNewArray = g_program_data[g_multiSelectArray[0].id].array_num;
	var record_data = {
		id: save_id_array.slice(),
		contents: contents,
		place1: tmpOldArray,
		place2: tmpNewArray,
		type: OPERATION_SORT,
	}
	/* check notice event */
	chk_sort_notice_event(record_data);
	// save_multiline(IO_SUCCESS);
	save_pasteLine(before_index, before_index + contents.length - 1, paste_index, 1, save_pasteLine_callback, save_id_array[0]);
	
	timeline_record.array_add(record_data);
	check_undoredo_active();
}

/*
 =========================================================================
 @function name          : onSortSave_add
 @argument[addElm]       : Added element
 @argument[before_index] : Index before sorting
 @description            : The saving process when added from the programming area.
 @return                 : none
 =========================================================================
*/
function onSortSave_add(addElm, before_index) {
	save_id_array = [];
	var contents = [];
	
	if(addElm.id.match("bktlead")) set_bktend_param(get_stretch_pairId(addElm.id, REQ_ID_KIND_END, null));
	
	save_id_array.push(addElm.id);
	contents.push(g_program_data[addElm.id]);
	/* Bracket instruction */
	if (stretch_idStrChk(STRETCH_ID_CHK_LEAD, addElm.id)) {
		/* Sets information for other than lead instructions. */
		for (var cnt = 1; cnt < g_program_data[addElm.id].stretch.idList.length; cnt++) {
			save_id_array.push(g_program_data[addElm.id].stretch.idList[cnt].id);
			contents.push(g_program_data[g_program_data[addElm.id].stretch.idList[cnt].id]);
		}
	}
	var record_data = {
		id:save_id_array.slice(),
		contents: contents,
		place1: '',
		place2: g_program_data[addElm.id].array_num,
		type: OPERATION_ADD
	}
	timeline_record.array_add(record_data);
	check_undoredo_active();
	need_position_save_flg = true;
	adinInitFunc(addElm.id);

	/* Cursor position : End */
	if(g_columnRelationInfo.dispPosId == 'end') {
		onSortSave_endCursor_adjust();
	}

	dropSaveFlg = true;
	save_tporder(save_id_array[0], EDIT_PRG_OPT_INSERT_AFTER, save_tporder_callback, save_id_array.shift());
	
}

/*
 =========================================================================
 @function name        : onSortSave_copy
 @argument[pasteindex] : The index of the instruction that is the reference for pasting.
 @argument[base]       : Copy source information.
 @description          : The saving process when added from copy area.
 @return               : none
 =========================================================================
*/
function onSortSave_copy(paste_index, base) {
	save_id_array = [];
	var contents = [];
	for(var cnt = 0; cnt < g_multiSelectArray.length; cnt++) {
		save_id_array.push(g_multiSelectArray[cnt].id);
		contents.push(g_multiSelectArray[cnt].g_prog_data);
	}
	var record_data = {
		id: save_id_array.slice(),
		contents: contents,
		place1: g_program_data[save_id_array[0]].array_num,
		place2: g_program_data[save_id_array[save_id_array.length - 1]].array_num,
		base: base,
		type: OPERATION_PASTE
	}
	timeline_record.array_add(record_data);
	check_undoredo_active();
	chk_copy_notice_event(record_data);
	var startIndex = g_multiSelectArray[0].g_prog_data.array_num + 1;
	var endIndex = startIndex + save_id_array.length - 1;
	if(base.length > SAVE_SPLIT_REF_VAL_PASTELINE) {
		var map = new Map();
		for(var baseCnt = 0; baseCnt < base.length; baseCnt++) {
			map.set(baseCnt, base[baseCnt].id);
		}
		for(var getCnt = 0; getCnt < base.length; getCnt++) {
			var o = map.get(getCnt)
			if(o != null) splitSaveInfo.baseArray.push(o);
		}
	}

	/* Cursor position : End */
	if(g_columnRelationInfo.dispPosId == 'end') {
		onSortSave_endCursor_adjust();
	}

	save_pasteLine(startIndex, endIndex, paste_index, 0, save_pasteLine_callback, g_multiSelectArray[0].id);
	
	position_record.array_add(position);
	positionregi_record.array_add(g_position_regi);
}

/*
 =========================================================================
 @function name : onSortSave_endCursor_adjust
 @argument[]    : none
 @description   : Adjust cursor position
 @return        : none
 =========================================================================
*/
function onSortSave_endCursor_adjust() {
	var crsrPosId = get_array_num_to_iconid(currentProgVal.line - 1);
	if(crsrPosId) {
		crsrPosId = chkExeAnimate(crsrPosId);
		/* Adjust the cursor position. */
		g_columnRelationInfo.dispPosId = crsrPosId;
		var mvIdx = g_TL_progInfo.dispProg.indexOf(crsrPosId);
		exe_column_move(mvIdx + 1);
	}
}

/*
 =========================================================================
 @function name        : nestCurveHidden
 @argument[dispState]  : dispState:''/'hidden'
 @description          : Timeline. Nest line curve display switching processing.
 @return               : none
 =========================================================================
*/
var g_nest_visDelaytimer = null;
function nestCurveHidden(dispState, delay) {
	var setTime = !delay ? 0 : delay;
	if(dispState === 'hidden') {
		if(g_nest_visDelaytimer) {
			clearTimeout(g_nest_visDelaytimer);
			g_nest_visDelaytimer = null;
		}
		$('.nestline_assy, .layer_nestline').css('visibility',dispState);
	}
	else {
		g_nest_visDelaytimer = setTimeout(function(){
			$('.nestline_assy, .layer_nestline').css('visibility',dispState);
			g_nest_visDelaytimer = null;
		}, setTime);
	}
}

/*
 =========================================================================
 @function name   : upperArea_selectHandling
 @argument        : none
 @description     : 4D graphic area. Display processing
 @return          : none
 =========================================================================
*/
function upperArea_selectHandling(target) {
	$('.upperDisp').removeClass('upperDisp_active');
	$(target === 'change_4d' ? '#upperDisp_4d' : '#upperDisp_moni').addClass('upperDisp_active');
	
	switch(target) {
		case 'change_4d':
			addframe4dGraph();
			removeMonitor();
			break;
		case 'monitor_io':
		case 'monitor_reg':
		case 'monitor_posreg':
		case 'monitor_safeio':
		case 'monitor_loadcheckresult':  /* Screw tightening only */
			remove4dGraph();
			addMonitor(target);
			break;
		default:
			break;
	}
}

/*
 =========================================================================
 @function name   : registTab_tabSelect
 @argument        : none
 @description     : Programming area. Tab selection display processing
 @return          : none
 =========================================================================
*/
function registTab_tabSelect() {
	var progTab_Area = {
		'progTab_1': {'area': 'progArea_1'},
		'progTab_2': {'area': 'progArea_2'}
	};
	var hammer = {};
	
	$('#progTab_1').addClass('progTab_active');
	$('#progArea_1').addClass('progArea_active');
	
	var progTab = document.getElementsByClassName('progTab');
	for(var cnt = 0; cnt < progTab.length; cnt++) {
		hammer[cnt] = new Hammer(progTab[cnt]);
		
		hammer[cnt].on('tap swipeleft swiperight', function(event) {
			active_elem = "";
			if(event.type === 'tap') {
				input_focusout();
				/* Tab switching */
				$('.progTab').removeClass('progTab_active');
				$('.progArea').removeClass('progArea_active');
				$(event.target).addClass('progTab_active');
				$('#' + progTab_Area[event.target.id].area).addClass('progArea_active');
			}
			else {
				/* If waiting for paste, nothing is done. */
				if(g_TL_selectModeFlg) return;
				/* Switch to next tab when swiping */
				$('.progTab').toggleClass('progTab_active');
				$('.progArea').toggleClass('progArea_active');
			}
			
			if(document.getElementById('progTab_1').classList.contains('progTab_active')) {
				input_focusout();
				/* Readjust the height of the palette tab. */
				$('.paletteTab').css('line-height', $('.paletteTab').outerHeight(true) + 'px');
				
				scrlThumbResize($('#' + progtabId[checkedTabId].iconAreaId)[0], 'progicon_scrl_track', false);
				scrlPosUpdate($('#progicon_scrl_thumb')[0], $('#' + progtabId[checkedTabId].iconAreaId)[0], 'progicon_scrl_track', $('#' + progtabId[checkedTabId].iconAreaId)[0].scrollTop);
			}
			else {
				var content = dtlfrm_contentchk(activeTarget);
				if(content != null) {
					scrlThumbResize(content, 'detail_scrlTrack_vrtcl', false);
					scrlPosUpdate($('#dtl_scrlThumb_vrtcl')[0], content, 'detail_scrlTrack_vrtcl', content.scrollTop);
					if(g_RO_flg || !g_TPenbl_flg) {
						$("#detailRestrict").css({
							'height':content.scrollHeight,
							'width':content.scrollWidth,
						});
					}
				}
			}
		});
	}
}

/*
 =========================================================================
 @function name   : registTab_iconTabSelect
 @argument        : none
 @description     : Programming area. Icon type tab selection display processing
 @return          : none
 =========================================================================
*/
var checkedTabId = 'progTab_1_1';
function registTab_iconTabSelect() {
	var hammer = {};
	
	$('#progTab_1_1').addClass('paletteTab_select');
	$('#cat_all').addClass('prg_icon_active');
	scrlThumbResize($('#cat_all')[0], 'progicon_scrl_track', false);
	
	for(var key in progtabId) {
		hammer[key] = new Hammer(document.getElementById(key));
		hammer[key].get('swipe').set({ direction: Hammer.DIRECTION_VERTICAL });
		
		hammer[key].on('tap swipeup swipedown', function(event) {
			/* No need for paste tab. */
			if(event.target.id == 'progTab_paste') return;
			if(event.type === 'tap') {
				/* Tab switching */
				checkedTabId = event.target.id;
				/* Selection tab highlight processing */
				registTab_selectIconTabHighlight();
			}
			else {
				registTab_verticalSwipe_tabSelect(event);
			}
		});
	}
}

/*
 =========================================================================
 @function name : registTab_selectIconTabHighlight
 @argument[]    : none
 @description   : Programming area. Highlight processing when selecting a tab.
 @return        : none
 =========================================================================
*/
function registTab_selectIconTabHighlight() {
	if(checkedTabId == 'progTab_1_fav' || checkedTabId == 'progTab_1_his') {
		if(checkedTabId == 'progTab_1_fav') {
			/* favorite tab re-sorted */
			add_favorite_programmingTab();
		}
		else {
			/* history tab re-sorted */
			add_latestHistory_programmingTab();
		}
		/* Sortable re-setting */
		sortable_setting();
		programingArea_Event();
	}
	
	$('.paletteTab').removeClass('paletteTab_select');
	$('#' + checkedTabId).addClass('paletteTab_select');
	
	$('.prg_icon').removeClass('prg_icon_active');
	prgicon_helpDisp(progtabId[checkedTabId].iconAreaId);
	var pTab_target = document.getElementById(progtabId[checkedTabId].iconAreaId);
	$(pTab_target).addClass('prg_icon_active');
	scrlThumbResize(pTab_target, 'progicon_scrl_track', false);
	scrlPosUpdate($('#progicon_scrl_thumb')[0], pTab_target, 'progicon_scrl_track', pTab_target.scrollTop);
}
/*
 =========================================================================
 @function name        : registTab_verticalSwipe_tabSelect
 @argument[swipeEvent] : 
 @description          : Programming area. Tab selection process when swiping up and down.
 @return               : none
 =========================================================================
*/
function registTab_verticalSwipe_tabSelect(swipeEvent) {
	var tabElm = document.getElementsByClassName('paletteTab');
	var selIdx = Array.from(tabElm).indexOf(tabElm[checkedTabId]) + ((swipeEvent.type === 'swipeup') ? -1 : 1);
	selIdx = (selIdx < 0) ? tabElm.length - 1 : (selIdx >= tabElm.length) ? 0 : selIdx;
	if(tabElm[selIdx] && (tabElm[selIdx].id.match('progTab_1_'))) {
		/* Tab switching */
		checkedTabId = tabElm[selIdx].id;
		/* Selection tab highlight processing */
		registTab_selectIconTabHighlight();
	}
}

/*
 =========================================================================
 @function name        : prgicon_helpDisp
 @argument[swipeEvent] : 
 @description          : 
 @return               : none
 =========================================================================
*/
function prgicon_helpDisp(dispCatId) {
	var helpDispList = {
		'cat_vision'   : {id: 'help_frm_vision', iframe: 'help_vision'},
		'multiCopyArea': {id: '', htm: 'help_paste'},
	}
	var helpArea = document.getElementById('helpArea');
	$('#helpArea, #progicon_scrl_track').removeClass('help_active');
	helpArea.innerHTML = '';
	if(helpDispList[dispCatId]) {
		$('#helpArea, #progicon_scrl_track').addClass('help_active');
		if(helpDispList[dispCatId].iframe) {
			append_helphtml(helpDispList[dispCatId].iframe);
			document.getElementById(helpDispList[dispCatId].id).onload = function(e) {
				var frm = document.getElementById(helpDispList[dispCatId].id);
				if(frm.contentDocument.body.innerText.indexOf('404') != -1) {
					$('#helpArea, #progicon_scrl_track').removeClass('help_active');
					$('#cat_vision').css({'width':'100%'});
				}
//				else {
//					$('#' + dispCatId).css({'width':''});
//				}
			};
		}
		else if(helpDispList[dispCatId].htm) {
			append_helphtml(helpDispList[dispCatId].htm);
		}
		else {}
		
	}
}

/*
 =========================================================================
 @function name : timeLine_Event
 @argument[]    : TimeLine element
 @description   : timeline. Event registration and event processing
 @return        : none
 =========================================================================
*/
var hammer_timeline = null;
function timeLine_Event() {
	if(hammer_timeline) hammer_timeline.destroy();
	/* Tap icon on the timeline */
	hammer_timeline = new Hammer(g_TL_elm);
	
	/* Disable pan and swipe direction(Is the default function enabled by disabling hammer pan and swipe?) */
	hammer_timeline.get('pan').set({direction: Hammer.none});
	hammer_timeline.get('swipe').set({direction: Hammer.none});
	//Long tap judgment updated to 800ms
	hammer_timeline.get('press').set({time:800});

	hammer_timeline.on('press tap', function(event) {
		switch(event.type) {
			case 'press':
				tl_pressEvent_func(event);
				break;
			case 'tap':
				tl_tapEvent_func(event);
				break;
			default:
				break;
		}
	});
}

/*
 =========================================================================
 @function name   : tl_pressEvent_func
 @argument[event] : Press event
 @description     : timeline. Event registration and event processing
 @return          : none
 =========================================================================
*/
function tl_pressEvent_func(event) {
	if(g_TL_elm.classList.contains('scrolling')) return;
	var selIconElm = search_eventTarget(event.target, EVT_TARGET_KIND_ELM);
	/* If it is 'timeline background' or 'column', the process is terminated. */
	if((selIconElm.id == 'TimeLineArea') || (selIconElm.classList.contains('exe_column'))) return;

	var vtclViewChk = g_tlScroll_direction == TL_SCRL_VRTCL;
	var wt_nodragChk = selIconElm.classList.contains('wt_nodrag');
	/* Editable program */
	if(!g_RO_flg  && g_TPenbl_flg && !wt_nodragChk && !selIconElm.classList.contains('weldingteach') && !selIconElm.classList.contains('include_wbt') && g_program_data[selIconElm.id].baseId != '-INST_WRIST_BUTTON_TEACH') {
		/* If you are already in selection mode, release it. */
		if(g_TL_selectModeFlg) {
			/* If a cut and copy operation has already been performed, the process is terminated. */
			if(g_multiSelectArray.length) return;
			
			change_TLselectMode(SELECT_MODE_NONE);
		}
		pressEvent = event;
		change_TLselectMode(SELECT_MODE);
		multiSelect_startPos();
		/* Pop-up display */
		toast.show(langResource.ihmieditor_pop_selecting_c);
	}
	else {
		var disp = toastStr_notEdit();
		toast.show(disp);
		if(wt_nodragChk) {
			scrlWrpElm.removeEventListener('click', onFilter_endEvent, false);
			scrlWrpElm.removeEventListener('pointerleave', onFilter_endEvent, false);
		}
	}
}

/*
 =========================================================================
 @function name   : tl_tapEvent_func
 @argument[event] : tap event
 @description     : timeline. Event registration and event processing
 @return          : none
 =========================================================================
*/
function tl_tapEvent_func(event) {
	/* Normal mode */
	if(!g_TL_selectModeFlg) {
		click_scale(event);
		tapEvent_normalMode(event);
	}
	/* Multiple selection mode */
	else {
		tapEvent_multiSelectMode(event);
	}
}

/*
 =========================================================================
 @function name    : tapEvent_normalMode
 @argument[event]  : 
 @description      : timeline. Tap event normal processing
 @return           : none
 =========================================================================
*/
function tapEvent_normalMode(event) {
	var targetElm = search_eventTarget(event.target, EVT_TARGET_KIND_ELM);
	if(targetElm.classList.contains('wt_nodrag')) {
		scrlWrpElm.removeEventListener('click', onFilter_endEvent, false);
		scrlWrpElm.removeEventListener('pointerleave', onFilter_endEvent, false);
	}
	if(g_RO_flg || !g_TPenbl_flg) {
		scrlWrpElm.removeEventListener('click', readOnly_onFilter_endEvent, false);
		scrlWrpElm.removeEventListener('pointerleave', readOnly_onFilter_endEvent, false);
	}
	/* Icon border */
	icon_activeChk(targetElm.id);
}

/*
 =========================================================================
 @function name    : tapEvent_multiSelectMode
 @argument[event]  : 
 @description      : timeline. tap event. Processing in multiple selection mode
 @return           : none
 =========================================================================
*/
var g_selectStartPos = '';
var g_selected = [];
function tapEvent_multiSelectMode(event) {
	var selectId = search_eventTarget(event.target, EVT_TARGET_KIND_ID);
	var targetElm = search_eventTarget(event.target, EVT_TARGET_KIND_ELM);
	
	if((!targetElm.parentElement) || (targetElm.parentElement.id === 'multiCopyArea')) {
		return false;
	}
	if(selectId.startsWith('TimeLineArea') != true && selectId !== '') {
		/* The menu is not yet selected. */
		if(multiSelect_opeType === '') {
			/* If you have added and changed the background color, restore it. */
			/* Class assignment */
			$(targetElm).addClass('ui_selected');
			g_program_data[targetElm.id].select = 'ui_selected';
			/* Start point not selected */
			if(g_selectStartPos === '') {
				g_selectStartPos = selectId;
			}
			else {
				/* select menu update */
				$('#iconSelectMenu').removeClass('stretch_selectMenu replace_selectMenu remarked_selectMenu');
				$('#iconSelectMenu').addClass('multi_selectMenu');
			}
			
			/* Already selected. */
			if(g_selected.length != 0) {
				/* Deselect once. */
				for(var cnt = 0; cnt < g_selected.length; cnt++) {
					/* Other than the starting point. */
					if(g_selected[cnt] !== g_selectStartPos) {
						$('#' + g_selected[cnt]).removeClass('ui_selected');
						g_program_data[g_selected[cnt]].select = '';
						/* Open IF / FOR / BKT */
						if((stretch_idStrChk(STRETCH_ID_CHK_LEAD, g_selected[cnt])) &&
						   (g_program_data[g_selected[cnt]].stretch.state === 'stretch_open')) {
							/* nest line color change */
							nestLineColorChange(g_selected[cnt], '');
						}
					}
				}
				g_selected = [];
			}
			
			timeline_multipleSelect(selectId);
		}
	}
	else {
		/* Cancel selected state */
		change_TLselectMode(SELECT_MODE_NONE);
	}
}

/*
 =========================================================================
 @function name  : multiSelect_tapEvent
 @argument       : none
 @description    : Multiple select mode: tap event process.
 @return         : none
 =========================================================================
*/
function multiSelect_tapEvent(event) {
	if(g_TL_selectModeFlg == SELECT_MODE) {
		change_TLselectMode(SELECT_MODE_NONE);
	}
}

/*
 =========================================================================
 @function name   : change_TLselectMode
 @argument[mode]  : 
 @description     : timeline. Selection state switching process
 @return          : 
 =========================================================================
*/
var SELECT_MODE_NONE	= 0;
var SELECT_MODE			= 1;
function change_TLselectMode(mode) {
	g_TL_selectModeFlg = mode;

	/* Selection Select start position */
	if(g_TL_selectModeFlg === SELECT_MODE) {
		/* There is an active icon */
		if(activeTarget !== '') {
			/* borderLine slide up */
			if(borderElemPos !== '') {
				/* Because it affects the pop-up display process, slide it immediately */
				inputFocus_dispSlide(false);
			}
			/* Deactivate */
			icon_inactive();
		}
		else {
			/* The detail screen is not displayed, but the detail tab is selected. */
			if(document.getElementById('progTab_2').classList.contains('progTab_active')) {
				input_focusout();
				$('#progTab_2').removeClass('progTab_active');
				$('#progArea_2').removeClass('progArea_active');
				$('#progTab_1').addClass('progTab_active');
				$('#progArea_1').addClass('progArea_active');
				/* Readjust the height of the palette tab. */
				$('.paletteTab').css('line-height', $('.paletteTab').outerHeight(true) + 'px');
				scrlThumbResize($('#' + progtabId[checkedTabId].iconAreaId)[0], 'progicon_scrl_track', false);
				scrlPosUpdate($('#progicon_scrl_thumb')[0], $('#' + progtabId[checkedTabId].iconAreaId)[0], 'progicon_scrl_track', $('#' + progtabId[checkedTabId].iconAreaId)[0].scrollTop);
			}
		}
		sortable_destroy();
		
		/* Operation restrictions */
		$('#viewchange, #tl_dragLock').css('opacity', '0.5');
		$('.undoredo').css('opacity','');
		overlayRistrict(SITUATION_MULTISEL, true);
		$(parts_block).removeClass('prog_dragging');
		$(".exe_column").removeClass('clm_active');

		if(g_favoriteFlg.progAdd == false && g_favoriteFlg.favoEdit == false) { /* If favorite save mode for progTab, subMenu noDisp.*/
			/* Menu display */
			selectMenu_dispUpdate(MULTI_SEL_MENU_ICON_UD_01);
		}

	}
	/* Cancel selected state */
	else {
		/* A duplicate element is exists. */
		var selected = get_progList_selected('ui_selected');
		for(var cnt in selected) {
			clear_selectInfo(selected[cnt]);
		}
		 $('.ui_selected', g_TL_elm).removeClass('ui_selected');
		clear_selectData();
		
		g_selectStartPos = '';
		g_selected = [];

		if(sortableTimeLine !== '') {
			var dragLock = g_tl_dragLock ?
							'#TimeLineArea .posTeach, #TimeLineArea .normal' :
							'.if_else, .if_end, .for_end, .bkt_end, .wt_nodrag';
			sortableTimeLine.option('filter', dragLock);
		}
		else {
			sortable_setting();
		}
		overlayRistrict(SITUATION_MULTISEL, false);

		cancel_favoSaveMode();

		if(g_timelinepopDispFlg == true) {
			/* After all attribute[] are stored. */
			if(g_lineCountOver.overflg) tlPopupDisplayReq(langResource.ihmieditor_pop_linecount_over_c);
			/* handle teach. */
			if(g_btnTeaching_list.weldteach.count > 1) tlPopupDisplayReq(langResource.ihmieditor_pop_weldingteach_countover_c + '<BR>' + langResource.ihmieditor_pop_weldingteach_not_operate_c);
		}

		if(g_activeClm_id) {
			$("#" + g_activeClm_id).addClass('clm_active');
		}
		else {
			$("#exe_column").addClass('clm_active');
		}
		if(g_nest_visDelaytimer == null) nestCurveHidden('');
		
		selectMenu_dispUpdate(MULTI_SEL_MENU_ICON_UD_00);
		toast.delete();
		pressEvent = '';
	}
}

/*
 =========================================================================
 @function name  : undoredo_control
 @argument       : none
 @description    : UndoRedo control.
 @return         : none
 =========================================================================
*/
function undoredo_control() {
	/* Undo */
	var undo_elm = document.getElementById('undo');
	var undotarget = new Hammer(undo_elm);

	undotarget.on('tap', function (event) {
		$('#undo').on(endEventTouch + ' ' + endEventMouse, function(e) { e.preventDefault(); });

		var tl_index = timeline_record.get_array_index();
		var tl_array = timeline_record.get_array();

		if (tl_index < (tl_array.length - 1) && tl_array.length > 1) {
			nestCurveHidden('hidden');
			edit_pos_notRestore_flg = false, edit_posregi_notRestore_flg = false;
			var toastText = unredoToastCreate(tl_array[tl_index] ,'undo');
			/* Undo operation */
			undo(tl_array[tl_index]);
			tl_index = timeline_record.array_index_increment();
			/* Update string */
			toastText = (edit_pos_notRestore_flg) ? langResource.ihmieditor_pop_cancelnoposedit_c :
							(edit_posregi_notRestore_flg) ? langResource.ihmieditor_pop_cancelposedit_c : toastText;
			nestCurveHidden('');
			/* Show toast */
			toast.show(toastText);
			timelineScrlbarUpdate();
			check_undoredo_active();
		}
		else {
			if(tl_index >= tl_array.length) undoredo_err_reload();
		}
	});


	/* Redo */
	var redo_elm = document.getElementById('redo');
	var redotarget = new Hammer(redo_elm);
	redotarget.on('tap', function (event) {
		$('#redo').on(endEventTouch + ' ' + endEventMouse, function(e) { e.preventDefault(); });

		var tl_index = timeline_record.get_array_index();
		var tl_array = timeline_record.get_array();

		if (tl_index < tl_array.length && tl_index > 0) {
			nestCurveHidden('hidden');
			edit_posregi_notRestore_flg = false;
			//redo g_program_data
			tl_index = timeline_record.array_index_decrement();
			var toastText = unredoToastCreate(tl_array[tl_index] ,'redo');
			/* Redo operation */
			redo(tl_array[tl_index]);
			/* Update string */
			toastText = (edit_posregi_notRestore_flg) ? langResource.ihmieditor_pop_cancelposedit_c : toastText;
			nestCurveHidden('');
			/* Show toast */
			toast.show(toastText);
			timelineScrlbarUpdate();
			check_undoredo_active();
		}
		else {
			if(tl_index > 0) undoredo_err_reload();
		}
	});

	function undoredo_err_reload() {
		display_popupmsg_confirm(top, langResource.ihmieditor_pop_error_reload_c, cb_closepopup_location_reload);
	}
}

/*
 =========================================================================
 @function name       : unredoToastCreate
 @argument[tl_record] : Timeline Operation record
 @argument[action]    : undo or redo
 @description         : Operation contents when undo or redo
 @return              : string
 =========================================================================
*/
function unredoToastCreate(tl_record, action) {
	var userOperation = "";
	var unredoText = action == "undo" ? langResource.ihmieditor_pop_undo_c : langResource.ihmieditor_pop_redo_c;
	switch(tl_record.type){
		case OPERATION_ADD:			/* add */
		case OPERATION_ADD_MULTI:	/* add sample program */
			userOperation = langResource.ihmieditor_pop_unredo_add_c;
			break;
		case OPERATION_SORT:		/* sort(Including cut) */
		case OPERATION_SORT_EDIT:
			userOperation = langResource.ihmieditor_pop_unredo_sort_c;
			break;
		case OPERATION_DELETE:		/* delete */
		case OPERATION_DELETE_MULTI:
			userOperation = langResource.ihmieditor_pop_unredo_del_c;
			break;
		case OPERATION_EDIT:		/* edit */
		case OPERATION_EDIT_MULTI:	/* edit adinst bracket */
		case OPERATION_SET_POS:	/* set Position*/
			userOperation = langResource.ihmieditor_pop_unredo_edit_c;
			break;
		case OPERATION_PASTE:		/* copy */
			userOperation = langResource.ihmieditor_pop_unredo_copy_c;
			break;
		default:
			return unredoText;
	}
	return gcurrentLang == "jp" || gcurrentLang == "kn" ? userOperation + unredoText : unredoText + " " + userOperation;
}

/*
 =========================================================================
 @function name  : viewchange_control
 @argument       : none
 @description    : View change control.
 @return         : none
 =========================================================================
*/
var DEF_TIMELINE_AREA_HEIGHT = 258.5;		/* timeline + undo/redo + scrollbar + bottomborder */
var TL_SCRL_HRZN  = 0;
var TL_SCRL_VRTCL = 1;
var g_tlScroll_direction = TL_SCRL_HRZN;
function viewchange_control() {
	$('#viewchange').on(endEventTouch + ' ' + endEventMouse, function(e) {
		e.preventDefault();
	})
	var vctarget = new Hammer(document.getElementById('viewchange'));

	g_activeClm_id = 'exe_column';

	vctarget.on('tap', function (event) {
		dispOnWaiting(0);
		/* toggle class */
		document.getElementById('viewchange').classList.toggle('vrtclview');
		g_tlScroll_direction = document.getElementById('viewchange').classList.contains('vrtclview') ? TL_SCRL_VRTCL : TL_SCRL_HRZN;

		/* Set system variables. */
		var frameXml = "";
		frameXml += '<?xml version="1.0" encoding="Shift_JIS"?>\r<XMLVAR>\r<PROG name="*SYSTEM*">\r';
		frameXml += '<VAR name="$IHMI_EDIT.$FULL_VIEW">' + ((g_tlScroll_direction == TL_SCRL_HRZN) ? 'FALSE' : 'TRUE') +'</VAR>\r</PROG>\r</XMLVAR>';
		setSysValXHR(frameXml, tl_viewChange, null);
	});
}

/*
 =========================================================================
 @function name    : tl_viewChange
 @argument[direct] : Scroll direction
 @description      : View change control.
 @return           : none
 =========================================================================
*/
function tl_viewChange() {
	var def_tlHeight = DEF_TIMELINE_AREA_HEIGHT + SYS_ALM_HEIGHT;
	$(TLspacerElm).css({'width': '', 'height': ''});
	var upperEdgeReach = $('#parts-upper')[0].classList.contains('upperEdge_reach');
	/* vertical scroll view */
	if(g_tlScroll_direction == TL_SCRL_VRTCL) {
		/* Get the display position. */
		var dispPos = Math.round((scrlWrpElm.scrollLeft + 30) / TL_ICON_WIDTH_OUTER);
		$(parts_timeline).appendTo('#upper-area');
		$(g_TL_elm).css('padding-left','');
		if($("#exe_column").css('position') === 'fixed') {
			$("#exe_column").css({position:"",top: ""});
		}
		$(scrlWrpElm).stop().scrollLeft(0).scrollTop(0);
		animation_flg = false;			
		$(parts_block).addClass('vtclscrlView');
		$(parts_timeline).css('height', 'calc(100% - ' + SYS_ALM_HEIGHT + 'px)');
		$(scrlWrpElm).css('height', 'calc(100% - ' + ($('#undoredo_area').height() + $('#TL_scrollbar').height() + 'px)'));
		$(g_TL_elm).addClass('vtclscrl');
		lateralResizeFunc();
		remove4dGraph();
		removeMonitor();
		$('#scrollContainer').css('height',Math.ceil(g_TL_progInfo.dispProg.length / get_dispWidth_iconNum()) * BASE_VERTICAL_TL_HEIGHT);
	}
	/* horizontal scroll view */
	else {
		/* Get the display position. */
		var dispPos = Math.round(scrlWrpElm.scrollTop / BASE_VERTICAL_TL_HEIGHT);
		var oneRowNum = Math.floor((parts_block.clientWidth - 30) / TL_ICON_WIDTH_OUTER);
		dispPos = dispPos * oneRowNum;
		
		$(parts_timeline).prependTo('#lower-area');
		$(scrlWrpElm).css('height', '');
		$(parts_timeline).css('height', '');
		$(parts_block).removeClass('vtclscrlView');
		$(g_TL_elm).removeClass('vtclscrl');
		$('.exe_column').removeClass('clm_active');
		$('#exe_column').addClass('clm_active');
		g_activeClm_id = 'exe_column';
		lateralResizeFunc();
		$(scrlWrpElm).stop().scrollLeft(0);
		animation_flg = false;
		$('.allViewTL').remove();
		$('#scrollContainer').css('height','');
		if(!upperEdgeReach) {
			if(document.getElementById('upperDisp_4d').classList.contains('upperDisp_active') == true) {
				addframe4dGraph()
			}
			else {
				addMonitor(g_lastDispMoni);
			}
		}
		
		/* for Timeline comment display */
		$('.commentText').removeClass('commentOmit');
		$('.commentText').css('width', '');
	}
	if(isCRXeditorActive) {
		var toastStr = (g_tlScroll_direction == TL_SCRL_VRTCL) ?
							langResource.ihmieditor_pop_view_change_vertical_c :
							langResource.ihmieditor_pop_view_change_normal_c;
		toast.show(toastStr);
	}
	/* Draw the timeline background and adjust the scroll position before redrawing the icons. */
	draw_TLscale(true);
	var upperAreaMinSize = (g_tlScroll_direction == TL_SCRL_VRTCL) ? def_tlHeight : SYS_ALM_HEIGHT;
	var upperAreaHide = (g_tlScroll_direction == TL_SCRL_VRTCL) ? false : true;
	var lowerAreaMinSize = (g_tlScroll_direction == TL_SCRL_VRTCL) ? 0 : parts_timeline.offsetHeight;
	$(parts_lowwer).css('height', 'calc(100% - ' + lowerAreaMinSize + 'px');
	var handelResizeOption = {
		first: {
			minSize: upperAreaMinSize,
			hide: upperAreaHide
		},
		second: {
			minSize: lowerAreaMinSize,
		}
	};
	parts_handleresize_area.refresh(handelResizeOption);
	adjustTimelinePos(dispPos, true);
	/* Icon redrawing */
	tl_adjust_dispRange();
	/* Adjust the position of the screen parts based on the position of the parts_handleresize_area. */
	adjustUpLowElem();
	if(device === 'pc') setScrollbooster();
	sortable_setting();
	if(currentProgVal.stat === I_WATCHEXEC_RUNNING) {
		overlayRistrict(SITUATION_PLAY, true);
	}
	if(g_overlay_enbl.timeline) {
		overlayRistrict(SITUATION_TIMELINE, true);
	}
	dispOffWaiting();
}

/*
 =========================================================================
 @function name       : adjustTimelinePos
 @argument[dispPos]   : Display position
 @argument[crslAdjst] : Adjusts the cursor position or not. (true:Adjustment)
 @description         : Adjusts the scrolling position of the timeline and cursor position.
 @return              : none
 =========================================================================
*/
function adjustTimelinePos(dispPos, crslAdjst) {
	var clmpos = g_columnRelationInfo.posNo;

	if(g_tlScroll_direction == TL_SCRL_VRTCL) {
		if(crslAdjst) exe_column_move(clmpos);
		
		/* Adjusts the timeline display position. */
		var clmRow = getRowFromTLTop(g_TL_progInfo.dispProg[dispPos - 1]);
		var scrlTop = ((clmRow - 1) * BASE_VERTICAL_TL_HEIGHT) > 0 ? ((clmRow - 1) * BASE_VERTICAL_TL_HEIGHT) : 0;
		if(scrlWrpElm.scrollHeight - scrlWrpElm.clientHeight < scrlTop) {
			scrlTop = scrlWrpElm.scrollHeight - scrlWrpElm.clientHeight;
		}
		$(scrlWrpElm).scrollTop(scrlTop);
	}
	else {
		if(currentProgVal.stat != I_WATCHEXEC_ABORTED) {
			display_exemode_standby();
			display_pausemode();
			draw_TLscale(false);
		}
		else {
			if(crslAdjst) exe_column_move(clmpos);
			
			/* Adjusts the timeline display position. */
			var scrollLeft = dispPos * TL_ICON_WIDTH_OUTER;
			if(g_TL_elm.scrollWidth - scrlWrpElm.clientWidth < scrollLeft) {
				scrollLeft = g_TL_elm.scrollWidth - scrlWrpElm.clientWidth;
			}
			$(scrlWrpElm).stop().scrollLeft(scrollLeft);
		}
		scrlPosUpdate($('#TLscrl_thumb')[0], scrlWrpElm, 'TL_scrollbar', scrollLeft);
	}
}

/*
 =========================================================================
 @function name         : timeline_multipleSelect
 @argument[endPosId]    : 
 @description           : Timeline. Multiple selection. Multiple selection process
 @return                : 
 =========================================================================
*/
function timeline_multipleSelect(endPosId) {
	/* Add class to each command */
	var startPos = g_TL_progInfo.saveProg.indexOf(g_selectStartPos);
	var endPos = g_TL_progInfo.saveProg.indexOf(endPosId);
	if(startPos > endPos) {
		var tmp = startPos;
		startPos = endPos;
		endPos = tmp
	}
	
	var tmpPos = '';
	var tmpId = '';
	for (var tmpCnt = startPos; tmpCnt <= endPos; tmpCnt++) {
		if(stretch_idStrChk(STRETCH_ID_CHK_ALL, g_TL_progInfo.saveProg[tmpCnt])) {
			/* lead or else */
			if(stretch_idStrChk(STRETCH_ID_CHK_N_END, g_TL_progInfo.saveProg[tmpCnt])) {
				/* Get the end ID */
				tmpId = get_stretch_pairId(g_TL_progInfo.saveProg[tmpCnt], REQ_ID_KIND_END, null);
				if(tmpId !== '') {
					tmpPos = g_TL_progInfo.saveProg.indexOf(tmpId);
					/* Temporary value is greater than end position */
					if(endPos < tmpPos) {
						/* endPos update */
						endPos = tmpPos;
					}
				}
			}
			/* end */
			else {
				/* Get the lead ID */
				tmpId = get_stretch_pairId(g_TL_progInfo.saveProg[tmpCnt], REQ_ID_KIND_LEAD, null);
				if(tmpId !== '') {
					tmpPos = g_TL_progInfo.saveProg.indexOf(tmpId);
					/* Temporary value is less than start position */
					if(startPos > tmpPos) {
						/* startPos update */
						startPos = tmpPos;
					}
				}
			}
		}
	}
	
	g_selected = [];
	for(var selectCnt = startPos; selectCnt <= endPos; selectCnt++) {
		var selId = g_TL_progInfo.saveProg[selectCnt];
		/* 'selected'class not granted */
		if(g_program_data[selId].select != 'ui_selected') {
			if(document.getElementById(selId)) { $('#' + selId).addClass('ui_selected'); }
			g_program_data[selId].select = 'ui_selected';
		}
		/* Open IF / FOR / BKT */
		if(stretch_idStrChk(STRETCH_ID_CHK_LEAD, selId) && g_program_data[selId].stretch.state === 'stretch_open') {
			/* nest line color change */
			nestLineColorChange(selId, 'ui_selected');
		}
		g_selected.push(selId);
	}
}

/*
 =========================================================================
 @function name  : timeLine_selectMode_subMenu
 @argument       : none
 @description    : Timeline. Selected state. Submenu processing
 @return         : none
 =========================================================================
*/
var multiSelect_opeType = '';
var OPETYPE_COPY = 1;
var OPETYPE_CUT = 2;
function timeLine_selectMode_subMenu() {
	/* del */
	$('body').on('click', '#selectMenu_del', function (event) {
		event.preventDefault();
		if(selectRange_baseIdCheck('-INST_ARC_HANDLE_TEACH').length) {
			change_TLselectMode(SELECT_MODE_NONE);
			toast.show(langResource.ihmieditor_pop_weldingteach_not_operate_2_c);
			return false;
		} else if (selectRange_baseIdCheck('-INST_WRIST_BUTTON_TEACH').length) {
			change_TLselectMode(SELECT_MODE_NONE);
			toast.show(langResource.ihmieditor_pop_wristteach_not_operate_2_c);
			return false;
		}
		else {
			timeLine_selectDel('ui_selected');
			toast.show(langResource.ihmieditor_pop_deleted_c);
			timelineScrlbarUpdate();
		}
	});

	/* copy */
	$('body').on('click', '#selectMenu_cpy', function (event) {
		event.preventDefault();
		if(multiSelect_opeType === '') {
			if(selectRange_baseIdCheck('-INST_ARC_HANDLE_TEACH').length) {
				change_TLselectMode(SELECT_MODE_NONE);
				toast.show(langResource.ihmieditor_pop_weldingteach_not_operate_2_c);
				return false;
			} else if (selectRange_baseIdCheck('-INST_WRIST_BUTTON_TEACH').length) {
				change_TLselectMode(SELECT_MODE_NONE);
				toast.show(langResource.ihmieditor_pop_wristteach_not_operate_2_c);
				return false;
			}
			else {
				if(g_TL_progInfo.saveProg.length + g_selected.length > MAX_LINE_COUNT) {
					/* Pop-up display due to excessive number of lines. */
					popup_lineCountMax();
					change_TLselectMode(SELECT_MODE_NONE);
					return false;
				}
				else {
					multiSelect_opeType = OPETYPE_COPY;
					timeLine_selectFix();
					/* Update process */
					nestCurveHidden('');
					$('#iconSelectMenu').removeClass('menu_active').css({'left':'', 'width':''});
					/* Pop-up display */
					toast.show(langResource.ihmieditor_pop_copied_c);
				}
			}
		}
	});

	/* cut */
	$('body').on('click', '#selectMenu_cut', function (event) {
		event.preventDefault();
		if(multiSelect_opeType === '') {
			if(selectRange_baseIdCheck('-INST_ARC_HANDLE_TEACH').length) {
				change_TLselectMode(SELECT_MODE_NONE);
				toast.show(langResource.ihmieditor_pop_weldingteach_not_operate_2_c);
				return false;
			} else if (selectRange_baseIdCheck('-INST_WRIST_BUTTON_TEACH').length) {
				change_TLselectMode(SELECT_MODE_NONE);
				toast.show(langResource.ihmieditor_pop_wristteach_not_operate_2_c);
				return false;
			}
			else {
				multiSelect_opeType = OPETYPE_CUT;
				timeLine_selectFix();
				nestCurveHidden('');
				$('#iconSelectMenu').removeClass('menu_active').css({'left':'', 'width':''});
				/* Pop-up display */
				toast.show(langResource.ihmieditor_pop_cutted_c);
			}
		}
	});

	/* favorite */
	$('body').on('click', '#selectMenu_favo', function (event) {
		event.preventDefault();
		if(g_favoDataErrorFlg.notExist == true) {
			toast.show(langResource.ihmieditor_pop_favoriteprog_notexist_c);
			return;
		}
		if(g_favoriteList.length < FAVORITE_CMD_MAX || g_favoNoDispList.length != 0) {
			g_favoriteFlg.tlAdd = true;	
			var selId = get_progList_selected('ui_selected');

			change_favoSaveMode(selId);

			if(g_favoriteFlg.paramSave) {
				detailTab_disp(g_addFavoData[0].favoId);
			}	else {
				progTabIcon_detailDisp(ACTIVE_DETAIL_DISP);
			}
			toast.show(langResource.ihmieditor_pop_favorited_c);
		}
		else {
			display_popupmsg_alert(DEF_POPUP_SCRN_TYP.ALERT, langResource.ihmieditor_pop_favorite_regist_max_c, DISP_CLOSE_BTN);
			change_TLselectMode(SELECT_MODE_NONE);
		}
		$('#iconSelectMenu').removeClass('menu_active').css('left','');
	});

	/* stretch */
	$('body').on('click', '#selectMenu_stretch', function (event) {
		event.preventDefault();
		submenu_stretch(event);
		change_TLselectMode(SELECT_MODE_NONE);
	});

	/* replace */
	$('body').on('click', '#selectMenu_replace', function (event) {
		event.preventDefault();
		display_popupmsg_replace_mtn(event);
		change_TLselectMode(SELECT_MODE_NONE);
	});

	/* remark */
	$('body').on('click', '#selectMenu_remark', function (event) {
		event.preventDefault();
		if(selectRange_baseIdCheck('-INST_ARC_HANDLE_TEACH').length) {
			change_TLselectMode(SELECT_MODE_NONE);
			toast.show(langResource.ihmieditor_pop_weldingteach_not_operate_2_c);
			return false;
		} else if (selectRange_baseIdCheck('-INST_WRIST_BUTTON_TEACH').length) {
			change_TLselectMode(SELECT_MODE_NONE);
			toast.show(langResource.ihmieditor_pop_wristteach_not_operate_2_c);
			return false;
		}
		else {
			submenu_remark(event);
		}
	});
}

/*
 =========================================================================
 @function name   : selectRange_baseIdCheck
 @argument[chkId] : 
 @description     : Timeline. Delete selected processing
 @return          : Check result.(Array)
 =========================================================================
*/
function selectRange_baseIdCheck(chkId) {
	var selList = get_progList_selected('ui_selected');
	return selList.filter(function(key) { return g_program_data[key].baseId == chkId; });
}

/*
 =========================================================================
 @function name         : timeLine_selectDel
 @argument[targetClass] : The class assigned to the element to be deleted.
 @description           : Timeline. Delete selected processing
 @return                : none
 =========================================================================
*/
function timeLine_selectDel(targetClass) {
	dispOnWaiting(0);

	var record_contents = [];
	var delList = g_TL_progInfo.saveProg.filter(function(key) {
		return g_program_data[key].select == targetClass ||
		targetClass == 'weldingteach' && g_program_data[key].baseId == '-INST_ARC_HANDLE_TEACH' ||
		targetClass == 'wristteach' && g_program_data[key].baseId == '-INST_WRIST_BUTTON_TEACH';
	});
	var del_startnum = g_TL_progInfo.saveProg.indexOf(delList[0]);
	var del_endnum = del_startnum + (delList.length - 1);
	/* Holds data for Undo. */
	for(var cnt = 0; cnt < delList.length; cnt++) {
		var tmpdata = JSON.parse(JSON.stringify(g_program_data[delList[cnt]]));
		tmpdata.select = '';
		record_contents.push(tmpdata);
	}
	/* weldingteach */
	if (targetClass === 'weldingteach' || targetClass === 'wristteach') {
		timeLine_btnTeachingDel(del_startnum, delList);
		/* Notify the end of teaching. */
		if (targetClass === 'weldingteach') {
			top.setArcTeachFg(false);
			weldingTeachEnd(true);
		} else {
			top.setWristTeachFg(false);
		}
	}
	else {
		/* Delete selected lines. */
		delete_multiicon(del_startnum, del_endnum, true, null);
	}
	if(targetClass === 'ui_selected') {
		/* Stores data for Undo. */
		var record_data = {
			id: delList.slice(),
			contents: record_contents,
			place1: del_startnum,
			place2: del_endnum,
			type: OPERATION_DELETE_MULTI,
		}
		timeline_record.array_add(record_data);
		check_undoredo_active();
		position_record.array_add(position);
		positionregi_record.array_add(g_position_regi);
	}
	
	change_TLselectMode(SELECT_MODE_NONE);
	/* Updated timeline background. */
	draw_TLscale(false);
}

/*
 =========================================================================
 @function name         : timeLine_btnTeachingDel
 @argument[targetClass] : 
 @description           : 
 @return                : none
 =========================================================================
*/
function timeLine_btnTeachingDel(delIndex, delList) {
	if(delList.length) {
		if(activeTarget) icon_inactive();
		delete g_program_data[delList[0]];
		progInfo_del_splice(delList[0]);
		if(g_TL_elm.children[delList[0]]) g_TL_elm.children[delList[0]].remove();

		timeLine_nestUpdate();
		g_program_arrayNumSave();
		tl_adjust_dispRange();

		/* Stop the Modified time monitoring monitor.*/
		stopMonitorCurProgModify();
		top.delLine(current_prog_name, (delIndex + 1), 1, delLine_callback, null);
	}
	else {
		dispOffWaiting();
	}
}

/*
 =========================================================================
 @function name  : clear_selectData
 @argument       : none
 @description    : 
 @return         : none
 =========================================================================
*/
function clear_selectData() {
	$('#parts-lowwer').removeClass('cp_active');
	if(g_select_catTab) {
		$('#multiCopyArea').removeClass('prg_icon_active');
		$('#' + progtabId[g_select_catTab].iconAreaId).addClass('prg_icon_active');
		prgicon_helpDisp(progtabId[g_select_catTab].iconAreaId);
		checkedTabId = g_select_catTab;
		g_select_catTab = '';
	}
	$(parts_block).removeClass('selectFixed');
	iconArea_verticalSet();
	check_undoredo_active();
	$('#viewchange, #tl_dragLock').css('opacity', '');
	var multisel = get_progList_selected('multiselected');
	for(var cnt in multisel) {
		clear_selectInfo(multisel[cnt]);
	}
	$('.multiselected', g_TL_elm).removeClass('multiselected');
	g_multiSelectArray = [];
	multiSelect_opeType = '';
}

/*
 =========================================================================
 @function name  : save_selectData
 @argument       : none
 @description    : 
 @return         : none
 =========================================================================
*/
var g_multiSelectArray = [];
function save_selectData() {
	/* Initialization */
	g_multiSelectArray = [];

	for(var cnt = 0; cnt < g_selected.length; cnt++) {
		g_multiSelectArray[cnt] = {id:'', g_prog_data:''};
		/* Data storage */
		g_multiSelectArray[cnt].id = g_selected[cnt];
		if(stretch_idStrChk(STRETCH_ID_CHK_LEAD, g_selected[cnt])) {
			/* nest line color change */
			nestLineColorChange(g_selected[cnt], 'multiselected');
		}
		g_program_data[g_selected[cnt]].select = 'multiselected';
		g_multiSelectArray[cnt].g_prog_data = JSON.parse(JSON.stringify(g_program_data[g_selected[cnt]]));
	}
}

/*
 =========================================================================
 @function name  : timeLine_selectFix
 @argument       : none
 @description    : Timeline. Cut & paste process
 @return         : none
 =========================================================================
*/
var g_select_catTab = '';
function timeLine_selectFix() {
	sortable_setting();
	sortableTimeLine.option('filter', "#TimeLineArea .normal, #TimeLineArea .posTeach");
	save_selectData();
	
	 $('.ui_selected', g_TL_elm).removeClass('ui_selected').addClass('multiselected');
	$(parts_block).addClass('selectFixed');
	$('#viewchange, #tl_dragLock').css('opacity', '0.5');
	$('.undoredo').css('opacity','');
	$('#parts-lowwer').addClass('cp_active');
	g_select_catTab = checkedTabId;
	checkedTabId = 'progTab_paste';
	$('.prg_icon').removeClass('prg_icon_active');
	$('#multiCopyArea').addClass('prg_icon_active');
	prgicon_helpDisp('multiCopyArea');
	var elm = document.getElementById('multiCopyArea');
	scrlThumbResize(elm, 'progicon_scrl_track', false);
	scrlPosUpdate($('#progicon_scrl_thumb')[0], elm, 'progicon_scrl_track', elm.scrollTop);
}

/*
 =========================================================================
 @function name  : timeline_scrollControl
 @argument       : none
 @description    : Timeline area scrollbar control.
 @return         : none
 =========================================================================
*/
function timeline_scrollControl() {
	scrlPosUpdate($('#TLscrl_thumb')[0], scrlWrpElm, 'TL_scrollbar', 0);
	
	$(scrlWrpElm).scroll(function(event) {
		if(g_tlScroll_direction == TL_SCRL_VRTCL) {
			$(TLspacerElm).css('width', '');
			var tmpTopRow = ~~((scrlWrpElm.scrollTop - (BASE_VERTICAL_TL_HEIGHT * 2)) / BASE_VERTICAL_TL_HEIGHT);
		    if(tmpTopRow < 0) tmpTopRow = 0;
			var tmpLeft = (tmpTopRow * get_dispWidth_iconNum());
			if(tmpLeft != g_TL_progInfo.dispRange.left) {
				tl_adjust_dispRange();
			}
			else {
				g_TL_progInfo.scrollDist = '';
			}
		}
		else {
			$(TLspacerElm).css('height', '');
			var padding = Number($(g_TL_elm).css('padding-left').replace(/[^0-9.]/g,"")) - 20;
			var calcSrclLeft = scrlWrpElm.scrollLeft < padding ? 0 : (scrlWrpElm.scrollLeft - padding);
			if(calcSrclLeft <= (g_TL_elm.scrollWidth - window.innerWidth) - padding) {
				var tmpLeft = ~~((calcSrclLeft - (TL_ICON_WIDTH_OUTER * 5)) / TL_ICON_WIDTH_OUTER);
				if(tmpLeft < 0) tmpLeft = 0;
				if(tmpLeft != g_TL_progInfo.dispRange.left) {
					tl_adjust_dispRange();
				}
				else {
					g_TL_progInfo.scrollDist = '';
				}
			}
		}
		if($('#TLscrl_thumb')[0].classList.contains('thumb_drag') != true) {
			scrlPosUpdate($('#TLscrl_thumb')[0], this, 'TL_scrollbar', this.scrollLeft);
		}
		if($('#TLscrl_vrtcl_thumb')[0].classList.contains('thumb_drag') != true) {
			scrlPosUpdate($('#TLscrl_vrtcl_thumb')[0], this, 'TL_scrollbar_vrtcl', this.scrollTop);
		}
		chk_TL_scrolling();
	});
	
	$('#TLscrl_thumb').draggable({
		containment: '#TL_scrollbar',
		axis:'x',
		drag:function(event,ui) {
			scrlPosUpdate(scrlWrpElm, this, 'TL_scrollbar', ui.position.left);
		},
		stop:function(event,ui) {
			scrlPosUpdate(scrlWrpElm, this, 'TL_scrollbar', ui.position.left);
			/* Update element size for drag scroll */
			scrollboost_positionSet();
			$(this).removeClass('thumb_drag');
			/* Restore transparent element */
			$('#progRestrict, #viewRestrict, #timelineRestrict, #overlay_undoredo').removeClass('scrlThumb_dragging');
			
			$('#timelineRestrict').css({'top':'', 'height':''});
		},
		start:function(event,ui) {
			$(this).addClass('thumb_drag');
			/* Display a transparent element on the iframe to enable smooth dragging */
			$('#progRestrict, #viewRestrict, #timelineRestrict, #overlay_undoredo').addClass('scrlThumb_dragging');
			
			if(!g_overlay_enbl.timeline) {
				$('#timelineRestrict').css({'top':'55px', 'height': 'calc(100% - 55px)'});
			}
		}
	});
	
	$('#TLscrl_vrtcl_thumb').draggable({
		containment: '#TL_scrollbar_vrtcl',
		axis:'y',
		drag:function(event,ui) {
			scrlPosUpdate(scrlWrpElm, this, 'TL_scrollbar_vrtcl', ui.position.top);
		},
		stop:function(event,ui) {
			scrlPosUpdate(scrlWrpElm, this, 'TL_scrollbar_vrtcl', ui.position.top);
			/* Update element size for drag scroll */
			scrollboost_positionSet();
			$(this).removeClass('thumb_drag');
			/* Restore transparent element */
			$('#progRestrict, #viewRestrict, #timelineRestrict, #overlay_undoredo').removeClass('vrtck_scrlThumb_dragging');
		},
		start:function(event,ui) {
			$(this).addClass('thumb_drag');
			/* Display a transparent element on the iframe to enable smooth dragging */
			$('#progRestrict, #viewRestrict, #timelineRestrict, #overlay_undoredo').addClass('vrtck_scrlThumb_dragging');
		}
	});
	
	$('#TL_scrollbar').on('click', function(event) {
		clickScrl(event, scrlWrpElm, 'TL_scrollbar', hrznScrlEndChk);
	});
	
	$('#TL_scrollbar_vrtcl').on('click', function(event) {
		clickScrl(event, scrlWrpElm, 'TL_scrollbar_vrtcl', vrtclScrlEndChk);
	});
}

/*
 =========================================================================
 @function name  : chk_TL_scrolling
 @argument       : none
 @description    : progicon area scrollbar control.
 @return         : none
 =========================================================================
*/
var scrlTOid = null;
function chk_TL_scrolling() {
	$(g_TL_elm).addClass('scrolling');
	if(sortableTimeLine) sortableTimeLine.option('disabled', true);
	if(hammer_timeline) hammer_timeline.destroy();
	if(scrlTOid) {
		clearTimeout(scrlTOid);
		scrlTOid = null;
	}
	scrlTOid = setTimeout(function() {
		$(g_TL_elm).removeClass('scrolling');
		if(sortableTimeLine) sortableTimeLine.option('disabled', false);
		timeLine_Event();
		scrlTOid = null;
	}, 50);
}

/*
 =========================================================================
 @function name  : progicon_scrlCtrl
 @argument       : none
 @description    : progicon area scrollbar control.
 @return         : none
 =========================================================================
*/
function progicon_scrlCtrl() {
	$('#progicon_scrl_thumb').on(endEventTouch + ' ' + endEventMouse, function(e) {
		e.preventDefault();
	})
	scrlPosUpdate($('#progicon_scrl_thumb')[0], $('#' + progtabId[checkedTabId].iconAreaId)[0], 'progicon_scrl_track', 0);
	
	$('.prg_icon').scroll(function(event) {
		if($('#progicon_scrl_thumb')[0].classList.contains('thumb_drag') != true) {
			scrlPosUpdate($('#progicon_scrl_thumb')[0], this, 'progicon_scrl_track', $(this)[0].scrollTop);
			
			/* If a timer is issued, discard it */
			if(vrtclScrlEndChk !== 0) clearTimeout(vrtclScrlEndChk);
				/* Timer reissue */
				vrtclScrlEndChk = setTimeout(()=>{
				vrtclScrlEndChk = 0;
			}, 50);
		}
	});
	
	$('#progicon_scrl_thumb').draggable({
		containment: '#progicon_scrl_track',
		axis:'y',
		drag:function(event,ui) {
			scrlPosUpdate($('#' + progtabId[checkedTabId].iconAreaId)[0], this, 'progicon_scrl_track', ui.position.top);
		},
		stop:function(event,ui) {
			scrlPosUpdate($('#' + progtabId[checkedTabId].iconAreaId)[0], this, 'progicon_scrl_track', ui.position.top);
			$(this).removeClass('thumb_drag');
			/* Restore transparent element */
			$('#progRestrict, #viewRestrict, #timelineRestrict').removeClass('prog_scrlThumb_dragging');
		},
		start:function(event,ui) {
			$(this).addClass('thumb_drag');
			/* Display a transparent element on the iframe to enable smooth dragging */
			$('#progRestrict, #viewRestrict, #timelineRestrict').addClass('prog_scrlThumb_dragging');
		}
	});
	
	$('#progicon_scrl_track').on('click', function(event) {
		clickScrl(event, $('#' + progtabId[checkedTabId].iconAreaId)[0], 'progicon_scrl_track', vrtclScrlEndChk);
	});
}

/*
 =========================================================================
 @function name     : detail_scrlCtrl
 @argument[scrlElm] : Scrolling elements.
 @description       : detail area scrollbar control.
 @return            : none
 =========================================================================
*/
var dtl_scrlEndChk = 0;
function detail_scrlCtrl(scrlElm) {
	$('.scrl_thumb', scrlElm).on(endEventTouch + ' ' + endEventMouse, function(e) {
		e.preventDefault();
	})
	scrlThumbResize(scrlElm, 'detail_scrlTrack_vrtcl', false);
	scrlThumbResize(scrlElm, 'detail_scrlTrack_hrzn', true);
	
	if(g_RO_flg || !g_TPenbl_flg || g_program_data[activeTarget].remark) {
		$('.restrictContainer').scroll(function(event) {
			$(scrlElm).scrollTop($('.restrictContainer').scrollTop());
			$(scrlElm).scrollLeft($('.restrictContainer').scrollLeft());
		});
	}
	
	$(scrlElm).scroll(function(event) {
		if($('#dtl_scrlThumb_vrtcl')[0].classList.contains('thumb_drag') != true &&
		   $('#dtl_scrlThumb_hrzn')[0].classList.contains('thumb_drag') != true) {
			scrlPosUpdate($('#dtl_scrlThumb_vrtcl')[0], this, 'detail_scrlTrack_vrtcl', this.scrollTop);
			scrlPosUpdate($('#dtl_scrlThumb_hrzn')[0], this, 'detail_scrlTrack_hrzn', this.scrollLeft);
			
			/* If a timer is issued, discard it */
			if(dtl_scrlEndChk !== 0) clearTimeout(dtl_scrlEndChk);
			/* Timer reissue */
			dtl_scrlEndChk = setTimeout(()=>{
				dtl_scrlEndChk = 0;
			}, 50);
		}
	});
	
	$('#dtl_scrlThumb_vrtcl').draggable({
		containment: '#detail_scrlTrack_vrtcl',
		axis:'y',
		drag:function(event,ui) {
			scrlPosUpdate(scrlElm, this, 'detail_scrlTrack_vrtcl', ui.position.top);
			if(g_RO_flg || !g_TPenbl_flg || g_program_data[activeTarget].remark) {
				scrlPosUpdate($('.restrictContainer')[0], this, 'detail_scrlTrack_vrtcl', ui.position.top);
			}
		},
		stop:function(event,ui) {
			scrlPosUpdate(scrlElm, this, 'detail_scrlTrack_vrtcl', ui.position.top);
			if(g_RO_flg || !g_TPenbl_flg || g_program_data[activeTarget].remark) {
				scrlPosUpdate($('.restrictContainer')[0], this, 'detail_scrlTrack_vrtcl', ui.position.top);
			}
			$(this).removeClass('thumb_drag');
		},
		start:function(event,ui) {
			$(this).addClass('thumb_drag');
		}
	});
	
	$('#dtl_scrlThumb_hrzn').draggable({
		containment: '#detail_scrlTrack_hrzn',
		axis:'x',
		drag:function(event,ui) {
			scrlPosUpdate(scrlElm, this, 'detail_scrlTrack_hrzn', ui.position.left);
			if(g_RO_flg || !g_TPenbl_flg || g_program_data[activeTarget].remark) {
				scrlPosUpdate($('.restrictContainer')[0], this, 'detail_scrlTrack_hrzn', ui.position.left);
			}
		},
		stop:function(event,ui) {
			scrlPosUpdate(scrlElm, this, 'detail_scrlTrack_hrzn', ui.position.left);
			if(g_RO_flg || !g_TPenbl_flg || g_program_data[activeTarget].remark) {
				scrlPosUpdate($('.restrictContainer')[0], this, 'detail_scrlTrack_hrzn', ui.position.left);
			}
			$(this).removeClass('thumb_drag');
		},
		start:function(event,ui) {
			$(this).addClass('thumb_drag');
		}
	});
	
	$('#detail_scrlTrack_vrtcl').on('click', function(event) {
		clickScrl(event, scrlElm, 'detail_scrlTrack_vrtcl', dtl_scrlEndChk);
	});
	
	$('#detail_scrlTrack_hrzn').on('click', function(event) {
		clickScrl(event, scrlElm, 'detail_scrlTrack_hrzn', dtl_scrlEndChk);
	});
}

/*
 =========================================================================
 @function name : multiSelect_startPos
 @argument      : none
 @description   : Multiple select process. Select a starting point.
 @return        : none
 =========================================================================
*/
function multiSelect_startPos() {
	
	var selIconElm = search_eventTarget(pressEvent.target, EVT_TARGET_KIND_ELM);
	
	$(selIconElm).addClass('ui_selected');
	g_program_data[selIconElm.id].select = 'ui_selected';
	if(g_tlmove_ghost) {
		$(g_tlmove_ghost).addClass('ui_selected');
	}
	g_selectStartPos = selIconElm.id;
	
	/* select icon is stretch icon */
	if(stretch_idStrChk(STRETCH_ID_CHK_ALL, g_selectStartPos)) {
		/* Find lead/end id */
		var leadId = get_stretch_pairId(g_selectStartPos, REQ_ID_KIND_LEAD, null);
		var listId;
		for(var cnt = 0; cnt < g_program_data[leadId].stretch.idList.length; cnt++) {
			listId = g_program_data[leadId].stretch.idList[cnt].id;
			g_selected.push(listId);
			$('#' + listId).addClass('ui_selected');
			g_program_data[listId].select = 'ui_selected';
			/* Open IF / FOR / BKT */
			if(stretch_idStrChk(STRETCH_ID_CHK_LEAD, listId) && g_program_data[listId].stretch.state === 'stretch_open') {
				/* nest line color change */
				nestLineColorChange(listId, 'ui_selected');
			}
		}
	}
	else {
		g_selected.push(g_selectStartPos);
	}
}

/*
 =========================================================================
 @function name    : iconRemove_drop
 @argument[event]  : 
 @description      : Processing when dropping icons outside the timeline
 @return           : addId
 =========================================================================
*/
var g_multiSel_dragdel_flg = false;
function iconRemove_drop(event) {
	var record_del_id = [];
	var record_contents = [];

	cancel_autoScroll('all');

	/* Normal mode & Drop outside the timeline area */
	if(g_delReady_flg === event.item.id) {
		/* Initialize image replacement management flag */
		g_delReady_flg = '';
		if(g_TL_selectModeFlg) {
			var TLAreaOffset = parts_timeline.getBoundingClientRect();
			var evt = event.originalEvent.changedTouches ? event.originalEvent.changedTouches[0] : event.originalEvent;
			if(TLAreaOffset.bottom < evt.pageY) {
				nestCurveHidden('');
				return;
			}
			change_TLselectMode(SELECT_MODE_NONE);
			toast.show(langResource.ihmieditor_pop_canceled_c);
		}
		else {
			if(event.item.id.substr(0, "-INST_ARC_HANDLE_TEACH".length) === "-INST_ARC_HANDLE_TEACH") {
				if(g_btnTeaching_list.weldteach.existsTimeline == true) {
					if (g_program_data[g_btnTeaching_list.weldteach.id].remark == false) {
						/* Redraw to restore. */
						tl_dispRange();
						weldingExitConfirm();
						return;
					} else {
						top.setArcTeachFg(false);
						weldingTeachEnd(false);			  
					}
				}
			}
			/* The icon to be deleted is active */
			if(activeTarget === event.item.id) icon_inactive();
			/* bracket lead */
			if(stretch_idStrChk(STRETCH_ID_CHK_LEAD, event.item.id)) {
				/* Retain the information in bracket. */
				for(var cnt = 0; cnt < g_program_data[event.item.id].stretch.idList.length; cnt++) {
					record_del_id[record_del_id.length] = (g_program_data[event.item.id].stretch.idList[cnt].id);
					var tmpdata = JSON.parse(JSON.stringify(g_program_data[g_program_data[event.item.id].stretch.idList[cnt].id]));
					tmpdata.select = '';
					record_contents.push(tmpdata);
				}
			} else {
				record_del_id[record_del_id.length] = event.item.id;
				record_contents[record_contents.length] = g_program_data[event.item.id];
			}
			var record_data = {
				id: record_del_id,
				contents: record_contents,
				place1: g_program_data[record_del_id[0]].array_num,
				place2: event.newIndex,
				type: OPERATION_DELETE
			}
			timeline_record.array_add(record_data);
			check_undoredo_active();
			delete_icon(event.item.id);
			
			position_record.array_add(position);
			positionregi_record.array_add(g_position_regi);
			/* Pop-up display */
			toast.show(langResource.ihmieditor_pop_deleted_c);
			if (event.item.id.substr(0, "-INST_WRIST_BUTTON_TEACH".length) === "-INST_WRIST_BUTTON_TEACH" || event.item.classList.contains('include_wbt')) {
				init_btnTeaching_list('wristteach');
				toast.show(langResource.ihmieditor_pop_wristteach_comp_c);
				top.setWristTeachFg(false);
			}
		}
		timelineScrlbarUpdate();
	}
	else {
		if(g_tlScroll_direction == TL_SCRL_VRTCL && event.from.id == 'TimeLineArea') {
			/* Drag end outside the timeline area */
			if(!tlAreaChk(event.originalEvent)) {
				toast.show(langResource.ihmieditor_pop_canceled_c);
			}
		}
	}
}
/*
 =========================================================================
 @function name    : iconRemove_move
 @argument[event]  : 
 @description      : Icons on the timeline. Area inside / outside image replacement processing
 @return           : none
 =========================================================================
*/
function iconRemove_move(event) {
	event.preventDefault();
	if(g_tlmove_ghost === '') {
		return false;
	}
	else {
		if(activeTarget === '') {
			$(g_tlmove_ghost).removeClass('TL_active');
		}
	}
	var delChkFlg = false, delAreaOffset = null;
	var ghostRect = g_tlmove_ghost.getBoundingClientRect();
	/* Vertical view */
	if(g_tlScroll_direction == TL_SCRL_VRTCL) {
		delAreaOffset = document.getElementById('overlay_tl_dispOption').getBoundingClientRect();
		/* Area check */
		delChkFlg = (delAreaOffset.left <= ghostRect.right && delAreaOffset.right >= ghostRect.left && delAreaOffset.bottom >= ghostRect.top);
	}
	/* Horizontal view */
	else {
		delChkFlg = !tlAreaChk(event);
	}
	/* Scrollable check */
	dragging_tlScrollChk(delAreaOffset, ghostRect);

	/* Drag outside the timeline area */
	if(delChkFlg) {
		/* Hide trash icon */
		if(g_delReady_flg === '') {
			/* Trash icon display */
			g_delReady_flg = g_tlmove_ghost.id;
			if(!g_TL_selectModeFlg) {
				$(g_tlmove_ghost).addClass('dustbox');
			}
		}
	}
	/* Drag into the timeline area */
	else {
		/* Trash icon displayed */
		if(g_delReady_flg !== '') {
			/* Hide trash icon */
			g_delReady_flg = '';
			if(!g_TL_selectModeFlg ||
			   (g_TL_selectModeFlg && multiSelect_opeType === OPETYPE_CUT)) {
				$(g_tlmove_ghost).removeClass('dustbox');
			}
		}
	}
}

/*
 =========================================================================
 @function name           : dragging_tlScrollChk
 @argument[delAreaOffset] : Coordinates of area to be deleted at instruction drop for vertical view.
 @argument[ghostRect]     : Coordinates of the instruction icon being dragged.
 @description             : Check if auto-scrolling by instruction drag is required.
 @return                  : none
 =========================================================================
*/
var g_autoScroll_timerId = {vrtcl: null, hrzn: null};
function dragging_tlScrollChk(delAreaOffset, ghostRect) {
	var scrlWrpRect = scrlWrpElm.getBoundingClientRect();
	var scrollVal = {vrtcl: scrlWrpElm.scrollHeight - scrlWrpElm.offsetHeight,
					 hrzn: scrlWrpElm.scrollWidth - scrlWrpElm.offsetWidth};

	/** Timeline auto-scrolling **/
	var autoScroll = function(direct) {
		/* vertical */
		if(direct == 'top' || direct == 'bottom') {
			var setTopVal = scrlWrpElm.scrollTop + ((direct == 'top') ? -10 : 10);
			setTopVal = (setTopVal < 0) ? 0 : (setTopVal > scrollVal.vrtcl) ? scrollVal.vrtcl : setTopVal;
			/* Set the scroll position. */
			scrlWrpElm.scrollTop = setTopVal;
		}
		/* horizontal (direct == 'left' || direct == 'right') */
		else {
			var setLeftVal = scrlWrpElm.scrollLeft + ((direct == 'left') ? -10 : 10);
			setLeftVal = (setLeftVal < 0) ? 0 : (setLeftVal > scrollVal.hrzn) ? scrollVal.hrzn : setLeftVal;
			/* Set the scroll position. */
			scrlWrpElm.scrollLeft = setLeftVal;
		}
	}
	/** Issue interval timer for auto scrolling **/
	var intervalStart = function(direct) {
		var interVal = 24;
		if(direct == 'top' || direct == 'bottom') {
			/* timer start for vertical */
			if(g_autoScroll_timerId.vrtcl == null) {
				g_autoScroll_timerId.vrtcl = setInterval(function() { autoScroll(direct) }, interVal);
			}
		}
		/* (direct == 'left' || direct == 'right') */
		else {
			if(g_autoScroll_timerId.hrzn == null) {
				/* timer start for horizontal */
				g_autoScroll_timerId.hrzn = setInterval(function() { autoScroll(direct) }, interVal);
			}
		}
	}

	/* auto scroll area check */
	var scrl_vrt = null, scrl_hrzn = null;
	var startArea = (g_tlmove_ghost.id == 'sel_data' ||                 /* true: programming area / false: timeline area*/
					 (g_tlmove_ghost.id != 'sel_data' &&
					  parts_block.classList.contains('prog_adding')));
	/* vertical view */
	if(g_tlScroll_direction == TL_SCRL_VRTCL) {
		if((scrlWrpRect.top + 20) >= ghostRect.top) {
			scrl_vrt = 'top';
		}
		else if((!startArea && (scrlWrpRect.bottom - 20) <= ghostRect.bottom) ||                                        /* Drag started from timeline area. */
				(startArea && scrlWrpRect.bottom >= ghostRect.top && (scrlWrpRect.bottom - 20) <= ghostRect.bottom)) {  /* Drag started from programming area. */
			scrl_vrt = 'bottom';
		}
		else {}
	}
	/* horizontal view */
	else {
		/* Vertical direction */
		scrl_vrt = ((scrlWrpRect.top + 20) >= ghostRect.top) ? 'top' :
						(!startArea && (scrlWrpRect.bottom - 20) <= ghostRect.bottom) ? 'bottom' : null;
		/* Horizontal direction */
		if((scrlWrpRect.top - 20) <= ghostRect.top && (scrlWrpRect.bottom + 20) >= ghostRect.bottom) {
			scrl_hrzn = ((scrlWrpRect.left + 20) >= ghostRect.left) ? 'left' :
							((scrlWrpRect.right - 20) <= ghostRect.right) ? 'right' : null;
		}
	}

	/* Vertical scroll control */
	if(scrl_vrt == null) {
		cancel_autoScroll('vertical');
	}
	else {
		intervalStart(scrl_vrt);
	}
	/* Horizontal scroll control */
	if(scrl_hrzn == null) {
		cancel_autoScroll('horizontal');
	}
	else {
		intervalStart(scrl_hrzn);
	}

	/* vertical view */
	if(g_tlScroll_direction == TL_SCRL_VRTCL) {
		/* Area check for delete */
		if(!startArea && delAreaOffset.left <= ghostRect.right &&
		   delAreaOffset.right >= ghostRect.left && (delAreaOffset.bottom + 25) > ghostRect.top) {
			cancel_autoScroll('all');
			$(parts_timeline).addClass('tlScrollFix');
		}
		else {
			$(parts_timeline).removeClass('tlScrollFix');
		}
	}
}


/*
 =========================================================================
 @function name : cancel_autoScroll
 @argument[]    : none
 @description   : Stop auto scroll.
 @return        : none
 =========================================================================
*/
function cancel_autoScroll(timerKind) {
	if(timerKind == 'vertical' || timerKind == 'all') {
		if(g_autoScroll_timerId.vrtcl != null) {
			clearInterval(g_autoScroll_timerId.vrtcl);
			g_autoScroll_timerId.vrtcl = null;
		}
	}
	if(timerKind == 'horizontal' || timerKind == 'all') {
		if(g_autoScroll_timerId.hrzn != null) {
			clearInterval(g_autoScroll_timerId.hrzn);
			g_autoScroll_timerId.hrzn = null;
		}
	}
}

/*
 =========================================================================
 @function name     : drawNestLine
 @argument[leadElm] : 
 @description       : Nest line drawing
 @return            : none
 =========================================================================
*/
function drawNestLine(leadElmId) {
	var leadElm = document.getElementById(leadElmId);
	/* Get first ID */
	var endId = get_stretch_pairId(leadElmId, REQ_ID_KIND_END, null);
	var lineColor = '';
	
	/* Active */
	if(leadElmId === activeTarget) {
		lineColor = 'TL_active';
	}
	else {
		if(leadElm) {
			if(leadElm.classList.contains('ui_selected')) {
				lineColor =  leadElm.classList.contains('multiselected') ? 'multiselected' : 'ui_selected';
			}
		}
	}
	
	/* nest line drawing */
	nestLineColorChange(leadElmId, lineColor);
}

/*
 =========================================================================
 @function name        : nestLineColorChange
 @argument[leadId]     : ID of the lead instruction.
 @argument[newClass]   : A new class name to be added to the nested line element.
 @description          : [Timeline] nest line color change
 @return               : none
 =========================================================================
*/
function nestLineColorChange(leadId, newClass) {
	var rmvClass = 'TL_active ui_selected multiselected';
	var nestSetInfo = function(id, nest, setClass) {
		var chkElm = document.getElementById(id);;
		var idx = g_program_data[id].nest.layer.find(function(data) {
			return data.row == nest;
		});
		if(idx) g_program_data[id].nest.layer[g_program_data[id].nest.layer.indexOf(idx)].color = setClass;
		if(chkElm) {
			$('.nestlayer_' + nest, chkElm).removeClass('TL_active ui_selected multiselected');
			$('.nestlayer_' + nest, chkElm).addClass(setClass);
		}
	};
	var targetElm = document.getElementById('nestline_' + leadId);
	if(targetElm) {
		$(targetElm).removeClass(rmvClass);
		if(newClass !== '') {
			$(targetElm).addClass(newClass);
		}
	}
	
	if(g_program_data[leadId].stretch.state === 'stretch_open') {
		for(var cnt = 1; cnt < g_program_data[leadId].stretch.idList.length - 1; cnt++) {
			nestSetInfo(g_program_data[leadId].stretch.idList[cnt].id, g_program_data[leadId].stretch.idList[0].dispNest, newClass);
		}
		if(g_program_data[leadId].baseId === 'iflead') {
			var elseId = get_stretch_pairId(leadId, REQ_ID_KIND_ELSE, null);
			var result = g_program_data[leadId].stretch.idList.find(function(data) { return data.id === elseId; });
			if(result) {
				var targetElseElm = document.getElementById('nestline_' + elseId);
				if(targetElseElm) {
					$(targetElseElm).removeClass(rmvClass);
					if(newClass !== '') {
						$(targetElseElm).addClass(newClass);
					}
				}
			}
		}
		
		var targetEndElm = document.getElementById('nestline_' + get_stretch_pairId(leadId, REQ_ID_KIND_END, null));
		if(targetEndElm) {
			$(targetEndElm).removeClass(rmvClass);
			if(newClass !== '') {
				$(targetEndElm).addClass(newClass);
			}
		}
	}
}

/*
 =========================================================================
 @function name     : programIcon_drop
 @argument[dropElm] : Elements added to the timeline.
 @description       : Processing when dropping from the programming area to the timeline
                    : ID assignment, icon image replacement
 @return            : addflg
 =========================================================================
*/
var g_latest_registBaseId = '';
function programIcon_drop(dropElm) {
	var addflg = false;
	
	/* Drop destination is timeline area and drag target id is retained */
	if((dropElm.parentElement.id == 'TimeLineArea') && (touchId !== '')) {
		/* Search information in table */
		var baseId = iconSortTbl.find(function(key) {
			return touchId == key || touchId == key + '_all' || touchId == key + '_history';
		});
		/* Search information in favorite list */
		var targetInfo = "";
		if(!baseId && touchId.indexOf('_fav') != -1) {
			targetInfo = g_favoriteList.find(function(target) {
				return touchId == target.indexId || touchId == target.indexId + '_history';
			});
			baseId = targetInfo.iconName;
		}
		/* Search information in arc list */
		var arcMotionFlg = false;
		if(!baseId && ['straight_arc', 'curve_arc', 'straight_arc_history', 'curve_arc_history'].includes(touchId)) {
			if(touchId.indexOf('_history') != -1) touchId = touchId.replace('_history', '');
			if(arcMotionTbl[touchId]) {
				baseId = arcMotionTbl[touchId].baseId;
				targetInfo = {'indexId' : touchId};
				arcMotionFlg = true;
			}
		}
		if(baseId) {
			var addNum = 1;
			if(stretch_idStrChk(STRETCH_ID_CHK_ALL, baseId)) {
				addNum = (baseId === 'iflead') ? 3 : 2;
			}
			if(g_TL_progInfo.saveProg.length + addNum > MAX_LINE_COUNT) {
				/* Pop-up display due to excessive number of lines. */
				popup_lineCountMax();
				dropElm.remove();
				//Initialization
				touchId = '';
				return addflg;
			}
			/* id replacement */
			dropElm.id = baseId + iconTbl[baseId].idCnt;
			iconTbl[baseId].idCnt = iconTbl[baseId].idCnt+ 1;
			
			/* Add to g_program_data */
			g_program_data[dropElm.id] = set_icon_data(baseId);
			if(baseId == 'payload' && payload_motionGrpChk()) g_program_data[dropElm.id].param = init_overwrite_param['payload'].param;
			set_linear_limitSpeed(dropElm.id, baseId);
			/*If the drop source is arcTab and drop icon is straight or curve, then disp is Weld speed. */
			if(arcMotionFlg) {
				g_program_data[dropElm.id].speed = {method: '', val: langResource.ihmieditor_order_weld_speed_c, unit: ''};
				g_program_data[dropElm.id].route = {stop: langResource.ihmieditor_order_nameraka_c, val: '100'}
			}
			/* if drop icon is from favorite tab, param is g_favoProg_data. */
			if(g_favoriteFlg.favoDrop) dropFavoriteIcon_setParam(dropElm.id);
			/* Dropped instruction class is "stretch" */
			if(stretch_idStrChk(STRETCH_ID_CHK_LEAD, baseId) === true) {
				/* Icon replacement */
				chg_icon(dropElm, baseId, 'stretch_open');
				/* g_program_data [] Additional processing */
				add_g_program_followOrder(dropElm, baseId);
				order_nestChk(dropElm.id);
			}
			else {
				/* With location information */
				if(dropElm.classList.contains('posTeach')) {
					/*When posinfo is specified, only the selected pin is displayed. */
					var posInfo = getPosInfoList(dropElm.id);
					if (posInfo.flg.length > 0) {
						chkPosInfo(null, g_program_data[dropElm.id].param, dropElm.id, posInfo);
					} else {
						for(var pos = 0; pos < g_program_data[dropElm.id].position.length; pos++) {
							if(g_program_data[dropElm.id].position[pos].number === 0) {
								g_program_data[dropElm.id].position[pos].number =
														(g_program_data[dropElm.id].position[pos].kind === 1) ? posIndex_get() : 1;
							}
							/* Create position pin. */
							if(g_program_data[dropElm.id].position[pos].disp == 'ON' && pos < 4){
								addPosTriangle(dropElm, g_program_data[dropElm.id].position[pos].number, pos);
							}
						}
					}
				}
			}
			/* Without position data. */
			if(dropElm.classList.contains('posTeach') != true) {
				position_record.array_add(position);
				/* If position data is available, process upon successful save. */
			}
			positionregi_record.array_add(g_position_regi);
			
			if(baseId === '-INST_ARC_HANDLE_TEACH') {
				progdata_addClassCheck(dropElm.id, 'excl_mark');
				/* Arc Teach=classadd "weldingteach" */
				progdata_addClassCheck(dropElm.id, 'weldingteach');
				g_btnTeaching_list.weldteach.existsTimeline = true;
				g_btnTeaching_list.weldteach.id = dropElm.id;
				g_btnTeaching_list.weldteach.count++;
				//WeldingTeach 
				weldingTeachStart();
				top.setArcTeachFg(true);
			} else if (baseId === '-INST_WRIST_BUTTON_TEACH') {
				g_program_data[dropElm.id].param = g_program_data[dropElm.id].param.replace("'spd'", String(g_limitSpeed));
				top.setWristTeachFg(true);
				g_btnTeaching_list.wristteach.existsTimeline = true;
				g_btnTeaching_list.wristteach.id = dropElm.id;
				g_btnTeaching_list.wristteach.count++;
			}
			/*default icon is baseId, favorite icon & arc mortion icon is touchId.*/
			g_latest_registBaseId = !targetInfo ? baseId : targetInfo.indexId;
		}
		
		//Initialization
		touchId = '';
	}
	addflg = true;
	
	return addflg;
}

/*
 =========================================================================
 @function name       : set_linear_limitSpeed
 @argument[id]        : 
 @argument[iconIndex] : 
 @description         : 
 @return              : none
 =========================================================================
*/
function set_linear_limitSpeed(id, baseId) {
	//The initial display of the speed when the welding start order is dropped is displayed as "constant".
	var limitSpdMtn = ['straight', 'vsnline', 'curve', 'circlearc', 'spline', 'laserpre', 'laserls', 'laserle', 'lasercls', 'lasercle', 'lasercals', 'lasercale', 'lasersls', 'lasersle', 'weldstartml', 'weldstartca'];
	if(limitSpdMtn.indexOf(baseId) >= 0) {
		var setVal = g_cobot_flg ? g_limitSpeed : 100;
		g_program_data[id].speed.val = setVal.toString();
	}
}

/*
 =========================================================================
 @function name    : latestCommand_check
 @argument[baseId] : 
 @description      : Add icon history check
 @return           : none
 =========================================================================
*/
function latestCommand_check(baseId) {
	var dupchk = '';
	for(var cnt = 0; cnt < g_latest_command.length; cnt++) {
		if(g_latest_command[cnt] == baseId) {
			dupchk = cnt;
			break;
		}
	}
	if(dupchk === '') {
		/* Already have 5 history. */
		if(g_latest_command.length === LATEST_CMD_MAX) {
			/* Delete the first data. */
			g_latest_command.shift();
		}
		
		/* Add to the end. */
		g_latest_command.push(baseId);
	}
	else {
		/* Delete the specified data. */
		g_latest_command.splice(cnt, 1);
		/* Add to the end. */
		g_latest_command.push(baseId);
	}
	/* Save to systemVariable */
	var argObj = {};
	setHistSysValXHR(setHistSysValXHRCallback,argObj);
}
function setHistSysValXHRCallback(status, getText, cbArgs) {
}

/*
 =========================================================================
 @function name : add_latestHistory_programmingTab
 @argument      : none
 @description   : Add history icon to programming tab
 @return        : none
 =========================================================================
*/
function add_latestHistory_programmingTab() {
	var targetElm = document.getElementById('cat_his');
	var indexArray = [], favIndex = {};
	/* Selection of icons to be displayed */
	for(var k in g_latest_command) {
		/* Check target icon is exist. */
		for(var tblKey in iconTbl) {
			if(g_latest_command[k] == tblKey || g_latest_command[k] == (tblKey + '_arc')) {
				indexArray.push(g_latest_command[k]);
				break;
			}
		}
		/* Check target icon is favorite. */
		var favChk = g_favoriteList.find(function(data) {return data.indexId == g_latest_command[k]});
		/* It exists in the favorite list and is subject to icon display.  */
 		if(favChk && iconTbl[favChk.iconName].category != '') {
			/* save favorite history index.*/
			favIndex[indexArray.length] = g_favoriteList.indexOf(favChk);
			indexArray.push(g_latest_command[k]);
		}
	}

	targetElm.innerHTML = '';
	if(!indexArray.length) return;
	/* Add an icon to the history tab */
	for(var cnt = indexArray.length - 1; cnt >= 0 ; cnt--) {
		if(typeof favIndex[cnt] == 'undefined') {
			/* disp default icon history. */
			programingArea_addIcon(indexArray[cnt], 'cat_his');
		}
		else {
			/* disp favorite icon history. */
			programingArea_addFavoIcon(g_favoriteList[favIndex[cnt]], 'cat_his');
		}
	}
}

/*
 =========================================================================
 @function name    : iconDrop_TLScroll
 @argument[event]  : 
 @description      : Scroll timeline area when dropping icons
 @return           : none
 =========================================================================
*/
var g_TL_scrolling = false;
function iconDrop_TLScroll(posId) {
	if(g_tlScroll_direction != TL_SCRL_VRTCL && scrlWrpElm.scrollWidth == scrlWrpElm.clientWidth ||
	   g_tlScroll_direction == TL_SCRL_VRTCL && scrlWrpElm.scrollHeight == scrlWrpElm.clientHeight) {
		/* No need for auto-scrolling. */
		tl_adjust_dispRange();
		return;
	}

	var scrlVal = 0;
	var scrlIndx = g_TL_progInfo.dispProg.indexOf(posId);
	if(scrlIndx == -1) return;

	if(g_tlScroll_direction == TL_SCRL_VRTCL) {
		scrlVal = iconDrop_TLScroll_vrtcl(scrlIndx);
	}
	else {
		scrlVal = iconDrop_TLScroll_hrzn(scrlIndx);
	}

	var timeoutFunc = function() {
		g_TL_scrolling = false;
		TL_autoScrolling_opeDisable();
		tl_adjust_dispRange();
		scrollboost_positionSet();
	}

	/* Need scrolling */
	if(g_TL_scrolling) {
		TL_autoScrolling_opeDisable();
		/* Scroll direction == vertical */
		if(g_tlScroll_direction == TL_SCRL_VRTCL) {
			$(scrlWrpElm).animate({'scrollTop' : scrlVal}, 500, timeoutFunc());
		}
		/* Scroll direction == horizontal */
		else {
			$(scrlWrpElm).animate({'scrollLeft' : scrlVal}, 500, timeoutFunc());
		}
	}
	/* No need for auto-scrolling. */
	else {
		tl_adjust_dispRange();
	}
}

/*
 =========================================================================
 @function name      : iconDrop_TLScroll_hrzn
 @argument[scrlIndx] : Array number of the instruction ID to be displayed.
 @description        : Scroll timeline area when dropping icons
 @return             : scrollLeft value
 =========================================================================
*/
function iconDrop_TLScroll_hrzn(scrlIndx) {
	var padding = Number($(g_TL_elm).css('padding-left').replace('px', '')),
		targetLeft = (scrlIndx * TL_ICON_WIDTH_OUTER) + padding + 10,                             /* 10 == Instruction left side margin */
		dispRange = {left: scrlWrpElm.scrollLeft + TL_ICON_WIDTH_OUTER,                           /* The left-hand edge of the current display position */
					 right: scrlWrpElm.scrollLeft + scrlWrpElm.clientWidth - TL_ICON_WIDTH_OUTER, /* Right-hand edge of the current display position */
					 leftLineNum: Math.ceil(scrlWrpElm.scrollLeft / TL_ICON_WIDTH_OUTER),         /* Number of lines shown on the left-hand side of the screen. */
					 rightLineNum: Math.floor((scrlWrpElm.scrollLeft + scrlWrpElm.clientWidth) / TL_ICON_WIDTH_OUTER), /* Number of lines shown on the right-hand side of the screen */
					 min: 0,                                                                      /* Minimum value of scrollLeft */
					 max: scrlWrpElm.scrollWidth - scrlWrpElm.clientWidth},                       /* Maximum value of scrollLeft */
		scrlLeft = targetLeft - padding,                                                          /* scrollLeft value */
		scrlDirect = dispRange.rightLineNum < (scrlIndx + 1);                                     /* true : Target position is to the right of the current display position */

	/* To add to the right side, adjust the value of scrlLeft. */
	if(scrlDirect) scrlLeft = targetLeft - (scrlWrpElm.clientWidth - (TL_ICON_WIDTH_OUTER * 2));
	/* **failsafe** If the maximum scroll value is exceeded, the MAX value is used. */
	if(dispRange.max < scrlLeft) scrlLeft = dispRange.max;

	/* Out of display range */
	if(targetLeft < dispRange.left || targetLeft > dispRange.right) {
		g_TL_scrolling = true;
		scrlLeft = (targetLeft < dispRange.left) ? (scrlLeft - TL_ICON_WIDTH_OUTER) : scrlLeft;
	}

	return scrlLeft;
}

/*
 =========================================================================
 @function name      : iconDrop_TLScroll_vrtcl
 @argument[scrlIndx] : Array number of the instruction ID to be displayed.
 @description        : Scroll timeline area when dropping icons
 @return             : scrollTop value
 =========================================================================
*/
function iconDrop_TLScroll_vrtcl(scrlIndx) {
	var targetRow = Math.ceil((scrlIndx + 1) / get_dispWidth_iconNum()),                      /* Target row */
		targetRowTop = (targetRow - 1) * BASE_VERTICAL_TL_HEIGHT,                             /* Target row position */
		dispRange = {top: scrlWrpElm.scrollTop,                                               /* Current scroll position : top */
					 bottom: scrlWrpElm.scrollTop + scrlWrpElm.clientHeight,                  /* Current scroll position : bottom */
					 upperRowNum: Math.ceil(scrlWrpElm.scrollTop / BASE_VERTICAL_TL_HEIGHT),  /* Top row in the display. */
					 lowerRowNum: Math.floor((scrlWrpElm.scrollTop + scrlWrpElm.clientHeight) / BASE_VERTICAL_TL_HEIGHT), /* Bottom row in the display */
					 min: 0,                                                                  /* Minimum value of scrollTop */
					 max: scrlWrpElm.scrollHeight - scrlWrpElm.clientHeight},                 /* Maximum value of scrollTop */
		scrlTop = targetRowTop,                                                               /* scrollTop value */
		scrlDirect = dispRange.lowerRowNum < targetRow;                                       /* true : targetRow position is to the lower of the current display position. */

	/* To add to the right side, adjust the value of scrlLeft. */
	if(scrlDirect) scrlTop = targetRowTop - (scrlWrpElm.clientHeight - BASE_VERTICAL_TL_HEIGHT);
	/* **failsafe** If the maximum scroll value is exceeded, the MAX value is used. */
	if(dispRange.max < scrlTop) scrlTop = dispRange.max;

	/* Out of display range */
	if(targetRowTop < dispRange.top || (targetRowTop + BASE_VERTICAL_TL_HEIGHT) > dispRange.bottom) {
		g_TL_scrolling = true;
	}

	return scrlTop;
}

/*
 =========================================================================
 @function name  : TL_autoScrolling_opeDisable
 @argument       : none
 @description    : progicon area scrollbar control.
 @return         : none
 =========================================================================
*/
function TL_autoScrolling_opeDisable() {
	if(g_TL_scrolling) {
		$(g_TL_elm).addClass('scrolling');
		if(sortableTimeLine) sortableTimeLine.option('disabled', true);
	}
	else {
		$(g_TL_elm).removeClass('scrolling');
		if(sortableTimeLine) sortableTimeLine.option('disabled', false);
	}
}

/*
 =========================================================================
 @function name   : order_nestChk
 @argument[chkId] : LEAD ID to be checked.
 @description     : Stretch instruction. Set the nest number.
 @return          : none
 =========================================================================
*/
function order_nestChk(chkId) {
	if(stretch_idStrChk(STRETCH_ID_CHK_LEAD_N_EQ, chkId)) return false;
	
	/* Extract LEAD, END, and ELSE from the program. */
	var stretchArray = g_TL_progInfo.bktSaveProg.slice(0, (g_TL_progInfo.saveProg.indexOf(chkId) + 1));
	var chkIdx = stretchArray.indexOf(chkId);
	/* Check the nesting number of the previous stretch instruction. */
	var prevId = chkIdx > 0 ? stretchArray[chkIdx - 1] : '';
	var prevInstNestNum = (prevId) ? g_program_data[prevId].nest.num : 0;
	/* Current nest number of the stretch instruction to be checked. */
	var myNestNum = g_program_data[chkId].nest.num;
	
	var addNestNum = 0;
	/* The previous stretch instruction does not have a nest number. */
	if(prevInstNestNum === 0) {
		addNestNum = 1;
	}
	/* A nest number is set for the previous stretch instruction. */
	else {
		/* If the previous instruction is other than END, the nesting is one step deeper. */
		addNestNum = (stretch_idStrChk(STRETCH_ID_CHK_END_N_EQ, prevId)) ?
						(prevInstNestNum + 1) : prevInstNestNum;
	}
	
	/* The check result is different from the current nest number. */
	if(addNestNum != myNestNum) {
		/* Update the nest number. */
		g_program_data[chkId].nest.num = addNestNum;
	}
}

/*
 =========================================================================
 @function name   : get_order_nestClass
 @argument[chkId] : 
 @description     : Telescopic instruction. Get class for nest
 @return          : nestClass
 =========================================================================
*/
function get_order_nestClass(chkId) {
	var nestClass = "";
	if(chkId != null) {
		var leadId = get_stretch_pairId(chkId, REQ_ID_KIND_LEAD, null);
		if(g_program_data[leadId].nest.num > 0) {
			nestClass = 'order_nest_' + g_program_data[leadId].nest.num;
		}
	}
	return nestClass;
}

/*
 =========================================================================
 @function name    : set_order_nestCss
 @argument[bktId]  : 
 @argument[target] : 
 @description      : Telescopic instruction. Css setting for nest
 @return           : none
 =========================================================================
*/
var TARGET_PAIR        = 0;
var TARGET_ASSIGNED_ID = 1;
function set_order_nestCss(bktId, target) {
	var bktIdArray = [];
	if(target == TARGET_ASSIGNED_ID) {
		bktIdArray.push(bktId);
	}
	else {
		bktIdArray.push(get_stretch_pairId(bktId, REQ_ID_KIND_LEAD, null));
		bktIdArray.push(get_stretch_pairId(bktId, REQ_ID_KIND_END, null));
		if(stretch_idStrChk(STRETCH_ID_CHK_IF, bktId)) {
			bktIdArray.push(get_stretch_pairId(bktId, REQ_ID_KIND_ELSE, null));
		}
	}

	var tmpLeadId = get_stretch_pairId(bktIdArray[0], REQ_ID_KIND_LEAD, null);
	if(g_tlScroll_direction == TL_SCRL_VRTCL) {
		var maxNum = MAX_NESTLINE_NUM_VRTCL;
		var limitClass = 'dispnest_6';
	}
	else {
		var maxNum = MAX_NESTLINE_NUM;
		var limitClass = 'dispnest_20';
	}
	var nestOver = (g_program_data[tmpLeadId].stretch.idList[0].dispNest > maxNum) ? true : false;
	var nestClass = (!nestOver) ? 'dispnest_' + g_program_data[tmpLeadId].stretch.idList[0].dispNest : limitClass;
	for(var cnt = 0; cnt < bktIdArray.length; cnt++) {
		$bktElm = $('#' + bktIdArray[cnt]);
		if($bktElm[0]) {
			$bktElm.removeClass('tlBottomOver');
			$bktElm.find('.stretchBackground').removeClass('dispnest_1 dispnest_2 dispnest_3 dispnest_4 dispnest_5 dispnest_6 ' +
															'dispnest_7 dispnest_8 dispnest_9 dispnest_10 dispnest_11 dispnest_12 ' +
															'dispnest_13 dispnest_14 dispnest_15 dispnest_16 dispnest_17 dispnest_18 dispnest_19 dispnest_20')
											  .addClass(nestClass);
			if(nestOver) $bktElm.addClass('tlBottomOver');
		}
	}
}

/*
 =========================================================================
 @function name      : add_g_program_followOrder
 @argument[leadElem] : 
 @argument[baseId]   : 
 @description        : Subsequent instruction holding process when expanding / contracting icon drop
 @return             : none
 =========================================================================
*/
function add_g_program_followOrder(leadElem, baseId) {
	var addId = leadElem.id;
	var saveNum = (g_program_data[leadElem.id].baseId === 'iflead') ? 3 : 2;
	var nestClass = get_order_nestClass(leadElem.id);
	var refElm = leadElem;
	
	/* Stretch data set */
	g_program_data[leadElem.id].stretch = {state:'stretch_open', idList:[]};
	for(var cnt = 0; cnt < saveNum; cnt++) {
		if(cnt > 0) {
			/* ID generation */
			var tblIdx = iconSortTbl.indexOf(g_program_data[leadElem.id].baseId);
			addId = iconSortTbl[tblIdx + cnt] + getSplitId(leadElem.id);
			iconTbl[iconSortTbl[tblIdx + cnt]].idCnt = iconTbl[iconSortTbl[tblIdx]].idCnt;
			
			/* Add to g_program_data */
			g_program_data[addId] = set_icon_data(iconSortTbl[tblIdx + cnt]);
			/* Create END or ELSE icon */
			var addElm = addIcon_create(addId, 'stretch_open');
			$(addElm).addClass(nestClass);
			refElm.after(addElm);
			refElm = addElm;
		}
		
		g_program_data[leadElem.id].stretch.idList[cnt] = JSON.parse(JSON.stringify(def_stretchData_struct));
		g_program_data[leadElem.id].stretch.idList[cnt].id = addId;
		g_program_data[leadElem.id].stretch.idList[cnt].nestNum = Number(nestClass.replace(/[^0-9]/g, ''));
	}
}

/*
 =========================================================================
 @function name  : border_slideCheck
 @argument       : none
 @description    : Slide check of the border with focus in/out
 @return         : none
 =========================================================================
*/
function border_slideCheck() {
	var slidFunc = function(evt) {
		if (evt.type != 'focus' && evt.type != 'blur') return;
		g_editor_status.detail_inputFocus = (evt.type == 'focus');
		if(g_editor_status.detail_inputFocus) {
			$('#timelineRestrict').addClass('textEditing');
		}
		else {
			$('#timelineRestrict').removeClass('textEditing');
		}
		if (top.irprogapi.getSlideScreenSide()) {
			var flg = (evt.type == 'focus');
			inputFocus_dispSlide(flg);
			inputFocus_slideForm(flg);
		}
	}
	$(document.getElementById(get_detail_frm_id(activeTarget))).contents().find("input[type='text']").on('focus blur', function(e) {
		slidFunc(e);
	});
	$(document.getElementById(get_detail_frm_id(activeTarget))).contents().find("input[type='tel']").on('focus blur', function(e) {
		slidFunc(e);
	});
	$(document.getElementById(get_detail_frm_id(activeTarget))).contents().find("input[type='number']").on('focus blur', function(e) {
		slidFunc(e);
	});
}

/*
 =========================================================================
 @function name  : input_focusout
 @argument       : none
 @description    : 
 @return         : none
 =========================================================================
*/
function input_focusout() {
	if (device == 'smt') {
		if(activeTarget != '') {
			var content = dtlfrm_contentchk(activeTarget);
			if(content != null && content.length != 0) {
				$(content[0]).trigger('click');
			}
			var dtfrmElm = document.getElementById(get_detail_frm_id(activeTarget));
			if(dtfrmElm != null &&
			   dtfrmElm.contentWindow.document.activeElement != null) {
				dtfrmElm.contentWindow.document.activeElement.blur();
			}
		}
		/* border slide up. */
		if (borderElemPos !== '') {
			setTimeout(inputFocus_dispSlide, 50, false);
		}
	}
}

/*
 =========================================================================
 @function name  : inputfocusEvt_Reregister
 @argument       : none
 @description    : Re-register the focus event.
 @return         : none
 =========================================================================
*/
function inputfocusEvt_Reregister() {
	/* Remove the event. */
	$(document.getElementById(get_detail_frm_id(activeTarget))).contents().find("input[type='text']").off('focus blur');
	$(document.getElementById(get_detail_frm_id(activeTarget))).contents().find("input[type='tel']").off('focus blur');
	$(document.getElementById(get_detail_frm_id(activeTarget))).contents().find("input[type='number']").off('focus blur');
	
	/* Register the event. */
	border_slideCheck();
}

/*
 =========================================================================
 @function name  : getProgramList
 @argument[subType]  : 
 @argument[callback] : A callback function to receive the program list.
 @description        : Get program (name) list of undefined type.
 @return             : StepMode
 =========================================================================
*/
function getProgramList(subType, callback) {
	top.lstProg(top.TV_PRG_ALL, top.MM_MNEPRG_C, subType, callback);  // io
}
/*
 =========================================================================
 @function name      : getKarelProgramList
 @argument[subType]  : 
 @argument[callback] : A callback function to receive the program list.
 @description        : Get program (name) list of undefined type.
 @return             : StepMode
 =========================================================================
*/
function getKarelProgramList(subType, callback) {
	top.lstProg(top.TV_PRG_ALL, top.MM_KRLPRG_C, subType, callback);  // io
}
/*
 =========================================================================
 @function name      : getKarelProgramListCB
 @argument[datatype] : 
 @argument[prglist]  : 
 @argument[listNum]  : 
 @description        : 
 @return             : 
 =========================================================================
*/
function getKarelProgramListCB(datatype, prglist, listNum) {
	prglist.pop();
	karelProgramFileList = [];
	for (var cnt = 0; cnt < prglist.length;cnt++){
		var insert_data = { "name": prglist[cnt], "type": "" }
		if (!prglist[cnt].match(/^IPL_.*/)) {
			karelProgramFileList.push(insert_data);
		}
	}
	top.rpcmc_gtmcrlst(getMacroListCB);
}

/////////////////////////////////////////////////////////////////////////////////
var currentLang = null; // Current language
var gcurrentLang = null; // Current language
var gcurrentJPLang = null; // Current language
/** Debug function **/
var DBGFATAL = 1;
var DBGERROR = 2;
var DBGWARN = 3;
var DBGINFO = 4;
var DBGDUMP = 5;
var debugLevel = DBGDUMP; // Debug level.
var debugDateOn = true; // Datetime add to message
var levelHead = ['', 'FATAL', 'ERROR', 'WARN ', 'INFO ', 'DUMP '];

/*
 =========================================================================
 @function name      : debug
 @argument[level]    : level
 @argument[message]  : message
 @description        : debug function.
 @return             : none
 =========================================================================
*/
function debug(level, message) {
	if (level <= debugLevel) {
		var dbgDttm = (debugDateOn) ? formatDateTime() : '';
		var dbgmsg = levelHead[level] + ':' + message;
		// console.log(dbgDttm + dbgmsg);
	}
}
/*
 =========================================================================
 @function name  : formatDateTime
 @argument       : none
 @description    : format DateTime
 @return         : format DateTime
 =========================================================================
*/
function formatDateTime() {
	var dtObj = new Date();
	var yStr = dtObj.getFullYear();
	var mStr = ('00' + (dtObj.getMonth() + 1)).slice(-2);
	var dStr = ('00' + dtObj.getDate()).slice(-2);
	var hStr = ('00' + dtObj.getHours()).slice(-2);
	var nStr = ('00' + dtObj.getMinutes()).slice(-2);
	var sStr = ('00' + dtObj.getSeconds()).slice(-2);
	var fmtStr = '[' + yStr + '/' + mStr + '/' + dStr + ' ' +
		hStr + ':' + nStr + ':' + sStr + ']';
	return fmtStr;
}

/*
 =========================================================================
 @function name  : debug_time_output
 @argument[str]  : message
 @description    : debug function.
 @return         : none
 =========================================================================
*/
function debug_time_output(str) {
	console.log(str + (Date.now() - 1617000000000) + ' ms');
}

/*
 =========================================================================
 @function name    : exe_column_setting
 @argument[column] : Column element
 @description      : Run line drag
 @return           : none
 =========================================================================
*/
var g_clm_drag_rowmv = false;
function exe_column_setting(column) {
	$(column).draggable({
		containment: '.exe_column_width',
		axis:'x',
		scroll:true,
		stop:function(event,ui) {
			/* When dragging is used to move rows. */
			if(g_clm_drag_rowmv) {
				g_clm_drag_rowmv = false;
				return;
			}
			var scroll_left = g_TL_elm.parentElement.parentElement.scrollLeft;
			var padding_size = parseInt($(g_TL_elm).css('padding-left').replace(/[^0-9.]/g,""));
			var stop_x = ui.position.left + padding_size + Math.floor($("#exe_column").outerWidth() / 2);
			var clmRow = getColumnRowFromTLTop();
			var fisrt_icon_left = padding_size;
			var last_icon_left = padding_size + 5;
			var rowIcnNum = get_dispWidth_iconNum();
			var remainder = g_TL_progInfo.dispProg.length % rowIcnNum;
			if(g_TL_progInfo.dispProg.length > 0) {
				last_icon_left = padding_size;
				if(g_tlScroll_direction == TL_SCRL_VRTCL) {
					var lastElmRow = getRowFromTLTop(g_TL_progInfo.dispProg[g_TL_progInfo.dispProg.length - 1]);
					var wdtIcnNum = (clmRow != lastElmRow || (clmRow == lastElmRow && remainder == 0)) ?
										rowIcnNum : remainder;
					last_icon_left += TL_ICON_WIDTH_OUTER * wdtIcnNum;
				}
				else {
					last_icon_left += TL_ICON_WIDTH_OUTER * g_TL_progInfo.dispProg.length;
				}
			}
			
			var numAdjust = (clmRow - 1) * rowIcnNum;
			if(fisrt_icon_left - scroll_left >= stop_x) {	/* Left of the first icon. */
				var exe_num = 1;
			} else if(last_icon_left < stop_x) {	/* Right of the last icon. */
				var exe_num = Math.ceil((last_icon_left - padding_size) / TL_ICON_WIDTH_OUTER);
			} else {
				var exe_num = Math.ceil((stop_x - padding_size) / TL_ICON_WIDTH_OUTER);
			}
			exe_num = exe_num < 1 ? 1 : exe_num + numAdjust;
			/* Move execution line to center of icon */
			g_columnRelationInfo.dispPosId = g_TL_progInfo.dispProg[exe_num - 1];
			exe_column_move(exe_num);
			columnPosInfoUpdate(false);
			notify_setLine();
			/* scrollBooster Update scroll start position */
			scrollboost_positionSet();
		},
		start:function(event,ui) {
		},
		drag:function(event,ui) {
			if(g_clm_drag_rowmv) return;
			if(g_tlScroll_direction == TL_SCRL_VRTCL) {
				var clmMvLmt = g_TL_elm.getElementsByClassName('exe_column_width')[0].getBoundingClientRect();
				
				if(Math.floor(clmMvLmt.left + 1) >= Math.floor(ui.offset.left)) {
					var clmRow = getColumnRowFromTLTop();
					if(clmRow > 1) {
						var exe_num = (clmRow - 1) * get_dispWidth_iconNum();
					}
				}
				else if(Math.floor(clmMvLmt.right - 1) <= Math.floor(ui.offset.left + $(this).outerWidth())) {
					var clmRow = getColumnRowFromTLTop();
					if(clmRow < getRowFromTLTop(g_TL_progInfo.dispProg[g_TL_progInfo.dispProg.length - 1])) {
						var exe_num = (clmRow * get_dispWidth_iconNum()) + 1;
					}
				}
				
				if(typeof exe_num != 'undefined') {
					g_columnRelationInfo.dispPosId = g_TL_progInfo.dispProg[exe_num - 1];
					exe_column_move(exe_num);
					/* Move execution line to center of icon */
					columnPosInfoUpdate(false);
					notify_setLine();
					g_clm_drag_rowmv = true;
				}
			}
		}
	});
}

/*
 =========================================================================
 @function name  : notify_setLine
 @argument[]     : none
 @description    : Notify the number of starting lines and update the main program information as needed.
 @return         : none
 =========================================================================
*/
function notify_setLine() {
	/* Program is aborting and the default and current programs are different. */
	if(currentProgVal.stat == I_WATCHEXEC_ABORTED) {
		/* Set program start line. */
		top.rpcmc_setVar(top.SYSNAME_C, '$SHELL_WRK.$CURR_LINE', (g_columnRelationInfo.arrayNum + 1));
		currentProgVal.uniManual = true;
	}
	else {
		/* Set program start line. */
		top.setLine(current_prog_name, (g_columnRelationInfo.arrayNum + 1), null);
	}

}

/*
 =========================================================================
 @function name  : file_check
 @argument       : none
 @description    : Error check before reading
 @return         : none
 =========================================================================
*/
function file_check() {
  //get progattr
  top.irprogapi.getCurrentGroup(getProgDataXHR, null);
}

/*
 =========================================================================
 @function name  : getProgDataXHR
 @argument       : none
 @description    : Get program data
 @return         : none
 =========================================================================
*/
function getProgDataXHR() {
  // The currently selected program (the name of the main program even if a subprogram is running)
  getSysValXHR(['$TP_DEFPROG'], getProgDataXHRCallback);
}

/*
 =========================================================================
 @function name  : getProgDataXHRCallback
 @argument       : none
 @description    : Get program data callback
 @return         : none
 =========================================================================
*/
function getProgDataXHRCallback(status, getText) {
  var xmlObj = getSysValXmlData(getText, 'VAR');

  if (xmlObj == null) { return; } // Add error messages if needed.
  var convData = extractRcvXHRData(xmlObj, 'VAR');

  /* Initialize */
  init_switchProg_backup();

  /* Acquisition data is empty */
  if(convData['$TP_DEFPROG'] == '') {
    popup_notDisplayable(NO_DISPLAYABLE_POP_FULL);
    /* Initialization of reloading flag */
    tp_prog_name = current_prog_name = '';
    set_tl_dispName();
  }
  else {
    // update local variable
    tp_prog_name = convData['$TP_DEFPROG'];
    current_prog_name = convData['$TP_DEFPROG'];
    set_tl_dispName();

    var args = {prg: tp_prog_name, callfunc: getFileAttrPrtctCB};
    getFileAttrMotionGroup(args);
  }
}


/*
 =========================================================================
 @function name  : file_read
 @argument       : none
 @description    : Start reading file
 @return         : none
 =========================================================================
*/
function file_read() {
	updateProgramList(recentTopPrgCallback);
}

/*
 =========================================================================
 @function name  : setScrollbooster
 @argument       : none
 @description    : Scrollbooster setting
 @return         : none
 =========================================================================
*/
var scrollboost = '';
function setScrollbooster() {
	var direct = (g_tlScroll_direction == TL_SCRL_VRTCL) ? 'vertical' : 'all';
	
	if(scrollboost) scrollboost.destroy();
	
	scrollboost = new ScrollBooster({
		viewport: scrlWrpElm,
		content: document.getElementById("scrollContainer"),
		bounce: false,
		direction: direct,
		scrollMode: 'native',
		textSelection: false,
		friction: 0.06,
		onUpdate: (data) => {
		},
		shouldScroll: (data, event) => {
			/* Scrollable only for TimeLineArea */
			if(event.target.classList.contains('TimeLineArea') ||
			   event.target.classList.contains('timeLineBottom') ||
			   event.target.id == 'scrollWrap') {
				if(event.changedTouches || (!event.changedTouches && event.buttons === 0x01)) {
				//	chk_TL_scrolling();
					return true;
				}
				else {
					return false;
				}
			}
			else {
				return false;
			}
		},
		onClick: (data, event) => {
		}
	});
}


/*
 =========================================================================
 @function name  : selectMenu_dispUpdate
 @argument[val]  : update pattern
 @description    : enable / disable submenu icon
 @return         : none
 =========================================================================
*/
var MULTI_SEL_MENU_ICON_UD_00 = 0;
var MULTI_SEL_MENU_ICON_UD_01 = 1;
function selectMenu_dispUpdate(val) {
	var $selmenu = $('#iconSelectMenu');
	if(val === MULTI_SEL_MENU_ICON_UD_01) {
		var selIconElm = search_eventTarget(pressEvent.target, EVT_TARGET_KIND_ELM);
		var adjMenuTop = g_TL_elm.offsetTop + 5;
		/* Remarked instruction */
		if(g_program_data[selIconElm.id].remark) {
			$selmenu.addClass('remarked_selectMenu');
		}
		/* stretch icon */
		if(stretch_idStrChk(STRETCH_ID_CHK_ALL, selIconElm.id)) {
			$selmenu.addClass('stretch_selectMenu');
			if(selIconElm.classList.contains('stretch_open')) {
				$selmenu.addClass('stretch_open');
				document.getElementById('selectMenu_stretch').getElementsByTagName('span')[0].innerText = langResource.ihmieditor_submenu_shrink_c;
			} else {
				$selmenu.removeClass('stretch_open');
				document.getElementById('selectMenu_stretch').getElementsByTagName('span')[0].innerText = langResource.ihmieditor_submenu_expand_c;
			}
		}
		/* replace icon */
		if(replace_idStrChk(selIconElm.id)) {
			$selmenu.addClass('replace_selectMenu');
		}
		var rect = selIconElm.getBoundingClientRect();
		var tElmRect = g_TL_elm.getBoundingClientRect();
		/* Check if submenu is off screen */
		var menuWidth = $selmenu.outerWidth();
		var setLeftVal = (rect.right > (scrlWrpElm.clientWidth - menuWidth)) ?
							(scrlWrpElm.clientWidth - (menuWidth + 10)) : (rect.right - 20);
		$selmenu.css('left', setLeftVal);

		if(g_tlScroll_direction == TL_SCRL_VRTCL) {
			adjMenuTop = (selIconElm.offsetTop - scrlWrpElm.scrollTop) - $selmenu.height();
			adjMenuTop -= (stretch_idStrChk(STRETCH_ID_CHK_ALL, selIconElm.id) ? 35 : 10);
			/* Check if submenu is off screen */
			var topChk = scrlWrpElm.offsetTop + 5;
			if(adjMenuTop < topChk) adjMenuTop = topChk;
		}
		$selmenu.css('top', adjMenuTop).addClass('menu_active');
	}
	else {
		/* select menu update */
		var rmvClass = 'stretch_selectMenu replace_selectMenu menu_active stretch_open multi_selectMenu remarked_selectMenu';
		$selmenu.removeClass(rmvClass).css('left','');
	}
}

/*
 =========================================================================
 @function name  : progPopMenu_dispUpdate
 @argument[val]  : update pattern
 @description    : enable / disable progsubmenu icon
 @return         : none
 =========================================================================
*/
var PROG_SEL_MENU_ICON_UD_00 = 0;
var PROG_SEL_MENU_ICON_UD_01 = 1;
function progPopMenu_dispUpdate(val, targetElem) {
	var $popmenu = $('#progPopMenu');
	if(val === PROG_SEL_MENU_ICON_UD_01) {
		var menuWidth = 38;
		if(g_favoTargetData.dataId != "") {
			if(targetElem.id === g_favoTargetData.dataId + "_history") {
				/*press icon is history tab & favorite icon.*/
				$popmenu.addClass('hisTab_selectMenu');
			} 
			else {
				/*press icon is favorite tab.*/
				$popmenu.addClass('favoTab_selectMenu');
			}
			menuWidth = 100;
		}
		var rect = targetElem.getBoundingClientRect();
		var parentrect = targetElem.offsetParent.getBoundingClientRect();
		var adjMenuTop = (rect.top - parentrect.top) - 29;
		/* Check if submenu is off screen */
		var setLeftVal = (rect.right > (scrlWrpElm.clientWidth - menuWidth)) ?
							(scrlWrpElm.clientWidth - (menuWidth + 115)) : (rect.left- parentrect.left + 40);

		$popmenu.css({'top': adjMenuTop +'px', 'left': setLeftVal +'px'});
		$popmenu.addClass('menu_active');

		document.addEventListener(startEventTouch, pArea_subMenu_event, false);
		document.addEventListener(startEventMouse, pArea_subMenu_event, false);
	}
	else {
		$popmenu.removeClass('menu_active').css({'top':'', 'left':''});
		$popmenu.removeClass('favoTab_selectMenu hisTab_selectMenu');
		
		document.removeEventListener(startEventTouch, pArea_subMenu_event, false);
		document.removeEventListener(startEventMouse, pArea_subMenu_event, false);
	}
}

/*
 =========================================================================
 @function name    : check_read_complete
 @argument[reason] : Reason for loading
 @description      : Check if screen generation and program loading are complete.
 @return           : none
 =========================================================================
*/
function check_read_complete(reason) {
	if (read_tpprog_finish_flg === true) {
		if (create_screen_finish_flg === true ||
			(typeof reason != 'undefined' && reason == PRG_LOAD_REASON_EXEC)) {  /* If the main program is reloaded during execution */
			if (create_screen_finish_flg === true) {
				dispOffWaiting();
				create_screen_finish_flg = false;
				read_tpprog_finish_flg = false;
				g_editor_status.tl_loading = false;
			}
			timeline_record.array_add(g_program_data);
			position_record.array_add(position);
			positionregi_record.array_add(g_position_regi);
			check_undoredo_active();
		}
	}
}


/*
 =========================================================================
 @function name  : programingArea_Event
 @argument       : none
 @description    : "Programing Area" event registration and event processing
 @return         : none
 =========================================================================
*/
var progIconHammer = [];
var g_progFavorite_command = [];
var pressProgIcon = '';
function programingArea_Event() {
	/* Tap teachIcon */
	var target = document.getElementsByClassName('teachIcon');
	
	/* Discard registered Hammer events */
	for(var delcnt in progIconHammer) {
		progIconHammer[delcnt].destroy();
	}
	progIconHammer = [];
	
	for(var cnt = 0; cnt < target.length; cnt++) {
		/* No need for paste icon. */
		if(target[cnt].firstElementChild.id == 'sel_data') continue;
		/* Hammer event registration */
		progIconHammer[cnt] = new Hammer(target[cnt]);
		progIconHammer[cnt].get('press').set({time:800});
		
		
		progIconHammer[cnt].on('press', function(event) {
			switch(event.type) {
				case 'press':
					
					if (((getMotionGroup() != 1) && (isDropRestIcon(event.target.id))) ||
						((getMotionGroup() == 0) && (event.target.classList.contains('posTeach'))) ||
						(event.target.classList.contains('teachIcon') || event.target.classList.contains('iconName'))) return;
					if(!g_RO_flg && g_TPenbl_flg) {
						var sortTblChk = iconSortTbl.find(function(key) {
											return event.target.id === key ||
												   event.target.id === key + '_all' ||
												   event.target.id === key + '_history';
										 });
						pressProgIcon = '';
						g_favoTargetData = {listIndex : 0, dataId : "", favoName : "", paramData : {}, lsParam : ""};
						if(sortTblChk == undefined) {
							/*check press icon is from favorite icon.*/
							for(var loop = 0; loop < g_favoriteList.length; loop++) {
								if(event.target.id === g_favoriteList[loop].indexId ||
									 event.target.id === g_favoriteList[loop].indexId + '_history') {
									sortTblChk = g_favoriteList[loop].iconName;
									g_favoTargetData.listIndex  = loop;
									g_favoTargetData.dataId = g_favoriteList[loop].indexId;
									break;
								}
							}
							/*check press icon is from arcmotion icon.*/
							if(event.target.id.indexOf('_arc') != -1) {
								if(arcMotionTbl[event.target.id]) {
									sortTblChk = event.target.id;
								}
								else {
									if(arcMotionTbl[event.target.id.replace('_history', '')]) {
										sortTblChk = event.target.id.replace('_history', '');
									}
								}
							}
						}
						if(sortTblChk) pressProgIcon = sortTblChk;
						progPopMenu_dispUpdate(PROG_SEL_MENU_ICON_UD_01, event.target);
					}
					break;
				default:
					break;
			}
		});
	}
}

/*
 =========================================================================
 @function name  : programingArea_subMenu
 @argument       : none
 @description    : "Programing Area" submenu processing
 @return         : none
 =========================================================================
*/
var FAVORITE_CMD_MAX	= 30;
function programingArea_subMenu() {
	/* favorite */
	new Hammer(document.getElementById('favorite_add')).on('tap', function (event) {
		if(g_favoDataErrorFlg.notExist == true) {
			toast.show(langResource.ihmieditor_pop_favoriteprog_notexist_c);
		}
		else {
			/* If there is an icon number in the array. */
			if(g_favoriteList.length < FAVORITE_CMD_MAX || g_favoNoDispList.length != 0) {
				g_favoriteFlg.progAdd = true;

				change_TLselectMode(SELECT_MODE);
				change_favoSaveMode(pressProgIcon);
				progTabIcon_detailDisp(ACTIVE_DETAIL_DISP);
				toast.show(langResource.ihmieditor_pop_favorited_c);
			}
			else {
				display_popupmsg_alert(DEF_POPUP_SCRN_TYP.ALERT, langResource.ihmieditor_pop_favorite_regist_max_c, DISP_CLOSE_BTN);
			}
		}
		progPopMenu_dispUpdate(PROG_SEL_MENU_ICON_UD_00);
		pressProgIcon = '';
	});
	/* del */
	new Hammer(document.getElementById('favorite_del')).on('tap', function (event) {

		del_fav_tp((g_favoTargetData.listIndex * 6) + 2, g_favoTargetData.listIndex);

		/*Favorite history delete. */
		if(g_latest_command.indexOf(g_favoTargetData.dataId) != -1) {
			var argObj = {};
			var index = g_latest_command.indexOf(g_favoTargetData.dataId);
			g_latest_command.splice(index, 1);
			setHistSysValXHR(setHistSysValXHRCallback, argObj);
		}

		/* Favorite tab update */
		add_favorite_programmingTab();
		sortable_setting();
		programingArea_Event();
		progPopMenu_dispUpdate(PROG_SEL_MENU_ICON_UD_00);
		pressProgIcon = '';
		g_favoTargetData = {listIndex : 0, dataId : "", favoName : "", paramData : {}, lsParam : ""};
	});
	/* edit */
	new Hammer(document.getElementById('favorite_edit')).on('tap', function (event) {
		g_favoriteFlg.favoEdit = true;

		change_TLselectMode(SELECT_MODE);
		var editData = [g_favoriteList[g_favoTargetData.listIndex].indexId, pressProgIcon];
		change_favoSaveMode(editData);
		progTabIcon_detailDisp(ACTIVE_DETAIL_DISP);
		toast.show(langResource.ihmieditor_pop_refavorited_c);
		programingArea_Event();
		progPopMenu_dispUpdate(PROG_SEL_MENU_ICON_UD_00);
		pressProgIcon = '';
	});
}


/*
 =========================================================================
 @function name   : pArea_subMenu_event
 @argument[event] : 
 @description     : "Programing Area" submenu hidden processing
 @return          : none
 =========================================================================
*/
function pArea_subMenu_event(event) {
	if(event.target.id !== 'favorite_add'  &&
		 event.target.id !== 'favorite_del'  &&
		 event.target.id !== 'favorite_edit' 
		) {
		progPopMenu_dispUpdate(PROG_SEL_MENU_ICON_UD_00);
		g_favoTargetData = {listIndex : 0, dataId : "", favoName : "", paramData : {}, lsParam : ""};
		pressProgIcon = '';
	}
}

/*
 =========================================================================
 @function name       : stretch_idStrChk
 @argument[kind]      : type to check
 @argument[chkId]     : ID to check
 @description         : Check if id contains string
 @return              : include:true / not included:false
 =========================================================================
*/
var STRETCH_ID_CHK_ALL			=	1;
var STRETCH_ID_CHK_LEAD			=	2;
var STRETCH_ID_CHK_N_LEAD		=	3;
var STRETCH_ID_CHK_LEAD_N_EQ	=	4;
var STRETCH_ID_CHK_N_LEAD_N_EQ	=	5;
var STRETCH_ID_CHK_END			=	6;
var STRETCH_ID_CHK_N_END		=	7;
var STRETCH_ID_CHK_END_N_EQ		=	8;
var STRETCH_ID_CHK_N_END_N_EQ	=	9;
var STRETCH_ID_CHK_IF			=	10;
var STRETCH_ID_CHK_FOR			=	11;
var STRETCH_ID_CHK_BKT			=	12;
function stretch_idStrChk(kind, chkId) {
	if(chkId == '' || chkId == null) return false;
	var ret = false;
	kindTbl = [
		{chkKind: STRETCH_ID_CHK_ALL,			chkStr: /^(iflead|forlead|bktlead|ifelse|ifend|forend|bktend)/},
		{chkKind: STRETCH_ID_CHK_LEAD,			chkStr: /^(iflead|forlead|bktlead)/                           },
		{chkKind: STRETCH_ID_CHK_N_LEAD,		chkStr: /^(ifelse|ifend|forend|bktend)/                       },
		{chkKind: STRETCH_ID_CHK_LEAD_N_EQ,		chkStr: /^(?!(iflead|forlead|bktlead))/                       },
		{chkKind: STRETCH_ID_CHK_N_LEAD_N_EQ,	chkStr: /^(?!(ifelse|ifend|forend|bktend))/                   },
		{chkKind: STRETCH_ID_CHK_END,			chkStr: /^(ifend|forend|bktend)/                              },
		{chkKind: STRETCH_ID_CHK_N_END,			chkStr: /^(iflead|forlead|bktlead|ifelse)/                    },
		{chkKind: STRETCH_ID_CHK_END_N_EQ,		chkStr: /^(?!(ifend|forend|bktend))/                          },
		{chkKind: STRETCH_ID_CHK_N_END_N_EQ,	chkStr: /^(?!(iflead|forlead|bktlead|ifelse))/                },
		{chkKind: STRETCH_ID_CHK_IF,			chkStr: /^(iflead|ifelse|ifend)/                              },
		{chkKind: STRETCH_ID_CHK_FOR,			chkStr: /^(forlead|forend)/                                   },
		{chkKind: STRETCH_ID_CHK_BKT,			chkStr: /^(bktlead|bktend)/                                   },
	];
	var tblSearch = kindTbl.find(function(data) {
		return data.chkKind == kind;
	});
	if(tblSearch) {
		if(chkId.match(tblSearch.chkStr)) ret = true;
	}
	
	return ret;
}

/*
 =========================================================================
 @function name       : replace_idStrChk
 @argument[kind]      : type to check
 @argument[chkId]     : ID to check
 @description         : Check if id contains string
 @return              : include:true / not included:false
 =========================================================================
*/
function replace_idStrChk(chkId) {
  var ret = false;
  var replaceChkTbl = [
    {chkStr: /^(straight|kakujiku|curve|circlearc|spline|vsnline|vsnjoint|weldstartml|weldstartca|weldstopml|weldstopca)$/ }
  ];
  var tblSearch = replaceChkTbl.find(function(data) {
    return chkId.match(/^[a-z]*/)[0].match(data.chkStr);
  });
  if(tblSearch) {
    if(g_program_data[chkId] && !g_program_data[chkId].remark) {
      ret = true;
    }
  }

  return ret;
}

/*
 =========================================================================
 @function name       : spdUnit_strChk
 @argument[kind]      : type to check
 @argument[chkId]     : unit to check
 @description         : Check if unit contains string
 @return              : include:true / not included:false
 =========================================================================
*/
var SPD_UNIT_CHK_PCNT = 1;
var SPD_UNIT_CHK_UNSUPPORT_KAKUJIKU = 2;
function spdUnit_strChk(kind, chkId) {
  var ret = false;
  kindTbl = [
    { chkKind: SPD_UNIT_CHK_PCNT, chkStr: /^(%)$/ },
    { chkKind: SPD_UNIT_CHK_UNSUPPORT_KAKUJIKU, chkStr: /^(mm\/sec|cm\/min|inch\/min|deg\/sec)$/ }
  ];
  var tblSearch = kindTbl.find(function(data) {
    return data.chkKind == kind;
  });
  if(tblSearch) {
    if(chkId.match(tblSearch.chkStr)) ret = true;
  }

  return ret;
}

//=============================================================================
// undo/redo
//=============================================================================

/*
 =========================================================================
 @function name : record
 @argument      : none
 @description   : function for Undo and Redo
 @return        : none
 =========================================================================
*/
var record = function () {
	this.operation_array_index = 0;
	this.operation_array = [];
};
record.prototype = {
	// addition to the array to record of the operation history
	array_add: function (data) {
	  for (var i = 0; i < this.operation_array_index; i++) {
		this.operation_array.shift();
	  }
	  if (this.operation_array.length > 10) {
		this.operation_array.pop();
	  }
	  this.operation_array_index = 0;
	//   this.operation_array.unshift(JSON.parse(JSON.stringify(data)));
	// this.operation_array.unshift(data);
	var copy = [];
	$.extend(true, copy, data)
	this.operation_array.unshift(copy);
	},
	// initialization of the array
	delete: function () {
	  this.operation_array_index = 0;
	  this.operation_array = [];
	},
	// the acquisition of the array
	get_array: function () {
	  return this.operation_array;
	},
	 
	get_array_index: function () {
	  return this.operation_array_index;
	},
   
	array_index_increment: function () {
	  this.operation_array_index += 1;
	  return this.operation_array_index;
	},
	 
	array_index_decrement: function () {
	  this.operation_array_index -= 1;
	  return this.operation_array_index;
	},
	array_overwrite: function (data) {
	  var copy = [];
	  $.extend(true, copy, data)
	  this.operation_array[this.operation_array_index] = copy;
	}
};
var tl_rcrd_main = new record();
var pos_rcrd_main = new record();
var posregi_rcrd_main = new record();
var tl_rcrd_sub = new record();
var pos_rcrd_sub = new record();
var posregi_rcrd_sub = new record();
var timeline_record = tl_rcrd_main;
var position_record = pos_rcrd_main;
var positionregi_record = posregi_rcrd_main;
/*
 =========================================================================
 @function name : switch_record
 @argument      : none
 @description   : Find out if it has changed program name
 @return        : none
 =========================================================================
*/
var SWITCH_MAIN_RECORD = 0;
var SWITCH_SUB_RECORD = 1;
function switch_record(switchRec) {
	if(switchRec == SWITCH_MAIN_RECORD) {
		timeline_record = tl_rcrd_main;
		position_record = pos_rcrd_main;
		positionregi_record = posregi_rcrd_main;
	}
	else {
		timeline_record = tl_rcrd_sub;
		position_record = pos_rcrd_sub;
		positionregi_record = posregi_rcrd_sub;
	}
	/* initialize */
	tl_rcrd_sub.delete();
	pos_rcrd_sub.delete();
	posregi_rcrd_sub.delete();
}

/*
 =========================================================================
 @function name : init_undoredo_data
 @argument      : none
 @description   : Initialize UndoRedo data.
 @return        : none
 =========================================================================
*/
function init_undoredo_data() {
	init_record();
	timeline_record.array_add(g_program_data);
	position_record.array_add(position);
	positionregi_record.array_add(g_position_regi);
	check_undoredo_active();
}

/*
 =========================================================================
 @function name : init_record
 @argument      : none
 @description   : Initialize UndoRedo data.
 @return        : none
 =========================================================================
*/
function init_record() {
	timeline_record.delete();
	position_record.delete();
	positionregi_record.delete();
}
var g_func_record = function(){
	this.setActiveIconFlg  = false,
	this.adinstAttachedFlg = false,    /* Adding attached instructions when adding instructions is in progress. */
	this.setInstTempFlg    = false,
	this.copyNoticeEvent   = false,
	this.sortNoticeEvent   = false,
	this.setAdinstArgFlg   = false,
	this.setBracketArgFlg  = false,
	this.pkgSampleProgAdding  = false,  /* A sample program that triggers a package instruction is being added. */
	this.record            = [],
	this.temp              = "",
	this.continuousRep = null;  /* Rep used when adding motion order continuously */
}
g_func_record.prototype = {
	init: function() {
		this.setActiveIconFlg  = false,
		this.adinstAttachedFlg = false,
		this.setInstTempFlg    = false,
		this.copyNoticeEvent   = false,
		this.sortNoticeEvent   = false,
		this.setAdinstArgFlg   = false,
		this.setBracketArgFlg  = false,
		this.pkgSampleProgAdding  = false,
		this.record            = [],
		this.temp = "",
		this.continuousRep = null;
	},
	array_add: function(data) {
		this.temp = data;
	}
}
var g_adin_state = new g_func_record();

// Toast notification class
var Toast = (function(){
    var m_toastId;
    function Toast() {
        this.m_toastId = null;
    }
    // Show toast message. 3 seconds by default
    Toast.prototype.show = function(message) {
        this.m_toastId = top.IHMIComponents.cf.toast.show(message);
    }
    // Delete toast message. 
    Toast.prototype.delete = function () {
        if (this.m_toastId === null) return;
        top.IHMIComponents.cf.toast.remove(this.m_toastId);
        this.m_toastId = null;
    }
    return Toast;
})();
var toast = new Toast(); 

/*
 =========================================================================
 @function name  : undo
 @argument[data] : undo data
 @description    : 
 @return         : none
 =========================================================================
*/
var unredo_flg = true;
function undo(data) {
	dispOnWaiting(0);
	var contents = data.contents;
	need_position_save_flg = true;
	switch (data.type) {
		case OPERATION_ADD:
			//delete
			undoredo_del(data, 'undo');
			break;
		case OPERATION_SORT://sort
		case OPERATION_SORT_EDIT:
			undoredo_sort(data, 'undo');
			break;
		case OPERATION_DELETE: // add
		case OPERATION_DELETE_MULTI: // paste
			toggleNode_whileSaving(true);
			undoredo_add(data, 'undo');
			break;
		case OPERATION_EDIT:// edit param
			undoredo_edit(data, 'undo');
			break;
		case OPERATION_EDIT_MULTI://edit adinst bracket param
			undoredo_multiEdit(data, 'undo');
			break;
		case OPERATION_ADD_MULTI://Delete sampleProgram add
		case OPERATION_PASTE://Delete multiple
		case OPERATION_COPY_EDIT:
			undoredo_multiDel(data, 'undo');
			break;
		case OPERATION_REPLACE:
			undoredo_replace(data, 'undo');
			break;
		case OPERATION_REMARK:   // remark
		case OPERATION_UNREMARK: // unremark
			undoredo_remark(data, 'undo');
			break;
		case OPERATION_SET_POS :
			toggleNode_whileSaving(true);
			undoredoSetPos(data, 'undo');
			break;
		default:
			break;
	}
}

/*
 =========================================================================
 @function name  : redo
 @argument[data] : redo data
 @description    : 
 @return         : none
 =========================================================================
*/
var isRedo_add = false;
function redo(data) {
	dispOnWaiting(0);
	var contents = data.contents;
	need_position_save_flg = true;
	switch (data.type) {
		case OPERATION_ADD://add
			isRedo_add = true;
			undoredo_add(data, 'redo');
			break;
		case OPERATION_SORT://sort
		case OPERATION_SORT_EDIT:
			undoredo_sort(data, 'redo');
			break;
		case OPERATION_DELETE://delete
			undoredo_del(data, 'redo');
			break;
		case OPERATION_EDIT://edit param
			undoredo_edit(data, 'redo');
			break;
		case OPERATION_EDIT_MULTI://edit adinst bracket param
			undoredo_multiEdit(data, 'redo');
			break;
		case OPERATION_ADD_MULTI://sampleProgram add
		case OPERATION_PASTE:// paste
		case OPERATION_COPY_EDIT:
			undoredo_add(data, 'redo');
			break;
		case OPERATION_DELETE_MULTI://Delete multiple
			undoredo_multiDel(data, 'redo');
			break;
		case OPERATION_REPLACE:
			undoredo_replace(data, 'redo');
			break;
		case OPERATION_REMARK:   // remark
		case OPERATION_UNREMARK: // unremark
			undoredo_remark(data, 'redo');
			break;
		case OPERATION_SET_POS :
			toggleNode_whileSaving(true);
			undoredoSetPos(data, 'redo');
			break;
		default:
			break;
	}
}

/*
 =========================================================================
 @function name : welding_undoredo_event
 @argument      :
 @description   : 
 @return        : none
 =========================================================================
*/
function welding_undoredo_event(ope, data) {
	if(g_order_sysVal["$AWSTABUI.$WSICONTYPE"] != undefined && g_order_sysVal["$AWSTABUI.$WSICONTYPE"].value == '1') {
		if(data.wt_longPress_state != undefined) {
			switch(ope) {
				case 'undo':
					if(data.wt_longPress_state.state == "startSaved") {
						g_wt_longPress_state = {state: "", addStartElmId: "", addEndElmId: ""};
						gLedState=RO_LEDOFF;
						top.rpcmc_iovalset(IO_TYPE_ROUT,RO_PIN1,gLedState);
					}
					else if(data.wt_longPress_state.state == "endSaved") {
						g_wt_longPress_state = {state: "startSaved", addStartElmId: data.wt_longPress_state.startId, addEndElmId: ""};
						gLedState=RO_LEDON;
						top.rpcmc_iovalset(IO_TYPE_ROUT,RO_PIN1,gLedState);
						progdata_addClassCheck(data.wt_longPress_state.startId, 'wt_nodrag');
					}
					break;
				case 'redo':
					if(data.wt_longPress_state.state == "startSaved") {
						g_wt_longPress_state = {state: "startSaved", addStartElmId: data.wt_longPress_state.startId, addEndElmId: ""};
						gLedState=RO_LEDON;
						top.rpcmc_iovalset(IO_TYPE_ROUT,RO_PIN1,gLedState);
						progdata_addClassCheck(data.wt_longPress_state.startId, 'wt_nodrag');
					}
					else if(data.wt_longPress_state.state == "endSaved") {
						g_wt_longPress_state = {state: "", addStartElmId: "", addEndElmId: ""};
						gLedState=RO_LEDOFF;
						top.rpcmc_iovalset(IO_TYPE_ROUT,RO_PIN1,gLedState);
					}
					break;
				default:
					break;
			}
		}
	}
	else {
		var parentData = getNestPosition("-INST_EASYAW_START");
		if(parentData){
			var bktData = getNestPosition();
			var parentNestId = nestIdChk(bktData);
		}
		switch (parentData) {
			case true:
				switch (parentNestId) {
				case true:
					gLedState=RO_LEDON;
					top.rpcmc_iovalset(IO_TYPE_ROUT,RO_PIN1,gLedState);
					break;
				case false:
					gLedState=RO_LEDOFF;
					top.rpcmc_iovalset(IO_TYPE_ROUT,RO_PIN1,gLedState);
					break;
				default:
					break;
				}
				break;
			case false:
				if(targetNestNum != 0){
					gLedState=RO_LEDOFF;
					top.rpcmc_iovalset(IO_TYPE_ROUT,RO_PIN1,gLedState);
				}
				break;
			default:
				break;  
		}
	}
	draw_TLscale(false);
}

/*
 =========================================================================
 @function name  : undoredo_dataRestore
 @argument[ope]  : Undo/Redo operation
 @description    : 
 @return         : none
 =========================================================================
*/
function undoredo_dataRestore(ope) {
	if(ope === 'undo') {
		undo_position_data();
		undo_position_regi_data();
	}
	else {
		redo_position_data();
		redo_position_regi_data();
	}
}

/*
 =========================================================================
 @function name : undo_position_data
 @argument      : none
 @description   : 
 @return        : none
 =========================================================================
*/
function undo_position_data() {
	if(!undoredo_pos_restore_check('undo')) {
		position = [];
		$.extend(true, position, position_record.get_array()[position_record.get_array_index()]);
	}
}

/*
 =========================================================================
 @function name : undoredo_pos_restore_check
 @argument      : none
 @description   : 
 @return        : none
 =========================================================================
*/
function undoredo_pos_restore_check(ope) {
	var no_restore = false, cmpPosArray = [], position_array = [];
	if(ope == 'undo') {
		$.extend(true, cmpPosArray, position_record.get_array()[position_record.get_array_index()]);
		position_record.array_index_increment();
		$.extend(true, position_array, position_record.get_array()[position_record.get_array_index()]);
	}
	else {  /* redo */
		$.extend(true, position_array, position_record.get_array()[position_record.get_array_index()]);
		position_record.array_index_decrement();
		$.extend(true, cmpPosArray, position_record.get_array()[position_record.get_array_index()]);
	}

	/** function: unteached check **/
	function chk_unteached(array, p_num, g_num) {
		var ret = false;
		var posArrayChk = array.find(function(pData) { return pData.posNumber == p_num });
		if(posArrayChk) {
			var grpArrayChk = posArrayChk.posData.find(function(gData) { return gData.groupNumber == g_num });
			if(grpArrayChk && grpArrayChk.empty == false) ret = true;
		}
		return ret;
	}

	for(var poscnt = 0; poscnt < position_array.length; poscnt++) {
		for(var grpcnt = 0; grpcnt < position_array[poscnt].posData.length; grpcnt++) {
			/* Undo data is unteached. */
			if(position_array[poscnt].posData[grpcnt].empty) {
				/* Check for change from unteached to teached status. */
				if(chk_unteached(position, position_array[poscnt].posNumber, position_array[poscnt].posData[grpcnt].groupNumber)) {
					no_restore = true;
					if(ope == 'undo') {
						edit_pos_notRestore_flg = chk_unteached(cmpPosArray, position_array[poscnt].posNumber, position_array[poscnt].posData[grpcnt].groupNumber);
					}
				}
			}
		}
	}

	return no_restore;
}

/*
 =========================================================================
 @function name : undo_position_regi_data
 @argument      : none
 @description   : 
 @return        : none
 =========================================================================
*/
function undo_position_regi_data() {
	undoredo_posregi_restore_check('undo');
	if(!edit_posregi_notRestore_flg) {
		g_position_regi = [];
		$.extend(true, g_position_regi, positionregi_record.get_array()[positionregi_record.get_array_index()]);
	}
}

/*
 =========================================================================
 @function name : undoredo_posregi_restore_check
 @argument      : none
 @description   : 
 @return        : none
 =========================================================================
*/
function undoredo_posregi_restore_check(ope) {
	var tmp_tl_urData = timeline_record.get_array()[timeline_record.get_array_index()];
	var tl_urData = {type:tmp_tl_urData.type, urData:[]};
	tl_urData.urData = (tmp_tl_urData.length > 0) ? tmp_tl_urData.slice() : [tmp_tl_urData];
	var before_posregi_array = positionregi_record.get_array()[positionregi_record.get_array_index()];
	(ope == 'undo') ? positionregi_record.array_index_increment() : positionregi_record.array_index_decrement();
	var posregi_array = positionregi_record.get_array()[positionregi_record.get_array_index()];

	if(tl_urData.type == OPERATION_EDIT || tl_urData.type == OPERATION_EDIT_MULTI) {
		for(var key in tl_urData.urData) {
			if((iconTbl[tl_urData.urData[key].contents.baseId].iconType == 'posTeach') &&
			   !(undoredo_param_compare(tl_urData.urData[key].param1, tl_urData.urData[key].param2))) {
				for(var i = 0; i < tl_urData.urData[key].param1.position.length; i++) {
					/* Not required if the edited content is a position type or position number. */
					if(tl_urData.urData[key].param1.position[i].kind != tl_urData.urData[key].param2.position[i].kind ||
					   (tl_urData.urData[key].param1.position[i].kind == tl_urData.urData[key].param2.position[i].kind &&
						tl_urData.urData[key].param1.position[i].number != tl_urData.urData[key].param2.position[i].number)) {
						break;
					}
					else {
						var chkParam = (ope === 'undo') ?
											tl_urData.urData[key].param1.position[i].kind : tl_urData.urData[key].param2.position[i].kind;
						if (chkParam == POSKIND_POSREGI) {	/* PR[] */
							var chkIndex = Object.keys(posregi_array);
							var compCheckLst = [];
							for (var urKeyIdx = 0; urKeyIdx < chkIndex.length; urKeyIdx++) {
								compCheckLst.push(undoredo_posData_compare(posregi_array[chkIndex[urKeyIdx]], before_posregi_array[chkIndex[urKeyIdx]]));
							}
							if (edit_posregi_notRestore_flg = (compCheckLst.indexOf(true) > -1)) { break; }
						}
					}
				}
			}
			if(edit_posregi_notRestore_flg) break;
		}
	}
}

/*
 =========================================================================
 @function name  : redo_position_data
 @argument       : none
 @description    : 
 @return         : none
 =========================================================================
*/
function redo_position_data() {
	if(!undoredo_pos_restore_check('redo')) {
		position = [];
		$.extend(true, position, position_record.get_array()[position_record.get_array_index()]);
	}
}

/*
 =========================================================================
 @function name  : redo_position_regi_data
 @argument       : none
 @description    : 
 @return         : none
 =========================================================================
*/
function redo_position_regi_data() {
	undoredo_posregi_restore_check('redo');
	if(!edit_posregi_notRestore_flg) {
		g_position_regi = [];
		$.extend(true, g_position_regi, positionregi_record.get_array()[positionregi_record.get_array_index()]);
	}

}

/*
 =========================================================================
 @function name  : undoredo_add
 @argument[data] : Undo/Redo data
 @argument[ope]  : Undo/Redo operation
 @description    : 
 @return         : none
 =========================================================================
*/
var g_prog_saveProgress = {lines: 0, saveLines: 0};
function undoredo_add(data, ope) {
	if(ope === 'undo') {
		var refElmId = (data.place1 == 0) ? 'TL_spacer' : g_TL_progInfo.saveProg[data.place1 - 1];
	}
	else {
		/* Switch references by operation type */
		var refData = (data.type == OPERATION_ADD) ? data.place2 : data.place1;
		var refElmId = (refData == 0) ? 'TL_spacer' : g_TL_progInfo.saveProg[refData - 1];
	}
	if(refElmId != 'TL_spacer') {
		chkShowUndoRedoTarget(refElmId, true);
	}
	undoredo_dataRestore(ope);

	var selectCopy_array_bkup = [];
	var icon_id = {addlist:data.id, contents:data.contents, base:(data.base ? data.base : [])};

	if((data.type == OPERATION_PASTE && data.base != undefined) ||
	   (data.type == OPERATION_COPY_EDIT && data.base != undefined)) {
		var startIndex = g_program_data[data.base[0].id].array_num + 1;
		var endIndex = startIndex + data.base.length - 1;
		var paste_index = (refElmId == 'TL_spacer') ? 0 : g_program_data[refElmId].array_num + 1;
		if(data.base.length > SAVE_SPLIT_REF_VAL_PASTELINE) {
			var map = new Map();
			for(var baseCnt = 0; baseCnt < data.base.length; baseCnt++) {
				map.set(baseCnt, data.base[baseCnt].id);
			}
			for(var getCnt = 0; getCnt < data.base.length; getCnt++) {
				var o = map.get(getCnt)
				if(o != null) splitSaveInfo.baseArray.push(o);
			}
		}
		paste_icon(refElmId, icon_id, false);
		chk_copy_notice_event(data, (ope === 'undo'));
		save_pasteLine(startIndex, endIndex, paste_index, 0, save_pasteLine_callback);
	}
	else {
		g_prog_saveProgress.lines = icon_id.addlist.length;
		/* The number of additional lines exceeded the threshold. */
		if(icon_id.addlist.length > SAVE_SPLIT_REF_VAL_ADD) {
			/* Display the progress bar. */
			display_splitSaveProgress();
		}

		paste_icon(refElmId, icon_id, true);
	}
	if (data.contents[0].baseId == "-INST_ARC_HANDLE_TEACH") {
		g_btnTeaching_list.weldteach.existsTimeline = true;
		g_btnTeaching_list.weldteach.id = data.id[0];
		g_btnTeaching_list.weldteach.count++;
		top.setArcTeachFg(true);
		if(g_program_data[data.id].remark == false) {
			icon_activeChk(icon_id);
			weldingTeachStart();
		}
	} else {
		for (var i = 0; i < data.contents.length; i++) {
			if (data.contents[i].baseId == "-INST_WRIST_BUTTON_TEACH") {
				top.setWristTeachFg(true);
				g_btnTeaching_list.wristteach.existsTimeline = true;
				g_btnTeaching_list.wristteach.id = data.id[i];
				g_btnTeaching_list.wristteach.count++;
				break;
			}
		}
	}
	if(ope === 'redo') {
		if(g_btnTeaching_list.weldteach.existsTimeline == true &&
		   (data.contents[0].baseId == 'bktlead-inst_easyaw_start' ||
			data.contents[0].baseId == 'weldstartml' ||
			data.contents[0].baseId == 'weldstopml')) {
			targetNestNum = getWeldNestNum();
			welding_undoredo_event('redo', data);
		}
	}
}

/*
 =========================================================================
 @function name  : undoredo_sort
 @argument       : none
 @description    : 
 @return         : none
 =========================================================================
*/
function undoredo_sort(data, ope) {
	var opeflg = (ope === 'undo') ? true : false;
	if(data.type == OPERATION_SORT_EDIT) {
		var setparam = opeflg ? data.param1 : data.param2;
		for(var cnt in data.id) {
			g_program_data[data.id[cnt]] = JSON.parse(JSON.stringify(setparam[cnt]));
		}
	}
	sort_icon(data, opeflg);
	if(data.contents.length == 1 && data.contents[0].baseId === '-INST_ARC_HANDLE_TEACH') {
		undoredo_arcBracketPos(data.id[0], ope === 'undo' ? true : false);
	}
}

/*
 =========================================================================
 @function name  : undoredo_edit
 @argument[data] : Undo/Redo data
 @argument[ope]  : Undo/Redo operation
 @description    : 
 @return         : none
 =========================================================================
*/
function undoredo_edit(data, ope) {
	var icon_id = get_array_num_to_iconid(data.lineNum - 1);
	chkShowUndoRedoTarget(icon_id);
	data_before_change = JSON.parse(JSON.stringify(g_program_data[icon_id]));
	var refData = (ope === 'undo') ? data.param1 : data.param2
	/* Update stretch & nest data to the latest. */
	$.extend(true, refData.nest, g_program_data[icon_id].nest);
	if(refData.stretch) $.extend(true, refData.stretch, g_program_data[icon_id].stretch);
	$.extend(true, g_program_data[icon_id], refData);
	g_program_data[icon_id].addMotion = refData.addMotion.slice();
	undoredo_dataRestore(ope);
	undoredo_editparam(icon_id, data, ope);
}

/*
 =========================================================================
 @function name  : undoredo_multiEdit
 @argument[data] : Undo/Redo data
 @argument[ope]  : Undo/Redo operation
 @description    : 
 @return         : none
 =========================================================================
*/
function undoredo_multiEdit(data, ope) {
	undoredo_dataRestore(ope);

	for(var cnt = 0; cnt < data.length; cnt++){
		icon_id = get_array_num_to_iconid(data[cnt].lineNum - 1);
		chkShowUndoRedoTarget(icon_id);
		data_before_change = JSON.parse(JSON.stringify(g_program_data[icon_id]));
		var refData = (ope === 'undo') ? data[cnt].param1 : data[cnt].param2;
		/* Update stretch & nest data to the latest. */
		$.extend(true, refData.nest, g_program_data[icon_id].nest);
		if(refData.stretch) $.extend(true, refData.stretch, g_program_data[icon_id].stretch);
		$.extend(true, g_program_data[icon_id], refData);
		/*The start TP saves the parameters and sets the position teach pin*/
		if(cnt == 0) {
			undoredo_editparam(icon_id, data[cnt], ope);
		}
		/*The end TP saves the parameter*/
		else {
			write_mode = EDIT_PRG_OPT_OVERWRITE;
			save_tporder(icon_id, write_mode, save_tporder_callback, icon_id);
		}
	}
}

/*
 =========================================================================
 @function name  : undoredo_del
 @argument[data] : Undo/Redo data
 @argument[ope]  : Undo/Redo operation
 @description    : 
 @return         : none
 =========================================================================
*/
function undoredo_del(data, ope) {
	if(ope === 'undo') {
		var delElmId = get_array_num_to_iconid(data.place2);
		if(data.contents.length == 1 && data.contents[0].baseId === '-INST_ARC_HANDLE_TEACH') {
			weldingExitConfirm(ope);
			undoredo_dataRestore(ope);
			return false;
		} else if (data.contents.length == 1 && data.contents[0].baseId === '-INST_WRIST_BUTTON_TEACH') {
			init_btnTeaching_list('wristteach');
			top.setWristTeachFg(false);
		}
	}
	else {
		var delElmId = get_array_num_to_iconid(data.place1);
		for (var i = 0; i < data.contents.length; i++) {
			if (data.contents[i].baseId == "-INST_ARC_HANDLE_TEACH") {
				init_btnTeaching_list('weldteach');
				top.setArcTeachFg(false);
				break;
			} else if (data.contents[i].baseId == "-INST_WRIST_BUTTON_TEACH") {
				init_btnTeaching_list('wristteach');
				top.setWristTeachFg(false);
				break;
			}
		}
	}
	chkShowUndoRedoTarget(delElmId, false);
	if(ope === 'undo') {
		if(data.id[0] == delElmId && stretch_idStrChk(STRETCH_ID_CHK_LEAD, delElmId)) {
			data.contents[0].stretch.state = g_program_data[delElmId].stretch.state;
		}
	}
	delete_icon(delElmId);
	
	undoredo_dataRestore(ope);
}

/*
 =========================================================================
 @function name  : undoredo_multiDel
 @argument[data] : Undo/Redo data
 @argument[ope]  : Undo/Redo operation
 @description    : 
 @return         : none
 =========================================================================
*/
function undoredo_multiDel(data, ope) {
	chkShowUndoRedoTarget(get_array_num_to_iconid(data.place1));
	chkShowUndoRedoTarget(get_array_num_to_iconid(data.place2));
	delete_multiicon(data.place1, data.place2, true, data);
	draw_TLscale(false);
	
	undoredo_dataRestore(ope);
	if(ope === 'undo') {
		if(g_btnTeaching_list.weldteach.existsTimeline == true &&
		   (data.contents[0].baseId == 'bktlead-inst_easyaw_start' ||
			data.contents[0].baseId == 'weldstartml' ||
			data.contents[0].baseId == 'weldstopml')) {
			welding_undoredo_event('undo', data);
		}
	}
}

/*
 =========================================================================
 @function name     : undoredo_editparam
 @argument[icon_id] : The ID of the instruction to be undo/redo.
 @argument[data]    : Undo/Redo data
 @argument[ope]     : Undo/Redo operation
 @descriptio        : 
 @return            : none
 =========================================================================
*/
var save_result = null;
function undoredo_editparam(icon_id, data, ope) {
	var id = (stretch_idStrChk(STRETCH_ID_CHK_ALL, icon_id) === true) ?
				get_stretch_pairId(icon_id, REQ_ID_KIND_LEAD, null) : icon_id;
	var elem = document.getElementById(id);
	var watchwaitcommunication = null;

	unredo_flg = false;

	/* Close the detail screen if it is currently being displayed. */
	if(activeTarget) icon_inactive();

	if(g_program_data[id] != undefined && g_program_data[id].baseId === 'comment') {
		timeline_commentDispCheck(icon_id);
	}
	write_mode = EDIT_PRG_OPT_OVERWRITE;
	save_tporder(icon_id, write_mode, save_tporder_callback, icon_id);

	/** Wait for the save process to complete. **/
	watchwaitcommunication = setInterval(function () {
		/* Wait until the "waiting" animation is removed. (== The save process is complete.) */
		if (!waiting_flg) {
			if(!data.inactive) {
				dispOnWaiting(0);
				icon_active(id, ACTIVE_DETAIL_NECESSARY);
			}
			else {
				g_program_data[id].select = "";
			}
			//If there is location information, number it
			if (elem && iconTbl[g_program_data[id].baseId].iconType == 'posTeach') {
				redraw_posInfoPin(id);
			}
			// Timer stop
			clearInterval(watchwaitcommunication);
		}
	}, 10);
	var save = setInterval(function () {
		/* Wait until the detail screen is displayed. */
		if (unredo_flg) {
			dispOffWaiting();
			var dtfrm = document.getElementById(get_detail_frm_id(activeTarget)).contentWindow;
			var edtElm = dtfrm.document.getElementById(data.elem);
			/* Failed to save */
			if (save_result != IO_SUCCESS) {
				/* Update modified time. */
				getCurProgModifyTime(startMonitorCurProgModify);
				if(edtElm.classList.contains("radio-button")) edtElm = get_radioSelected_elm(edtElm);
				if(edtElm) {
					if(edtElm.tagName === 'INPUT') {
						edtElm.style.color = "rgb(230, 0, 18)";
						if(g_program_data[icon_id].baseId === 'label') {
							dtfrm.document.getElementById('setreq_str').style.display = 'block';
						}
					}
					else {
						$(edtElm.getElementsByTagName('INPUT')).css('color', 'rgb(230, 0, 18)');
					}
				}
				g_program_data[icon_id] = JSON.parse(JSON.stringify(data_before_change));
			}
			else {
				if(g_program_data[icon_id].baseId == 'nosupport') {
					nosupport_remarkChk(icon_id, edtElm);
				}
			}
			// Timer stop
			clearInterval(save);
		}
	}, 100);
}

/*
 =========================================================================
 @function name  : undoredo_param_compare
 @argument[cmp1] : Data before editing.
 @argument[cmp2] : Data after editing.
 @description    : Check if any data other than position data has been edited.
 @return         : Check result. (true:Edited data)
 =========================================================================
*/
function undoredo_param_compare(cmp1, cmp2) {
	var ret = false;
  if (JSON.stringify(cmp1.param) != JSON.stringify(cmp2.param) ||
	  JSON.stringify(cmp1.speed) != JSON.stringify(cmp2.speed) ||
	  JSON.stringify(cmp1.route) != JSON.stringify(cmp2.route) ||
	  JSON.stringify(cmp1.addMotion) != JSON.stringify(cmp2.addMotion)) {
		ret = true;
	}
	
	return ret;
}

/*
 =========================================================================
 @function name  : undoredo_posData_compare
 @argument[cmp1] : 
 @argument[cmp2] : 
 @description    : 
 @return         : none
 =========================================================================
*/
function undoredo_posData_compare(cmp1, cmp2) {
	var ret = false;
	if ((typeof cmp1 === 'undefined') || (typeof cmp2 === 'undefined')) { return ret;}
	if (cmp1.posData) {
		if (cmp1.Comment != cmp2.Comment) { return true; }
		for (var i = 0; i < getGroupCount(); i++){
			if ((typeof cmp1.posData[i] === 'undefined') && (typeof cmp2.posData[i] === 'undefined')) {
				continue; // Even if the data for all groups does not exist, it will not cause an error.
			}
			if ((typeof cmp1.posData[i] === 'undefined') ||
				(typeof cmp2.posData[i] === 'undefined') ||
				(cmp1.posData[i].configStr != cmp2.posData[i].configStr) || // config
				(cmp1.posData[i].empty != cmp2.posData[i].empty) || // empty
				(cmp1.posData[i].groupNumber != cmp2.posData[i].groupNumber)) { // group number(insurance)
				return true; // If the number of stored data is different, it is assumed that there is a difference.
			}
			if (cmp1.posData[i].poskey.length != cmp2.posData[i].poskey.length) {
				// If the data of the number of axes does not match due to processing such as format conversion,
				return true; // it is assumed that there is a difference.
			}
			for (var j = 0; j < cmp1.posData[i].poskey.length; j++) {
				if (cmp1.posData[i].poskey[j].val != cmp2.posData[i].poskey[j].val) { return true; }
			}
		}
	}
	else {
		if(cmp1.comment != cmp2.comment ||
		   cmp1.Config != cmp2.Config ||
		   cmp1.gnum != cmp2.gnum ||
		   cmp1.P != cmp2.P ||
		   cmp1.R != cmp2.R ||
		   cmp1.W != cmp2.W ||
		   cmp1.X != cmp2.X ||
		   cmp1.Y != cmp2.Y ||
		   cmp1.Z != cmp2.Z ||
		   JSON.stringify(cmp1.J1) != JSON.stringify(cmp2.J1) ||
		   JSON.stringify(cmp1.J2) != JSON.stringify(cmp2.J2) ||
		   JSON.stringify(cmp1.J3) != JSON.stringify(cmp2.J3) ||
		   JSON.stringify(cmp1.J4) != JSON.stringify(cmp2.J4) ||
		   JSON.stringify(cmp1.J5) != JSON.stringify(cmp2.J5) ||
		   JSON.stringify(cmp1.J6) != JSON.stringify(cmp2.J6)) {
			ret = true;
		}
		if (cmp1.rep != cmp2.rep) { ret = true; }
	}
	
	return ret;
}

/*
 =========================================================================
 @function name        : undoredo_arcBracketPos
 @argument[arcTeachId] : The sorted arcHandleTeach instruction ID.
 @argument[opeType]    : Operation type of Undo/Redo. (true : undo / false : redo)
 @description          : 
 @return               : none
 =========================================================================
*/
function undoredo_arcBracketPos(arcTeachId, opeType) {
	if(opeType) {
		longPushAddNestFlg = true;
		targetNestNum = getWeldNestNum();
		gLedState = RO_LEDON;
		var icon_id = get_stretch_pairId(get_array_num_to_iconid(g_program_data[arcTeachId].array_num + 1), REQ_ID_KIND_LEAD, null);
	}
	else {
		longPushAddNestFlg = false;
		targetNestNum = 0;
		gLedState = RO_LEDOFF;
		var icon_id = get_stretch_pairId(get_array_num_to_iconid(g_program_data[arcTeachId].array_num - 1), REQ_ID_KIND_LEAD, null);
	}
	top.rpcmc_iovalset(IO_TYPE_ROUT,RO_PIN1, gLedState);
	save_tporder(icon_id, write_mode, save_tporder_callback, icon_id);
}

/*
 =========================================================================
 @function name  : undoredo_replace
 @argument[data] : Undo/Redo data
 @argument[ope]  : Undo/Redo operation
 @description    : 
 @return         : none
 =========================================================================
*/
function undoredo_replace(data, ope) {
  var temp_flg = need_position_save_flg;
  need_position_save_flg = false;
  if (ope === 'undo') {
    /* Check if the target is displayed on the timeline. */
    chkShowUndoRedoTarget(data.instId.after1);

    g_program_data[data.instId.before] = data.before;
    progInfo_update(data.instId.after1, [data.instId.before], false);
    g_program_arrayNumSave();
    var save_tporder_cbarg = {
      id: data.instId.before,
      callback: insertAfterMtnCB
    };
    save_tporder(data.instId.before, EDIT_PRG_OPT_INSERT_AFTER, save_tporder_callbackWithCB, save_tporder_cbarg);
  }
  else {
    /* Check if the target is displayed on the timeline. */
    chkShowUndoRedoTarget(data.instId.before);

    g_program_data[data.instId.after1] = data.after1;
    var updArr = [data.instId.after1];
    if (data.instId.after2 != '') {
      g_program_data[data.instId.after2] = data.after2;
      updArr.push(data.instId.after2);
    }
    progInfo_update(data.instId.before, updArr, false);
    g_program_arrayNumSave();
    var save_tporder_cbarg = {
      id: data.instId.after1,
      callback: (data.instId.after2 != '') ? saveDestLine : insertAfterMtnCB
    };
    save_tporder(data.instId.after1, EDIT_PRG_OPT_INSERT_AFTER, save_tporder_callbackWithCB, save_tporder_cbarg);
  }

  // add destination line
  function saveDestLine(state, cbarg) {
    var save_tporder_cbarg = {
      id: data.instId.after2,
      callback: insertAfterMtnCB,
    };
    save_tporder(data.instId.after2, EDIT_PRG_OPT_INSERT_AFTER, save_tporder_callbackWithCB, save_tporder_cbarg);
  }

  // delete before replacement line
  function insertAfterMtnCB(state, cbarg) {
    need_position_save_flg = temp_flg;
    if (ope === 'undo') {
      delete_icon(data.instId.after1);
      if (data.instId.after2 != '') {
        delete_icon(data.instId.after2);
      }
    }
    else {
      delete_icon(data.instId.before);
    }
    undoredo_dataRestore(ope);
  }
}

/*
 =========================================================================
 @function name  : undoredo_remark
 @argument[data] : Undo/Redo data
 @argument[ope]  : Undo/Redo operation
 @description    : 
 @return         : none
 =========================================================================
*/
function undoredo_remark(data, ope) {
  undoredo_dataRestore(ope);

  save_id_array = [];
  if(ope == 'redo') {
    save_id_array = data.id.slice();
    var setRemark = (data.type == OPERATION_REMARK) ? true : false;
    /* remark or unremark */
    save_remarkLine(setRemark);
  }
  else {
    save_id_array = data.id.slice();
    for(var cnt = 0; cnt < data.contents.length; cnt++) {
      $.extend(true, g_program_data[data.id[cnt]], data.contents[cnt]);
      g_program_data[data.id[cnt]].assignClass = data.contents[cnt].assignClass.slice();
    }
    save_undo_remark();
  }
}

/*
 =========================================================================
 @function name  : undoredoSetPos
 @argument[data] : Undo/Redo data
 @argument[ope]  : Undo/Redo operation
 @description    : Undo/redo for position data edits
 @return         : none
 =========================================================================
*/
function undoredoSetPos(data, ope) {
  stopMonitorCurProgModify();
  undoredo_dataRestore(ope);
  var undoredoPosNum = 0;
  var undoredoSetPosCallBack = function (response) {
    var status = (typeof response === 'object') ? response.status : response;
    if (status === IO_SUCCESS) {
      if(undoredoPosNum === data.setPosNum.length) {
        toggleNode_whileSaving(false);
        getCurProgModifyTime(startMonitorCurProgModify);
        dispOffWaiting();
        if (bkActiveIconId !== null) icon_active(bkActiveIconId, ACTIVE_DETAIL_NECESSARY);
      }
      else {
        var positionIndex = position.findIndex(function(posData) {return posData.posNumber == data.setPosNum[undoredoPosNum];});
        undoredoPosNum++;
        save_posdata(positionIndex, undoredoSetPosCallBack);
      }
    }
    else {
      toggleNode_whileSaving(false);
      getCurProgModifyTime(startMonitorCurProgModify);
      dispOffWaiting();
      if (bkActiveIconId !== null) icon_active(bkActiveIconId, ACTIVE_DETAIL_NECESSARY);
    }
  }
  var bkActiveIconId = null;
  unredo_flg = false;
  if (activeTarget) {
    for (var i = 0; i < g_program_data[activeTarget].position.length; i++) {
      if (data.setPosNum.includes(g_program_data[activeTarget].position[i].number)) {
        bkActiveIconId = activeTarget;
        icon_inactive();
        break;
      }
    }
  }
  undoredoSetPosCallBack(IO_SUCCESS);
}

/*
 =========================================================================
 @function name : check_undoredo_active
 @argument      : none
 @description   : Update the icon with or without undo/redo data.
 @description   : none
 =========================================================================
*/
function check_undoredo_active() {
	/* Do not process if "TP OFF" or "Vertical Scroll"  */
	if(!g_TPenbl_flg) return false;

	var tl_index = timeline_record.get_array_index();
	var tl_array = timeline_record.get_array();
	//undo
	var undo_act = (tl_array.length != 0 && tl_index < tl_array.length - 1) ? '1' : '';
	$("#undo").css('opacity', undo_act);
	//redo
	var redo_act = (0 < tl_index) ? '1' : '';
	$("#redo").css('opacity', redo_act);
}

//=============================================================================
// undo/redo end
//=============================================================================

/*
 =========================================================================
 @function name      : rcvIOevent
 @argument[event]    : 
 @argument[io_type]  : 
 @argument[io_index] : 
 @argument[io_value] : 
 @description        : The receiving process of binded IO events.
 @return             : none
 =========================================================================
*/
function rcvIOevent(event, io_type, io_index, io_value) {
	if(typeof io_type === 'undefined') {
		return false;
	}
	if(io_type == top.tpin_type_c) {
		if(io_index == top.tp_enbl_c) {
			g_TPenbl_flg = (io_value === '1') ? true : false;
		}
		if (g_TL_selectModeFlg) {
			/* Cancel selected state */
			change_TLselectMode(SELECT_MODE_NONE);
		}
		delete_popup_screen(DEF_POPUP_SCRN_TYP.REPLACE_MTN);//delete the pop-up screen
		/* TP is valid */
		if(g_TPenbl_flg) {
			readwrite_setting();
		}
		/* TP is invalid */
		else {
			readOnly_setting();
			var upperMoni = document.getElementById('upperDisp_moni');
			if(upperMoni.classList.contains('upperDisp_active')) {
				if(document.getElementById('disp_monitor')) {
					var moni_frm = document.getElementById('disp_monitor').contentWindow;
				}
			}
			if(moni_frm && moni_frm.document.activeElement.tagName != 'BODY') {
				moni_frm.document.activeElement.blur();
			}
		}
	}
}

/*=========================================================================
 @function name      : rcvVarEvent
 @argument[event]    : Event object
 @argument[progName] : Category Name ? (Not used, so not yet surveyed)
 @argument[varName]  : System variable name
 @argument[typeCode] : Var type ? (Not used, so not yet surveyed)
 @argument[valStr]   : varName's value
 @description        : 'VarEvent' monitor callback
 @return[ret]        : none
 =========================================================================*/
function rcvVarEvent(event, progName, varName, typeCode, valStr) {
  switch(varName) {
  case '$JCR.$JOG_GP':
    setCurrentGroupNum(parseInt(valStr));
    break;
  case '$IHMI_EDIT.$MDFY_TIME':
    monitorEventCurProgModify(valStr);
    break;
  case '$ALM_IF.$LAST_ERCODE':
    checkErrorCode(valStr);
    break;
  default:
    break;
  }
}

/*
 =========================================================================
 @function name      : isDropRestIcon
 @arg[targetIconId]  : check ID
 @description        : Determines if an icon has drop restrictions based on its ID and group composition.
 @return             : Check result
 =========================================================================
*/
function isDropRestIcon(targetIconId) {

  // If only the first group is enabled, there will be no icons with drop restrictions
  if (getMotionGroup() == 1) { return false; }

  var dragCancelItem = getDropRestIconList(); // subject to restrictions
  for (var i = 0; i < ICON_AREA_KEY.length; i++) {
    dragCancelItem = dragCancelItem.concat((dragCancelItem.join(ICON_AREA_KEY[i] + " ") + ICON_AREA_KEY[i]).split(' '));
  }

  // If the target is included in the generated ID list, it is a restricted icon.
  return (dragCancelItem.indexOf(targetIconId) > -1);
}

/*
 =========================================================================
 @function name : getDropRestIconList
 @arg[]         : none
 @description   : Get a list of the IDs of the instructions to be restricted.
 @return        : ID list of restricting advanced instructions.
 =========================================================================
*/
function getDropRestIconList() {
  // Some plugins are not type 'posTeach' 'posBracket', but they are subject to restrictions.
  var returnIdList = ["bktlead-inst_path_start", "-INST_ARC_HANDLE_TEACH"];

  var instKeyList = Object.keys(g_inst_obj);
  // Search for type 'posTeach' 'posBracket' instructions.
  for (var i = 0; i < instKeyList.length; i++){
    if ((g_inst_obj[instKeyList[i]].type == typePosTeach) ||
        (g_inst_obj[instKeyList[i]].type == typePosBracket)) {
      returnIdList.push(instKeyList[i]);
    }
  }
  var favList = g_favoriteList.filter(function(data) { return returnIdList.includes(data.iconName); });
  for(var key in favList) {
    returnIdList.push(favList[key].indexId);
  }

  return returnIdList;
}

/*
 =========================================================================
 @function name   : tl_dragLock_control
 @argument[event] : click event.
 @description     : 
 @return          : none
 =========================================================================
*/
var g_tl_dragLock = false;
function tl_dragLock_control(event) {
	dispOnWaiting(0);

	var lockBtn = document.getElementById('tl_dragLock');
	/* toggle class */
	lockBtn.classList.toggle('drag_lock');
	g_tl_dragLock = lockBtn.classList.contains('drag_lock');

	/* Set system variables. */
	var frameXml = "";
	frameXml += '<?xml version="1.0" encoding="Shift_JIS"?>\r<XMLVAR>\r<PROG name="*SYSTEM*">\r';
	frameXml += '<VAR name="$IHMI_EDIT.$DRAG_LOCK">' + (g_tl_dragLock ? '1' : '0') +'</VAR>\r</PROG>\r</XMLVAR>';
	setSysValXHR(frameXml, tl_dragLock_toggle, g_tl_dragLock);
}

/*
 =========================================================================
 @function name   : tl_dragLock_toggle
 @argument[state] : Write Result
 @argument[arg]   : Callback arg
 @description     : 
 @return          : none
 =========================================================================
*/
function tl_dragLock_toggle(state, arg) {
	/* read failure */
	if(state != IO_SUCCESS) {
		g_tl_dragLock = !g_tl_dragLock;
		if(g_tl_dragLock) {
			document.getElementById('tl_dragLock').classList.add('drag_lock');
		}
		else {
			document.getElementById('tl_dragLock').classList.remove('drag_lock');
		}
	}

	if(g_tl_dragLock) {
		parts_timeline.classList.add('tl_dragLock');
		var toastStr = langResource.ihmieditor_pop_tl_drag_prohibited_c;
		var filterStr = '#TimeLineArea .posTeach, #TimeLineArea .normal';
	}
	else {
		parts_timeline.classList.remove('tl_dragLock');
		var toastStr = langResource.ihmieditor_pop_tl_drag_enabled_c;
		var filterStr = '.if_else, .if_end, .for_end, .bkt_end, .wt_nodrag';
	}
	if(state == IO_SUCCESS && isCRXeditorActive) {
		toast.show(toastStr);
	}
	if(sortableTimeLine != '') sortableTimeLine.option('filter', filterStr);
	if(typeof arg != 'undefined') dispOffWaiting();
}

/*
 =========================================================================
 @function name        : init_btnTeaching_list
 @argument[teach_kind] : weldteach or wristteach
 @description          : initing g_btnTeaching_list
 @return               : none
 =========================================================================
*/
function init_btnTeaching_list(teach_kind) {
	switch (teach_kind) {
		case 'weldteach':
			g_btnTeaching_list.weldteach.existsTimeline = false;
			g_btnTeaching_list.weldteach.id = null;
			g_btnTeaching_list.weldteach.count = 0;
			break;
		case 'wristteach':
			g_btnTeaching_list.wristteach.existsTimeline = false;
			g_btnTeaching_list.wristteach.id = null;
			g_btnTeaching_list.wristteach.count = 0;
			break;
		default:
			break;
	}
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * @fileoverview : structure define file
 * @char-code    : SJIS
 * @NewLineCode  : LF
 */
/*
 =========================================================================
 @function name   : set_icon_data
 @argument[order  : order
 @description     : Returns icon data of default_data_structure.
 @return          : icon_data
 =========================================================================
*/
function set_icon_data(order) {
	var icon_data = JSON.parse(JSON.stringify(default_data_structure[order]));

	return icon_data;

}

var default_data_structure = {
	"kakujiku"	: {baseId:"kakujiku", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[{number:0, kind:1, disp:"ON"}], speed: {method:'', val:100, unit:'%'}, route:{stop:langResource.ihmieditor_order_ichigime_c, val:''}, addMotion:[], param:'', remark:false},
	"straight"	: {baseId:"straight", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[{number:0, kind:1, disp:"ON"}], speed: {method:'', val:100, unit:'mm/sec'}, route:{stop:langResource.ihmieditor_order_ichigime_c, val:''}, addMotion:[], param:'', remark:false},
	"curve"		: {baseId:"curve", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[{number:0, kind:1, disp:"ON"}, {number:0, kind:1, disp:"ON"}], speed: {method:'', val:100, unit:'mm/sec'}, route:{stop:langResource.ihmieditor_order_ichigime_c, val:''}, addMotion:[], param:'', remark:false},
	"circlearc" : {baseId:"circlearc", array_num: 0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[{number:0, kind:1, disp:"ON"}], speed: {method:'', val: 100, unit:'mm/sec'}, route:{stop:langResource.ihmieditor_order_ichigime_c, val:''}, addMotion:[], param:'', remark:false},
	"spline"	: {baseId:"spline", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[{number:0, kind:1, disp:"ON"}], speed: {method:'', val:100, unit:'mm/sec'}, route:{stop:langResource.ihmieditor_order_ichigime_c, val:''}, addMotion:[], param:'', remark:false},
	"macro"		: {baseId:"macro", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:'Get Data', remark:false},
	"call"		: {baseId:"call", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:'Please_select_a_file', remark:false},
	"wait"		: {baseId:"wait", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:'0.00sec', remark:false},
	"iflead"	: {baseId:"iflead", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:'', stretch:{state:'stretch_open', idList:[]}, remark:false},
	"ifelse"	: {baseId:"ifelse", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:'ELSE', remark:false},
	"ifend"		: {baseId:"ifend", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:'ENDIF', remark:false},
	"forlead"	: {baseId:"forlead", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:'FOR R[0]=0 TO 0', stretch:{state:'stretch_open', idList:[]}, remark:false},
	"forend"	: {baseId:"forend", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:'ENDFOR', remark:false},
	"jump"		: {baseId:"jump", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:langResource.ihmieditor_order_jump_c + ' ' + langResource.ihmieditor_order_label_c + '[0]', remark:false},
	"label"		: {baseId:"label", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:langResource.ihmieditor_order_label_c + '[0]', remark:false},
	"regi"		: {baseId:"regi", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:langResource.ihmieditor_order_regi_c + '[0]=0', remark:false},
	"payload"	: {baseId:"payload", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:langResource.ihmieditor_order_call_c + ' -INST_PAYLOAD(2,0,1,0.30)', remark:false},
	"setuframe"	: {baseId:"setuframe", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:langResource.ihmieditor_order_uframe_c + '[1]=' + langResource.ihmieditor_order_posregi_c + '[1]', remark:false},
	"setutool"	: {baseId:"setutool", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:langResource.ihmieditor_order_utool_c + '[1]=' + langResource.ihmieditor_order_posregi_c + '[1]', remark:false},
	"seluframe"	: {baseId:"seluframe", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:langResource.ihmieditor_order_uframe_num_c + '=0', remark:false},
	"selutool"	: {baseId:"selutool", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:langResource.ihmieditor_order_utool_num_c + '=1', remark:false},
	"output"	: {baseId:"output", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:'DO[1]=OFF', remark:false},
	"comment"	: {baseId:"comment", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:'', remark:false},
	"nosupport"	: {baseId:"nosupport", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:'', remark:false},
	"vsnline"	: {baseId:"vsnline", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[{number:0, kind:1, disp:"ON"}], speed: {method:'', val:100, unit:'mm/sec'}, route:{stop:langResource.ihmieditor_order_ichigime_c, val:''}, addMotion:[langResource.ihmieditor_order_voffset_c], param:'', remark:false},
	"vsnjoint"	: {baseId:"vsnjoint", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[{number:0, kind:1, disp:"ON"}], speed: {method:'', val:100, unit:'%'}, route:{stop:langResource.ihmieditor_order_ichigime_c, val:''}, addMotion:[langResource.ihmieditor_order_voffset_c], param:'', remark:false},
	"laserpre"	: {baseId:"laserpre", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[{number:0, kind:1, disp:"ON"}], speed: {method:'', val:100, unit:'mm/sec'}, route:{stop:langResource.ihmieditor_order_ichigime_c, val:''}, addMotion:[], param:'', remark:false},
	"laserls"	: {baseId:"laserls", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[{number:0, kind:1, disp:"ON"}], speed: {method:'', val:100, unit:'mm/sec'}, route:{stop:langResource.ihmieditor_order_ichigime_c, val:''}, addMotion:[], param:'', remark:false},
	"laserle"	: {baseId:"laserle", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[{number:0, kind:1, disp:"ON"}], speed: {method:'', val:100, unit:'mm/sec'}, route:{stop:langResource.ihmieditor_order_ichigime_c, val:''}, addMotion:[], param:'', remark:false},
	"laserpow"	: {baseId:"laserpow", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:langResource.ihmieditor_order_laser_powc_c + '[1]', remark:false},
	"laserpresi": {baseId:"laserpresi", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:'', remark:false},
	"laserlssi"	: {baseId:"laserlssi", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:'', remark:false},
	"laserlesi"	: {baseId:"laserlesi", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:'', remark:false},
	"noconnect"	: {baseId:"noconnect", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:'', remark:false},
	"weldstartml"	: {baseId:"weldstartml", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[{number:0, kind:1, disp:"ON"}], speed: {method:'', val:100, unit:'mm/sec'}, route:{stop:langResource.ihmieditor_order_ichigime_c, val:''}, addMotion:[langResource.ihmieditor_order_weldstart_c + '[...,...]'], param:'', remark:false},
	"weldstopml"	: {baseId:"weldstopml", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[{number:0, kind:1, disp:"ON"}], speed: {method:'', val:langResource.ihmieditor_order_weld_speed_c, unit:''}, route:{stop:langResource.ihmieditor_order_ichigime_c, val:''}, addMotion:[langResource.ihmieditor_order_weldend_c + '[...,...]'], param:'', remark:false},
	"weldstartal"	: {baseId:"weldstartal", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:langResource.ihmieditor_order_weldstart_c + '[...,...]', remark:false},
	"weldstopal"	: {baseId:"weldstopal", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:langResource.ihmieditor_order_weldend_c + '[...,...]', remark:false},
	"weldstartca"	: {baseId:"weldstartca", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[{number:0, kind:1, disp:"ON"}], speed: {method:'', val:100, unit:'mm/sec'}, route:{stop:langResource.ihmieditor_order_ichigime_c, val:''}, addMotion:[langResource.ihmieditor_order_weldstart_c + '[...,...]'], param:'', remark:false},
	"weldstopca"	: {baseId:"weldstopca", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[{number:0, kind:1, disp:"ON"}], speed: {method:'', val:langResource.ihmieditor_order_weld_speed_c, unit:''}, route:{stop:langResource.ihmieditor_order_ichigime_c, val:''}, addMotion:[langResource.ihmieditor_order_weldend_c + '[...,...]'], param:'', remark:false},
	"laserkpre"	: {baseId:"laserkpre",array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[{number:0, kind:1, disp:"ON"}], speed: {method:'', val:100, unit:'%'}, route:{stop:langResource.ihmieditor_order_ichigime_c, val:''}, addMotion:[], param:'', remark:false},
	"laserkls"	: {baseId:"laserkls",array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[{number:0, kind:1, disp:"ON"}], speed: {method:'', val:100, unit:'%'}, route:{stop:langResource.ihmieditor_order_ichigime_c, val:''}, addMotion:[], param:'', remark:false},
	"laserkle"	: {baseId:"laserkle",array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[{number:0, kind:1, disp:"ON"}], speed: {method:'', val:100, unit:'%'}, route:{stop:langResource.ihmieditor_order_ichigime_c, val:''}, addMotion:[], param:'', remark:false},
	"lasercls"	: {baseId:"lasercls", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[{number:0, kind:1, disp:"ON"}, {number:0, kind:1, disp:"ON"}], speed: {method:'', val:100, unit:'mm/sec'}, route:{stop:langResource.ihmieditor_order_ichigime_c, val:''}, addMotion:[], param:'', remark:false},
	"lasercle"	: {baseId:"lasercle", array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[{number:0, kind:1, disp:"ON"}, {number:0, kind:1, disp:"ON"}], speed: {method:'', val:100, unit:'mm/sec'}, route:{stop:langResource.ihmieditor_order_ichigime_c, val:''}, addMotion:[], param:'', remark:false},
	"lasercals"	: {baseId:"lasercals", array_num: 0, select: '', assignClass: [], nest: { num: 0, layer: [] }, position: [{ number: 0, kind: 1, disp: "ON" }], speed: { method: '', val: 100, unit: 'mm/sec' }, route: { stop: langResource.ihmieditor_order_ichigime_c, val: '' }, addMotion: [], param: '', remark:false },
	"lasercale"	: {baseId:"lasercale", array_num: 0, select: '', assignClass: [], nest: { num: 0, layer: [] }, position: [{ number: 0, kind: 1, disp: "ON" }], speed: { method: '', val: 100, unit: 'mm/sec' }, route: { stop: langResource.ihmieditor_order_ichigime_c, val: '' }, addMotion: [], param: '', remark:false },
	"lasersls"	: {baseId:"lasersls", array_num: 0, select: '', assignClass: [], nest: { num: 0, layer: [] }, position: [{ number: 0, kind: 1, disp: "ON" }], speed: { method: '', val: 100, unit: 'mm/sec' }, route: { stop: langResource.ihmieditor_order_ichigime_c, val: '' }, addMotion: [], param: '', remark:false },
	"lasersle"	: {baseId:"lasersle", array_num: 0, select: '', assignClass: [], nest: { num: 0, layer: [] }, position: [{ number: 0, kind: 1, disp: "ON" }], speed: { method: '', val: 100, unit: 'mm/sec' }, route: { stop: langResource.ihmieditor_order_ichigime_c, val: '' }, addMotion: [], param: '', remark:false },
	"laserwirc"	: {baseId:"laserwirc",array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]} ,position:[], speed: {}, route:{}, addMotion:[], param:langResource.ihmieditor_order_laser_wirc_c + '[Ty=1,Sp=200]', remark:false},
	"sensoron"		: {baseId:"sensoron",array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]}, position:[], speed: {}, route:{}, addMotion:[], param:langResource.ihmieditor_order_arc_sensor_c + ' ON[1,*,*,*]', remark:false},
	"sensoroff"		: {baseId:"sensoroff",array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]}, position:[], speed: {}, route:{}, addMotion:[], param:langResource.ihmieditor_order_arc_sensor_c + ' OFF[1,*,*,*]', remark:false},
	"searchon"		: {baseId:"searchon",array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]}, position:[], speed: {}, route:{}, addMotion:[], param:langResource.ihmieditor_order_arc_search_c + ' ON[1,*,*,*]', remark:false},
	"detectjoint"	: {baseId:"detectjoint",array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]}, position:[], speed: {}, route:{}, addMotion:[], param:langResource.ihmieditor_order_arc_detect_joint_c + '[...,...]', remark:false},
	"trackdpm"		: {baseId:"trackdpm",array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]}, position:[], speed: {}, route:{}, addMotion:[], param:langResource.ihmieditor_order_arc_tracking_dpm_c + '[...]', remark:false},
	"trackend"		: {baseId:"trackend",array_num:0, select:'', assignClass:[], nest:{num:0, layer:[]}, position:[], speed: {}, route:{}, addMotion:[], param:langResource.ihmieditor_order_arc_tracking_end_c, remark:false},
};
/* For overwriting initial values */
var init_overwrite_param = {
	"payload"	: {param:ORDER_PAYLOAD + '[1]'}
}

var def_stretchData_struct = {id:'', nestNum:0, dispNest: 0};

var def_TL_progInfo = {
	dispRange :{left:0, right:0}, dispProg :[], saveProg :[], scrollDist :'', sort_dragging :false, bktSaveProg :[],
}

var def_splitSaveInfo = {
	idArray:[], baseArray:[], pasteDirection:'', splitSaveInsId:'', splitRefVal:SAVE_SPLIT_REF_VAL_PASTELINE, startPos:0, refPos:0, opeType:0
};

                                                                                                                                                                                                                                                                                                                                                     //=============================================================================
// define
// FOR I/O
//=============================================================================

// IO TYPE
var IO_TYPE_DIN  = 1;
var IO_TYPE_DOUT = 2;
var IO_TYPE_AIN  = 3;
var IO_TYPE_AOUT = 4;
var IO_TYPE_RIN  = 8;
var IO_TYPE_ROUT = 9;

var RI_PIN1   = 1;
var RI_PIN2   = 2;
var RO_PIN1   = 1;

var RO_LEDOFF = 0;
var RO_LEDON  = 1;
var RI_BTNOFF = 0;


//=============================================================================
// Global variable
//=============================================================================
var LONGPUSHTIME   = 1000;// 1sec
var gTimerID1      = null;
var RI1LongPushFlg = false;
var gLedState      = RO_LEDOFF;
var gPopDispFlg    = false;
var targetNestNum = 0;

//weldingTeach Position information data
var g_MTGData = {
  savingTeachPosFlg : false,
  teachEasyArcFlg : false,
  teachPosData : {
    joint: "", 
    cart: "", 
    posNo: 0,
  }
};

/*
 =========================================================================
 @function name : weldingTeachStart
 @argument[]    : none
 @description   : 
 @return        : none
 =========================================================================
*/
function weldingTeachStart(){
  //initial
  var gTimerID1      = null;
  RI1LongPushFlg     = false;


  //Direct teach Panel
  top.irprogapi.setPnlState(top.pnlarea.JOG_PNL, top.pnlarea.PNL_DISP, top.pnlarea.PNL_LOCK, top.pnlarea.LDTR_TAB);
  
  
  // LED INIT
  gLedState          = RO_LEDOFF;
 
  top.rpcmc_iovalset(IO_TYPE_ROUT,RO_PIN1,gLedState);
  
  if(typeof top.rpcmc_startMGTHandleTeach == 'function') {
    top.rpcmc_startMGTHandleTeach();
    top.jQuery.iolis.bind("HandleIOEvent", null, weldingTeachIOEnableEvent);
  }
  else{
    alert('rpcmc.js V9.40P/35 or later is required.');
  }
  

  touch_firstEdge(HANDLERESIZE_REACH);
}
/*
 =========================================================================
 @function name : IOEnableEvent
 @argument      : event, io_type, io_index, io_value
 @description   : Enable status event.
 @return        : none
 =========================================================================
*/
function weldingTeachIOEnableEvent(event, io_type, io_index, io_value, jpos, cpos) {
	if (typeof io_index === 'undefined') { return; }
	if (IO_TYPE_RIN == io_type) {
		if (!g_TPenbl_flg || g_RO_flg) {
			if(io_value == '0') {
				var disp = toastStr_notEdit_welding();
				toast.show(disp);
			}
			return;
		}
		if (!isCRXeditorActive) return;
		if (g_adinDropList.length > 0) return;
		if (g_adin_state.adinstAttachedFlg) return;
		if (g_tlmove_ghost != "") return;
		if (g_MTGData.savingTeachPosFlg) return;

		/* If in selection mode, it is released. */
		if(g_TL_selectModeFlg) change_TLselectMode(SELECT_MODE_NONE);
		delete_popup_screen(DEF_POPUP_SCRN_TYP.REPLACE_MTN);//delete the pop-up screen

		switch(io_index) {
			case "1": // RI_PIN1
				icon_inactive();
				icon_active(g_btnTeaching_list.weldteach.id, ACTIVE_DETAIL_NECESSARY);
				if("0" == io_value){
					/*save positon data joint & cart.*/
					g_MTGData.teachPosData.joint = jpos;
					g_MTGData.teachPosData.cart = cpos;
					/*Teaching positon saving start or end flag.(true:Teaching position saving now/false:Teaching position save completed)*/
					g_MTGData.savingTeachPosFlg = true;
					weldingTeachoffRI_pin1();
				} else {
					weldingTeachonRI_pin1();
				}
				break;
			default:
				break;
		}
	}
}
/*
 =========================================================================
 @function name : offRI_pin1
 @argument      : none
 @description   : RI_PIN1 [OFF]
 @return        : none
 =========================================================================
*/
function weldingTeachoffRI_pin1() {
	if(null != gTimerID1){
		clearTimeout(gTimerID1);
		gTimerID1=null;
	}
	if(false == RI1LongPushFlg){
		welding_ShortClick();
	} else {
		welding_LongClick();
	}
	RI1LongPushFlg = false;
}
/*
 =========================================================================
 @function name : onRI_pin1
 @argument      : none
 @description   : RI_PIN1 [ON]
 @return        : none
 =========================================================================
*/
function weldingTeachonRI_pin1() {
	if(null != gTimerID1){
		clearTimeout(gTimerID1);
		gTimerID1=null;
	}
	gTimerID1=setTimeout(weldingTeachTimerID1Over, LONGPUSHTIME);
}
/*
 =========================================================================
 @function name : weldingTeachTimerID1Over
 @argument      : none
 @description   : Long Push Timer Timeout(2 second)
 @return        : none
 =========================================================================
*/
function weldingTeachTimerID1Over() {
  RI1LongPushFlg = true;
  if(g_order_sysVal["$AWSTABUI.$WSICONTYPE"] != undefined && g_order_sysVal["$AWSTABUI.$WSICONTYPE"].value == '1') {
    if(g_wt_longPress_state.state == '') {
      gLedState = RO_LEDON;
      top.rpcmc_iovalset(IO_TYPE_ROUT,RO_PIN1, gLedState);
    }
    else if(g_wt_longPress_state.state == 'startSaved') {
      gLedState = RO_LEDOFF;
      top.rpcmc_iovalset(IO_TYPE_ROUT,RO_PIN1, gLedState);
    }
  }
  else {
    var parentData = getNestPosition("-INST_EASYAW_START");
    if(parentData){
      var bktData = getNestPosition();
      var parentNestId = nestIdChk(bktData);
    }
    switch (parentData) {
      case true:
        switch (parentNestId) {
          case true:
            gLedState=RO_LEDOFF;
            top.rpcmc_iovalset(IO_TYPE_ROUT,RO_PIN1,gLedState);
            break;
          case false:
            gLedState=RO_LEDON;
            top.rpcmc_iovalset(IO_TYPE_ROUT,RO_PIN1,gLedState);
            break;
          default:
            break;
        }
        break;
      case false:
          gLedState=RO_LEDON;
          top.rpcmc_iovalset(IO_TYPE_ROUT,RO_PIN1,gLedState);
        break;
      default:
        break;  
    }
  }
}
//unload
/*
 =========================================================================
 @function name          : weldingTeachEnd
 @argument[initUndoRedo] : Whether or not to initialize the undoredo data when teaching is finished.(true : initialize)
 @description            : Monitor Stop,bind Stop
 @return                 : none
 =========================================================================
*/
function weldingTeachEnd(initUndoRedo) {
  if(typeof top.rpcmc_stopMGTHandleTeach == 'function') {
    //close btn unbind
    top.rpcmc_stopMGTHandleTeach();
    top.jQuery.iolis.unbind("HandleIOEvent", weldingTeachIOEnableEvent);
  }
  gLedState=RO_LEDOFF;
  top.rpcmc_iovalset(IO_TYPE_ROUT,RO_PIN1,gLedState);
  targetNestNum = 0;
  init_btnTeaching_list('weldteach');
  g_wt_longPress_state = {state: '', addStartElmId: '', addEndElmId: ''};
  if(initUndoRedo) {
    /* [constraint] Initialize the data so that UndoRedo is not possible. */
    init_undoredo_data();
  }
}
/*
 =========================================================================
 @function name : exitConfirm
 @argument      : none
 @description   : Exit PositionWriteChk
 @return        : none
 =========================================================================
*/
function weldingExitConfirm(status) {
  var popConfirm = function(btn, message, id, callback) {
    gPopDispFlg = true;
    var customizeObj = {selectBtn:{}, isHTML:true};
    for(var cnt = 0; cnt < btn.length; cnt++) {
      customizeObj.selectBtn[cnt + 1] = {label: btn[cnt]};
    }
    top.IHMIComponents.cf.confirmMessage("ihmieditor", message, id, status, null, top, callback, null, customizeObj);
  };

  if(g_order_sysVal["$AWSTABUI.$WSICONTYPE"] != undefined && g_order_sysVal["$AWSTABUI.$WSICONTYPE"].value == '1') {
    if(g_wt_longPress_state.state == 'startSaved') {
      var message = langResource.ihmieditor_pop_weldpathteach_no_weldendcomp_message_c;
      var callback = weldingExitConfirmCallback;
      var btn = ["OK", langResource.ihmieditor_pop_cancel2_c];
    }
    else {
      var message = langResource.ihmieditor_pop_weldpathteach_comp_no_parent_c;
      var callback = noParent_exitConfirmCallback;
      var btn = ["OK"];
    }
    var id;
    popConfirm(btn, message, id, callback);
  }
  else {
    var parentData = getNestPosition("-INST_EASYAW_START");
    var id = "sampleId";
    if(parentData){
      var bktData = getNestPosition();
      var parentNestId = nestIdChk(bktData);
    }
    switch (parentData) {
      case false:
        /* no parent confirm */
        var btn = ["OK"];
        /* status = "undo" Deleted handleTeach with undo */
        popConfirm(btn, langResource.ihmieditor_pop_weldpathteach_comp_no_parent_c, id, noParent_exitConfirmCallback);
        break;
      case true:
        switch (parentNestId) {
          case false:
            var btn = ["OK"];
            /* status = "undo" Deleted handleTeach with undo in not parent easyarc */
            popConfirm(btn, langResource.ihmieditor_pop_weldpathteach_comp_no_parent_c, id, noParent_exitConfirmCallback);
            break;
          case true:
            if(status == "complete") {
              var btn = ["OK"];
              popConfirm(btn, langResource.ihmieditor_pop_weldpathteach_comp_no_parent_c, id, noParent_exitConfirmCallback);
            }
            /* no parent confirm */
            else if(status == undefined) {
              var btn = ["OK", langResource.ihmieditor_pop_cancel2_c];
              popConfirm(btn, langResource.ihmieditor_pop_weldpathteach_comp_message_c, id, weldingExitConfirmCallback);
            } else {}
            break;
          default:
            break;
        }
        break;
      default:
        var btn = ["OK", langResource.ihmieditor_pop_cancel2_c];
        popConfirm(btn, langResource.ihmieditor_pop_weldpathteach_comp_message_c, id, weldingExitConfirmCallback);
        break;
    }
  }
}
// confirm OK/Cansel callback
function weldingExitConfirmCallback(id, operation) {
  gPopDispFlg = false;
  switch(id){
    case 'btn1':
      if(g_order_sysVal["$AWSTABUI.$WSICONTYPE"] != undefined && g_order_sysVal["$AWSTABUI.$WSICONTYPE"].value == '1') {
        welding_LongClick_addWeldMotion('endAdding');
      }
      else {
        var status = "complete"
        //PositionWrite
        weldingSetEasyawPosition();
      }
      setTimeout(function(){
        weldingExitConfirm(status);
      },1);
      break;
    case 'btn2':
      break;
    default:
      break;
  }
}

function noParent_exitConfirmCallback(id, operation, status) {
  gPopDispFlg = false;
  switch(id){
    case 'btn1':
      break;
    case 'closeBtn':
      break;
    default:
      break;
  }
//  if(status == undefined){
    //Exit
    setTimeout(function(){
      instructionDeleteIcon('weldingteach');
    },1);
//  }
//  /*status = "undo" Remain undoData*/
//  else {
//    top.setArcTeachFg(false);
//    weldingTeachEnd(false);
//  }
}


/*
 =========================================================================
 @function name : weldingSetEasyawPosition
 @argument      : none
 @description   : INST_EASYAW_START,INST_EASYAW_END End Position Write
 @return        : none
 =========================================================================
*/
function weldingSetEasyawPosition() {
    var parentArray = getNestPosition();
    var tpName = "-INST_EASYAW_START";
    var posArg = 2;
    var posNum = getParentPosNum(parentArray, tpName, posArg);
    updatePosData(posNum);

}
function getParentPosNum(parentData, targetTp, targetNum){
  for(var k in parentData){
    if(parentData[k].tpName.toUpperCase() == targetTp.toUpperCase()){
      var gProgData = g_program_data[parentData[k].parentId];
      if(Number(targetNum) <= gProgData.position.length){
        return gProgData.position[Number(targetNum) - 1].number;
      }
    }
  }
  return false;
}
/*
 =========================================================================
 @function name : welding_ShortClick
 @argument      : none
 @description   : welding_ShortClick Buttom Clicked
 @return        : none
 =========================================================================
*/
function welding_ShortClick() {
  if(g_RO_flg || !g_TPenbl_flg || gPopDispFlg){
    if(g_RO_flg || !g_TPenbl_flg) {
      var disp = toastStr_notEdit_welding();
      toast.show(disp);
    }
    return;
  }

  var prg = [
    ORDER_LINE + " P[N] " + "250mm/sec " + ORDER_FINE,
    ORDER_LINE + " P[N] " + ORDER_WELD_SPEED + " " + ORDER_CNT + "100"
  ];

  nestCurveHidden('hidden');
  if(g_order_sysVal["$AWSTABUI.$WSICONTYPE"] != undefined && g_order_sysVal["$AWSTABUI.$WSICONTYPE"].value == '1') {
    if(g_wt_longPress_state.state == '') {
      dispAddProgSave(prg[0]);
    }
    else {
      dispAddProgSave(prg[1]);
    }
  }
  else {
    var parentData = getNestPosition("-INST_EASYAW_START");
    if(parentData){
      var bktData = getNestPosition();
      var parentNestId = nestIdChk(bktData);
    }
    switch (parentData) {
      case false:
        dispAddProgSave(prg[0]);
        break;
      case true:
        switch (parentNestId) {
          case false:
            dispAddProgSave(prg[0]);
            break;
          case true:
            dispAddProgSave(prg[1]);
            break;
          default:
            break;
        }
        break;
      default:
        break;  
    }
  }
  nestCurveHidden('');
}
/*
 =========================================================================
 @function name : welding_LongClick
 @argument      : none
 @description   : welding_LongClick Buttom Clicked
 @return        : none
 =========================================================================
*/
var g_wt_longPress_state = {state: '', addStartElmId: '', addEndElmId: ''};
function welding_LongClick() {
  if(g_RO_flg || !g_TPenbl_flg|| gPopDispFlg){
    if(g_RO_flg || !g_TPenbl_flg) {
      var disp = toastStr_notEdit_welding();
      toast.show(disp);
    }
    return;
  }
  var prg = [];
  nestCurveHidden('hidden');
  if(g_order_sysVal["$AWSTABUI.$WSICONTYPE"] != undefined && g_order_sysVal["$AWSTABUI.$WSICONTYPE"].value == '1') {
    if(g_wt_longPress_state.state == '') {
      welding_LongClick_addWeldMotion('startAdding');
    }
    else if(g_wt_longPress_state.state == 'startSaved') {
      welding_LongClick_addWeldMotion('endAdding');
    }
  }
  else {
    var parentData = getNestPosition("-INST_EASYAW_START");
    if(parentData){
      var bktData = getNestPosition();
      var parentNestId = nestIdChk(bktData);
    }
    switch (parentData) {
      case false:
        var dropFuncFlg = true;
        /*hadleTeach icon is easyArc flag.(true:easyArc position saving now/false:easyArc position save completed)*/
        g_MTGData.teachEasyArcFlg = true;
        prg[0] = ORDER_CALL + " " +
          "-INST_EASYAW_START(" + "P[N]," + "P[N]," + "200,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)";
        prg[1] = ORDER_CALL + " " +
          "-INST_EASYAW_END(" + "P[N]," + "P[N]," + "200,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)";
        dispAddProgSave(prg, dropFuncFlg);
        targetNestNum = getWeldNestNum();
        gLedState = RO_LEDON;
        top.rpcmc_iovalset(IO_TYPE_ROUT,RO_PIN1,gLedState);
        break;
      case true:
        switch (parentNestId) {
          case false:
            var dropFuncFlg = true;
            /*hadleTeach icon is easyArc flag.(true:easyArc position saving now/false:easyArc position save completed)*/
            g_MTGData.teachEasyArcFlg = true;
            prg[0] = ORDER_CALL + " " +
              "-INST_EASYAW_START(" + "P[N]," + "P[N]," + "200,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)";
            prg[1] = ORDER_CALL + " " +
              "-INST_EASYAW_END(" + "P[N]," + "P[N]," + "200,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)";
            dispAddProgSave(prg, dropFuncFlg);
            targetNestNum = getWeldNestNum();
            gLedState = RO_LEDON;
            top.rpcmc_iovalset(IO_TYPE_ROUT,RO_PIN1,gLedState);
            break;
          case true:
            targetNestNum = 0;
            gLedState=RO_LEDOFF;
            top.rpcmc_iovalset(IO_TYPE_ROUT,RO_PIN1,gLedState);
            weldingSetEasyawPosition();
            break;
          default:
            break;
        }
        break;
      default:
        break;  
    }
  }
  nestCurveHidden('');
}

/*
 =========================================================================
 @function name       : welding_LongClick_addWeldMotion
 @argument[nextstate] : 
 @description         : 
 @return[]            : none
 =========================================================================
*/
function welding_LongClick_addWeldMotion(nextstate) {
  if(nextstate == 'startAdding') {
    g_wt_longPress_state.state = nextstate;
    var prg = ORDER_LINE + " P[N] 100mm/sec "+ ORDER_FINE + " " + ORDER_WELDSTART + "[...,...]";
    dispAddProgSave(prg);
    gLedState = RO_LEDON;
    top.rpcmc_iovalset(IO_TYPE_ROUT,RO_PIN1,gLedState);
  }
  else if(nextstate == 'endAdding') {
    g_wt_longPress_state.state = nextstate;
    var prg = ORDER_LINE + " P[N] " + ORDER_WELD_SPEED + " " +ORDER_FINE + " " + ORDER_WELDEND;
    prg += (g_sysval['$AWSCFG.$WELD_ID_ENA']) ? '[...,...,WID:0]' : '[...,...]';
    dispAddProgSave(prg);
    gLedState = RO_LEDOFF;
    top.rpcmc_iovalset(IO_TYPE_ROUT,RO_PIN1,gLedState);
  }
}

/*
 =========================================================================
 @function name : toastStr_notEdit_welding
 @argument[]    : none
 @description   : 
 @return[]      : The wording to display toast.
 =========================================================================
*/
function toastStr_notEdit_welding() {
  var ret = toastStr_notEdit();
  /* fail safe : Overwrite strings */
  if(ret == langResource.ihmieditor_pop_weldingteach_not_operate_c) {
    ret = langResource.ihmieditor_pop_tpreadonly_c;
  }

  return ret;
}
/*
 =========================================================================
 @function name : getWeldNestNum
 @argument[]    : none
 @description   : 
 @return[]      : nestID.
 =========================================================================
*/
function getWeldNestNum() {
  var existChk = function(key) {
    var tmp = g_program_data[key].stretch.idList.find(function(data) {
      return g_program_data[data.id].baseId === '-INST_ARC_HANDLE_TEACH';
    });
    return tmp ? true : false;
  };
  var stretchArray = get_progList_bktlead();
  var nestChk = stretchArray.filter(function(key) {
    return existChk(key);
  });
  return nestChk.length > 0 ? nestChk.length : '';
}
/*
 =========================================================================
 @function name : nestIdChk
 @argument[]    : none
 @description   : sample program add bracket return true
 @return[]      : 
 =========================================================================
*/
function nestIdChk (bktData) {
  if (targetNestNum == undefined || targetNestNum == 0) {
    return false;
  } 
  var tl = g_TL_progInfo.dispProg;
  for (var i = 0; i < bktData.length; i++) {
    if(tl.indexOf(bktData[i].parentId) != -1 && g_program_data[bktData[i].parentId].nest.num == targetNestNum) {
      return true;
    }
  }
  return false;
}

/*
 =========================================================================
 @function name    : addprgRecord_wt_longPress_state
 @argument[saveId] : 
 @description      : 
 @return[]         : 
 =========================================================================
*/
function addprgRecord_wt_longPress_state(saveId) {
  var setState = {state:'', startId:''};
  if(g_wt_longPress_state.state == 'startAdding') {
    g_wt_longPress_state.state = 'startSaved';
    var setState = {state: g_wt_longPress_state.state, startId: saveId};
    progdata_addClassCheck(saveId, 'wt_nodrag');
  }
  else if(g_wt_longPress_state.state == 'endAdding') {
    var setState = {state: 'endSaved', startId: g_wt_longPress_state.addStartElmId};
    /* Consider the case where 'wt_nodrag' class remains in Weld Start. */
    progdata_rmvClassCheck(g_wt_longPress_state.addStartElmId, 'wt_nodrag');
    g_wt_longPress_state = {state: '', addStartElmId: '', addEndElmId: ''};
  }
  return setState;
}

/*
 =========================================================================
 @function name            : weldingTeachPosInfo
 @argument[posNo]          : position number
 @argument[coordinate]     : coordinate format to save (COORDINATECART or COORDINATEJOINT)
 @description              : Gat the information necessary to save the coordinates
 @return                   :
 =========================================================================
*/
function weldingTeachPosInfo(posNo, coordinate) {
  //Gat the information necessary to save the coordinates
  var posItem = top.IHMIComponents.position.createRecord.get();
  var cartPosInfo  = top.irprogapi.analyzePositionStr(COORDINATECART,  g_MTGData.teachPosData.cart,  posItem);
  var jointPosInfo = top.irprogapi.analyzePositionStr(COORDINATEJOINT, g_MTGData.teachPosData.joint, posItem);
  var cbArg = {call:checkConvComp};
  g_MTGData.teachPosData.posNo = posNo;
  //Joint save
  posItem.joint.J1 = jointPosInfo.J1;
  posItem.joint.J2 = jointPosInfo.J2;
  posItem.joint.J3 = jointPosInfo.J3;
  posItem.joint.J4 = jointPosInfo.J4;
  posItem.joint.J5 = jointPosInfo.J5;
  posItem.joint.J6 = jointPosInfo.J6;
  posItem.ext.E1 = jointPosInfo.EXT1;
  posItem.ext.E2 = jointPosInfo.EXT2;
  posItem.ext.E3 = jointPosInfo.EXT3;
  //any pos save
  posItem.posNumber = posNo; // Position number created by drop operation
  posItem.conf = cartPosInfo.Config;
  posItem.ut = cartPosInfo.UT;
  posItem.uf = cartPosInfo.UF;
  posItem.group = cartPosInfo.group;
  posItem.frame = 0; 
  posItem.rep = 0; 
  posItem.empty = false;
  posItem.cbArg = cbArg;

  var exchgInfo,posStr;
  if(coordinate == COORDINATECART) {
    //Cart save
    posItem.cart.X = cartPosInfo.X;
    posItem.cart.Y = cartPosInfo.Y;
    posItem.cart.Z = cartPosInfo.Z;
    posItem.cart.W = cartPosInfo.W;
    posItem.cart.P = cartPosInfo.P;
    posItem.cart.R = cartPosInfo.R;
    posItem.rep = FORMAT_CART; 
    // Get and set format conversion data
    exchgInfo = prepareExchgInfo(posItem);
    exchgInfo.posNum     = (posItem.posKind != top.IHMIComponents.position.posDef['POSKIND_REG']) ? posItem.posNumber: posItem.posRegNum;
    exchgInfo.posRec     = posItem;
    exchgInfo.exchgTo    = COORDINATEJOINT;
    exchgInfo.comp       = true;
    posStr = top.irprogapi.constructExchangePosText(exchgInfo);
    // Get coordinates where Cart is changed to Joint
    top.rpcmc_mnchgrep(posStr, exchgPosCallback, exchgInfo);
  }
  else{ /*save joint coordinates*/
    weldingTeach_editPos(posItem, COORDINATEJOINT);
  }
}

/*
 =========================================================================
 @function name            : weldingTeach_editPos
 @argument[posItem]        : information necessary to save the coordinates
 @argument[coordinate]     : coordinate format to save (COORDINATECART or COORDINATEJOINT)
 @description              : This function is save Arbitrary Coordinates by Specifying Coordinate Format
 @return                   :
 =========================================================================
*/
function weldingTeach_editPos(posItem, coordinate) {
  var robotAxes = top.irprogapi.getAxisData();
  // Get and set format conversion data
  if(coordinate == COORDINATEJOINT) { 
    posItem.frame = COORDINATEJOINT;
  }
  else{
    posItem.frame = COORDINATECART;
  }
  posItem.axes = robotAxes.robot[posItem.group];
  posItem.rep = getRepKind(posItem.frame, posItem.group);
  /*The type you were originally trying to save*/
  var sortPosData = {0: posItem};
  var sortArgs = {baseData: sortPosData, mergeData: sortPosData, armType: g_config.armType};
  /*saving Specified position*/
  top.irprogapi.editMergePositionData(current_prog_name, sortArgs, weldingTeach_editPosCallback);
}

/*
 =========================================================================
 @function name            : weldingTeach_editPosCallback
 @argument[states]         : 
 @argument[progName]       : program name
 @description              : editpos_multi callback
 @return                   :
 =========================================================================
*/
function weldingTeach_editPosCallback(status, progName) {
  if (status.status !== IO_SUCCESS) {
    display_popupmsg_confirm(top, langResource.ihmieditor_pop_error_reload_c, cb_closepopup_location_reload);
    return;
  }
  var str = [g_MTGData.teachPosData.cart];
  var analyzePos = top.irprogapi.analyzeMultiPositionStr(str);
  var posJson = { "Comment": "", "posNumber": 0, "rep": FORMAT_CART, "posData": [] };
 
  for (var i = 0; i < analyzePos.length; i++) {
    var searchPosAxis = ((analyzePos[i].rep == FORMAT_JOINT) ? [].concat(top.REF_POS_JOINT) : [].concat(top.REF_POS_CART)).concat(top.REF_POS_EXT);
    posJson["posData"].push({ "poskey": [], "groupNumber": analyzePos[i].GP });
    posJson["posData"][i].ufVal = analyzePos[i].UF || 0; // UF
    posJson["posData"][i].utVal = analyzePos[i].UT || 1; // UT
    if (analyzePos[i].Config) {
      posJson["posData"][i].configStr = analyzePos[i].Config; // CONFIG
    }
    for (var j = 0; j < searchPosAxis.length; j++){ // POSITION
      if (typeof analyzePos[i][searchPosAxis[j]] === 'undefined') { continue; }
      posJson["posData"][i]["poskey"].push({ "key": searchPosAxis[j], "val": analyzePos[i][searchPosAxis[j]] });
    }
  }
  set_position_dataj(posJson, g_MTGData.teachPosData);

  if(g_MTGData.teachEasyArcFlg) { /*In case of easyArc, pass twice*/
    g_MTGData.teachEasyArcFlg = false;
  }
  else{
    /*Teaching positon saving start or end flag.(true:Teaching position saving now/false:Teaching position save completed)*/
    g_MTGData.savingTeachPosFlg = false; 
  }

  if (!save_id_array.length) {
    position_record.array_add(position);
  }
  save_icon_position_data(save_iconId);
}

                                                                                                                                                                                                                                                      /*
 * @fileoverview : Advanced Instruction API
 * @char-code    : SJIS
 * @NewLineCode  : LF
 */

/*
 =========================================================================
 @function name : setInstructionParam
 @argument[str] : String
 @description   :
 @return        : none
 =========================================================================
*/
function setInstructionParam(str){
	setInstParam(str);
}

/*
 =========================================================================
 @function name : setInstructionParamWithCB
 @argument[str] : String
 @argument[callback]     : set a CallBack
 @argument[cbarg]        : set an argument of CallBack
 @description   :
 @return        : none
 =========================================================================
*/
function setInstructionParamWithCB(str, callback, cbarg) { 
  try { 
    if (!setInstParamWithCB(str, callback, cbarg) && typeof callback === "function") callback(top.IO_COMFAILURE, cbarg); 
  } catch(e){ 
    if (typeof callback === "function") callback(top.IO_COMFAILURE, cbarg); 
  } 
}

/*
 =========================================================================
 @function name : InstructionWaiting
 @argument      : none
 @description   :
 @return        : none
 =========================================================================
*/
function InstructionWaiting(){
	dispOnWaiting();
}

/*
 =========================================================================
 @function name : InstructionOffWaiting
 @argument      : none
 @description   :
 @return        : none
 =========================================================================
*/
function InstructionOffWaiting(){
	dispOffWaiting();
}

/*
 =========================================================================
 @function name : setEndInstructionParam
 @argument[str] : String
 @description   :
 @return        : none
 =========================================================================
*/
function setEndInstructionParam(str){
	setEndParam(str);
}

/*
 =========================================================================
 @function name : setEndInstructionParamWithCB
 @argument[str] : String
 @argument[callback]     : set a CallBack
 @argument[cbarg]        : set an argument of CallBack
 @description   :
 @return        : none
 =========================================================================
*/ 
function setEndInstructionParamWithCB(str, callback, cbarg) { 
  try { 
    if (!setEndParamWithCB(str, callback, cbarg) && typeof callback === "function") callback(top.IO_COMFAILURE, cbarg); 
  } catch(e){ 
    if (typeof callback === "function") callback(top.IO_COMFAILURE, cbarg); 
  } 
}

/*
 =========================================================================
 @function name : instructionFrameDisp
 @argument[str] : String
 @description   :
 @return        : none
 =========================================================================
*/
function instructionFrameDisp(str){
	instFrameDisp(str);
}

/*
 =========================================================================
 @function name : instructionFrameHide
 @argument      : none
 @description   :
 @return        : none
 =========================================================================
*/
function instructionFrameHide(){
	instFrameHide();
}

/*
 =========================================================================
 @function name       : instructionDeleteIcon
 @argument[classname] : The class assigned to the element to be deleted.
 @description         :
 @return              : none
 =========================================================================
*/
function instructionDeleteIcon(classname){
	timeLine_selectDel(classname);
}

/*
 =========================================================================
 @function name        : instructionsetArrowPos
 @argument[percentage] : Position from the top of the editor screen. (specified by %)
 @description          :
 @return               : none
 =========================================================================
*/
function instructionsetArrowPos(percentage){
	setArrowPos(percentage);
}

/*
 =========================================================================
 @function name : setInstructionParamTemp
 @argument[str] : String
 @description   :
 @return        : none
 =========================================================================
*/
function setInstructionParamTemp(str){
	setParamTemp(str);
}

/*
 =========================================================================
 @function name : setInstructionDropEnd
 @argument      : none
 @description   :
 @return        : none
 =========================================================================
*/
function setInstructionDropEnd(){
	setDropEnd();
}

/*
 =========================================================================
 @function name     : instructionSetActiveIcon
 @argument[lineNum] : none
 @description       : Specify activeIcon from ProgramLine
 @return            : Result. (true : success / false : Specified line number does not exist.)
 =========================================================================
*/
function instructionSetActiveIcon(lineNum){
	return instSetActiveIcon(lineNum);
}

/*
 =========================================================================
 @function name : instructionGetCurrentLineNum
 @argument      : none
 @description   : Get the line number of the active instruction.
 @return        : 
 =========================================================================
*/
function instructionGetCurrentLineNum(){
	return instGetCurrentLineNum();
}

/*
=========================================================================
@function name   : instructionGetEndLineNum
@argument[]      : none
@description     : Get the last line number.
@return          : current program end lineNumber
=========================================================================
*/
function instructionGetEndLineNum() {
	return instGetEndLineNum();
}

/*
=========================================================================
@function name        : getNestPosition
@argument[chkPrgName] : Name of the program to check the nest position.
@description          : 
@return               : parent bracket id
=========================================================================
*/
function getNestPosition(chkPrgName) {
	return getNestIdList(chkPrgName);
}

/*
 =========================================================================
 @function name     : getProgList
 @argument[prgName] : The name of the program to get.
 @description       : Get a list of program names that use "prgName" from the beginning of the program name.
 @return            : TPprogramList
 =========================================================================
*/
function getProgList(prgName) {
	return getProgNameList(prgName);
}

/*
 =========================================================================
 @function name          : bracketArg_addRecord
 @argument[woRegUndoFlg] : Boolean (true: Update tp program without registering undoPoint.) [For withCB]
 @description            : 
 @return                 : none
 =========================================================================
*/
function bracketArg_addRecord(woRegUndoFlg) {
  if (g_adin_state.record.length > 0) {
    if(woRegUndoFlg == false || woRegUndoFlg == null) {
      g_adin_state.record.type = OPERATION_EDIT_MULTI;
      timeline_record.array_add(g_adin_state.record);
      check_undoredo_active();
      position_record.array_add(position);
      positionregi_record.array_add(g_position_regi);
      g_adin_state.record = [];
    }
  }
  g_adin_state.setBracketArgFlg = false;
}

/*
 =========================================================================
 @function name : getLoadCheckResultMonitorStat
 @argument[]    : none
 @description   :
 @return        : Display state. (true:Displaying)
 =========================================================================
*/
/**** For screw tightening only ****/
function getLoadCheckResultMonitorStat() {
  return getLoadCheckResultApndStat();
}

/*
 =========================================================================
 @function name : load_loadCheckResultMonitor
 @argument[]    : none
 @description   :
 @return        : none
 =========================================================================
*/
/**** For screw tightening only ****/
function load_loadCheckResultMonitor() {
  upperArea_selectHandling("monitor_loadcheckresult");
}

/*
 =========================================================================
 @function name : remove_loadCheckResulMonitor
 @argument[]    : none
 @description   :
 @return        : none
 =========================================================================
*/
/**** For screw tightening only ****/
function remove_loadCheckResulMonitor() {
  upperArea_selectHandling("change_4d");
}

var editorAPI = {
	funcs: null
};

var g_setTpOrderCallBack = null; //Use in setTpOrder().

(function () {

	/*
	=========================================================================
	@function name     : getLineTpName
	@argument[num]     : The number of the program to get.
	@description       : Gets the TPName for the given line number.
	@return            : TPName
	=========================================================================
	*/
	function getLineTpName(num) {
		const progId = g_TL_progInfo.saveProg[num - 1];
		return (typeof progId === "undefined" || chk_basicInstruction(g_program_data[progId].baseId)) ?
					"" : g_program_data[progId].param.split("(")[0].toUpperCase();
	}

	/*
	=========================================================================
	@function name     : getLineDispName
	@argument[num]     : The number of the Title to get.
	@description       : Gets the DispName for the given line number.
	@return            : DispName
	=========================================================================
	*/
	function getLineDispName(num) {
		const progId = g_TL_progInfo.saveProg[num - 1];
		return (typeof progId === "undefined" || chk_basicInstruction(g_program_data[progId].baseId)) ?
					"" : g_xml_data[g_program_data[progId].baseId].detailTitle;
	}

	/*
	=========================================================================
	@function name     : getIconsArray
	@argument : none
	@description       : Get the information of the currently displayed timeline.
	@return            : timeline infomation
	=========================================================================
	*/
	function getIconsArray() {
		const lineEnd = instructionGetEndLineNum();
		const iconsArray = [];
		for (let i = 1; i <= lineEnd; i++) {
			const name = getLineTpName(i);
			const dispName = getLineDispName(i);
			iconsArray.push({name: name, line: i, dispName: dispName});
		}
		return iconsArray;
	}

	/*
	=========================================================================
	@function name     : getAdinstArg
	@argument[num]     : The number of the argument to get.
	@description       : Gets the argument for the given line number.
	@return            : argument
	=========================================================================
	*/
	function getAdinstArg(num) {
		const progId = g_TL_progInfo.saveProg[num - 1];
		if (typeof progId === "undefined" || chk_basicInstruction(g_program_data[progId].baseId)) return "";
		let advArg = split_param_call(g_program_data[progId].param)[1];
		if (typeof advArg == "undefined") return "";
		advArg = commentParse(langConvEng(adinstArg_rmvParen(advArg)));
		return advArg;
	}

	/*
	=========================================================================
	@function name     : getIoSysValLimit
	@argument[num]     : 
	@description       : Value obtained from system variables
	@return            : Setting limit value of IO
	=========================================================================
	*/
	function getIoSysValLimit(){
		/*Structure of extend_IOlimit_val
			AI: {max: number, min: number} AO: {max: number, min: number} DI: {max: number, min: number}
			DO: {max: number, min: number}  F: {max: number, min: number} GI: {max: number, min: number}
			GO: {max: number, min: number} PR: {max: number, min: number}  R: {max: number, min: number}
			RI: {max: number, min: number} RO: {max: number, min: number} SI: {max: number, min: number}
			SO: {max: number, min: number} UI: {max: number, min: number} UO: {max: number, min: number} 
		+ if Lang = "kn"{
			PR(Translated): {max: number, min: number} R(Translated): {max: number, min: number}
		  }*/
		if(Object.keys(extend_IOlimit_val).length == 0) {
			$.extend(true, extend_IOlimit_val, g_regIOlimit_val);
			if(gcurrentLang == "kn") {
				$.extend(true, extend_IOlimit_val, {
					["R"]: {max: extend_IOlimit_val[ORDER_REGI].max, min: extend_IOlimit_val[ORDER_REGI].min},
					["PR"]: {max: extend_IOlimit_val[ORDER_POSREGI].max, min: extend_IOlimit_val[ORDER_POSREGI].min}
				});
			}
		}
		return extend_IOlimit_val;
	}

	/*
    =========================================================================
    @function name     : getMainProg
    @argument          : none
    @description       : Pass the name of the Main program name.
    @return            : main program name
    =========================================================================
    */
    function getMainProg() {
        return tp_prog_name;
    }
    
    /*
    =========================================================================
    @function name     : getCurrProg
    @argument          : none
    @description       : Pass the name of the currently open program name.
    @return            : current program name
    =========================================================================
    */
    function getCurrProg() {
        return current_prog_name;
    }

	/*
    =========================================================================
    @function name     : getMtGrpNum
    @argument          : none
    @description       : Pass the number of the motion group data.
    @return            : motion group data (bit)
    =========================================================================
    */
    function getMtGrpNum() {
        return getMotionGroup();
    }
  
		/*
	=========================================================================
	@function name          : setDeleteCallBack
	@argument[iconName]     : set an event TP Program Name
	@argument[callBack]     : set an delete event CallBack
	@description            : In case of Bracket, perform key search with bktlead
	@return                 : true false
	=========================================================================
	*/
	function setDeleteCallBack(iconName, callBack) {
		if(typeof callBack !== "function") return false;
		var key = (iconName in g_inst_obj) ? iconName
			: ("bktlead" + iconName in g_inst_obj) ? "bktlead" + iconName
			: false;
		if(key !== false) g_inst_obj[key].funcList.m_deletefunc = callBack;
		return true;
	}
	/*
	=========================================================================
	@function name          : setCopyCallBack
	@argument[iconName]     : set an event TP Program Name
	@argument[callBack]     : set an copy event CallBack
	@description            : In case of Bracket, perform key search with bktlead
	@return                 : true false
	=========================================================================
	*/
	function setCopyCallBack(iconName, callBack) {
		if(typeof callBack !== "function") return false;
		var key = (iconName in g_inst_obj) ? iconName
			: ("bktlead" + iconName in g_inst_obj) ? "bktlead" + iconName
			: false;
		if(key !== false) g_inst_obj[key].funcList.m_copyfunc = callBack;
		return true;
	}

	/*
	=========================================================================
	@function name          : setDropCallBack
	@argument[iconName]     : set an event TP Program Name
	@argument[callBack]     : set an init event CallBack
	@description            : In case of Bracket, perform key search with bktlead
	@return                 : true false
	=========================================================================
	*/
	function setDropCallBack(iconName, callBack) {
		if(typeof callBack !== "function") return false;
		var key = (iconName in g_inst_obj) ? iconName
			: ("bktlead" + iconName in g_inst_obj) ? "bktlead" + iconName
			: false;
		if(key !== false) g_inst_obj[key].funcList.m_dropfunc = callBack;
		return true;
	}
	/*
	=========================================================================
	@function name          : setSortCallBack
	@argument[iconName]     : set an event TP Program Name
	@argument[callBack]     : set an init event CallBack
	@description            : In case of Bracket, perform key search with bktlead
	@return                 : true false
	=========================================================================
	*/
	function setSortCallBack(iconName, callBack) {
		if(typeof callBack !== "function") return false;
		var key = (iconName in g_inst_obj) ? iconName
			: ("bktlead" + iconName in g_inst_obj) ? "bktlead" + iconName
			: false;
		if(key !== false) g_inst_obj[key].funcList.m_sortfunc = callBack;
		return true;
	}
	/*
	=========================================================================
	@function name          : setAdinstArg
	@argument[num]          : program line
	@argument[callBack]     : arg
	@description            : Update tp program without registering undoPoint
	@return                 : none
	=========================================================================
	*/
	function setAdinstArg(num, arg) {
		g_adin_state.setAdinstArgFlg = true;
		const progId = g_TL_progInfo.saveProg[num - 1];
		if (typeof progId === "undefined" || chk_basicInstruction(g_program_data[progId].baseId)) return "";
		var prgName = editorAPI.funcs.getLineTpName(g_program_data[progId].array_num + 1);
		g_program_data[progId].param = prgName + "(" + arg + ")";
		if (g_program_data[progId].position.length > 0) {
			posNumChk(progId,"(" + arg + ")");
		}
		if(g_adin_state.temp) {
			var tmpIdx = g_adin_state.temp.allId.indexOf(progId);
			if(tmpIdx > -1) {
				g_adin_state.temp.allData[tmpIdx].param = prgName + "(" + arg + ")";
			}
		}
		write_mode = EDIT_PRG_OPT_OVERWRITE;
		need_position_save_flg = true;
		save_tporder(progId, write_mode, save_tporder_callback, progId);
	}

	/*
	=========================================================================
	@function name          : setTpOrder
	@argument[line]         : insert program line
	@argument[order_array]  : insert sample program array
	@argument[setPosObj]    : set positions object
	@argument[callback]     : set an init event CallBack
	@argument[cbarg]        : set an argument of CallBack
	@description            : When an instruction is added, the attached instruction is added.
	@return                 : none
	=========================================================================
	*/
	function setTpOrder(line, order_array, setPosObj, callback, cbarg) {
		g_setTpOrderCallBack = function(state) {
			dispOffWaiting();
			toggleNode_whileSaving(false);
			g_adin_state.pkgSampleProgAdding = false;
			var editorSetTpOrderCB = function(setPosState, setPositionNum) {
				if (setPosState !== EDITER_API_SUCCESS) {
					display_popupmsg_confirm(top, langResource.ihmieditor_pop_error_reload_c, cb_closepopup_location_reload);
				}
				if (typeof callback === "function") callback(setPosState, order_array.length, setPositionNum, cbarg);
			}
			if (state === EDITER_API_SUCCESS) {
				if (Array.isArray(setPosObj) && (setPosObj.length > 0)) {
					setPositions(setPosObj, editorSetTpOrderCB);
					return;
				}
				if (typeof callback === "function") callback(state, order_array.length, 0, cbarg);
			}
			else {
				var addProgNum = (isError) ? 0 : order_array.length - (save_id_array.length + 1);
				if (typeof callback === "function") callback(state, addProgNum, 0, cbarg);
			}
			g_setTpOrderCallBack = null;
		};
		try {
			toggleNode_whileSaving(true);
			dispOnWaiting(0, true);
			var isError = false;
			g_adin_state.pkgSampleProgAdding = true;
			/*positive integer check*/
			if (String(line).match(/^\d*$/g == null)) isError = true;
			// add line check
			if ((line < 0) || (line > MAX_LINE_COUNT)) isError = true;
			// sampleProg check
			if (order_array.length > MAX_SAMPLEPROG_LINE) isError = true;
			isError = isError || !addSampleProgTp(g_adintarget, false, line, order_array);
			if ((isError)) {
				g_setTpOrderCallBack(EDITER_API_ERROR);
			}
		}
		catch {
			isError = true;
			g_setTpOrderCallBack(EDITER_API_ERROR);
		}
	}
	/*
	=========================================================================
	@function name          : setBracketArg
	@argument[arg]          : String or array
	@description            : Combine undoPoints into one and update the tp program
	@return                 : none
	=========================================================================
	*/
	function setBracketArg(arg) {
		var argArray = chkInstPrm(arg);
		if (!argArray) return;
		g_adin_state.setBracketArgFlg = true;
		if (argArray.length == 1) setEndInstructionParam(argArray[0]);
		if (argArray.length >= 2) setEndInstructionParam(argArray[1]);
		setInstructionParam(argArray[0]);
		/* Pending start side processing. */
		if(setEndParamPos.endId != '') {
			setEndParamPos.bktUndoInfo.hold = true;
		}
		else {
			bracketArg_addRecord(null);
		}
	}
  /*
  =========================================================================
  @function name          : setBracketArgWithCB
  @argument[arg]          : String or array
  @argument[callback]     : set a CallBack
  @argument[cbarg]        : set an argument of CallBack
  @argument[withoutRegUndoFlg]  : Boolean (true: Update tp program without registering undoPoint.)
  @description            : Combine undoPoints into one and update the tp program
  @return                 : none
  =========================================================================
  */
  function setBracketArgWithCB(arg, callback, cbarg, withoutRegUndoFlg) {
    var argArray = chkInstPrm(arg);
    if (!argArray) {
      callback(top.IO_COMFAILURE, cbarg);
      return;
    }
    var SET_INST_STAT = {
      YET: 0,
      SUCCESS: 1,
      FAIL: 2
    };
    var SET_INST = {
      START: 0,
      END: 1
    }
    var setInst = Array(Object.keys(SET_INST).length).fill(SET_INST_STAT.YET);
    g_adin_state.setBracketArgFlg = true;
    if (argArray.length == 1) setEndInstructionParamWithCB(argArray[0], setEndInstructionParamCB);
    if (argArray.length >= 2) setEndInstructionParamWithCB(argArray[1], setEndInstructionParamCB);
    setInstructionParamWithCB(argArray[0], setInstructionParamCB);
    /* Pending start side processing. */
    if(setEndParamPos.endId != '') {
      setEndParamPos.bktUndoInfo = {hold: false, withoutRegist: withoutRegUndoFlg};
    }
    else {
      bracketArg_addRecord(withoutRegUndoFlg);
    }

    function setInstructionParamCB(state) {
      if (typeof callback === 'function') {
        setInst[SET_INST.START] = (state == IO_SUCCESS) ? SET_INST_STAT.SUCCESS : SET_INST_STAT.FAIL;
        setBracketArgCB();
      }
    }
    function setEndInstructionParamCB(state) {
      if (typeof callback === 'function') {
        setInst[SET_INST.END] = (state == IO_SUCCESS) ? SET_INST_STAT.SUCCESS : SET_INST_STAT.FAIL;
        setBracketArgCB();
      }
    }
    function setBracketArgCB() {
      if ((typeof callback === 'function') && (setInst.indexOf(SET_INST_STAT.YET) == -1)) {
        var state = (setInst.indexOf(SET_INST_STAT.FAIL) == -1) ? IO_SUCCESS : top.IO_COMFAILURE;
        callback(state, cbarg);
      }
    }
  }
	/*
	=========================================================================
	@function name          : getPosNumber
	@argument[arg]          : TPprogram argument
	@description            : get Argument with position number
	@return                 : Argument with position number
	=========================================================================
	*/
	function getPosNumber(arg){
		var prm = arg.split(",");
		for (var i = 0; i < prm.length; i++) {
			if (prm[i].indexOf(ORDER_POS+"[N]") != -1 || prm[i].indexOf("P[N]") != -1) {
				var posnum = getMinPos();
				prm[i] = prm[i].replace("[N]", "["+posnum+"]");
			}
			else if (prm[i].indexOf(ORDER_POSREGI+"["+ORDER_REGI+"[") != -1 ||
					 prm[i].indexOf("PR[R[N]]") != -1 ||
					 prm[i].indexOf(ORDER_POSREGI+"["+ORDER_ARGUMENT+"[") != -1 ||
					 prm[i].indexOf("PR[AR[N]]") != -1) {
				/* The value to be replaced shall be a fixed value. */
				prm[i] = prm[i].replace("[N]", "[1]");
			}
			else if (prm[i].indexOf(ORDER_POSREGI+"[N]") != -1 || prm[i].indexOf("PR[N]") != -1) {
				var posnum = getMinPosreg();
				prm[i] = prm[i].replace("[N]", "["+posnum+"]");
			}
			prm[i] = setLangConvJpEng(prm[i]);
		}
		posTemporary = [];
		posRegTemporary = [];
		return prm.join(",");
  }
  /*
  =========================================================================
  @function name          : refreshLocalRTBComp
  @argument[elm]          : element
  @argument[value]        : input value
  @argument[isCmpDsb]     : If TRUE, invalid indication.
  @argument[isLocalREnb]  : If TRUE, enables local registers.
  =========================================================================
  */
  function refreshLocalRTBComp(elm, value, isCmpDsb, isLocalREnb) {
    var R_IDX = 0;
    var localRegNum = g_config['localReg'][R_IDX];
    if (isLocalREnb && Number(localRegNum) > 0) {
      var optionObj = {
        range: [
          {
            min: LOCAL_REG_MIN,
            max: LOCAL_REG_MIN + localRegNum - 1
          }
        ]
      }
      elm.refresh(String(value), String(g_regIOlimit_val[ORDER_REGI].min), String(g_regIOlimit_val[ORDER_REGI].max), isCmpDsb, optionObj);
    } else {
      elm.refresh(String(value), String(g_regIOlimit_val[ORDER_REGI].min), String(g_regIOlimit_val[ORDER_REGI].max), isCmpDsb);
    }
  }
  /*
  =========================================================================
  @function name          : refreshLocalPRTBComp
  @argument[elm]          : element
  @argument[value]        : input value
  @argument[isCmpDsb]     : If TRUE, invalid indication.
  @argument[isLocalREnb]  : If TRUE, enables local registers.
  =========================================================================
  */
  function refreshLocalPRTBComp(elm, value, isCmpDsb, isLocalREnb) {
    var PR_IDX = 1;
    var localPRNum = g_config['localReg'][PR_IDX];
    if (isLocalREnb && Number(localPRNum) > 0) {
      var optionObj = {
        range: [
          {
            min: LOCAL_REG_MIN,
            max: LOCAL_REG_MIN + localPRNum - 1
          }
        ]
      }
      elm.refresh(String(value), String(g_regIOlimit_val[ORDER_POSREGI].min), String(g_regIOlimit_val[ORDER_POSREGI].max), isCmpDsb, optionObj);
    } else {
      elm.refresh(String(value), String(g_regIOlimit_val[ORDER_POSREGI].min), String(g_regIOlimit_val[ORDER_POSREGI].max), isCmpDsb);
    }
  }
  /*
  =========================================================================
  @function name          : undoRedoInactive
  @argument[elm]          : element
  @argument[value]        : input value
  @argument[isCmpDsb]     : If TRUE, invalid indication.
  @argument[isLocalREnb]  : If TRUE, enables local registers.
  =========================================================================
  */
  function undoRedoInactive() {
    if(timeline_record.operation_array[0].type === OPERATION_EDIT) {
      timeline_record.operation_array[0].inactive = true;
    }
    return;
  }

  /*
  =========================================================================
  @function name             : setPositions
  @argument[posDataObj]      : set positions object
  @argument[callBack]        : callback that returns result
  @argument[callBackObj]     : set an argument of CallBack
  @description               : set positions
  @return                    : none
  =========================================================================
  */
  function setPositions(posDataObj, callBack, callBackObj) {
    dispOnWaiting(0, true);
    stopMonitorCurProgModify();
    toggleNode_whileSaving(true);
    var setPositionNum = 0;
    var setPosFinishCallback = function(state) {
      if (state !== EDITER_API_SUCCESS) {
        dispOffWaiting();
        getCurProgModifyTime(startMonitorCurProgModify);
        toggleNode_whileSaving(false);
        if (typeof callBack === "function") callBack(EDITER_API_ERROR, setPositionNum, callBackObj);
        return;
      }
      setPositionNum++;
      if (setPositionNum === posDataObj.length) {
        var record_data = {
          setPosNum: posDataObj.map(posData => posData.posNumber),
          type: OPERATION_SET_POS
        };
        if (callBack.name === 'editorSetTpOrderCB') {
          position_record.array_overwrite(position); //Put together the undo data of setTpOrder() and setPosiotions().
        }
        else {
          timeline_record.array_add(record_data);
          position_record.array_add(position);
          positionregi_record.array_add(g_position_regi);
        }
        check_undoredo_active();
        dispOffWaiting();
        getCurProgModifyTime(startMonitorCurProgModify);
        toggleNode_whileSaving(false);
        if (typeof callBack === "function") callBack(EDITER_API_SUCCESS, setPositionNum, callBackObj);
        return;
      }
      setPosition(posDataObj[setPositionNum], setPosFinishCallback);
    };
    setPosition(posDataObj[setPositionNum], setPosFinishCallback);
  }

  /*
  =========================================================================
  @function name : stopAutoRefresh
  @argument[]    : none
  =========================================================================
  */
  function stopAutoRefresh() {
    g_progModifyInfo.frcStop = true;
    stopMonitorCurProgModify();
  }

  /*
  =========================================================================
  @function name : restartAutoRefresh
  @argument[]    : none
  =========================================================================
  */
  function restartAutoRefresh() {
    g_progModifyInfo.frcStop = false;
    getCurProgModifyTime(startMonitorCurProgModify);
  }

	editorAPI.funcs = {
		getLineTpName: getLineTpName,
		getLineDispName: getLineDispName,
		getIconsArray: getIconsArray,
		getAdinstArg: getAdinstArg,
		getIoSysValLimit: getIoSysValLimit,
		getMainProg: getMainProg,
		getCurrProg: getCurrProg,
		getMtGrpNum: getMtGrpNum,
		getPosNumber: getPosNumber,
		setDeleteCallBack: setDeleteCallBack,
		setCopyCallBack: setCopyCallBack,
		setSortCallBack: setSortCallBack,
		setDropCallBack: setDropCallBack,
		setAdinstArg: setAdinstArg,
		setBracketArg: setBracketArg,
		setBracketArgWithCB: setBracketArgWithCB,
		setTpOrder: setTpOrder,
		setPositions: setPositions,
		stopAutoRefresh: stopAutoRefresh,
		restartAutoRefresh: restartAutoRefresh,
		refreshLocalRTBComp: refreshLocalRTBComp,
		refreshLocalPRTBComp: refreshLocalPRTBComp,
		undoRedoInactive: undoRedoInactive,
		getLoadCheckResultMonitorStat: getLoadCheckResultMonitorStat,
		load_loadCheckResultMonitor: load_loadCheckResultMonitor,
		remove_loadCheckResulMonitor: remove_loadCheckResulMonitor
	};
})();
                                                                                                                                                                                                                                                                                                                                                                                                             IHMIE~15JS    MjXX  MjX  BJ S    c  D E T A I  cL _ L A S E   R . DETAIL~1JS    MjXX  MjXf  BV O R I T  E . J S     I H M I E  D I T O R _   F A IHMIE~16JS    MjXX  MjXH  BT R A N S  #. J S     I H M I E  #D I T O R _   S I IHMIE~17JS    MjXX  MjX>  BT . J S    C  I H M I E  CD I T O R _   W B IHMIE~18JS    MjXX  MjXE                                                                                                  /*
 * @fileoverview : List of instructions to be made resident.
 * @char-code    : SJIS
 * @NewLineCode  : LF
 */

/*
 * Add to the list if you want to leave the detail screen once it is displayed without deleting it.
 * Advanced Instruction            : TP name
 *                                   ** Currently, multi-Advanced Instructions cannot be made resident! **
 * Other than advanced Instruction : iconTbl[] from ihmieditor_define.js
 */
var g_inst_residentList = [
	'straight',
	'kakujiku',
	'curve',
	'circlearc',
	'spline',
	'macro',
	'call',
	'wait',
	'iflead',
	'ifelse',
	'ifend',
	'forlead',
	'forend',
	'jump',
	'label',
	'output',
	'regi',
	'payload',
	'setuframe',
	'setutool',
	'seluframe',
	'selutool',
	'comment',
	'nosupport',
	'noconnect',
	'vsnline',
	'vsnjoint',
	'-inst_ext_pallet',
	'-inst_pallet_3d',
	'-inst_easyaw_start',
	'-inst_easywv_start',
	'laserpre',
	'laserls',
	'laserle',
	'laserpow',
	'laserpresi',
	'laserlssi',
	'laserlesi',
	'weldstartml',
	'weldstopml',
	'weldstartal',
	'weldstopal',
	'weldstartca',
	'weldstopca',
	'laserkpre',
	'laserkls',
	'laserkle',
	'lasercls',
	'lasercle',
	'lasercals',
	'lasercale',
	'lasersls',
	'lasersle',
	'laserwirc',
];

                                                                                                                                                                                                                                                                                                                                                
/*
 =========================================================================
 @function name   : detail_laser_load
 @argument        : dtfrm, baseId
 @description     : This function sets the laser parameter on the laser linear command screen.
 @return          : none
 =========================================================================
*/
function detail_laser_load(dtfrm, baseId, params) {
  var ls_param;
  var slpu_param;
  var slpd_param;
  var ls_sch_flg = 0;
  var le_param;
  

  chk_laser_title(dtfrm, baseId);
  switch (baseId) {
    case 'laserpre':
    case 'laserkpre':
    case 'laserpresi':
      if(pre_ls_ini[1] == true){
        dtfrm.document.getElementById("ch_dise").style.display = "none";
        dtfrm.document.getElementById("ch_enab").style.display = "flex";

        var pre_ls = '';
        if(baseId === 'laserpre' || baseId === 'laserkpre') {
          var chkStr = new RegExp('^' + ORDER_PLE_LS + '\\[');
          for(var cnt = 0; cnt < params.length; cnt++) {
            if(params[cnt].match(chkStr)) {
              pre_ls = params[cnt].slice(params[cnt].indexOf('[') + 1, params[cnt].indexOf(']'));
              break;
            }
          }
        }
        else {
          pre_ls = params.slice(params.indexOf('[') + 1, params.indexOf(']'));
        }
        paramRefresh(dtfrm, pre_ls, [{id:"sel_pos", setVal:[1, 2]}, {id:"ch_val", setVal:[{min:pre_ls_ini[3], max:pre_ls_ini[4]}, {min:"1", max:"16383"}]}]);
      }else{
        dtfrm.document.getElementById("ch_enab").style.display = "none";
        dtfrm.document.getElementById("ch_dise").style.display = "flex";
      }
      break;
    case 'laserls':
    case 'laserkls':
    case 'lasercls':
    case 'lasercals':
    case 'lasersls':
      var chkStr = new RegExp('(^' + ORDER_LS + '|' + ORDER_LS_SCH + ')\\[');
      for(var cnt = 0; cnt < params.length; cnt++){
        var matchResult = params[cnt].match(chkStr);
        if(matchResult){
          ls_param = params[cnt];
          ls_sch_flg = matchResult[1] == ORDER_LS_SCH ? 2 : 1;
          break;
        }
      }
      setDispParam_ls_common(dtfrm, ls_param, ls_sch_flg);

      if(baseId == 'laserls' || baseId == 'lasercls' || baseId == 'lasercals'|| baseId == 'lasersls') {
        /* slopeup & slopedown */
        dtfrm.document.getElementById("slpu_edit").refresh([],1,null,false);
        dtfrm.document.getElementById("slpu_val").refresh(1, 1, 10, false);
        dtfrm.document.getElementById("slpd_edit").refresh([],1,null,false);
        dtfrm.document.getElementById("slpd_val").refresh(1, 1, 10, false);
        dtfrm.document.getElementById("slope_up").refresh(false, false);
        dtfrm.document.getElementById("slope_down").refresh(false, false);

        for(var cnt = 0; cnt < params.length; cnt++){
          if(params[cnt].match(ORDER_SLPU)){
            var slpu_param = params[cnt].slice(params[cnt].indexOf('['), params[cnt].lastIndexOf(']'));
            dtfrm.document.getElementById("slope_up").refresh(true, false);
            paramRefresh(dtfrm, slpu_param, [{id:"slpu_edit", setVal:[1, 2]}, {id:"slpu_val", setVal:[{min:"1", max:"10"}, {min:"1", max:"16383"}]}]);
            var slpuFlg = true;
          }
          if(params[cnt].match(ORDER_SLPD)){
            slpd_param = params[cnt].slice(params[cnt].indexOf('['), params[cnt].lastIndexOf(']'));
            dtfrm.document.getElementById("slope_down").refresh(true, false);
            paramRefresh(dtfrm, slpd_param, [{id:"slpd_edit", setVal:[1, 2]}, {id:"slpd_val", setVal:[{min:"1", max:"10"}, {min:"1", max:"16383"}]}]);
            var slpdFlg = true;
          }
          if(slpuFlg && slpdFlg) break;
        }
      }
      break;
    case 'laserlssi':
      setDispParam_ls_common(dtfrm, params, params.match(ORDER_LS_SCH) ? 2 : 1);
      break;
    case 'laserle':
    case 'laserkle':
    case 'lasercle':
    case 'lasercale':
    case 'lasersle':
      for(var cnt = 0; cnt < params.length; cnt++){
        var matchResult = params[cnt].match(/^LE\[/);
        if(matchResult){
          le_param = params[cnt];
          break;
        }
      }
      setDispParam_le_common(dtfrm, le_param);

      if(baseId == 'laserle' || baseId == 'lasercle' || baseId == 'lasercale' || baseId == 'lasersle') {
        /* slopedown */
        dtfrm.document.getElementById("slpd_edit").refresh([],1,null,false);
        dtfrm.document.getElementById("slpd_val").refresh(1, 1, 10, false);
        dtfrm.document.getElementById("slope_down").refresh(false, false);

        for(var cnt = 0; cnt < params.length; cnt++){
          if(params[cnt].match(ORDER_SLPD)){
            slpd_param = params[cnt].slice(params[cnt].indexOf('['), params[cnt].lastIndexOf(']'));
            dtfrm.document.getElementById("slope_down").refresh(true, false);
            paramRefresh(dtfrm, slpd_param, [{id:"slpd_edit", setVal:[1, 2]}, {id:"slpd_val", setVal:[{min:"1", max:"10"}, {min:"1", max:"16383"}]}]);
            break;
          }
        }
      }
      break;
    case 'laserlesi':
      setDispParam_le_common(dtfrm, params);
      break;
    case 'laserpow':
      var pow_ctl = params.slice(params.indexOf('[') + 1, params.indexOf(']'));
      /* Constant */
      if(pow_ctl.includes(ORDER_REGI) == false) {
        paramRefresh(dtfrm, pow_ctl, [{id:"pwc_pos", setVal:[1, 2]}, {id:"ctrl_table", setVal:[{min:"0", max:"10"}, {min:"", max:""}]}]);
        dtfrm.document.getElementById("pwc_reg").style.display = "none";
        dtfrm.document.getElementById("pwc_inp").style.display = "block";
      }
      /* Resistor */
      else {
        paramRefresh(dtfrm, pow_ctl, [{id:"pwc_pos", setVal:[1, 2]}, {id:"ctrl_reg", setVal:[{min:"", max:""}, {min:"1", max:"16383"}]}]);
        dtfrm.document.getElementById("pwc_inp").style.display = "none";
        dtfrm.document.getElementById("pwc_reg").style.display = "block";
      }
      break;
    case 'laserwirc':
      /* Wire feed type */
      var ty_param = params.slice(params.indexOf('[Ty=') + 4, params.indexOf(','));
      /* Constant */
      if(ty_param.includes(ORDER_REGI) == false) {
        paramRefresh(dtfrm, ty_param, [{id:"pwc_pos", setVal:[1, 2]}, {id:"ctrl_table", setVal:[{min:"0", max:"2"}, {min:"", max:""}]}]);
        dtfrm.document.getElementById("pwc_inp").style.display = "block";
        dtfrm.document.getElementById("pwc_reg").style.display = "none";
      }
      /* Resistor */
      else {
        paramRefresh(dtfrm, ty_param, [{id:"pwc_pos", setVal:[1, 2]}, {id:"ctrl_reg", setVal:[{min:"", max:""}, {min:"1", max:"16383"}]}]);
        dtfrm.document.getElementById("pwc_inp").style.display = "none";
        dtfrm.document.getElementById("pwc_reg").style.display = "block";
      }

      /* Wire feed speed */
      var sp_param = params.slice(params.indexOf('Sp=') + 3, params.lastIndexOf(']'));
      /* Constant */
      if(sp_param.includes(ORDER_REGI) == false) {
        paramRefresh(dtfrm, sp_param, [{id:"pwc_pos2", setVal:[1, 2]}, {id:"ctrl_table2", setVal:[{min:"1", max:"32766"}, {min:"", max:""}]}]);
        dtfrm.document.getElementById("pwc_inp2").style.display = "block";
        dtfrm.document.getElementById("pwc_reg2").style.display = "none";
      }
      /* Resistor */
      else {
        paramRefresh(dtfrm, sp_param, [{id:"pwc_pos2", setVal:[1, 2]}, {id:"ctrl_reg2", setVal:[{min:"", max:""}, {min:"1", max:"16383"}]}]);
        dtfrm.document.getElementById("pwc_inp2").style.display = "none";
        dtfrm.document.getElementById("pwc_reg2").style.display = "block";
      }
      break;
    default:
      break;
  }
}

/*
 =========================================================================
 @function name   : setDispParam_ls_common
 @argument        : dtfrm, ls_param, ls_sch_flg
 @description     : 
 @return          : none
 =========================================================================
*/
function setDispParam_ls_common(dtfrm, ls_param, ls_sch_flg) {
  ls_param = ls_param.slice(ls_param.indexOf('['), ls_param.lastIndexOf(']') + 1);

  if(ls_sch_flg == 1) {
    dtfrm.document.getElementById("ls_title").style.display = "inline-block";
    dtfrm.document.getElementById("ls_sch_title").style.display = "none";

    if(ls_out_flg == false){
      var param_end = ls_param.indexOf(',');
      var s_param = ls_param.slice(ls_param.indexOf('S=') + 2, param_end);
      paramRefresh(dtfrm, s_param, [{id:"s_pos", setVal:[1, 2]}, {id:"p_power", setVal:[{min:ls_ini[5], max:ls_ini[6]}, {min:"1", max:"16383"}]}]);

      param_end = ls_param.indexOf(',', param_end + 1);
      var l_param = ls_param.slice(ls_param.indexOf('L=') + 2, param_end);
      paramRefresh(dtfrm, l_param, [{id:"l_pos", setVal:[1, 2]}, {id:"b_power", setVal:[{min:ls_ini[7], max:ls_ini[8]}, {min:"1", max:"16383"}]}]);

      param_end = ls_param.indexOf(',', param_end + 1);
      var p_param = ls_param.slice(ls_param.indexOf('P=') + 2, param_end);
      paramRefresh(dtfrm, p_param, [{id:"p_pos", setVal:[1, 2]}, {id:"freque", setVal:[{min:ls_ini[9], max:ls_ini[10]}, {min:"1", max:"16383"}]}]);

      param_end = ls_param.indexOf(',', param_end + 1);
      var q_param = ls_param.slice(ls_param.indexOf('Q=') + 2, param_end);
      paramRefresh(dtfrm, q_param, [{id:"q_pos", setVal:[1, 2]}, {id:"r_duty", setVal:[{min:ls_ini[11], max:ls_ini[12]}, {min:"1", max:"16383"}]}]);
      
      var v_param = ls_param.slice(ls_param.indexOf('V=') + 2, ls_param.lastIndexOf(']'));
      
      if(ls_ini[15] != '3') {
        paramRefresh(dtfrm, v_param, [{id:"v_pos", setVal:[1, 2]}, {id:"r_tlrance", setVal:[{min:ls_ini[13], max:ls_ini[14]}, {min:"1", max:"16383"}]}]);
      } else {
        if(v_param.includes(ORDER_REGI) == false) {
          var convVal = function(oriVal) {return String(Number(oriVal)/10);};
          dtfrm.document.getElementById("v_pos").refresh([],1,null,false);
          dtfrm.document.getElementById("r_tlrance_r").refresh(v_param, convVal(ls_ini[13]), convVal(ls_ini[14]), false);
          dtfrm.document.getElementById("sp_unit_i").style.display = "none";
          dtfrm.document.getElementById("sp_unit_r").style.display = "block";
        } else {
          paramRefresh(dtfrm, v_param, [{id:"v_pos", setVal:[1, 2]}, {id:"r_tlrance", setVal:[{min:"", max:""}, {min:"1", max:"16383"}]}]);
          dtfrm.document.getElementById("sp_unit_i").style.display = "block";
          dtfrm.document.getElementById("sp_unit_r").style.display = "none";
        }
      }
      dtfrm.document.getElementById("ls_data").style.display = "";
      dtfrm.document.getElementById("ls_out_data").style.display = "none";
    }else{
      ls_param = ls_param.replace(/[^0-9]/g, '');
      //dtfrm.document.getElementById("out_number").refresh(ls_param, 0, 32767, false);
      paramRefresh(dtfrm, ls_param, [{id:"o_pos", setVal:[1, 2]}, {id:"out_number", setVal:[{min:"0", max:"32767"}, {min:"1", max:"16383"}]}]);
      dtfrm.document.getElementById("ls_data").style.display = "none";
      dtfrm.document.getElementById("ls_out_data").style.display = "";
    }

    dtfrm.document.getElementById("ls_command").refresh(null, "0", false);
    dtfrm.document.getElementById("ls_data_area").style.display = "";
    dtfrm.document.getElementById("ls_sch_dat_area").style.display = "none";
  } else if(ls_sch_flg == 2) {
    dtfrm.document.getElementById("ls_title").style.display = "none";
    dtfrm.document.getElementById("ls_sch_title").style.display = "inline-block";
    paramRefresh(dtfrm, ls_param, [{id:"sch_pos", setVal:[1, 2]}, {id:"sch_val", setVal:[{min:ls_ini[17], max:ls_ini[18]}, {min:"1", max:"16383"}]}]);
    dtfrm.document.getElementById("ls_command").refresh(null, "1", false);
    dtfrm.document.getElementById("ls_data_area").style.display = "none";
    dtfrm.document.getElementById("ls_sch_dat_area").style.display = "";
  }
}

/*
 =========================================================================
 @function name   : setDispParam_le_common
 @argument        : dtfrm, le_param
 @description     : 
 @return          : none
 =========================================================================
*/
function setDispParam_le_common(dtfrm, le_param) {
  var le_param = le_param.slice(le_param.indexOf('['), le_param.lastIndexOf(']') + 1);

  var param_end = le_param.indexOf(',');
  var at_param = le_param.slice(le_param.indexOf('AT=') + 3, param_end);
  paramRefresh(dtfrm, at_param, [{id:"at_pos", setVal:[1, 2]}, {id:"gus_out", setVal:[{min:le_ini[3], max:le_ini[4]}, {min:"1", max:"16383"}]}]);

  if(pre_ls_ini[0] == 14) {
    var lof_param = le_param.slice(le_param.indexOf('LOF=') + 4, le_param.lastIndexOf(']'));
    if(lof_param.includes(ORDER_REGI) == false) {
      dtfrm.document.getElementById("lof_pos").refresh([],1,null,false);
      lof_param = lof_param.replace(/[^0-9]/g, '');
      var setParam = lof_param == "0" ? false : true;
      dtfrm.document.getElementById("laser_off").refresh(setParam, false);
      dtfrm.document.getElementById("lof_chk").style.display = "block";
      dtfrm.document.getElementById("lof_reg").style.display = "none";
    } else {
      paramRefresh(dtfrm, lof_param, [{id:"lof_pos", setVal:[1, 2]}, {id:"laser_off_reg", setVal:[{min:"", max:""}, {min:"1", max:"16383"}]}]);
      dtfrm.document.getElementById("lof_chk").style.display = "none";
      dtfrm.document.getElementById("lof_reg").style.display = "block";
    }
  } else {
    param_end = le_param.indexOf(',', param_end + 1);
    var st_param = le_param.slice(le_param.indexOf('ST=') + 3, param_end);
    paramRefresh(dtfrm, st_param, [{id:"st_pos", setVal:[1, 2]}, {id:"shu_off", setVal:[{min:le_ini[5], max:le_ini[6]}, {min:"1", max:"16383"}]}]);

    var sof_param = le_param.slice(le_param.indexOf('SOF=') + 4, le_param.lastIndexOf(']'));
    if(sof_param.includes(ORDER_REGI) == false) {
      dtfrm.document.getElementById("sof_pos").refresh([],1,null,false);
      sof_param = sof_param.replace(/[^0-9]/g, '');
      var setParam = sof_param == "0" ? false : true;
      dtfrm.document.getElementById("stand_off").refresh(setParam, false);
      dtfrm.document.getElementById("sof_chk").style.display = "block";
      dtfrm.document.getElementById("sof_reg").style.display = "none";
    } else {
      paramRefresh(dtfrm, sof_param, [{id:"sof_pos", setVal:[1, 2]}, {id:"stand_off_reg", setVal:[{min:"", max:""}, {min:"1", max:"16383"}]}]);
      dtfrm.document.getElementById("sof_chk").style.display = "none";
      dtfrm.document.getElementById("sof_reg").style.display = "block";
    }
  }
}

/*
 =========================================================================
 @function name   : paramRefresh
 @argument        : dtfrm, param, setInfo
 @description     : 
 @return          : 
 =========================================================================
*/
function paramRefresh(dtfrm, param, setInfo) {
  var set_param = param.replace(/[^0-9]/g, '');
  set_param = set_param.length != 0 ? set_param : "0";
  if(param.includes(ORDER_REGI) == false) {
    dtfrm.document.getElementById(setInfo[0].id).refresh([], setInfo[0].setVal[0], null, false);
    dtfrm.document.getElementById(setInfo[1].id).refresh(set_param, setInfo[1].setVal[0].min, setInfo[1].setVal[0].max, false);
  } else {
    dtfrm.document.getElementById(setInfo[0].id).refresh([], setInfo[0].setVal[1], null, false);
    dtfrm.document.getElementById(setInfo[1].id).refresh(set_param, setInfo[1].setVal[1].min, setInfo[1].setVal[1].max, false);
  }
}

/*
 =========================================================================
 @function name   : create_laser_data
 @argument        : dtfrm baseId
 @description     : This function create laser save data.
 @return          : param : laser save data
 =========================================================================
*/
function create_laser_data(dtfrm, baseId) {
  switch (baseId) {
    case 'laserpre':
    case 'laserkpre':
      var chkStr = new RegExp('^' + ORDER_PLE_LS);
      for(var cnt = 0; cnt < g_program_data[activeTarget].addMotion.length; cnt++) {
        if(g_program_data[activeTarget].addMotion[cnt].match(chkStr)) {
          g_program_data[activeTarget].addMotion[cnt] = get_laserPre(dtfrm);
          break;
        }
      }
      break;
    case 'laserpresi':
      g_program_data[activeTarget].param = get_laserPre(dtfrm);
      break;
    case 'laserls':
    case 'laserkls':
    case 'lasercls':
    case 'lasercals':
    case 'lasersls':
      var lsChkStr = new RegExp('^(' + ORDER_LS + '|' + ORDER_LS_SCH + ')\\[');
      var select_ls_cmd = dtfrm.document.getElementById("ls_command").getValue();
      for(var cnt = 0; cnt < g_program_data[activeTarget].addMotion.length; cnt++) {
        if(g_program_data[activeTarget].addMotion[cnt].match(lsChkStr)) {
          g_program_data[activeTarget].addMotion[cnt] = get_laserLs(dtfrm);
          break;
        }
      }
      if(baseId == 'laserls' || baseId == 'lasercls' || baseId == 'lasercals' || baseId == 'lasersls') {
        get_slopeParam(dtfrm, 'slope_up.input', 'slpu_val', 'slpu_edit');
        get_slopeParam(dtfrm, 'slope_down.input', 'slpd_val', 'slpd_edit');
      }
      break;
    case 'laserlssi':
      g_program_data[activeTarget].param = get_laserLs(dtfrm);
      break;
    case 'laserle':
    case 'laserkle':
    case 'lasercle':
    case 'lasercale':
    case 'lasersle':
      var leChkStr = new RegExp('^(' + ORDER_LE + ')\\[');
      for(var cnt = 0; cnt < g_program_data[activeTarget].addMotion.length; cnt++) {
        if(g_program_data[activeTarget].addMotion[cnt].match(leChkStr)) {
          g_program_data[activeTarget].addMotion[cnt] = get_laserLe(dtfrm);
          break;
        }
      }
      if(baseId == 'laserle' || baseId == 'lasercle' || baseId == 'lasercale' || baseId == 'lasersle') {
        get_slopeParam(dtfrm, 'slope_down.input', 'slpd_val', 'slpd_edit');
      }
      break;
    case 'laserlesi':
      g_program_data[activeTarget].param = get_laserLe(dtfrm);
      break;
    case 'laserpow':
      var val = dtfrm.document.getElementById('pwc_pos').getValue();
      if(val == 1) {
        var setParam = dtfrm.document.getElementById('ctrl_table').getValue();
        g_program_data[activeTarget].param = ORDER_PWC + '[' + setParam + ']';
      } else {
        var setParam = dtfrm.document.getElementById('ctrl_reg').getValue();
        g_program_data[activeTarget].param = ORDER_PWC + '[' + ORDER_REGI +'[' + setParam + ']]';
      }
      break;

    default:
      break;
  }
}

/*
 =========================================================================
 @function name   : get_laserPre
 @argument        : dtfrm
 @description     : 
 @return          : 
 =========================================================================
*/
function get_laserPre(dtfrm) {
  var retTxt = ORDER_PLE_LS;
  var val = dtfrm.document.getElementById('sel_pos').getValue();
  var setParam = dtfrm.document.getElementById('ch_val').getValue();
  if(pre_ls_ini[1] == true) {
    if(val == '1') {
      retTxt += '[CH=' + setParam + ']';
    }
    else {
      if(setParam == '0') setParam = '...';
      retTxt += '[CH=' + ORDER_REGI + '[' + setParam + ']]';
    }
  }
  return retTxt;
}

/*
 =========================================================================
 @function name   : get_laserLs
 @argument        : dtfrm
 @description     : 
 @return          : 
 =========================================================================
*/
function get_laserLs(dtfrm) {
  var select_ls_cmd = dtfrm.document.getElementById("ls_command").getValue();
  var retTxt = (select_ls_cmd == 0) ? ORDER_LS : ORDER_LS_SCH;

  if(select_ls_cmd == 0) {
    if(ls_out_flg == false){
      retTxt += createTxt_laserLsLe(dtfrm, 's_pos', 'p_power', '[S=', ',', '],');
      retTxt += createTxt_laserLsLe(dtfrm, 'l_pos', 'b_power', 'L=', ',', '],');
      retTxt += createTxt_laserLsLe(dtfrm, 'p_pos', 'freque', 'P=', ',', '],');
      retTxt += createTxt_laserLsLe(dtfrm, 'q_pos', 'r_duty', 'Q=', ',', '],');
      
      val = dtfrm.document.getElementById('v_pos').getValue();
      setParam = dtfrm.document.getElementById('r_tlrance').getValue();
      if(val == 1) {
        retTxt += (ls_ini[15] != 3) ? 'V=' + setParam + ']' : createTxt_laserLsLe(dtfrm, 'v_pos', 'r_tlrance_r', 'V=', ']', null);
      } else {
        retTxt += createTxt_laserLsLe(dtfrm, 'v_pos', 'r_tlrance', 'V=', null, ']]');
      }
    }else{
      retTxt += createTxt_laserLsLe(dtfrm, 'o_pos', 'out_number', '[', ']', ']]');
    }
  } else {
    retTxt += createTxt_laserLsLe(dtfrm, 'sch_pos', 'sch_val', '[SN=', ']', ']]');
  }
  return retTxt;
}

/*
 =========================================================================
 @function name   : get_laserLe
 @argument        : dtfrm
 @description     : 
 @return          : 
 =========================================================================
*/
function get_laserLe(dtfrm) {
  var retTxt = ORDER_LE;

  retTxt += createTxt_laserLsLe(dtfrm, 'at_pos', 'gus_out', '[AT=', ',', '],');
  if(pre_ls_ini[0] == 14) {
    val = dtfrm.document.getElementById('lof_pos').getValue();
    if(val == '1') {
      retTxt += (dtfrm.document.getElementById('laser_off.input').checked == true) ? 'LOF=1]' : 'LOF=0]';
    }else{
      retTxt += createTxt_laserLsLe(dtfrm, 'lof_pos', 'laser_off_reg', 'LOF=', null, ']]');
    }
  } else {
    retTxt += createTxt_laserLsLe(dtfrm, 'st_pos', 'shu_off', 'ST=', ',', '],');

    val = dtfrm.document.getElementById('sof_pos').getValue();
    if(val == 1) {
      retTxt += (dtfrm.document.getElementById('stand_off.input').checked == true) ? 'SOF=1]' : 'SOF=0]';
    } else {
      retTxt += createTxt_laserLsLe(dtfrm, 'sof_pos', 'stand_off_reg', 'SOF=', null, ']]');
    }
  }
  return retTxt;
}

/*
 =========================================================================
 @function name   : createTxt_laserLsLe
 @argument        : dtfrm, id1, id2, setStr, endChar1, endChar2
 @description     : 
 @return          : 
 =========================================================================
*/
function createTxt_laserLsLe(dtfrm, id1, id2, setStr, endChar1, endChar2) {
  var txt = '';
  var val = dtfrm.document.getElementById(id1).getValue();
  var setParam = dtfrm.document.getElementById(id2).getValue();
  if(val == '1') {
    txt = setStr + setParam + endChar1;
  }
  else {
    if(setParam == '0') setParam = '...';
    txt = setStr + ORDER_REGI + '[' + setParam + endChar2;
  }
  return txt;
}

/*
 =========================================================================
 @function name   : get_slopeParam
 @argument        : dtfrm, inputId, id1, id2
 @description     : 
 @return          : 
 =========================================================================
*/
function get_slopeParam(dtfrm, inputId, id1, id2) {
  var slopeCheck = dtfrm.document.getElementById(inputId).checked;
  var orderStr = (inputId == 'slope_down.input') ? ORDER_SLPD : ORDER_SLPU
  var slpChkStr = new RegExp('^(' + orderStr + ')\\[');
  if(slopeCheck) {
    var setParam = dtfrm.document.getElementById(id1).getValue();
    var slpVal = dtfrm.document.getElementById(id2).getValue();
  }
  for(var cnt = 0; cnt < g_program_data[activeTarget].addMotion.length; cnt++) {
    if(g_program_data[activeTarget].addMotion[cnt].match(slpChkStr)) {
      if(slopeCheck) {
        if(slpVal == '1') {
          g_program_data[activeTarget].addMotion[cnt] = orderStr + '[' + setParam + ']';
        } else {
          g_program_data[activeTarget].addMotion[cnt] = orderStr + '[' + ORDER_REGI + '[' + setParam + ']]';
        }
      }
      else {
        g_program_data[activeTarget].addMotion.splice(cnt, 1);
      }
      break;
    }
  }
  if(slopeCheck && cnt >= g_program_data[activeTarget].addMotion.length) {
    if(slpVal == '1') {
      g_program_data[activeTarget].addMotion.push(orderStr + '[' + setParam + ']');
    } else {
      g_program_data[activeTarget].addMotion.push(orderStr + '[' + ORDER_REGI + '[' + setParam + ']]');
    }
  }
}

/*
 =========================================================================
 @function name   : chk_laser_title
 @argument        : dtfrm, baseId
 @description     : 
 @return          : 
 =========================================================================
*/
function chk_laser_title(dtfrm, baseId) {
  var remark = (g_program_data[activeTarget] && g_program_data[activeTarget].remark);
  var titleElmList = [];
  switch (baseId) {
    case 'laserpre':
    case 'laserkpre':
      titleElmList.push(dtfrm.document.getElementsByClassName('ordar_title_pre')[0]);
      titleElmList.push(dtfrm.document.getElementsByClassName('ordar_title')[0]);
      break;
    case 'laserpresi':
      titleElmList.push(dtfrm.document.getElementsByClassName('ordar_title_pre')[0]);
      break;
    case 'laserls':
    case 'laserkls':
    case 'lasercls':
    case 'lasercals':
    case 'lasersls':
      titleElmList.push(dtfrm.document.getElementsByClassName('ordar_title_ls')[0]);
      titleElmList.push(dtfrm.document.getElementsByClassName('ordar_title_ls_sch')[0]);
      titleElmList.push(dtfrm.document.getElementsByClassName('ordar_title')[0]);
      break;
    case 'laserlssi':
      titleElmList.push(dtfrm.document.getElementsByClassName('ordar_title_ls')[0]);
      titleElmList.push(dtfrm.document.getElementsByClassName('ordar_title_ls_sch')[0]);
      break;
    case 'laserle':
    case 'laserkle':
    case 'lasercle':
    case 'lasercale':
    case 'lasersle':
      titleElmList.push(dtfrm.document.getElementsByClassName('ordar_title_le')[0]);
      titleElmList.push(dtfrm.document.getElementsByClassName('ordar_title')[0]);
      break;
    case 'laserlesi':
      titleElmList.push(dtfrm.document.getElementsByClassName('ordar_title_le')[0]);
      break;
    case 'laserpow':
    case 'laserwirc':
      titleElmList.push(dtfrm.document.getElementsByClassName('ordar_title')[0]);
      break;
    default:
      break;
  }

  for(var cnt = 0; cnt < titleElmList.length; cnt++) {
    var setText = titleElmList[cnt].children[0].innerText.replace(' ' + langResource.ihmieditor_title_instruction_remarked_c, '');
    setText = setText + (remark ? ' ' + langResource.ihmieditor_title_instruction_remarked_c : '');
    titleElmList[cnt].children[0].innerText = setText;
  }
}
                                                                                                                                                                                                                                                                                                                                     /*favorite system version.*/
var g_favoSysVersion = {
  currentVersion : 'Favorite Ver_2.0',
  dataVersion : '',
}; 
/*add favorite data temporarily saved.*/
var g_addFavoData = [];
/*favorite tab data list.*/
var g_favoriteList = [];
/*g_program_data like favorite data.*/
var g_favoProg_data = [];
/*favorite data to store in favorite program.*/
var g_save_progData = [];
/*favorite data save program name.*/
var g_favoriteSaveProg = 'DF_TBINST';
/*favorite flg table.*/
var g_favoriteFlg = {
  tlAdd      : false,  // favorite add event flg form timeline.
  progAdd    : false,  // favorite add event flg form progtab.
  favoEdit   : false,  // favorite edit event flg.
  paramSave  : false,  // favorite param save flg.
  favoLoad   : false,  // favorite data load flg.
  favoDrop   : false,  // favorite icon drop flg.
  favoUpdate : false,  // favorite sistem version up event flg.
};
/*favorite icon data to operate on.*/
var g_favoTargetData = {
  listIndex   : 0,
  dataId      : "",
  favoName    : "",
  paramData   : {},
  lsParam     : ""
};
/*Table for icon that not allows favorite param save.*/
var g_favoPrmSaveIconTbl = [
  'payload',
  'label',
  'nosupport',
  'trackend',
  'call',
  'noconnect',
  'laserpresi',
  'searchon',
  'sensoroff',
  'sensoron',
];
/*Favorite tab non disp icon list.*/
var g_favoNoDispList = [];
/*already disp timeline popup flg.*/
var g_timelinepopDispFlg = false;
/*not exist favorite prog flg.*/
var g_favoDataErrorFlg = {
  notExist    : false,
  malfunction : false,
};

/*
 =========================================================================
 @function name : load_fav_tp_callback
 @argument      : none
 @description   : Get information from favorite program to favorite data.
 @return        : none
 =========================================================================
*/
var fav_ls_text = [];
function load_fav_tp_callback(status, programName, programText, lineCount) {
  if (status != IO_SUCCESS) {
    /*Save program does not exist. */
    g_favoDataErrorFlg.notExist = true;
    return;
  }
  g_favoriteFlg.favoLoad = true;
  convertProgramLines(programText, lineCount, cvrtCB);

  function cvrtCB(lsArray) {
    fav_ls_text = lsArray;
    var tagGroup = 0;
    var mnArray = [];
    for (var i = 0; i < fav_ls_text.length; i++) {
      // Get 1 line data
      var line = fav_ls_text[i];
      if (line.startsWith('/')) { // Header
        var tags = line.split(' '); // Program name is exist after tag name
        var tag = tags[0].substr(1).trim(); // Cut out tag name
        // tag name check
        tagGroup = checkTagName(tag);
      } else {
        switch (tagGroup) {
          case TAGMN: // Line is mnemonic
            var colonPos = line.indexOf(':'); // Skip go colon
            var mnText = line.substr(colonPos + 1);
            var lineNum = parseInt(line.trim());
            var setIndex = mnArray.length;
            // If there is no line number, concatenate it to the previous line.
            if ((isNaN(lineNum)) && (colonPos < 0)) {
              break; // Delimitation line, etc. (------ ;)
            }
            if (isNaN(lineNum)) {
              setIndex--;
              mnText = mnArray[setIndex].trim() + ' ' + mnText.trim();
            } else {
              mnText = line; // add index data
            }
            if(g_favoSysVersion.dataVersion) {
              mnArray[setIndex] = (mnText[mnText.length - 1] == ';') ? mnText.substr(0, mnText.length - 1) : mnText;
            }
            else {
              g_favoSysVersion.dataVersion = mnText.substring(mnText.indexOf('!') + 2).replace(/\s$/, '');
            }
            break;
          default:
            // especially none.
            break;
        }
      }
    }
    g_favoriteList = [];
    for(var mnCnt = 0; mnCnt < mnArray.length; mnCnt++) {
      if(g_favoDataErrorFlg.malfunction) break;
      switch((mnCnt % 6)) {
        case 0: //set icon id. 
          if(mnArray[mnCnt].indexOf('!') == -1) {
            g_favoDataErrorFlg.malfunction = true;
            break;
          }
          var id = mnArray[mnCnt].substring(mnArray[mnCnt].indexOf('!') + 2).replace(/\s$/, '');
          g_favoriteList.push({indexId: id, endId: '', iconName: '', param: '', setName: '', disp: 'ON'});
          break;
        case 1: //set icon name. 
          if(mnArray[mnCnt].indexOf('--') == -1) {
            g_favoDataErrorFlg.malfunction = true;
            break;
          }
          var name = set_program_data_MultiLang_param(mnCnt+2, mnArray[mnCnt]).replace('--', '');
          g_favoriteList[g_favoriteList.length - 1].setName = name;
          break;
        case 2: //set icon param. 
          set_program_data(mnArray[mnCnt]);
          g_favoriteList[g_favoriteList.length - 1].param = mnArray[mnCnt].replace(/^\s*\d+\:/, '').replace(/\s{4}$/, '');
          break;
        case 3: //set icon end param. 
          if(mnArray[mnCnt].indexOf("END") >= 0) {
            set_program_data(mnArray[mnCnt]);
          }
          break;
        default:
          if(mnArray[mnCnt].indexOf(':   ') == -1) {
            g_favoDataErrorFlg.malfunction = true;
            break;
          }
          break;
      }
    }
    if((mnCnt) % 6 != 0) g_favoDataErrorFlg.malfunction = true;
    /*Initialize if the save program is broken.*/
    if(g_favoDataErrorFlg.malfunction) {
      var delStart = Math.floor((mnCnt-1) / 6);
      del_fav_tp(((delStart * 6) + 2), delStart, mnArray.length);
    }
    favoriteTab_dispOnOff();
    g_favoriteFlg.favoLoad = false;
  }
}

/*
 =========================================================================
 @function name : change_favoSaveMode
 @argument[arr] : arr[0] : iconName /  arr[1] : iconId on timeline.
 @description   : Change display to favorite save mode.
 @return        : none
 =========================================================================
*/
function change_favoSaveMode(arr){
  /*favorite data create. */
  if(g_favoriteFlg.tlAdd == true) { //Timeline add favorite.
    g_addFavoData[0] = {iconId: arr[0], favoId: '', oldName: g_program_data[arr[0]].baseId, newName : '', param: ''};
    if(arr[0].indexOf('lead') != -1 && !chk_basicInstruction(g_addFavoData[0].oldName)) {
      g_addFavoData[1] = {iconId: arr[1], favoId: '', oldName: g_program_data[arr[1]].baseId, newName : '', param: ''};
    }
  }
  else if(g_favoriteFlg.progAdd == true) { //Progtab add favorite.
    /*If arc motion id save to iconId.*/
    var id = arcMotionTbl[arr] ? arr : "";
    var name = arcMotionTbl[arr] ? arr.replace('_arc', '') : arr;
    g_addFavoData[0] = {iconId: id, favoId: '', oldName: name, newName : '', param: ''};
    if(arr.indexOf('lead') != -1 && !chk_basicInstruction(g_addFavoData[0].oldName)) {
      g_addFavoData[1] = {iconId: "", favoId: '', oldName: 'bktend' + g_inst_obj[arr].end.appName, newName : '', param: ''};
    }
  }
  else { //Edit favorite data.
    g_addFavoData[0] = {iconId: arr[0], favoId: arr[0], oldName: arr[1], newName : '', param: ''};
  }
  g_favoriteFlg.paramSave = favoParamSaveCheck(g_addFavoData[0].oldName);

  /*Change display to favorite save mode.*/
  $(parts_block).addClass('addFavorite');
  $('#viewchange').css('opacity', '0.5');
  $('.undoredo').css('opacity','');

  overlayRistrict(SITUATION_TIMELINE, true);
  document.getElementById('timelinePop').innerHTML = favorite_formDisp();
  $('#timelinePop').addClass('favoFormPopup');
  favoRegistNameChk();

  /*favorite data create. */
  if(!g_favoriteFlg.favoEdit) {
    create_favoProgData();
  }
  else {
    activeTarget = arr[0];
    g_program_data[activeTarget] = JSON.parse(JSON.stringify(g_favoProg_data[activeTarget]));
    /*Data save before editing */
    g_favoTargetData.favoName  = g_favoriteList[g_favoTargetData.listIndex].setName;
    g_favoTargetData.lsParam   = g_favoriteList[g_favoTargetData.listIndex].param;
    g_favoTargetData.paramData = JSON.parse(JSON.stringify(g_favoProg_data[activeTarget]));
  }
}

/*
 =========================================================================
 @function name : cancel_favoSaveMode
 @argument[]    : none
 @description   : Cancel favorite save mode.
 @return        : none
 =========================================================================
*/
function cancel_favoSaveMode() {
  //Favorite form popup is delete.
  $('#timelinePop').removeClass('favoFormPopup');
  document.getElementById('timelinePop').innerHTML = "<div id='tlPopMesArea' disable><div id='messageArea'></div></div>";
  $(parts_block).removeClass('addFavorite');
  overlayRistrict(SITUATION_TIMELINE, false);

  //If favorite save mode for progTab, detail disp delete.
  if(g_favoriteFlg.progAdd || g_favoriteFlg.favoEdit || (g_favoriteFlg.tlAdd && !g_favoriteFlg.paramSave)) { 
    progTabIcon_detailDisp(INACTIVE_DETAIL_DISP);
    activeTarget = "";
  }
  if(g_favoriteFlg.tlAdd && g_favoriteFlg.paramSave) {
    activeTarget = g_addFavoData[0].iconId;
    icon_inactive();
  }
  //Favorite save is cancel. Flag is false.
  for(var loop = 0; loop < g_addFavoData.length; loop++) {
    delete g_program_data[g_addFavoData[loop].favoId];
  }
  g_addFavoData = [];
  g_favoTargetData = {listIndex : 0, dataId : "", favoName : "", paramData : {}, lsParam : ""};
  g_favoriteFlg = {tlAdd : false, progAdd  : false, favoEdit : false, paramSave : false, favoLoad : false, favoDrop : false, favoUpdate : false};
}

/*
 =========================================================================
 @function name : progTabIcon_detailDisp
 @argument[mode]: ACTIVE_DETAIL_DISP(0):detail display block. / 
                  ACTIVE_DETAIL_DISP(1):detail display hide.
 @description   : non activeTarget detail display block or hide.
 @return        : none
 =========================================================================
*/
var ACTIVE_DETAIL_DISP = 0;
var INACTIVE_DETAIL_DISP = 1;
function progTabIcon_detailDisp(mode){
  if(mode == 0) { /*detail display block.*/
    /* parts_handleresize_area adjustment */
    active_vrtcl_scrlAdjust();
    /* Switch to details tab */
    $('#progTab_1').removeClass('progTab_active');
    $('#progArea_1').removeClass('progArea_active');
    $('#progTab_2').addClass('progTab_active');
    $('#progArea_2').addClass('progArea_active');

    /* Switching display items according to icon type */
    $('.detail_actSet').removeClass('active_disp');
    document.getElementById("detail_version").classList.add('hide');

    if(g_favoriteFlg.paramSave == true) { //progTab add favorite & favorite param save.
      var frm_id = 'detail_frm_' + iconSortTbl.indexOf(g_addFavoData[0].oldName);
      document.getElementById("detail_act").classList.add('active');
      $('#' + frm_id).off();

      /* Add display element */
      append_detailhtml(g_addFavoData[0].oldName);

      if(frm_id) {
        $('#' + frm_id).on('load', detail_load);
        lateralResizeFunc();
      }
    }
    else { //progTab add favorite & favorite param not save.
      document.getElementById("detail_act").classList.add('active');
      var text = "<div id='nonFavoDisp' style='font-family:Meiryo UI,sans-serif;font-size: 22px;padding: 5px 0px 0px 20px;'>" + langResource.ihmieditor_title_favorite_nodetail_c + "</div>";
      document.getElementById('detail_act').insertAdjacentHTML('afterbegin', text);
    }
  }
  else { /*detail display hide.*/
    /* Switch to new tab */
    $('#progTab_2').removeClass('progTab_active');
    $('#progArea_2').removeClass('progArea_active');
    $('#progTab_1').addClass('progTab_active');
    $('#progArea_1').addClass('progArea_active');
    /* Readjust the height of the palette tab. */
    $(".paletteTab").css('line-height', $('.paletteTab').outerHeight(true) + 'px');
  
    /* Hide details */
    if(g_favoriteFlg.paramSave == true) { //progTab add favorite & favorite param save.
      document.getElementById('detail_act').classList.remove('active');
      var actfrm = document.getElementById('detail_frm_' + iconSortTbl.indexOf(g_addFavoData[0].oldName));
      if(actfrm) {
        document.getElementById('detail_act').removeChild(actfrm.parentElement);
      }
      /* Hide "Position" in "Details" tab */
      document.getElementById("detail_version").classList.remove('hide');

      dtlMutObserver.disconnect();
      $('#dtl_scrlThumb_vrtcl').css({'top':'', 'height':''});
      $('#dtl_scrlThumb_hrzn').css({'left':'', 'width':''});
      
      scrlThumbResize($('#' + progtabId[checkedTabId].iconAreaId)[0], 'progicon_scrl_track', false);
      scrlPosUpdate($('#progicon_scrl_thumb')[0], $('#' + progtabId[checkedTabId].iconAreaId)[0], 'progicon_scrl_track', $('#' + progtabId[checkedTabId].iconAreaId)[0].scrollTop);
    
      if(g_RO_flg || !g_TPenbl_flg) {
        $('.restrictContainer').scrollTop(0);
        $('#detail_act').addClass('detail_noEdit');
      }
    }
    else { //progTab add favorite & favorite param not save.
      document.getElementById('detail_act').classList.remove('active');
      document.getElementById('detail_version').classList.remove('hide');
      var nonFavoDisp = document.getElementById('nonFavoDisp');
      if(nonFavoDisp) document.getElementById('nonFavoDisp').remove();
    }

    /* Restore the parts_handleresize_area to its original position. */
    if(g_tlScroll_direction == TL_SCRL_VRTCL && vrtcl_act_arrowPos_prcnt != '') {
      parts_handleresize_area.refresh({firstAreaSize: vrtcl_act_arrowPos_prcnt});
      adjustUpLowElem();
      vrtcl_act_arrowPos_prcnt = '';
    }
  }
}

/*
 =========================================================================
 @function name : create_favoProgData
 @argument      : none
 @description   : Favorite data create in g_program_data. 
 @return        : none
 =========================================================================
*/
function create_favoProgData() {
  for(var addIndex = 0; addIndex < g_addFavoData.length; addIndex++) {
    /*create favorite id. */
    for(var loop = 1; loop <= FAVORITE_CMD_MAX; loop++) {
      if(chk_basicInstruction(g_addFavoData[0].oldName)) {
        g_addFavoData[addIndex].favoId = g_addFavoData[addIndex].oldName + '_fav' + loop;
      }
      else {
        g_addFavoData[addIndex].favoId = g_addFavoData[addIndex].oldName.substring(g_addFavoData[addIndex].oldName.indexOf('-inst') + 6).replace(/\s$/, '') + '_fav' + loop;
      }
      if(!g_favoProg_data[g_addFavoData[addIndex].favoId]) break;
    }
    /*create save favorite param. */
    if(g_favoriteFlg.tlAdd == true && g_favoriteFlg.paramSave == true) { //copy target g_program_data.
      g_program_data[g_addFavoData[addIndex].favoId] = JSON.parse(JSON.stringify(g_program_data[g_addFavoData[addIndex].iconId]));
      /* Initialize the state, taking into account the case where the instruction of the registration source is remarked. */
      g_program_data[g_addFavoData[addIndex].favoId].remark = false;
    }
    else { //create new target g_program_data. 
      g_program_data[g_addFavoData[addIndex].favoId] = set_icon_data(g_addFavoData[addIndex].oldName);
      if(g_addFavoData[0].oldName == 'payload' && payload_motionGrpChk()) g_program_data[g_addFavoData[0].favoId].param = init_overwrite_param['payload'].param;
      set_linear_limitSpeed(g_addFavoData[0].favoId, g_addFavoData[0].oldName);
      /*If the favorite source is arcTab and favorite icon is straight or curve, then disp is Weld speed. */
      if(arcMotionTbl[g_addFavoData[0].iconId]) {
        g_program_data[g_addFavoData[addIndex].favoId].speed = {method: '', val: langResource.ihmieditor_order_weld_speed_c, unit: ''};
        g_program_data[g_addFavoData[addIndex].favoId].route = {stop: langResource.ihmieditor_order_nameraka_c, val: '100'}
      }
    }
  }
  activeTarget = g_addFavoData[0].favoId;
}


/*
 =========================================================================
 @function name : favoRegistNameChk
 @argument      : none
 @description   : Favorite register name check. 
 @return        : none
 =========================================================================
*/
var FAVORITE_NAME_LENMIN	= 1;
var FAVORITE_NAME_LENMAX	= 24;
function favoRegistNameChk() {
  var newName = document.getElementById("setIconName").value;
  var nameLength = favoNameBytesChk(newName);
  if(nameLength.numBytes < FAVORITE_NAME_LENMIN || nameLength.numBytes > FAVORITE_NAME_LENMAX){
    document.getElementById("saveBtn").classList.add("disabled");
    document.getElementById('alertName').style.color = 'red';
    return;
  }
  /* black list */
  var reg = new RegExp(/[\"';:&]/);
  if( true == reg.test(newName) ){
    document.getElementById("saveBtn").classList.add("disabled");
    document.getElementById('alertName').style.color = 'red';
    return;
  }
  document.getElementById("saveBtn").classList.remove("disabled");
  document.getElementById('alertName').style.color = 'rgba(0,0,0,0)';
  return;
}

/*
 =========================================================================
 @function name : favoNameBytesChk
 @argument[text]: favorite name
 @description   : This function to check the length of favorite name.
 @return        : arr.numBytes = favorite name length /
                  arr.newline  = favorite name newline index.
                  arr.overline = favorite name overline index.
 =========================================================================
*/
function favoNameBytesChk(text) {
  var arr = {numBytes: 0, newline: 0, overline: 0};
  var charCode;
  for (var i = 0, len = text.length; i < len; i++) {
    charCode = text.charCodeAt(i); // charCode is returned in UNICODE
    if ((charCode >= 0x00   && charCode <= 0xFF) ||   // latin-1
        (charCode >= 0xFF65 && charCode <= 0xFF9F)) { // hankaku katakana
      arr.numBytes += 1;
    }
    else {
      arr.numBytes += 2;
    }
    if(arr.newline == 0 && arr.numBytes > 12) arr.newline = i;
    if(arr.overline == 0 && arr.numBytes > 21) arr.overline = i;
  }
  return arr;
}

/*
 =========================================================================
 @function name : create_favoSaveData
 @argument      : none
 @description   : function when push favorite save botton. create save data.
 @return        : none
 =========================================================================
*/
function create_favoSaveData() {
  var mode = SAVE_TP_ADD;
  if( true == document.getElementById("saveBtn").classList.contains("disabled") ) {
    return;
  }
  g_addFavoData[0].newName = document.getElementById("setIconName").value;

  /*if favorite tab max & favorite non disp icon, first favorite non disp icon del.*/
  if(g_favoriteList.length >= FAVORITE_CMD_MAX && g_favoNoDispList.length != 0) {
    del_fav_tp((g_favoNoDispList[0] * 6) + 2, g_favoNoDispList[0]);
  }
  /*if favorite edit & not param save, only name edit.*/
  if(g_favoriteFlg.favoEdit == true && g_favoriteFlg.paramSave == false) {
    mode = SAVE_TP_OVERWRITE;
    g_favoriteList[g_favoTargetData.listIndex].setName = g_addFavoData[0].newName;
    save_fav_data.list.push('--' + g_addFavoData[0].newName + ' ;');
    save_fav_data.idx = ((g_favoTargetData.listIndex + 1) * 6) - 3;
    SAVE_REGION = save_fav_data.list.length;
    save_fav_tp(mode, save_fav_tp_callback);
    return;
  }
  var indexNum = 0;
  /*LS param create. */
  make_favols_data();
  /*copy g_favoProg_data to favorite data.*/
  for(var loop = 0; loop < g_addFavoData.length; loop++) {
    g_favoProg_data[g_addFavoData[loop].favoId] = g_program_data[g_addFavoData[loop].favoId];
  }
  /*Check add or edit.*/
  if(g_favoriteFlg.favoEdit == true) { //Overwrite
    mode = SAVE_TP_OVERWRITE;
    indexNum = g_favoTargetData.listIndex;
  }
  else { //add
    indexNum = g_favoriteList.length;
  }
  if(g_addFavoData.length == 1) {
    g_favoriteList[indexNum] = {indexId : g_addFavoData[0].favoId, endId : '', iconName : g_addFavoData[0].oldName, setName : g_addFavoData[0].newName, param: g_addFavoData[0].param, disp: 'ON'};
  }
  else {
    g_favoriteList[indexNum] = {indexId : g_addFavoData[0].favoId, endId : g_addFavoData[1].favoId, iconName : g_addFavoData[0].oldName, setName : g_addFavoData[0].newName, param: g_addFavoData[0].param, disp: 'ON'};
  }
  /* Additional position storage */
  save_fav_data.idx = g_favoriteFlg.favoEdit == true ? ((g_favoTargetData.listIndex + 1) * 6) - 4 : ((g_favoriteList.length) * 6) - 4 ;
  save_fav_tp(mode, save_fav_tp_callback);
}

/*
 =========================================================================
 @function name : make_favols_data
 @argument      : none
 @description   : make save favorite ls data create.
 @return        : none
 =========================================================================
*/
function make_favols_data() {
  var arr = []; 
  for(var loop = 0; loop < g_addFavoData.length; loop++) {
    arr[loop] = {"order":g_addFavoData[loop].favoId , "num":0};
  }

  make_lsfile_data(arr);

  for(var loop = 0; loop < tp_text_array.length; loop++) {
    g_addFavoData[loop].param = tp_text_array[loop];
  }
  /* Registration data retention */
  save_fav_data.list.push('! ' + g_addFavoData[0].favoId + ' ;');
  save_fav_data.list.push('--' + g_addFavoData[0].newName + ' ;');
  for(var tpcnt = 0; tpcnt < 4; tpcnt++) {
    save_fav_data.list.push((tp_text_array[tpcnt]) ? tp_text_array[tpcnt] : ' ;');
  }
}

/*
 =========================================================================
 @function name  : save_fav_tp
 @argument[mode] : Write mode. (0:overwrite, 1)
 @description    : 
 @return         : none
 =========================================================================
*/
var save_fav_data = {idx:0, list:[]};
var SAVE_REGION       = 6; //favorite data save region.
var SAVE_TP_OVERWRITE = 0;
var SAVE_TP_ADD       = 1;
function save_fav_tp(mode, callback) {
  dispOnWaiting(0);
  var w_line = save_fav_data.idx + (SAVE_REGION - save_fav_data.list.length);
  var write_mode = (mode == SAVE_TP_OVERWRITE) ? EDIT_PRG_OPT_OVERWRITE :
                     (w_line == 1) ? EDIT_PRG_OPT_INSERT : EDIT_PRG_OPT_INSERT_AFTER;
  w_line = (write_mode == EDIT_PRG_OPT_INSERT_AFTER) ? w_line - 1 : w_line;

  /* iRP I/F call */
  top.editPrg(g_favoriteSaveProg, urlEncode(save_fav_data.list[0]), w_line, write_mode, callback, save_fav_data.list.shift());
}

/*
 =========================================================================
 @function name : save_fav_tp_callback
 @argument[]    : 
 @description   : 
 @return        : none
 =========================================================================
*/
function save_fav_tp_callback(state, name, id) {
  if(state == "0x0") {
    if(save_fav_data.list.length) {
      var fav_write_mode = (g_favoriteFlg.favoEdit == true) ? SAVE_TP_OVERWRITE : SAVE_TP_ADD;
      save_fav_tp(fav_write_mode, save_fav_tp_callback);
    }
    else {
      if(!g_favoriteFlg.favoLoad) {
        for(var loop = 0; loop < g_addFavoData.length; loop++) {
          delete g_program_data[g_addFavoData[loop].favoId];
        }
        if(g_favoriteFlg.tlAdd == true && g_favoriteFlg.paramSave == true) {
          activeTarget = g_addFavoData[0].iconId;
          icon_inactive();
        }
        else {
          activeTarget = "";
        }
        registTab_selectIconTabHighlight();
        change_TLselectMode(SELECT_MODE_NONE);
        dispOffWaiting();
      }
      g_addFavoData = [];
      SAVE_REGION   = 6;
      save_fav_data = {idx:0, list:[]};
      g_favoTargetData = {listIndex : 0, dataId : "", favoName : "", paramData : {}, lsParam : ""};
      g_favoriteFlg = {tlAdd : false, progAdd  : false, favoEdit : false, paramSave : false, favoLoad : false, favoDrop : false, favoUpdate : false};
    }
  }
  else { // save error.
    if(!g_favoriteFlg.favoLoad) {
      if(g_favoriteFlg.favoEdit == false) {
        /*Delete all data in the process of saving.*/
        del_fav_tp(((g_favoriteList.length - 1) * 6) + 2, (g_favoriteList.length - 1), (6 - save_fav_data.list.length));
      }
      else {
        /*Revert to data before editing.*/
        if((SAVE_REGION - save_fav_data.list.length) < 3) g_favoriteList[g_favoTargetData.listIndex].setName = g_favoTargetData.favoName;
        g_favoProg_data[activeTarget] = g_favoTargetData.paramData;
        g_favoriteList[g_favoTargetData.listIndex].param   = g_favoTargetData.lsParam;
        dispOffWaiting();
        registTab_selectIconTabHighlight();
      }
      SAVE_REGION   = 6;
      save_fav_data = {idx:0, list:[]};
      display_popupmsg_alert(DEF_POPUP_SCRN_TYP.ALERT, langResource.ihmieditor_pop_favorite_save_error_c, DISP_CLOSE_BTN);
    }
  }
}

/*
 =========================================================================
 @function name : del_fav_tp
 @argument[]    : 
 @description   : 
 @return        : none
 =========================================================================
*/
function del_fav_tp(lineNum, delListIndex, delCnt) {
  //delete target g_favoriteList & g_favoProg_data.
  if(g_favoriteList[delListIndex]) {
    if(g_favoProg_data[g_favoriteList[delListIndex].indexId]) {
      delete g_favoProg_data[g_favoriteList[delListIndex].indexId];
    }
    if(g_favoriteList[delListIndex].endId != '') {
      delete g_favoProg_data[g_favoriteList[delListIndex].endId];
    }
    g_favoriteList.splice(delListIndex, 1);
  }
  //delete target program.
  if(!delCnt) delCnt = 6;
  dispOnWaiting(0);
  var cb_func = function(state, progName, linenum, deleteline, delcontents) {
    //console.log('state:' + state);
    dispOffWaiting();
  };
  top.delLine(g_favoriteSaveProg, lineNum, delCnt, cb_func, lineNum);
}

/*
 =========================================================================
 @function name : add_favorite_programmingTab
 @argument      : none
 @description   : Add favorite icon to programming tab
 @return        : none
 =========================================================================
*/
function add_favorite_programmingTab() {
  var targetElm = document.getElementById('cat_fav');
  if(targetElm.children.length > 0) {
    targetElm.innerHTML = '';
  }
  
  if(g_favoriteList.length !== 0) {
    g_favoNoDispList = [];
    /* Instruction icon generation */
    for(var cnt = 0; cnt < g_favoriteList.length ; cnt++) {
      if(g_favoriteList[cnt].disp == 'ON') {
        programingArea_addFavoIcon(g_favoriteList[cnt], 'cat_fav')
      }
      else {
        g_favoNoDispList.push(cnt);
      }
    }
  }
}

/*
 =========================================================================
 @function name : programingArea_addFavoIcon
 @argument[baseId]   : 
 @argument[addTabId] : 
 @description        : "Programming" tab favorite icon add.
 @return             : none
 =========================================================================
*/
function programingArea_addFavoIcon(targetInfo, addTabId) {
  var addContents = "";
  var addIcon = $('<div>', {class: 'teachIcon'});
  var baseElm = document.getElementById(addTabId);

  var addChk = $(baseElm).find('.prg_subcat');
  if(addChk.length == 0) {
    baseElm.appendChild(addIcon[0]);
  }
  else {
    $(addIcon[0]).insertBefore(addChk[0]);
  }
  var addIconElm = g_def_iconElm.cloneNode(true);
  addIconElm.id = addTabId == 'cat_his' ? targetInfo.indexId + '_history' : targetInfo.indexId;
  addIconElm.classList.add(iconTbl[targetInfo.iconName].iconType);
  $(addIconElm.firstElementChild).css('background-image', 'url(' + iconTbl[targetInfo.iconName].imgPath + ')');
  $(addIcon[0]).append(addIconElm);
  /*If there is no name under the language, favorite name is [icon name + _ + favorite number].*/
  targetInfo.setName = targetInfo.setName != "" ? targetInfo.setName : create_dispfavoName(targetInfo.iconName) + '_' + String(cnt+1).padStart(2, '0');
  var nameChk = favoNameBytesChk(targetInfo.setName);
  /*Is there a line break. */
  if (nameChk.numBytes > FAVORITE_NAME_LENMAX / 2) {
    var sliceName = [targetInfo.setName.slice(0,nameChk.newline) , targetInfo.setName.slice(nameChk.newline)];
    addContents = '<div style="position:relative;"><span class=favoImage style="top:-60px;"></span><span class=iconName>' + sliceName[0] + '<br>' + sliceName[1] + '</span></div>';
  }
  else {
    /*favorite image display position setting.*/
    addContents = '<div style="position:relative;"><span class=favoImage style="top:-60px;"></span><span class=iconName>' + targetInfo.setName + '</span></div>';
  }
  $(addIcon[0]).append(addContents);
}

/*
 =========================================================================
 @function name : create_dispfavoName
 @argument[iconName] : icon name
 @description   : 
 @return        : none
 =========================================================================
*/
function create_dispfavoName(iconName) {
  var favoDispName = "";
  if(!chk_basicInstruction(iconName)) {
    favoDispName = g_inst_obj[iconName].iconText;
  }
  else {
    favoDispName = iconTbl[iconName].dispName;
  }
  favoDispName = favoDispName.replace('<br>', '');

  var nameChk = favoNameBytesChk(favoDispName);
  if(nameChk.overline != 0) favoDispName = favoDispName.slice(0, nameChk.overline);

  return favoDispName;
}

/*
 =========================================================================
 @function name : dropFavoriteIcon_setParam
 @argument[dataId]: g_program_data object name
 @description   : drop icon is updata favorite param 
 @return        : none
 =========================================================================
*/
function dropFavoriteIcon_setParam(dataId) {
  /*Pick up target g_favoriteList id & g_favoProg_data object name. */
  var targetIndex = g_favoriteList[g_favoTargetData.listIndex].indexId;
  /*Copy drop icon data to favorite param. */
  g_program_data[dataId].addMotion   = g_favoProg_data[targetIndex].addMotion;
  g_program_data[dataId].param       = g_favoProg_data[targetIndex].param;
  g_program_data[dataId].route       = g_favoProg_data[targetIndex].route;
  g_program_data[dataId].speed       = g_favoProg_data[targetIndex].speed;

  /*If curve icon, also copy offsetMotion. */
  for(var loop = 0; loop < g_favoProg_data[targetIndex].position.length; loop++) {
    if(g_favoProg_data[targetIndex].position[loop].offsetMotion != undefined) {
      g_program_data[dataId].position[loop].offsetMotion = g_favoProg_data[targetIndex].position[loop].offsetMotion;
    }
  }
  g_favoTargetData = {listIndex : 0, dataId : "", favoName : "", paramData : {}, lsParam : ""};
  g_favoriteFlg.favoDrop = false;
}

/*
 =========================================================================
 @function name : favoParamSaveCheck
 @argument[iconName] : icon name
 @description   : Check if the target icon is a favorite param save icon.
 @return        : true / false
 =========================================================================
*/
function favoParamSaveCheck(iconName) {
  if(!chk_basicInstruction(iconName)) return false;
  for(var loop = 0; loop < g_favoPrmSaveIconTbl.length; loop++) {
    if(iconName == g_favoPrmSaveIconTbl[loop]) return false;
  }
  return true;
}

/*
 =========================================================================
 @function name : favorite_systemUpdateChk
 @argument      : none
 @description   : Check if favorite is up to date
 @return        : none
 =========================================================================
*/
function favorite_systemUpdateChk() {
  /*DF_TBINST.DF is not exist.*/
  if(g_favoDataErrorFlg.notExist) return;
  /*Check exist old favorite icon.*/
  var existOldfavoFlg = false;
  if(g_progFavorite_command.length != 0 && g_favoriteList.length == 0) {
    display_popupmsg_favorite(langResource.ihmieditor_pop_favorite_update_c, favorite_systemUpdate);
    existOldfavoFlg = true;
  }
  /*Check doing old favorite system version with add favorite.*/
  if(g_favoSysVersion.dataVersion.indexOf(g_favoSysVersion.currentVersion) == -1) {
    save_fav_data = {idx:1, list:['! ' + g_favoSysVersion.currentVersion + ' ;']};
    SAVE_REGION = save_fav_data.list.length;
    switch(g_favoSysVersion.dataVersion) {
      case '': //old favorite system version.
        save_fav_tp(SAVE_TP_ADD, save_fav_tp_callback);
        break;
      case 'Favorite Ver_1.0 ;':
        /*Update to current version.*/
        save_fav_tp(SAVE_TP_OVERWRITE, save_fav_tp_callback);
        /*Do not show versionup popup from favorite version1 if old favorite icon exists. */
        if(!existOldfavoFlg) display_popupmsg_favorite(langResource.ihmieditor_pop_favorite_update1_c, delete_popupmsg_favorite);
        break;
      case '  1:   ;': //favorite data version is not exist and already write favorite icon.
      case 'External_favorite_data ;': //This favorite data is external favorite override data.
        save_fav_tp(SAVE_TP_OVERWRITE, save_fav_tp_callback);
        break;
      default:
        break;
    }
    g_favoSysVersion.dataVersion = g_favoSysVersion.currentVersion;
  }
}

/*
 =========================================================================
 @function name : display_popupmsg_favorite
 @argument      : none
 @description   : delete_popupmsg_favorite
 @return        : none
 =========================================================================
*/
function delete_popupmsg_favorite(id, operation, status) {
  delete_popup_screen(DEF_POPUP_SCRN_TYP.FAVO_UPDATE);
}

/*
 =========================================================================
 @function name : favorite_systemUpdate
 @argument      : none
 @description   : Handover of registered information from old favorite to new favorite 
 @return        : none
 =========================================================================
*/
function favorite_systemUpdate(id, operation, status) {
  delete_popup_screen(DEF_POPUP_SCRN_TYP.FAVO_UPDATE);
  g_favoriteFlg.favoUpdate = true; 
  g_favoriteFlg.progAdd = true;
  //Handover of registered information
  var favoDataType = 0;
  for(var oldFavoIndex = 0; oldFavoIndex < g_progFavorite_command.length; oldFavoIndex++) {
    /*Check if old favorite id is arc motion id. */
    var weldspeedFlg = { 
      liner : g_progFavorite_command[oldFavoIndex] == 'straight_arc' ? true : false, 
      curve : g_progFavorite_command[oldFavoIndex] == 'curve_arc' ? true : false, 
    };
    var arr = [];
    favoDataType = g_progFavorite_command[oldFavoIndex].indexOf('lead') != -1 && !chk_basicInstruction(g_progFavorite_command[oldFavoIndex]) ? 2 : 1;
    if(weldspeedFlg.liner) g_progFavorite_command[oldFavoIndex] = 'straight';
    if(weldspeedFlg.curve) g_progFavorite_command[oldFavoIndex] = 'curve';
    g_addFavoData[0] = {iconId: "", favoId: '', oldName: g_progFavorite_command[oldFavoIndex], newName : 'FAVORITE_' + (oldFavoIndex+1), param: ''};
    if(favoDataType == 2) {
      g_addFavoData[1] = {iconId: "", favoId: '', oldName: 'bktend' + g_inst_obj[g_progFavorite_command[oldFavoIndex]].end.appName, newName : 'FAVORITE_' + (oldFavoIndex+1), param: ''};
    }
    for(var loop = 0; loop < favoDataType; loop++) {
      if(chk_basicInstruction(g_addFavoData[0].oldName)) {
        g_addFavoData[loop].favoId = g_addFavoData[loop].oldName + '_fav' + (loop+1);
      }
      else {
        g_addFavoData[loop].favoId = g_addFavoData[loop].oldName.substring(g_addFavoData[loop].oldName.indexOf('-inst') + 6).replace(/\s$/, '') + '_fav' + (loop+1);
      }
      /*create new target g_program_data.*/ 
      g_program_data[g_addFavoData[loop].favoId] = set_icon_data(g_addFavoData[loop].oldName);
      if(g_addFavoData[loop].oldName == 'payload' && payload_motionGrpChk()) g_program_data[g_addFavoData[loop].favoId].param = init_overwrite_param['payload'].param;
      set_linear_limitSpeed(g_addFavoData[loop].favoId, g_addFavoData[loop].oldName);
      /*If the icon is straight_arc or curve_arc, then Weld speed. */
      if(weldspeedFlg.liner || weldspeedFlg.curve) {
        g_program_data[g_addFavoData[loop].favoId].speed = {method: '', val: langResource.ihmieditor_order_weld_speed_c, unit: ''};
        g_program_data[g_addFavoData[loop].favoId].route = {stop: langResource.ihmieditor_order_nameraka_c, val: '100'}
      }
      /*copy g_favoProg_data to favorite data.*/
      g_favoProg_data[g_addFavoData[loop].favoId] = g_program_data[g_addFavoData[loop].favoId];

      /*LS param create. */
      arr[loop] = {"order":g_addFavoData[loop].favoId , "num":0};
    }

    make_lsfile_data(arr);
    for(var loop = 0; loop < tp_text_array.length; loop++) {
      g_addFavoData[loop].param = tp_text_array[loop];
    }
    /* Registration data retention */
    save_fav_data.list.push('! ' + g_addFavoData[0].favoId + ' ;');
    save_fav_data.list.push('--' + g_addFavoData[0].newName + ' ;');
    for(var tpcnt = 0; tpcnt < 4; tpcnt++) {
      save_fav_data.list.push((tp_text_array[tpcnt]) ? tp_text_array[tpcnt] : ' ;');
    }

    if(g_addFavoData.length == 1) {
      g_favoriteList[g_favoriteList.length] = {indexId : g_addFavoData[0].favoId, endId : '', iconName : g_addFavoData[0].oldName, setName : g_addFavoData[0].newName, param: g_addFavoData[0].param, disp: 'ON'};
    }
    else {
      g_favoriteList[g_favoriteList.length] = {indexId : g_addFavoData[0].favoId, endId : g_addFavoData[1].favoId, iconName : g_addFavoData[0].oldName, setName : g_addFavoData[0].newName, param: g_addFavoData[0].param, disp: 'ON'};
    }
    /* Additional position storage */
    save_fav_data.idx = 2;
    for(var loop = 0; loop < g_addFavoData.length; loop++) {
      delete g_program_data[g_addFavoData[loop].favoId];
    }
    g_addFavoData = [];
  }
  SAVE_REGION = save_fav_data.list.length;
  save_fav_tp(SAVE_TP_ADD, updata_fav_tp_callback);
}

/*
 =========================================================================
 @function name : updata_fav_tp_callback
 @argument      : none
 @description   : favorite_systemUpdate callback
 @return        : none
 =========================================================================
*/
function updata_fav_tp_callback(state, name, id) {
  if(save_fav_data.list.length) {
    save_fav_tp(SAVE_TP_ADD, updata_fav_tp_callback);
  }
  else {
    SAVE_REGION = 6;
    favoriteTab_dispOnOff();
    g_favoriteFlg = {tlAdd : false, progAdd  : false, favoEdit : false, paramSave : false, favoLoad : false, favoDrop : false, favoUpdate : false};
    /* Delete old favorite system var.*/
    for(var histArray = 1; histArray <= 5; histArray++) {
      top.rpcmc_setVar(top.SYSNAME_C, '$IHMI_EDIT.$FAVORITE[' + histArray + ']', '*uninit*');
    }
    dispOffWaiting();
  }
}

/*
 =========================================================================
 @function name : display_popupmsg_favorite
 @argument      : none
 @description   : disp favorite update popup.
 @return        : none
 =========================================================================
*/
function display_popupmsg_favorite(message, callback) {
  //popup-box-frame
  var nIdx = DEF_POPUP_SCRN_TYP.FAVO_UPDATE - 1;
  if (DEF_POPUP_SCRN_STS.REQ_ON === g_popup_frame[nIdx].disp_sts) {
    return;
  }
  delete_popup_screen(DEF_POPUP_SCRN_TYP.FAVO_UPDATE);//delete the pop-up screen
  g_popup_frame[nIdx].disp_sts = DEF_POPUP_SCRN_STS.REQ_ON;
  var popupStmPath = "/frh/irprog/ihmieditor/iframe/";
  var contensPage = popupStmPath + "popup_screen.stm";//pop-up screen stm filepath.

  //set popup customizeObj
  var customizeObj = {};
  customizeObj.appendArg = {
    popup_screen_type: DEF_POPUP_SCRN_TYP.FAVO_UPDATE,
    confirmation_message: message,
    close_cb_function: callback,
  };
  customizeObj.height          = '650px';
  customizeObj.width           = '760px';
  customizeObj.callerWindowObj = window;//if caller window removed, ihcp remove popup.
  customizeObj.hideCloseBtn    = true;//show close button
  //show pop-up screen
  ihmif.appendPopupFrm(contensPage, null, window, customizeObj);
}                                                                                                                                                                                                                                      // = Status area setting
var I_WATCHEXEC_ABORTED = 0;
var I_WATCHEXEC_RUNNING = 1;
var I_WATCHEXEC_PAUSED = 2;

var statWordArrayData = [  // Table of status string to status code.
  { res: langResource.ihmieditor_execstat_Running_c, stat: I_WATCHEXEC_RUNNING },
  { res: langResource.ihmieditor_execstat_Paused_c,  stat: I_WATCHEXEC_PAUSED  },
  { res: langResource.ihmieditor_execstat_Aborted_c, stat: I_WATCHEXEC_ABORTED }
];
var statSubWordsArray = [  // For fail-safe check
  { res: langResource.ihmieditor_execsubstat_Running_c, stat: I_WATCHEXEC_RUNNING },
  { res: langResource.ihmieditor_execsubstat_Paused_c,  stat: I_WATCHEXEC_PAUSED  },
  { res: langResource.ihmieditor_execsubstat_Aborted_c, stat: I_WATCHEXEC_ABORTED }
];

var getProgStatVal = [
  '$ALM_IF.$CURR_STAT',
  '$ALM_IF.$TPEDIT_PROG',
  '$ALM_IF.$TPEDIT_LINE',
  '$SHELL_WRK.$ROUT_NAME',
  '$SHELL_WRK.$CURR_LINE',
  '$SHELL_WRK.$BY_MANUAL'
];
var currentProgVal = { prog: '', line: 0, stat: '', shell:{prog: '', line: 0, by_manual: false}, uniManual: false };
//var callBackFunc = null;
var statFunc = null;
var scrollLeft = 0;
var programLine = 1;
var initialFlg = false;
var change_prog_flg = false;
var statChangeFlg = false;
var animation_flg = false;
var status_mode;
var TL_NO_DISP_NAME = '** No display name **';

/*
 =========================================================================
 @function name  : startProgStatInfoMonitor
 @argument       : none
 @description    : start monitor 'VarEvent'
 @return         : none
 =========================================================================
*/
function startProgStatInfoMonitor() {
  // Start PMON monitor for $ALM_IF.$CURR_STAT
  top.rpcmc_startVarMonitor(top.SYSNAME_C, '$ALM_IF.$CURR_STAT', 100);
  // Start PMON monitor for $ALM_IF.$TPEDIT_PROG
  top.rpcmc_startVarMonitor(top.SYSNAME_C, '$ALM_IF.$TPEDIT_PROG', 100);
  // Start PMON monitor for $ALM_IF.$TPEDIT_LINE
  top.rpcmc_startVarMonitor(top.SYSNAME_C, '$ALM_IF.$TPEDIT_LINE', 100);
  // Start PMON monitor for $SHELL_WRK.$ROUT_NAME
  top.rpcmc_startVarMonitor(top.SYSNAME_C, '$SHELL_WRK.$ROUT_NAME', 100);
  // Start PMON monitor for $SHELL_WRK.$CURR_LINE
  top.rpcmc_startVarMonitor(top.SYSNAME_C, '$SHELL_WRK.$CURR_LINE', 100);
  // Start PMON monitor for $SHELL_WRK.$BY_MANUAL
  top.rpcmc_startVarMonitor(top.SYSNAME_C, '$SHELL_WRK.$BY_MANUAL', 100);
  // Attach handler for VarEvent.
  top.jQuery.varlis.bind('VarEvent', null, setProgStatInfoVarEvent);
}

/*
 =========================================================================
 @function name  : stopProgStatInfoMonitor
 @argument       : none
 @description    : stop monitor 'VarEvent'
 @return         : none
 =========================================================================
*/
//This function is usually not called.
function stopProgStatInfoMonitor() {
  // Detach all VarEvents
  top.jQuery.varlis.unbind('VarEvent', setProgStatInfoVarEvent);
  console.log("ihmieditor_sitrans.js error.");
}

/*
 =========================================================================
 @function name      : setProgStatInfoVarEvent
 @argument[event]    : Event object
 @argument[progName] : Category Name ? (Not used, so not yet surveyed)
 @argument[varName]  : '$ALM_IF.$CURR_PROG' or '$ALM_IF.$CURR_LINE' or '$ALM_IF.$CURR_STAT' or ect
 @argument[typeCode] : Var type ? (Not used, so not yet surveyed)
 @argument[valStr]   : varName's value
 @description        : 'VarEvent' monitor callback
 @return             : none
 =========================================================================
*/
function setProgStatInfoVarEvent(event, progName, varName, typeCode, valStr) {
  var changeStat = setStatVal(varName, valStr);
  if (initialFlg == true && changeStat != NOT_CAHNGE) {
    progExecolumn(changeStat);
  }
}

/*
 =========================================================================
 @function name  : initcurrentProgStat
 @argument       : none
 @description    : get current status when the startup is completed.
 @return         : none
 =========================================================================
*/
function initcurrentProgStat() {
  initialFlg = true; //Initialization completion flag.
  getStatProgInfoVal();
}

/*
 =========================================================================
 @function name  : getStatProgInfoVal
 @argument       : none
 @description    : Get the current execution status
 @return         : none
 =========================================================================
*/
function getStatProgInfoVal() {
  getSysValXHR(getProgStatVal, ProgStatVarEventCallBack);
}

/*
 =========================================================================
 @function name     : ProgStatVarEventCallBack
 @argument[statue]  : Result
 @argument[getText] : Acquired text data
 @description       : getStatProgInfoVal() callback processing
 @return            : none
 =========================================================================
*/
function ProgStatVarEventCallBack(status, getText) {
  if(status != IO_SUCCESS) {
    return;
  }
  var valList = getSysValXmlData(getText, 'VAR').getElementsByTagName('VAR');
  for(var i = 0; i < valList.length; i++) {
    var valName = valList[i].getAttribute("name");
    setStatVal(valName, valList[i].textContent);
  }
  /* Startup processing */
  if (initialFlg == true) {
    /* Process even if there is no change in content. */
    statChangeFlg = true;
    progExecolumn(NOT_CAHNGE);
  }
}

/*
 =========================================================================
 @function name  : setStatVal
 @argument[name] : System variables
 @argument[val]  : name's value
 @description    : set current status
 @return         : Judgment Result
 =========================================================================
*/
var befProgName = "";
function setStatVal(name, val){
  var changeVal = NOT_CAHNGE;
  // console.log("setStatVal name:" + name + " val:" + val);
  switch(name){
    case '$ALM_IF.$TPEDIT_PROG':
      if(currentProgVal.prog != val) { statChangeFlg = true; }
      /* If the string is empty, a string for judgment is stored. */
      currentProgVal.prog = (val != '') ? val : TL_NO_DISP_NAME;
      // Execute temporary program to move position.When returning from a temporary program.
      if(currentProgVal.prog == 'MOVEONLYPROG' || befProgName == 'MOVEONLYPROG') { 
        return NOT_CAHNGE;
      }
      befProgName = val;
      changeVal = CHANGE_TPEDIT_PROG;
      break;
    case '$ALM_IF.$TPEDIT_LINE':
      if(!cursor_manual_check() && currentProgVal.line != Number(val)) { statChangeFlg = true; }
      currentProgVal.line = Number(val);
      changeVal = CHANGE_TPEDIT_LINE;
      break;
    case '$ALM_IF.$CURR_STAT':
      var oldStatVal = currentProgVal.stat;
      currentProgVal.stat = changeExecStatNumber(val.trim());
      if(initialFlg) statChangeFlg = true;
      if(currentProgVal.stat != I_WATCHEXEC_ABORTED) {
        currentProgVal.uniManual = false;
        /* status:abort -> Other than abort */
        if(oldStatVal == I_WATCHEXEC_ABORTED && tp_prog_name != current_prog_name) {
          /* Replace Sub program information as Main program */
          progSubToMainReplace();
        }
      }
      changeVal = CHANGE_CURR_STAT;
      break;
    case '$SHELL_WRK.$ROUT_NAME':
      currentProgVal.shell.prog = val;
      if(cursor_manual_check()) {
        if(!cursor_manual_check() && currentProgVal.prog != val) { statChangeFlg = true; }
        /* If the string is empty, a string for judgment is stored. */
        currentProgVal.prog = (val != '') ? val : TL_NO_DISP_NAME;
        changeVal = CHANGE_ROUT_NAME;
      }
      break;
    case '$SHELL_WRK.$CURR_LINE':
      currentProgVal.shell.line = Number(val);
      if(cursor_manual_check()) {
        /* pause */
        if(currentProgVal.stat == I_WATCHEXEC_PAUSED) {
          if(!cursor_manual_check() && currentProgVal.line != currentProgVal.shell.line) { statChangeFlg = true; }
          currentProgVal.line = currentProgVal.shell.line;
          changeVal = CHANGE_CURR_LINE;
        }
        /* abort */
        else {
          /* Return to top. */
          if(currentProgVal.shell.line == 1) {
            statChangeFlg = true;
            currentProgVal.line = currentProgVal.shell.line;
            currentProgVal.uniManual = false;
            changeVal = CHANGE_CURR_LINE;
          }
        }
      }
      break;
    case '$SHELL_WRK.$BY_MANUAL':
      var oldVal = currentProgVal.shell.by_manual;
      currentProgVal.shell.by_manual = (val == 'TRUE');
      if(cursor_manual_check() || (oldVal == true && currentProgVal.shell.by_manual == false)) {
        changeVal = CHANGE_BY_MANUAL;
        /* by_manual:true -> false */
        if(oldVal == true && currentProgVal.shell.by_manual == false) {
          statChangeFlg = true;
          /* Adjust cursor position information. */
          var setLine_ID = chkExeAnimate(get_array_num_to_iconid(currentProgVal.shell.line - 1));
          var tlIdx = g_TL_progInfo.dispProg.indexOf(setLine_ID);
          g_columnRelationInfo.posNo = (tlIdx > -1) ? (tlIdx + 1) : 1;
          columnPosInfoUpdate(false);
        }
        else {
          currentProgVal.prog = currentProgVal.shell.prog;
          currentProgVal.line = currentProgVal.shell.line;
        }
      }
      break;
    default:
      break;
  }
  return changeVal;
}

/***********************/
/* cursor_manual_check */
/***********************/
function cursor_manual_check() {
  return ((currentProgVal.stat == I_WATCHEXEC_PAUSED && currentProgVal.shell.by_manual) ||
          (currentProgVal.stat == I_WATCHEXEC_ABORTED && currentProgVal.uniManual));
}

/*
 =========================================================================
 @function name         : changeExecStatNumber
 @argument[execStatStr] : exective States 
 @description           : Find exec status string from resources and return status code.
 @return                : status code
 =========================================================================
*/
function changeExecStatNumber(execStatStr) {
  var stat = -1;
  for (var i = 0; i < statWordArrayData.length; i++) {
    // Correct a generate the RegExp object because it is not correctly generated on the iPad.
    if (execStatStr.indexOf(statWordArrayData[i].res) >= 0 || execStatStr.indexOf(statSubWordsArray[i].res) >= 0) {
      // The status word contains the status list status.
      stat = statWordArrayData[i].stat;
      break;
    }
  }
  return stat;
}

/*
 =========================================================================
 @function name        : progExecolumn
  @argument[chgSysVal] : change system val number.
 @description          : Running timeline operations
 @return               : none
 =========================================================================
*/
var NOT_CAHNGE         = 0; //Invocation except when execution state changes.
var CHANGE_CURR_STAT   = 1; //Call on exe stat change.(kinds:CURR)
var CHANGE_ROUT_NAME   = 2; //Call on exe program change.(kinds:CURR)
var CHANGE_CURR_LINE   = 3; //Call on exe line change.(kinds:CURR)
var CHANGE_TPEDIT_PROG = 4; //Call on exe program change.(kinds:TPEDIT)
var CHANGE_TPEDIT_LINE = 5; //Call on exe line change.(kinds:TPEDIT)
var CHANGE_BY_MANUAL   = 6; //Call on exe line change.(kinds:TPEDIT)
function progExecolumn(chgSysVal) {
  if (isCRXeditorActive === false) return;
  if(g_adinDropList.length) delete_g_adinDrop();
  /*If multi touch sort at start of execution, cancel multi touch sort.*/
  if(g_tlmove_ghost != '') {
    if(touchId) {
      cancel_progArea_sortable(); //multi touch at programming sort.
    } else {
      cancel_timeline_sortable(); //multi touch at timeline sort.
    }
  }
  /* The running program exists in the list. */
  if(chk_progInList(currentProgVal.prog, programFileList)) {
    /* Obtain the ID of the corresponding instruction from the line number. */
    var execId = get_array_num_to_iconid(currentProgVal.line - 1);
    if(execId) execId = chkExeAnimate(execId);
  }
  /* Assign processing by execution status. */
  // console.log("PROG:" + currentProgVal.prog + " LINE:" + currentProgVal.line + " STATE:"  + currentProgVal.stat);
  if(statChangeFlg) {
    var statClass = '';
    switch(currentProgVal.stat) {
      case I_WATCHEXEC_ABORTED: // end
        statFunc = watchExeEnd;
        statClass = 'prog_abort';
        break;
      case I_WATCHEXEC_RUNNING: // Execution
        statFunc = watchExeRun;
        statClass = 'prog_run';
        break;
      case I_WATCHEXEC_PAUSED:  // pause
        statFunc = watchExePause;
        statClass = 'prog_pause';
        break;
      default:
        break;
    }
    statChangeFlg = false;
    if(statClass != '') {
      $(parts_block).removeClass('prog_abort prog_run prog_pause');
      $(parts_block).addClass(statClass);
    }
  }

  /* Cursor is in animation */
  if (animation_flg) {
    /* Wait for 0.1 second interval to finish */
    var id = setInterval(function () {
      // When the animation ends.
      if (!(animation_flg)) {
        // Timer stop
        clearInterval(id);

        // Execute function on completion
        progExecolumn(NOT_CAHNGE);
      }
    }, 100);
  } else {
    /* in the process of switching */
    if (change_prog_flg) {
      /* Loading complete */
      if (read_tpprog_finish_flg) {
        inExeNextProgram(execId);
      } else {
        /* Do nothing until loading is complete. */
        return;
      }
    }
    // console.log(currentProgVal.prog + ":LINE:" + currentProgVal.line + ":STATE:"  + currentProgVal.stat);
    var tl_switch = false;
    if(statFunc != null) {
      tl_switch = statFunc(execId);
      statFunc = null;
      act_scrollChk = false;
    }
    //Whether or not a subprogram is being called during execution
    if (current_prog_name !== "" && currentProgVal.prog !== "" &&    /* Program name is OK. */
        !g_editor_status.tl_loading &&                               /* Not in the process of switching programs. */
        (tl_switch || g_lineCountOver.overflg)) {                    /* Display needs to be updated or display line count is exceeded. */
      outExeCurrentProgram();
    }
    /* Aborted during display of timeline error popup caused by parse error. */
    if(currentProgVal.stat == I_WATCHEXEC_ABORTED && !tl_switch) {
      /* parse error occurred */
      if(parts_timeline.classList.contains('notDisplayable')) {
        /* Displaying subprogram and error popup on timeline. */
        if(tp_prog_name != currentProgVal.prog &&
           document.getElementById('timelinePop').classList.contains('tl_popup_notDisplayable')) {
          /* Switch error popup to full screen */
          tlPopupDisplayResetReq();
          popup_notDisplayable(NO_DISPLAYABLE_POP_FULL);
        }
      }
    }
  }
}

/*
 =========================================================================
 @function name    : watchExeEnd
 @argument[iconId] : exective icon name
 @description      : Execution end processing
 @return           : Need to switch timeline (true : Need to switch)
 =========================================================================
*/
function watchExeEnd(iconId){
  /* Compare with the displayed program name. */
  var tl_switch = (current_prog_name != currentProgVal.prog);

  overlayRistrict(SITUATION_PLAY, false);
  display_endmode(iconId);
  if(iconId != '') {
    /* Adjust the cursor position. */
    g_columnRelationInfo.dispPosId = iconId;
    var mvIdx = g_TL_progInfo.dispProg.indexOf(iconId);
    exe_column_move(mvIdx + 1);
    if(!act_scrollChk) adjustTimelinePos(mvIdx, false);
  }
  else {
    /* Display no need to be update & Instructions exist & Notified execution line is the number of program lines + 1 */
    if(!tl_switch && g_TL_progInfo.saveProg.length != 0 && (g_TL_progInfo.saveProg.length + 1) == currentProgVal.line) {
      exe_column_moveToEnd();
    }
  }

  check_undoredo_active();
  draw_TLscale(false);
  scrollboost_positionSet();
  programLine = currentProgVal.line;

  return tl_switch;
}

/*
 =========================================================================
 @function name    : watchExeRun
 @argument[iconId] : exective icon name
 @description      : exective  processing
 @return           : Need to switch timeline (true : Need to switch)
 =========================================================================
*/
function watchExeRun(iconId){
  var watchexe = Object.assign({}, currentProgVal);
  var tl_switch = true;
  if(g_TL_selectModeFlg) change_TLselectMode(SELECT_MODE_NONE);
  /* Erase motion replace popups if they are displayed. */
  delete_popup_screen(DEF_POPUP_SCRN_TYP.REPLACE_MTN);

  /** function: Display vision camera frame **/
  var visCamDisp = function(paramStr) {
    var call_param = split_param_call(paramStr);
    var regexp = new RegExp(VISION_FIND_ORDER,'i');
    if(regexp.test(call_param[0])) {
      call_param[1] = langConvEng(adinstArg_rmvParen(call_param[1]));
      var params = call_param[1].split(",");
      visionCamDisp(params[5]);
    }
  };

  overlayRistrict(SITUATION_PLAY, true);
  $('.undoredo').css('opacity','');
  if (current_prog_name == watchexe.prog) {//start Execution
    display_exemode(watchexe);
    if(watchexe.line === programLine) {
      /* Scroll position and cursor position animation */
      progExeAnimate();
      if(iconId) {
        visCamDisp(g_program_data[iconId].param);
      }
      tl_switch = false;
    } else { //runnning
      if(iconId) {
        visCamDisp(g_program_data[iconId].param);
        animation_flg = true;
        if (watchexe.line > g_TL_progInfo.saveProg.length) {
          watchexe.line = g_TL_progInfo.saveProg.length;
        }
        /* Scroll position and cursor position animation */
        progExeAnimate();

        programLine = watchexe.line;  // Current program
        g_columnRelationInfo.posNo = get_TL_targetOrder(iconId) + 1;
        if(g_columnRelationInfo.posNo == 0) {
          g_columnRelationInfo.posNo = 1;
        }
        columnPosInfoUpdate(true);
      }
    }
  }

  return tl_switch;
}

/*
 =========================================================================
 @function name    : watchExePause
 @argument[iconId] : exective icon name
 @description      : exective pause processing
 @return           : Need to switch timeline (true : Need to switch)
 =========================================================================
*/
function watchExePause(iconId){
  if(g_TL_selectModeFlg) change_TLselectMode(SELECT_MODE_NONE);
  /* Erase motion replace popups if they are displayed. */
  delete_popup_screen(DEF_POPUP_SCRN_TYP.REPLACE_MTN);

  display_exemode_standby();
  display_pausemode();
  overlayRistrict(SITUATION_PLAY, false);
  check_undoredo_active();
  draw_TLscale(false);

  /* Matches the program being displayed */
  if (current_prog_name === currentProgVal.prog && currentProgVal.line > 0) {
    /* Instructions exist & Notified execution line is the number of program lines + 1 */
    if(g_TL_progInfo.saveProg.length != 0 && (g_TL_progInfo.saveProg.length + 1) == currentProgVal.line) {
      exe_column_moveToEnd();
    }
    else {
      /* "iconId" is set. */
      if(iconId) {
        /* The execution line is different. */
        if(programLine != currentProgVal.line) {
          if (currentProgVal.line > g_TL_progInfo.saveProg.length) {
            currentProgVal.line = g_TL_progInfo.saveProg.length;
          }
          programLine = currentProgVal.line;  // Current program
          /* Adjust the cursor position. */
          g_columnRelationInfo.posNo = get_TL_targetOrder(iconId) + 1;
          if(g_columnRelationInfo.posNo == 0) {
            g_columnRelationInfo.posNo = 1;
          }
          if(!animation_flg) exe_column_move(g_columnRelationInfo.posNo)
          if(g_tlScroll_direction == TL_SCRL_VRTCL) {
            adjustTimelinePos(programLine, true);
            progExecolumn(NOT_CAHNGE);
            columnPosInfoUpdate(true);
          }
          else {
            animation_flg = true;
            /* Scroll position and cursor position animation */
            progExeAnimate();
          }
        }
        else {
          /* Update cursor position information just in case. */
          g_columnRelationInfo.columnId = get_array_num_to_iconid(currentProgVal.line - 1);
          g_columnRelationInfo.arrayNum = g_program_data[g_columnRelationInfo.columnId].array_num;
          g_columnRelationInfo.dispPosId = iconId;
          g_columnRelationInfo.posNo = (iconId != '') ? (g_TL_progInfo.dispProg.indexOf(iconId) + 1) : 1;
        }
      }
    }
  }

  return true;
}

/*
 =========================================================================
 @function name : display_exemode
 @argument      : none
 @description   : Run mode processing
 @return        : none
 =========================================================================
*/
function display_exemode() {
  display_exemode_standby();
  status_mode = I_WATCHEXEC_RUNNING;
  
  //When returning from the subprogram, redraw because the length of the program changes
  draw_TLscale(false);
}

/*
 =========================================================================
 @function name : display_exemode_standby
 @argument      : none
 @description   : The timeline preparation process at run mode.
 @return        : none
 =========================================================================
*/
function display_exemode_standby() {
  if(chk_progInList(currentProgVal.prog, programFileList)) {
    var execId = get_array_num_to_iconid(currentProgVal.line - 1);
    if(execId) execId = chkExeAnimate(execId);
  }
  if(g_tlScroll_direction != TL_SCRL_VRTCL) {
    if(currentProgVal.stat !== I_WATCHEXEC_RUNNING) {
      document.getElementById('TL_scale').setAttribute('width', $("#TL_scale").outerWidth() + $(scrlWrpElm).outerWidth());
      $('#TL_scale').css('width', $("#TL_scale").outerWidth() + $(scrlWrpElm).outerWidth() + "px");
    }
    var rect = document.getElementById('exe_column').getBoundingClientRect();
    //Center alignment
    var screen_size = window.innerWidth;
    var left = parseInt($('#exe_column').css("left").replace(/[^0-9.]/g,""));

    var tlleft = Math.floor((screen_size / 2) - (TL_ICON_WIDTH_OUTER/2));
    $("#exe_column").css({
      position:"fixed",
      top: $(g_TL_elm).offset().top + 7,
      left: tlleft + 26,
    });

    $(g_TL_elm).css('padding-left',tlleft + 'px');
    $('#scrollContainer').css({'width':g_TL_elm.scrollWidth});
    //draw_TLscale(false);
    var scroll = (g_columnRelationInfo.posNo - 1) * TL_ICON_WIDTH_OUTER;
    $(scrlWrpElm).stop().scrollLeft(scroll);
    animation_flg = false;
    /* Update element size for drag scroll */
    scrollboost_positionSet();
  }
  else {
    if(currentProgVal.line === programLine) {
      var dispPos = getPositionFromTLBeginning(execId);
      adjustTimelinePos(dispPos, true);
    }
  }
}

/*
 =========================================================================
 @function name : display_pausemode
 @argument      : none
 @description   : Pause processing
 @return        : none
 =========================================================================
*/
function display_pausemode() {
  if(chk_progInList(currentProgVal.prog, programFileList)) {
    /* g_columnRelationInfo update */
    var execId = get_array_num_to_iconid(currentProgVal.line - 1);
    if(execId) execId = chkExeAnimate(execId);
  }
  
  if(g_tlScroll_direction != TL_SCRL_VRTCL) {
    var exe_column_left = scrlWrpElm.scrollLeft + 26;
    $("#exe_column").css({
      position:"",
      top: "",
      left: exe_column_left,
    });
  }
  status_mode = I_WATCHEXEC_PAUSED;
}
/*
 =========================================================================
 @function name : display_endmode
 @argument      : none
 @description   : Stop processing
 @return        : none
 =========================================================================
*/
function display_endmode(iconId) {
  if(status_mode !== I_WATCHEXEC_ABORTED) {
    if(g_tlScroll_direction == TL_SCRL_VRTCL) {
      $('.exe_column').stop();
    }
    else {
      $("#exe_column").css({position: "", top: "", left: ""});
      $(g_TL_elm).css('padding-left','');
      $('#scrollContainer').css('width', g_TL_elm.scrollWidth);
    }
    $(scrlWrpElm).stop();
    animation_flg = false;
    status_mode = I_WATCHEXEC_ABORTED;
    g_activeLine_exec = {};
  }
}

/*
 =========================================================================
 @function name : progExeAnimate
 @argument[]    : none
 @description   : Timeline and execolumn animation
 @return        : none
 =========================================================================
*/
function progExeAnimate() {
  if(chk_progInList(currentProgVal.prog, programFileList) == false) {
    return;
  }
  var speed = 500;
  var execId = chkExeAnimate(get_array_num_to_iconid(currentProgVal.line - 1));
  if(execId == '') return;
  if(g_tlScroll_direction == TL_SCRL_VRTCL) {
    var clmRow = getRowFromTLTop(execId);
    var clmId = clmRow == 1 ? 'exe_column' : 'exe_column_' + clmRow;
    var offsetLeft = (Math.floor(g_TL_progInfo.dispProg.indexOf(execId) % get_dispWidth_iconNum()) * TL_ICON_WIDTH_OUTER) + 26;
    if((clmId != g_activeClm_id) || currentProgVal.stat == I_WATCHEXEC_RUNNING) {
      $('.exe_column').removeClass('clm_active');
      $(document.getElementById(clmId)).addClass('clm_active');
      $(scrlWrpElm).animate(
        {scrollTop: ((clmRow - 1) * BASE_VERTICAL_TL_HEIGHT) > 0 ? ((clmRow - 1) * BASE_VERTICAL_TL_HEIGHT) : 0},
        {
          duration: 300,
          easing: 'swing',
          queue: false,
          complete: function(){
          }
        }
      );
      if(clmId != g_activeClm_id) {
        g_activeClm_id = clmId;
        $('#' + g_activeClm_id).css('left', offsetLeft);
      }
    }
    $('#' + g_activeClm_id).animate(
      {'left':offsetLeft},
      {
        duration: speed,
        easing: 'swing',
        queue: false,
        complete:function(){
          // console.log("Scroll end");
          animation_flg = false;
        }
      }
    );
  }
  else {
    var scrollLeft = (g_TL_progInfo.dispProg.indexOf(execId) * TL_ICON_WIDTH_OUTER);
    $(scrlWrpElm).animate(
      { scrollLeft:scrollLeft },
      {
        duration: speed,
        easing: 'swing',
        queue: false,
        complete:function(){
          // console.log("Scroll end");
          animation_flg = false;
        }
      }
    );
  }
}

/*
 =========================================================================
 @function name   : chkExeAnimate
 @argument[runId] : ID of the instruction being executed
 @description     : Get the instruction ID on the display from the instruction ID being executed.
 @return          : Instruction ID of the cursor position on the display
 =========================================================================
*/
function chkExeAnimate(runId) {
  if(runId == '') return '';
  var ret = runId;
  g_columnRelationInfo.columnId = runId;
  g_columnRelationInfo.arrayNum = g_program_data[runId].array_num;
  var tmpArray = [];
  for(var cnt = 0; cnt < g_bkt_dspCls_list.length; cnt++) {
    if(g_program_data[g_bkt_dspCls_list[cnt]]) {
      /* Checks if the instruction is inside a bracket instruction in a closed state */
      if(g_program_data[g_bkt_dspCls_list[cnt]].stretch.state === 'stretch_close' &&
         g_program_data[g_bkt_dspCls_list[cnt]].array_num <= g_program_data[runId].array_num) {
        tmpArray = g_program_data[g_bkt_dspCls_list[cnt]].stretch.idList;
        if(g_program_data[tmpArray[tmpArray.length - 1].id].array_num >= g_program_data[runId].array_num) {
          ret = g_bkt_dspCls_list[cnt];
          break;
        }
      }
    }
  }
  return ret;
}

/*
 =========================================================================
 @function name : outExeCurrentProgram()
 @argument      : none
 @description   : Change from the currently displayed program
 @return        : none
 =========================================================================
*/
function outExeCurrentProgram(){
  if (current_prog_name !== currentProgVal.prog &&
      (chk_progInList(currentProgVal.prog, programFileList) || currentProgVal.prog == TL_NO_DISP_NAME)) {
    /* Stop the Modified time monitoring monitor.*/
    stopMonitorCurProgModify();
    initCurProgModifyInfo(INIT_MDFY_INFO_SUB);
    if(g_TL_selectModeFlg) change_TLselectMode(SELECT_MODE_NONE);
    // delete the pop-up screen
    delete_popup_screen(DEF_POPUP_SCRN_TYP.REPLACE_MTN);
    if(g_timelinepopDispFlg) tlPopupDisplayResetReq();
    // Changed from main
    if (current_prog_name === tp_prog_name && tp_prog_name !== currentProgVal.prog) {
      /* Back up the main program. */
      switchProg_backupMainProg();
    }
    if(tp_prog_name === currentProgVal.prog) {
      switch_record(SWITCH_MAIN_RECORD);
    }
    else {
      switch_record(SWITCH_SUB_RECORD);
    }
    if(activeTarget != '') {
      setActiveLine();
      icon_inactive();
    }
    change_prog_flg = true;
    // console.log("call" + current_prog_name + ":" + currentProgVal.prog + ":" + currentProgVal.line + ":" + currentProgVal.stat);
    current_prog_name = currentProgVal.prog;
    set_tl_dispName();
    programLine = 1;
    if(g_btnTeaching_list.weldteach.existsTimeline == true) {
      top.setArcTeachFg(false);
      weldingTeachEnd(false);
    }
    if(g_btnTeaching_list.wristteach.existsTimeline == true) {
      top.setWristTeachFg(false);
      init_btnTeaching_list('wristteach');
    }
    check_undoredo_active();
    /* not displayable class initialize */
    $(parts_timeline).removeClass('notDisplayable');
    /* Check the attributes of the program to be switched. */
    var args = {prg: current_prog_name, callfunc: chg_runProg_prtctAttr};
    getFileAttrMotionGroup(args);
  }
}

/*
 =========================================================================
 @function name     : chk_progInList
 @argument[prgName] : Program name to check.
 @argument[prgList] : List of programs to check.
 @description       : Check if the program exists in the list.
 @return            : Check result.(true:exist)
 =========================================================================
*/
function chk_progInList(prgName, prgList) {
  return (prgList.find(function(prglist) {return prglist.name === prgName}) != undefined) ? true : false;
}

/*
 =========================================================================
 @function name : setActiveLine
 @argument[]    : none
 @description   : If the detail screen is being displayed, the corresponding line number is retained.
 @return        : none
 =========================================================================
*/
var g_activeLine_exec = {};
function setActiveLine() {
  /* Displaying detail screen */
  if(activeTarget != '') {
    /* Hold target line number */
    g_activeLine_exec[current_prog_name] = {line: (g_TL_progInfo.saveProg.indexOf(activeTarget) + 1)};
  }
}

/*
 =========================================================================
 @function name    : inExeNextProgram
 @argument[iconId] : exective icon name
 @description      : change sub program for main program
 @return           : none
 =========================================================================
*/
function inExeNextProgram(iconId){
  if(iconId) {
    var execPos = getPositionFromTLBeginning(iconId);
    exe_column_move(execPos);
    columnPosInfoUpdate(false);
    /* Scroll position and cursor position adjustment */
    if(g_tlScroll_direction == TL_SCRL_VRTCL) {
      adjustTimelinePos(execPos, true);
    }
    else {
      scroll_val = (execPos - 1) * TL_ICON_WIDTH_OUTER;
      // console.log("scroll scroll_val:" + scroll_val);
      $(scrlWrpElm).stop().scrollLeft(scroll_val);
      animation_flg = false;
      scrlPosUpdate($('#TLscrl_thumb')[0], scrlWrpElm, 'TL_scrollbar', scrlWrpElm.scrollLeft);
    }
  }
  change_prog_flg = false;
  read_tpprog_finish_flg = false;
  
  if(g_activeLine_exec[current_prog_name]) {
    var actid = get_array_num_to_iconid(g_activeLine_exec[current_prog_name].line - 1);
    if(actid) icon_active(actid, ACTIVE_DETAIL_NECESSARY);
    delete g_activeLine_exec[current_prog_name];
  }
  dispOffWaiting();
}

/*
 =========================================================================
 @function name       : chg_runProg_prtctAttr
 @argument[status]    : Status of Communication Results
 @argument[progname]  : program name
 @argument[mmVarName] : Attrubute type
 @argument[mmValue]   : Attrubute value(2:read-only)
 @description         : Compare to see if the no-writing attribute has changed.
 @return              : none
 =========================================================================
*/
function chg_runProg_prtctAttr(status, progName, mmVarName, mmValue) {
  if (status != IO_SUCCESS) {
    //Error popup
    dispOffWaiting();
    display_popupmsg_confirm(window, langResource.ihmieditor_pop_loaderr_c + '<br>' + langResource.ihmieditor_pop_moveprglist_c, cb_closepopup_move_prglist);
    read_tpprog_finish_flg = true;
    return;
  }
  
  /* read only */
  if (mmValue === "2") {
    g_RO_flg = true;
    readOnly_setting();
  }
  else {
    g_RO_flg = false;
    readwrite_setting();
  }

  /* main program */
  if (tp_prog_name === progName) {
    /* Check to see if main program has been modified during sub program execution. */
    chg_runProg_mainModifiedCheck();
  }
  else {
    toast.show(current_prog_name + ".TP");
    getProgramText(progName, 1, readPrgCallback);
  }
}

/*
 =========================================================================
 @function name : chg_runProg_mainModifiedCheck()
 @argument      : none
 @description   : Check to see if main program has been modified during sub program execution.
 @return        : none
 =========================================================================
*/
function chg_runProg_mainModifiedCheck() {
  /* Back up for comparison */
  var beforeUpdate = JSON.parse(JSON.stringify(g_progModifyInfo.main));
  /* Get modified time */
  getCurProgModifyTime(runProg_mainModifiedTime_callback);

  /** callback function **/
  function runProg_mainModifiedTime_callback() {
    /* Not modified. */
    if(beforeUpdate.name == g_progModifyInfo.main.name &&
       beforeUpdate.time == g_progModifyInfo.main.time) {
      toast.show(current_prog_name + ".TP");
      /* Resume Monitoring */
      startMonitorCurProgModify();
      chg_runProg_returnMain();
    }
    /* Modified */
    else {
      /* reload */
      modifyProgReload(g_progModifyInfo.main.name, PRG_LOAD_REASON_EXEC);
    }
  }
}

/*
 =========================================================================
 @function name : chg_runProg_returnMain()
 @argument      : none
 @description   : 
 @return        : none
 =========================================================================
*/
function chg_runProg_returnMain() {
  initializ_timeline();
  switchProg_restoreMainProg();
  /* Check for error pop ups. */
  var popFrmKey = [DEF_POPUP_SCRN_TYP.CONFIRM, DEF_POPUP_SCRN_TYP.NOT_DISPLAYABLE].find(
    function(key) { return (g_popup_frame[key - 1].iframe_object != null ||
                            g_popup_frame[key - 1].disp_sts == DEF_POPUP_SCRN_STS.REQ_ON); }
  );
  if(popFrmKey) delete_popup_screen(popFrmKey);
  progExecolumn();
}

/*
 =========================================================================
 @function name : switchProg_backupMainProg()
 @argument      : none
 @description   : Back up main program information when switching from the main program to a subprogram
 @return        : none
 =========================================================================
*/
function switchProg_backupMainProg() {
  /* failsafe : Initialize */
  init_switchProg_backup();

  $.extend(true, g_switchProg_bkup.program_data, g_program_data);
  $.extend(true, g_switchProg_bkup.position, position);
  $.extend(true, g_switchProg_bkup.labelNumList, g_labelNumList);
  $.extend(true, g_switchProg_bkup.TL_progInfo, g_TL_progInfo);
  $.extend(true, g_switchProg_bkup.iconTbl, iconTbl);
  $.extend(true, g_switchProg_bkup.attribute, attribute);
  $.extend(true, g_switchProg_bkup.applData, applData);
}

/*
 =========================================================================
 @function name : switchProg_restoreMainProg()
 @argument      : none
 @description   : Restore program information when returning from a subprogram to the main program
 @return        : none
 =========================================================================
*/
function switchProg_restoreMainProg() {
  initPosition();
  initAttribute();
  initApplData();

  /* Restore the main program information. */
  $.extend(true, g_program_data, g_switchProg_bkup.program_data);
  $.extend(true, position, g_switchProg_bkup.position);
  $.extend(true, g_labelNumList, g_switchProg_bkup.labelNumList);
  $.extend(true, g_TL_progInfo, g_switchProg_bkup.TL_progInfo);
  $.extend(true, iconTbl, g_switchProg_bkup.iconTbl);
  $.extend(true, attribute, g_switchProg_bkup.attribute);
  $.extend(true, applData, g_switchProg_bkup.applData);

  g_lineCountOver = g_lineCountOver_base['main'];
  g_config['localReg'] = attribute[18].val.split(',').map(function(str) {return parseInt(str, 10);});
  if(g_lineCountOver.overflg) {
    tlPopupDisplayReq(langResource.ihmieditor_pop_linecount_over_c)
  }
  else {
    initLineCountInfo();
  }
  setLineTrack();
  display_program_data();
  read_tpprog_finish_flg = true;
  /* Main program: active icon check.*/
  var mainActChk = Object.keys(g_program_data).find(function(key) { return g_program_data[key].select == 'TL_active'; });
  /* Active icons exist. */
  if(mainActChk) {
    icon_active(mainActChk, ACTIVE_DETAIL_NECESSARY);
    if(g_activeLine_exec[current_prog_name]) delete g_activeLine_exec[current_prog_name];
  }

  /* Initialize */
  init_switchProg_backup();
  if(currentProgVal.stat == I_WATCHEXEC_ABORTED) g_activeLine_exec = {};

  if(g_RO_flg) {
    init_record();
    check_undoredo_active();
  }
}

/*
 =========================================================================
 @function name : init_switchProg_backup()
 @argument      : none
 @description   : Initialize variables for main program information backup
 @return        : none
 =========================================================================
*/
function init_switchProg_backup() {
  g_switchProg_bkup = {program_data:{}, TL_progInfo:{}, iconTbl:{}, position:[], labelNumList:[], attribute:[], applData:[]};
}

/*
 =========================================================================
 @function name : progSubToMainReplace()
 @argument      : none
 @description   : Replace Sub program information as Main program
 @return        : none
 =========================================================================
*/
function progSubToMainReplace() {
  /* tp_prog_name update */
  tp_prog_name = current_prog_name;

  g_lineCountOver_base['main'] = JSON.parse(JSON.stringify(g_lineCountOver_base['sub']));
  g_lineCountOver = g_lineCountOver_base['main'];
  initLineCountInfo();

  /* UndoRedo infomation */
  /* Initialize undoredo information for Main program. */
  tl_rcrd_main.delete();
  pos_rcrd_main.delete();
  posregi_rcrd_main.delete();

  /* Overwrite with Sub program information. */
  $.extend(true, tl_rcrd_main.operation_array, tl_rcrd_sub.operation_array);
  tl_rcrd_main.operation_array_index = tl_rcrd_sub.operation_array_index;
  $.extend(true, pos_rcrd_main.operation_array, pos_rcrd_sub.operation_array);
  pos_rcrd_main.operation_array_index = pos_rcrd_sub.operation_array_index;
  $.extend(true, posregi_rcrd_main.operation_array, posregi_rcrd_sub.operation_array);
  posregi_rcrd_main.operation_array_index = posregi_rcrd_sub.operation_array_index;
  /* Switch UndoRedo Information. */
  switch_record(SWITCH_MAIN_RECORD);

  /* Initialize */
  init_switchProg_backup();
  initCurProgModifyInfo();
  getCurProgModifyTime();
}

/*
 =========================================================================
 @function name      : cancel_execLineChange
 @argument[progname] : Target Program Name.
 @argument[setline]  : Number of lines to specify.
 @description        : Cursor movement processing when the execution line change is canceled.
 @return             : none
 =========================================================================
*/
/** This function is called by iRP. **/
function cancel_execLineChange(progname, setline) {
  /* Get the paused execution line. */
  var pausePosId = get_array_num_to_iconid(setline - 1);
  if(pausePosId) {
    /* Get the ID of the element at the cursor position. */
    var execId = chkExeAnimate(pausePosId);
    /* Get the timeline element where the cursor is. */
    var clmRow = getRowFromTLTop(execId);
    var clmId = clmRow == 1 ? 'exe_column' : 'exe_column_' + clmRow;
    var pos = get_TL_targetOrder(execId) + 1;
    
    $('.exe_column').removeClass('clm_active');
    $(document.getElementById(clmId)).addClass('clm_active');
    /* Moves the cursor and updates the cursor position information. */
    exe_column_move(pos);
    /* Retain the instruction at the original execution cursor position. */
    adjustTimelinePos(pos - 1, false);
    /* Overwrite the cursor position information. */
    g_columnRelationInfo.columnId = pausePosId;
    g_columnRelationInfo.arrayNum = g_program_data[pausePosId].array_num;
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  //=============================================================================
// define
// FOR I/O
//=============================================================================

// IO TYPE
var RI_MONITOROFF = 0;
var RI_MONITORON = 1;
var RI_MONITOR_RANGE = 1;
var RI_MONITOR_BTN_1 = 3;
var RI_MONITOR_BTN_2 = 4;
var RI_MONITOR_BTN_3 = 5;
var RI_NO_SETTING = 0;
var RI_SET_BTN_1 = 1;
var RI_SET_BTN_2 = 2;
var RI_SET_BTN_3 = 3;
var SMTG_POS_TEACH = 4;
//=============================================================================
// Global variable
//=============================================================================
var g_condtionWristMonitor = RI_MONITOROFF;
var g_setWristButton = null;
var g_monitorIndex = null;
//WristTeach Position information data
var g_wbtData = {
  savingTeachPosFlg : false,
  teachPosData : {
    joint: "", 
    cart: "", 
    posNo: 0
  }
};
/*
 =========================================================================
 @function name : startWristButtonTeach
 @argument      : none
 @description   : Start WristButtonTeach
 @return        : none
 =========================================================================
*/
function startWristButtonTeach() {
  var sysValArr = ["$SMTD_CFG[1].$TYPE", "$SMTD_CFG[2].$TYPE", "$SMTD_CFG[3].$TYPE"];
  // Get time out value
  getSysValXHR(sysValArr, setWristButton);
}
/*
 =========================================================================
 @function name : endWristButtonTeach
 @argument      : none
 @description   : End WristButtonTeach
 @return        : none
 =========================================================================
*/
function endWristButtonTeach() {
  top.jQuery.iolis.unbind("HandleIOEvent", wristTeachIOEnableEvent);
  switch (g_monitorIndex) {
    case RI_MONITOR_BTN_1:
      rpcmc_stopButtonMonitor(IO_TYPE_RI, RI_MONITOR_BTN_1);
      break;
    case RI_MONITOR_BTN_2:
      rpcmc_stopButtonMonitor(IO_TYPE_RI, RI_MONITOR_BTN_2);
      break;
    case RI_MONITOR_BTN_3:
      rpcmc_stopButtonMonitor(IO_TYPE_RI, RI_MONITOR_BTN_3);
      break;
    default:
      break;
  }

}
/*
 =========================================================================
 @function name : wristExitConfirm
 @argument      : none
 @description   : Exit PositionWriteChk
 @return        : none
 =========================================================================
*/
function wristExitConfirm(status) {
  var record_del_id = [];
  var record_contents = [];
  icon_inactive();
  record_del_id[record_del_id.length] = g_btnTeaching_list.wristteach.id;
  record_contents[record_contents.length] = g_program_data[g_btnTeaching_list.wristteach.id];
  var record_data = {
    id: record_del_id,
    contents: record_contents,
    place1: g_program_data[record_del_id[0]].array_num,
    place2: null,
    type: OPERATION_DELETE
  }
  timeline_record.array_add(record_data);
  check_undoredo_active();
  position_record.array_add(position);
  positionregi_record.array_add(g_position_regi);
  init_btnTeaching_list('wristteach');
  instructionDeleteIcon('wristteach');
  toast.show(langResource.ihmieditor_pop_wristteach_comp_c);
  top.setWristTeachFg(false);
  timelineScrlbarUpdate();
}

/*
 =========================================================================
 @function name : setWristButton
 @argument      : prog_name, var_name, type_code, str, callbackarg1, callbackarg2
 @description   : Select a monitor to start with
 @return        : none
 =========================================================================
*/
function setWristButton(status, str) {
  // Get time out value
  var XmlObj = getSysValXmlData(str, 'VAR');
	var valList = XmlObj.getElementsByTagName('VAR');
  var result = [];
	for(var loop = 0; loop < valList.length; loop++){
		result[loop] = valList[loop].textContent;
  }
  if (result[0] == SMTG_POS_TEACH) {
    g_setWristButton = RI_SET_BTN_1;
    g_monitorIndex = RI_MONITOR_BTN_1;
    rpcmc_startButtonMonitor(IO_TYPE_RI, RI_MONITOR_BTN_1);
  } else if (result[1] == SMTG_POS_TEACH) {
    g_setWristButton = RI_SET_BTN_2;
    g_monitorIndex = RI_MONITOR_BTN_2;
    rpcmc_startButtonMonitor(IO_TYPE_RI, RI_MONITOR_BTN_2);
  } else if (result[2] == SMTG_POS_TEACH) {
    g_setWristButton = RI_SET_BTN_3;
    g_monitorIndex = RI_MONITOR_BTN_3;
    rpcmc_startButtonMonitor(IO_TYPE_RI, RI_MONITOR_BTN_3);
  } else {
    g_setWristButton = RI_NO_SETTING; //When the button is not set
  }
  top.jQuery.iolis.bind("HandleIOEvent", null, wristTeachIOEnableEvent);
  sortable_setting();
}
/*
 =========================================================================
 @function name : wristTeachIOEnableEvent
 @argument      : event, io_type, io_index, io_value
 @description   : Enable status event.
 @return        : none
 =========================================================================
*/
function wristTeachIOEnableEvent(event, io_type, io_index, io_value, jpos, cpos) {
  if (typeof io_index === 'undefined') { return; }
  if (io_type == IO_TYPE_RI && Number(io_index) == g_monitorIndex) {
    if (IO_TYPE_RI == io_type) {
      if (!isCRXeditorActive) return;
      if (g_tlmove_ghost != "") return;
      /* If in selection mode, it is released. */
      if (g_TL_selectModeFlg) change_TLselectMode(SELECT_MODE_NONE);
      delete_popup_screen(DEF_POPUP_SCRN_TYP.REPLACE_MTN);//delete the pop-up screen
  
      if (g_condtionWristMonitor == RI_MONITORON && io_value == RI_MONITOROFF) { // RI_ON -> RI_OFF
        if (!g_TPenbl_flg || g_RO_flg) {
          var disp = toastStr_notEdit_welding();
          toast.show(disp);
          return;
        } else if (g_btnTeaching_list.wristteach.existsTimeline == false || g_program_data[g_btnTeaching_list.wristteach.id].remark == true) {
          toast.show(langResource.ihmieditor_pop_wristteach_not_operate_3_c);
          return;
        }
        var isWBTActive = (activeTarget.indexOf('-INST_WRIST_BUTTON_TEACH') != -1);
        icon_inactive();
        icon_active(g_btnTeaching_list.wristteach.id, ACTIVE_DETAIL_NECESSARY);
        if (isWBTActive) {
          /*save positon data joint & cart.*/
          g_wbtData.teachPosData.joint = jpos;
          g_wbtData.teachPosData.cart = cpos;
          /*Teaching positon saving start or end flag.(true:Teaching position saving now/false:Teaching position save completed)*/
          g_wbtData.savingTeachPosFlg = true;
          addMotionWristButton();
        }
      }
      g_condtionWristMonitor = io_value;
    }    
  } else {
    return;
  }
}

/*
 =========================================================================
 @function name : addMotionWristButton
 @argument      : none
 @description   : Create Motion to Add
 @return        : none
 =========================================================================
*/
function addMotionWristButton() {
  var params = split_param_call(g_program_data[activeTarget].param);
  var order = setAddProg(params);
  dispAddProgSave(order);
}
/*
 =========================================================================
 @function name : setAddProg
 @argument      : param
 @description   : Set AddMotion Program
 @return        : order
 ===========